











	       1mXlib - C Language X Interface0m

		   1mX Consortium Standard0m

	      1mX Version 11, Release 6.7 DRAFT0m






			James Gettys
	       Cambridge Research Laboratory
	       Digital Equipment Corporation


		    Robert W. Scheifler
	      Laboratory for Computer Science
	   Massachusetts Institute of Technology



		  4mwith24m 4mcontributions24m 4mfrom0m



		Chuck Adams, Tektronix, Inc.

	  Vania Joloboff, Open Software Foundation

	    Hideki Hiura, Sun Microsystems, Inc.

	   Bill McMahon, Hewlett-Packard Company

     Ron Newman, Massachusetts Institute of Technology

	       Al Tabayoyon, Tektronix, Inc.

	       Glenn Widener, Tektronix, Inc.

		Shigeru Yamada, Fujitsu OSSI





























The X Window System is a trademark of The Open Group.

TekHVC is a trademark of Tektronix, Inc.



Copyright © 1985, 1986, 1987, 1988, 1989, 1990, 1991, 1994,
1996, 2002 The Open Group

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documenta-
tion files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or
sell copies of the Software, and to permit persons to whom
the Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall
be included in all copies or substantial portions of the
Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY
KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PUR-
POSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE X CONSOR-
TIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open
Group shall not be used in advertising or otherwise to pro-
mote the sale, use or other dealings in this Software with-
out prior written authorization from The Open Group.




Copyright © 1985, 1986, 1987, 1988, 1989, 1990, 1991 by Dig-
ital Equipment Corporation

Portions Copyright © 1990, 1991 by Tektronix, Inc.













Permission to use, copy, modify and distribute this documen-
tation for any purpose and without fee is hereby granted,
provided that the above copyright notice appears in all
copies and that both that copyright notice and this permis-
sion notice appear in all copies, and that the names of Dig-
ital and Tektronix not be used in in advertising or public-
ity pertaining to this documentation without specific, writ-
ten prior permission.  Digital and Tektronix makes no repre-
sentations about the suitability of this documentation for
any purpose.  It is provided ``as is'' without express or
implied warranty.

























































		      1mAcknowledgments0m



The design and implementation of the first 10 versions of X
were primarily the work of three individuals: Robert Schei-
fler of the MIT Laboratory for Computer Science and Jim Get-
tys of Digital Equipment Corporation and Ron Newman of MIT,
both at MIT Project Athena.  X version 11, however, is the
result of the efforts of dozens of individuals at almost as
many locations and organizations.  At the risk of offending
some of the players by exclusion, we would like to acknowl-
edge some of the people who deserve special credit and
recognition for their work on Xlib.  Our apologies to anyone
inadvertently overlooked.

1mRelease 10m

Our thanks does to Ron Newman (MIT Project Athena), who con-
tributed substantially to the design and implementation of
the Version 11 Xlib interface.

Our thanks also goes to Ralph Swick (Project Athena and Dig-
ital) who kept it all together for us during the early
releases.  He handled literally thousands of requests from
people everywhere and saved the sanity of at least one of
us.  His calm good cheer was a foundation on which we could
build.

Our thanks also goes to Todd Brunhoff (Tektronix) who was
``loaned'' to Project Athena at exactly the right moment to
provide very capable and much-needed assistance during the
alpha and beta releases.  He was responsible for the suc-
cessful integration of sources from multiple sites; we would
not have had a release without him.

Our thanks also goes to Al Mento and Al Wojtas of Digital's
ULTRIX Documentation Group.  With good humor and cheer, they
took a rough draft and made it an infinitely better and more
useful document.  The work they have done will help many
everywhere.  We also would like to thank Hal Murray (Digital
SRC) and Peter George (Digital VMS) who contributed much by
proofreading the early drafts of this document.

Our thanks also goes to Jeff Dike (Digital UEG), Tom Benson,
Jackie Granfield, and Vince Orgovan (Digital VMS) who helped
with the library utilities implementation; to Hania Gajewska
(Digital UEG-WSL) who, along with Ellis Cohen (CMU and
Siemens), was instrumental in the semantic design of the
window manager properties; and to Dave Rosenthal (Sun
Microsystems) who also contributed to the protocol and pro-
vided the sample generic color frame buffer device-dependent












code.

The alpha and beta test participants deserve special recog-
nition and thanks as well.  It is significant that the bug
reports (and many fixes) during alpha and beta test came
almost exclusively from just a few of the alpha testers,
mostly hardware vendors working on product implementations
of X.  The continued public contribution of vendors and uni-
versities is certainly to the benefit of the entire X commu-
nity.

Our special thanks must go to Sam Fuller, Vice-President of
Corporate Research at Digital, who has remained committed to
the widest public availability of X and who made it possible
to greatly supplement MIT's resources with the Digital staff
in order to make version 11 a reality.	Many of the people
mentioned here are part of the Western Software Laboratory
(Digital UEG-WSL) of the ULTRIX Engineering group and work
for Smokey Wallace, who has been vital to the project's suc-
cess.  Others not mentioned here worked on the toolkit and
are acknowledged in the X Toolkit documentation.

Of course, we must particularly thank Paul Asente, formerly
of Stanford University and now of Digital UEG-WSL, who wrote
W, the predecessor to X, and Brian Reid, formerly of Stan-
ford University and now of Digital WRL, who had much to do
with W's design.

Finally, our thanks goes to MIT,  Digital Equipment Corpora-
tion, and IBM for providing the environment where it could
happen.

1mRelease 40m

Our thanks go to Jim Fulton (MIT X Consortium) for designing
and specifying the new Xlib functions for Inter-Client Com-
munication Conventions (ICCCM) support.

We also thank Al Mento of Digital for his continued effort
in maintaining this document and Jim Fulton and Donna Con-
verse (MIT X Consortium) for their much-appreciated efforts
in reviewing the changes.

1mRelease 50m

The principal authors of the Input Method facilities are
Vania Joloboff (Open Software Foundation) and Bill McMahon
(Hewlett-Packard).  The principal author of the rest of the
internationalization facilities is Glenn Widener (Tek-
tronix).  Our thanks to them for keeping their sense of
humor through a long and sometimes difficult design process.
Although the words and much of the design are due to them,
many others have contributed substantially to the design and
implementation.	 Tom McFarland (HP) and Frank Rojas (IBM)












deserve particular recognition for their contributions.
Other contributors were: Tim Anderson (Motorola), Alka Bad-
shah (OSF), Gabe Beged-Dov (HP), Chih-Chung Ko (III), Vera
Cheng (III), Michael Collins (Digital), Walt Daniels (IBM),
Noritoshi Demizu (OMRON), Keisuke Fukui (Fujitsu), Hitoshoi
Fukumoto (Nihon Sun), Tim Greenwood (Digital), John Harvey
(IBM), Hideki Hiura (Sun), Fred Horman (AT&T), Norikazu
Kaiya (Fujitsu), Yuji Kamata (IBM), Yutaka Kataoka (Waseda
University), Ranee Khubchandani (Sun), Akira Kon (NEC),
Hiroshi Kuribayashi (OMRON), Teruhiko Kurosaka (Sun), Seiji
Kuwari (OMRON), Sandra Martin (OSF), Narita Masahiko
(Fujitsu), Masato Morisaki (NTT), Nelson Ng (Sun), Takashi
Nishimura (NTT America), Makato Nishino (IBM), Akira Ohsone
(Nihon Sun), Chris Peterson (MIT), Sam Shteingart (AT&T),
Manish Sheth (AT&T), Muneiyoshi Suzuki (NTT), Cori Mehring
(Digital), Shoji Sugiyama (IBM), and Eiji Tosa (IBM).

We are deeply indebted to Tatsuya Kato (NTT), Hiroshi Kurib-
ayashi (OMRON), Seiji Kuwari (OMRON), Muneiyoshi Suzuki
(NTT), and Li Yuhong (OMRON) for producing one of the first
complete sample implementation of the internationalization
facilities, and Hiromu Inukai (Nihon Sun), Takashi Fujiwara
(Fujitsu), Hideki Hiura (Sun), Yasuhiro Kawai (Oki Tech-
nosystems Laboratory), Kazunori Nishihara (Fuji Xerox),
Masaki Takeuchi (Sony), Katsuhisa Yano (Toshiba), Makoto
Wakamatsu (Sony Corporation) for producing the another com-
plete sample implementation of the internationalization
facilities.

The principal authors (design and implementation) of the
Xcms color management facilities are Al Tabayoyon (Tek-
tronix) and Chuck Adams (Tektronix).  Joann Taylor (Tek-
tronix), Bob Toole (Tektronix), and Keith Packard (MIT X
Consortium) also contributed significantly to the design.
Others who contributed are: Harold Boll (Kodak), Ken Bron-
stein (HP), Nancy Cam (SGI), Donna Converse (MIT X Consor-
tium), Elias Israel (ISC), Deron Johnson (Sun), Jim King
(Adobe), Ricardo Motta (HP), Chuck Peek (IBM), Wil Plouffe
(IBM), Dave Sternlicht (MIT X Consortium), Kumar Talluri
(AT&T), and Richard Verberg (IBM).

We also once again thank Al Mento of Digital for his work in
formatting and reformatting text for this manual, and for
producing man pages.  Thanks also to Clive Feather (IXI) for
proof-reading and finding a number of small errors.

1mRelease 60m

Stephen Gildea (X Consortium) authored the threads support.
Ovais Ashraf (Sun) and Greg Olsen (Sun) contributed substan-
tially by testing the facilities and reporting bugs in a
timely fashion.














The principal authors of the internationalization facili-
ties, including Input and Output Methods, are Hideki Hiura
(SunSoft) and Shigeru Yamada (Fujitsu OSSI).  Although the
words and much of the design are due to them, many others
have contributed substantially to the design and implementa-
tion.  They are: Takashi Fujiwara (Fujitsu), Yoshio Horiuchi
(IBM), Makoto Inada (Digital), Hiromu Inukai (Nihon Sun-
Soft), Song JaeKyung (KAIST), Franky Ling (Digital), Tom
McFarland (HP), Hiroyuki Miyamoto (Digital), Masahiko Narita
(Fujitsu), Frank Rojas (IBM), Hidetoshi Tajima (HP), Masaki
Takeuchi (Sony), Makoto Wakamatsu (Sony), Masaki Wakao
(IBM), Katsuhisa Yano(Toshiba) and Jinsoo Yoon (KAIST).

The principal producers of the sample implementation of the
internationalization facilities are: Jeffrey Bloomfield
(Fujitsu OSSI), Takashi Fujiwara (Fujitsu), Hideki Hiura
(SunSoft), Yoshio Horiuchi (IBM), Makoto Inada (Digital),
Hiromu Inukai (Nihon SunSoft), Song JaeKyung (KAIST), Riki
Kawaguchi (Fujitsu), Franky Ling (Digital), Hiroyuki
Miyamoto (Digital), Hidetoshi Tajima (HP), Toshimitsu Tera-
zono (Fujitsu), Makoto Wakamatsu (Sony), Masaki Wakao (IBM),
Shigeru Yamada (Fujitsu OSSI) and Katsuhisa Yano (Toshiba).

The coordinators of the integration, testing, and release of
this implementation of the internationalization facilities
are Nobuyuki Tanaka (Sony) and Makoto Wakamatsu (Sony).

Others who have contributed to the architectural design or
testing of the sample implementation of the international-
ization facilities are: Hector Chan (Digital), Michael Kung
(IBM), Joseph Kwok (Digital), Hiroyuki Machida (Sony), Nel-
son Ng (SunSoft), Frank Rojas (IBM), Yoshiyuki Segawa
(Fujitsu OSSI), Makiko Shimamura (Fujitsu), Shoji Sugiyama
(IBM), Lining Sun (SGI), Masaki Takeuchi (Sony), Jinsoo Yoon
(KAIST) and Akiyasu Zen (HP).




Jim Gettys
Cambridge Research Laboratory
Digital Equipment Corporation

Robert W. Scheifler
Laboratory for Computer Science
Massachusetts Institute of Technology






















			 1mChapter 10m

		    1mIntroduction to Xlib0m



The X Window System is a network-transparent window system
that was designed at MIT.  X display servers run on comput-
ers with either monochrome or color bitmap display hardware.
The server distributes user input to and accepts output
requests from various client programs located either on the
same machine or elsewhere in the network.  Xlib is a C sub-
routine library that application programs (clients) use to
interface with the window system by means of a stream con-
nection.  Although a client usually runs on the same machine
as the X server it is talking to, this need not be the case.

4mXlib24m 4m-24m 4mC24m 4mLanguage24m 4mX24m 4mInterface24m is a reference guide to the
low-level C language interface to the X Window System proto-
col.  It is neither a tutorial nor a user's guide to pro-
gramming the X Window System.  Rather, it provides a
detailed description of each function in the library as well
as a discussion of the related background information.	4mXlib0m
4m-24m 4mC24m 4mLanguage24m 4mX24m 4mInterface24m assumes a basic understanding of a
graphics window system and of the C programming language.
Other higher-level abstractions (for example, those provided
by the toolkits for X) are built on top of the Xlib library.
For further information about these higher-level libraries,
see the appropriate toolkit documentation.  The 4mX24m 4mWindow0m
4mSystem24m 4mProtocol24m provides the definitive word on the behavior
of X.  Although additional information appears here, the
protocol document is the ruling document.

To provide an introduction to X programming, this chapter
discusses:

·    Overview of the X Window System

·    Errors

·    Standard header files

·    Generic values and types

·    Naming and argument conventions within Xlib

·    Programming considerations

·    Character sets and encodings

·    Formatting conventions




			      1m10m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


1m1.1.	Overview of the X Window System0m

Some of the terms used in this book are unique to X, and
other terms that are common to other window systems have
different meanings in X.  You may find it helpful to refer
to the glossary, which is located at the end of the book.

The X Window System supports one or more screens containing
overlapping windows or subwindows.  A screen is a physical
monitor and hardware that can be color, grayscale, or mono-
chrome.	 There can be multiple screens for each display or
workstation.  A single X server can provide display services
for any number of screens.  A set of screens for a single
user with one keyboard and one pointer (usually a mouse) is
called a display.

All the windows in an X server are arranged in strict hier-
archies.  At the top of each hierarchy is a root window,
which covers each of the display screens.  Each root window
is partially or completely covered by child windows.  All
windows, except for root windows, have parents.	 There is
usually at least one window for each application program.
Child windows may in turn have their own children.  In this
way, an application program can create an arbitrarily deep
tree on each screen.  X provides graphics, text, and raster
operations for windows.

A child window can be larger than its parent.  That is, part
or all of the child window can extend beyond the boundaries
of the parent, but all output to a window is clipped by its
parent.	 If several children of a window have overlapping
locations, one of the children is considered to be on top of
or raised over the others, thus obscuring them.	 Output to
areas covered by other windows is suppressed by the window
system unless the window has backing store.  If a window is
obscured by a second window, the second window obscures only
those ancestors of the second window that are also ancestors
of the first window.

A window has a border zero or more pixels in width, which
can be any pattern (pixmap) or solid color you like.  A win-
dow usually but not always has a background pattern, which
will be repainted by the window system when uncovered.
Child windows obscure their parents, and graphic operations
in the parent window usually are clipped by the children.

Each window and pixmap has its own coordinate system.  The
coordinate system has the X axis horizontal and the Y axis
vertical with the origin [0, 0] at the upper-left corner.
Coordinates are integral, in terms of pixels, and coincide
with pixel centers.  For a window, the origin is inside the
border at the inside, upper-left corner.





			      1m20m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


X does not guarantee to preserve the contents of windows.
When part or all of a window is hidden and then brought back
onto the screen, its contents may be lost.  The server then
sends the client program an 4mExpose24m event to notify it that
part or all of the window needs to be repainted.  Programs
must be prepared to regenerate the contents of windows on
demand.

X also provides off-screen storage of graphics objects,
called pixmaps.	 Single plane (depth 1) pixmaps are some-
times referred to as bitmaps.  Pixmaps can be used in most
graphics functions interchangeably with windows and are used
in various graphics operations to define patterns or tiles.
Windows and pixmaps together are referred to as drawables.

Most of the functions in Xlib just add requests to an output
buffer.	 These requests later execute asynchronously on the
X server.  Functions that return values of information
stored in the server do not return (that is, they block)
until an explicit reply is received or an error occurs.	 You
can provide an error handler, which will be called when the
error is reported.

If a client does not want a request to execute asyn-
chronously, it can follow the request with a call to 4mXSync24m,
which blocks until all previously buffered asynchronous
events have been sent and acted on.  As an important side
effect, the output buffer in Xlib is always flushed by a
call to any function that returns a value from the server or
waits for input.

Many Xlib functions will return an integer resource ID,
which allows you to refer to objects stored on the X server.
These can be of type 4mWindow24m, 4mFont24m, 4mPixmap24m, 4mColormap24m, 4mCursor24m,
and 4mGContext24m, as defined in the file <4mX11/X.h24m>.  These
resources are created by requests and are destroyed (or
freed) by requests or when connections are closed.  Most of
these resources are potentially sharable between applica-
tions, and in fact, windows are manipulated explicitly by
window manager programs.  Fonts and cursors are shared auto-
matically across multiple screens.  Fonts are loaded and
unloaded as needed and are shared by multiple clients.
Fonts are often cached in the server.  Xlib provides no sup-
port for sharing graphics contexts between applications.

Client programs are informed of events.	 Events may either
be side effects of a request (for example, restacking win-
dows generates 4mExpose24m events) or completely asynchronous
(for example, from the keyboard).  A client program asks to
be informed of events.	Because other applications can send
events to your application, programs must be prepared to
handle (or ignore) events of all types.





			      1m30m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


Input events (for example, a key pressed or the pointer
moved) arrive asynchronously from the server and are queued
until they are requested by an explicit call (for example,
4mXNextEvent24m or 4mXWindowEvent24m).	In addition, some library
functions (for example, 4mXRaiseWindow24m) generate 4mExpose24m and
4mConfigureRequest24m events.  These events also arrive asyn-
chronously, but the client may wish to explicitly wait for
them by calling 4mXSync24m after calling a function that can
cause the server to generate events.

1m1.2.	Errors0m

Some functions return 4mStatus24m, an integer error indication.
If the function fails, it returns a zero.  If the function
returns a status of zero, it has not updated the return
arguments.  Because C does not provide multiple return val-
ues, many functions must return their results by writing
into client-passed storage.  By default, errors are handled
either by a standard library function or by one that you
provide.  Functions that return pointers to strings return
NULL pointers if the string does not exist.

The X server reports protocol errors at the time that it
detects them.  If more than one error could be generated for
a given request, the server can report any of them.

Because Xlib usually does not transmit requests to the
server immediately (that is, it buffers them), errors can be
reported much later than they actually occur.  For debugging
purposes, however, Xlib provides a mechanism for forcing
synchronous behavior (see section 11.8.1).  When synchro-
nization is enabled, errors are reported as they are gener-
ated.

When Xlib detects an error, it calls an error handler, which
your program can provide.  If you do not provide an error
handler, the error is printed, and your program terminates.

1m1.3.	Standard Header Files0m

The following include files are part of the Xlib standard:

·    <4mX11/Xlib.h24m>

     This is the main header file for Xlib.  The majority of
     all Xlib symbols are declared by including this file.
     This file also contains the preprocessor symbol 4mXlib-0m
     4mSpecificationRelease24m.	 This symbol is defined to have
     the 6 in this release of the standard.  (Release 5 of
     Xlib was the first release to have this symbol.)

·    <4mX11/X.h24m>





			      1m40m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


     This file declares types and constants for the X proto-
     col that are to be used by applications.  It is
     included automatically from <4mX11/Xlib.h24m>, so applica-
     tion code should never need to reference this file
     directly.

·    <4mX11/Xcms.h24m>

     This file contains symbols for much of the color man-
     agement facilities described in chapter 6.	 All func-
     tions, types, and symbols with the prefix ``Xcms'',
     plus the Color Conversion Contexts macros, are declared
     in this file.  <4mX11/Xlib.h24m> must be included before
     including this file.

·    <4mX11/Xutil.h24m>

     This file declares various functions, types, and sym-
     bols used for inter-client communication and applica-
     tion utility functions, which are described in chapters
     14 and 16.	 <4mX11/Xlib.h24m> must be included before
     including this file.

·    <4mX11/Xresource.h24m>

     This file declares all functions, types, and symbols
     for the resource manager facilities, which are
     described in chapter 15.  <4mX11/Xlib.h24m> must be included
     before including this file.

·    <4mX11/Xatom.h24m>

     This file declares all predefined atoms, which are sym-
     bols with the prefix ``XA_''.

·    <4mX11/cursorfont.h24m>

     This file declares the cursor symbols for the standard
     cursor font, which are listed in appendix B.  All cur-
     sor symbols have the prefix ``XC_''.

·    <4mX11/keysymdef.h24m>

     This file declares all standard KeySym values, which
     are symbols with the prefix ``XK_''.  The KeySyms are
     arranged in groups, and a preprocessor symbol controls
     inclusion of each group.  The preprocessor symbol must
     be defined prior to inclusion of the file to obtain the
     associated values.	 The preprocessor symbols are
     XK_MISCELLANY, XK_XKB_KEYS, XK_3270, XK_LATIN1,
     XK_LATIN2, XK_LATIN3, XK_LATIN4, XK_KATAKANA, XK_ARA-
     BIC, XK_CYRILLIC, XK_GREEK, XK_TECHNICAL, XK_SPECIAL,
     XK_PUBLISHING, XK_APL, XK_HEBREW, XK_THAI, and
     XK_KOREAN.



			      1m50m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


·    <4mX11/keysym.h24m>

     This file defines the preprocessor symbols XK_MISCEL-
     LANY, XK_XKB_KEYS, XK_LATIN1, XK_LATIN2, XK_LATIN3,
     XK_LATIN4, and XK_GREEK and then includes
     <4mX11/keysymdef.h24m>.

·    <4mX11/Xlibint.h24m>

     This file declares all the functions, types, and sym-
     bols used for extensions, which are described in appen-
     dix C.  This file automatically includes <4mX11/Xlib.h24m>.

·    <4mX11/Xproto.h24m>

     This file declares types and symbols for the basic X
     protocol, for use in implementing extensions.  It is
     included automatically from <4mX11/Xlibint.h24m>, so appli-
     cation and extension code should never need to refer-
     ence this file directly.

·    <4mX11/Xprotostr.h24m>

     This file declares types and symbols for the basic X
     protocol, for use in implementing extensions.  It is
     included automatically from <4mX11/Xproto.h24m>, so applica-
     tion and extension code should never need to reference
     this file directly.

·    <4mX11/X10.h24m>

     This file declares all the functions, types, and sym-
     bols used for the X10 compatibility functions, which
     are described in appendix D.

1m1.4.	Generic Values and Types0m

The following symbols are defined by Xlib and used through-
out the manual:

·    Xlib defines the type 4mBool24m and the Boolean values 4mTrue0m
     and 4mFalse24m.

·    4mNone24m is the universal null resource ID or atom.

·    The type 4mXID24m is used for generic resource IDs.

·    The type 4mXPointer24m is defined to be char* and is used as
     a generic opaque pointer to data.

1m1.5.	Naming and Argument Conventions within Xlib0m

Xlib follows a number of conventions for the naming and syn-
tax of the functions.  Given that you remember what



			      1m60m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


information the function requires, these conventions are
intended to make the syntax of the functions more pre-
dictable.

The major naming conventions are:

·    To differentiate the X symbols from the other symbols,
     the library uses mixed case for external symbols.	It
     leaves lowercase for variables and all uppercase for
     user macros, as per existing convention.

·    All Xlib functions begin with a capital X.

·    The beginnings of all function names and symbols are
     capitalized.

·    All user-visible data structures begin with a capital
     X.	 More generally, anything that a user might derefer-
     ence begins with a capital X.

·    Macros and other symbols do not begin with a capital X.
     To distinguish them from all user symbols, each word in
     the macro is capitalized.

·    All elements  of or variables in a data structure are
     in lowercase.  Compound words, where needed, are con-
     structed with underscores (_).

·    The display argument, where used, is always first in
     the argument list.

·    All resource objects, where used, occur at the begin-
     ning of the argument list immediately after the display
     argument.

·    When a  graphics context is present together with
     another type of resource (most commonly, a drawable),
     the graphics context occurs in the argument list after
     the other resource.  Drawables outrank all other
     resources.

·    Source arguments always precede the destination argu-
     ments in the argument list.

·    The x argument always precedes the y argument in the
     argument list.

·    The width argument always precedes the height argument
     in the argument list.

·    Where the x, y, width, and height arguments are used
     together, the x and y arguments always precede the
     width and height arguments.




			      1m70m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


·    Where a mask is accompanied with a structure, the mask
     always precedes the pointer to the structure in the
     argument list.

1m1.6.	Programming Considerations0m

The major programming considerations are:

·    Coordinates and sizes in X are actually 16-bit quanti-
     ties.  This decision was made to minimize the bandwidth
     required for a given level of performance.	 Coordinates
     usually are declared as an 4mint24m in the interface.  Val-
     ues larger than 16 bits are truncated silently.  Sizes
     (width and height) are declared as unsigned quantities.

·    Keyboards are the greatest variable between different
     manufacturers' workstations.  If you want your program
     to be portable, you should be particularly conservative
     here.

·    Many display systems have limited amounts of off-screen
     memory.  If you can, you should minimize use of pixmaps
     and backing store.

·    The user should have control of his screen real estate.
     Therefore, you should write your applications to react
     to window management rather than presume control of the
     entire screen.  What you do inside of your top-level
     window, however, is up to your application.  For fur-
     ther information, see chapter 14 and the 4mInter-Client0m
     4mCommunication24m 4mConventions24m 4mManual24m.

1m1.7.	Character Sets and Encodings0m

Some of the Xlib functions make reference to specific char-
acter sets and character encodings.  The following are the
most common:

·    X Portable Character Set

     A basic set of 97 characters, which are assumed to
     exist in all locales supported by Xlib.  This set con-
     tains the following characters:



a..z A..Z 0..9 !"#$%&'()*+,-./:;<=>?@[\]^_`{|}~ <space>,
<tab>, and <newline>



     This set is the left/lower half of the graphic charac-
     ter set of ISO8859-1 plus space, tab, and newline.	 It
     is also the set of graphic characters in 7-bit ASCII



			      1m80m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


     plus the same three control characters.  The actual
     encoding of these characters on the host is system
     dependent.

·    Host Portable Character Encoding

     The encoding of the X Portable Character Set on the
     host.  The encoding itself is not defined by this stan-
     dard, but the encoding must be the same in all locales
     supported by Xlib on the host.  If a string is said to
     be in the Host Portable Character Encoding, then it
     only contains characters from the X Portable Character
     Set, in the host encoding.

·    Latin-1

     The coded character set defined by the ISO 8859-1 stan-
     dard.

·    Latin Portable Character Encoding

     The encoding of the X Portable Character Set using the
     Latin-1 codepoints plus ASCII control characters.	If a
     string is said to be in the Latin Portable Character
     Encoding, then it only contains characters from the X
     Portable Character Set, not all of Latin-1.

·    STRING Encoding

     Latin-1, plus tab and newline.

·    UTF-8 Encoding

     The ASCII compatible character encoding scheme defined
     by the ISO 10646-1 standard.

·    POSIX Portable Filename Character Set

     The set of 65 characters, which can be used in naming
     files on a POSIX-compliant host, that are correctly
     processed in all locales.	The set is:


     a..z A..Z 0..9 ._-


1m1.8.	Formatting Conventions0m

4mXlib24m 4m-24m 4mC24m 4mLanguage24m 4mX24m 4mInterface24m uses the following conven-
tions:

·    Global symbols are printed in 4mthis24m 4mspecial24m 4mfont24m.  These
     can be either function names, symbols defined in
     include files, or structure names.	 When declared and



			      1m90m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


     defined, function arguments are printed in 4mitalics24m.  In
     the explanatory text that follows, they usually are
     printed in regular type.

·    Each function is introduced by a general discussion
     that distinguishes it from other functions.  The func-
     tion declaration itself follows, and each argument is
     specifically explained.  Although ANSI C function pro-
     totype syntax is not used, Xlib header files normally
     declare functions using function prototypes in ANSI C
     environments.  General discussion of the function, if
     any is required, follows the arguments.  Where applica-
     ble, the last paragraph of the explanation lists the
     possible Xlib error codes that the function can gener-
     ate.  For a complete discussion of the Xlib error
     codes, see section 11.8.2.

·    To eliminate any ambiguity between those arguments that
     you pass and those that a function returns to you, the
     explanations for all arguments that you pass start with
     the word 4mspecifies24m or, in the case of multiple argu-
     ments, the word 4mspecify24m.  The explanations for all
     arguments that are returned to you start with the word
     4mreturns24m or, in the case of multiple arguments, the word
     4mreturn24m.  The explanations for all arguments that you
     can pass and are returned start with the words 4mspeci-0m
     4mfies24m 4mand24m 4mreturns24m.

·    Any pointer to a structure that is used to return a
     value is designated as such by the 4m_return24m suffix as
     part of its name.	All other pointers passed to these
     functions are used for reading only.  A few arguments
     use pointers to structures that are used for both input
     and output and are indicated by using the 4m_in_out24m suf-
     fix.






















			     1m100m





1mXlib - C Library			X11, Release 6.7 DRAFT0m




			    1mChapter 20m

			1mDisplay Functions0m



Before your program can use a display, you must establish a
connection to the X server.  Once you have established a
connection, you then can use the Xlib macros and functions
discussed in this chapter to return information about the
display.  This chapter discusses how to:

·    Open (connect to) the display

·    Obtain information about the display, image formats, or
     screens

·    Generate a 4mNoOperation24m protocol request

·    Free client-created data

·    Close (disconnect from) a display

·    Use X Server connection close operations

·    Use Xlib with threads

·    Use internal connections

1m2.1.	Opening the Display0m

To open a connection to the X server that controls a dis-
play, use 4mXOpenDisplay24m.

__
|
Display *XOpenDisplay(4mdisplay_name24m)
      char *4mdisplay_name24m;


4mdisplay_name0m
	  Specifies the hardware display name, which deter-
	  mines the display and communications domain to be
	  used.	 On a POSIX-conformant system, if the dis-
	  play_name is NULL, it defaults to the value of the
	  DISPLAY environment variable.
|__

The encoding and interpretation of the display name are
implementation-dependent.  Strings in the Host Portable
Character Encoding are supported; support for other charac-
ters is implementation-dependent.  On POSIX-conformant



			     1m110m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


systems, the display name or DISPLAY environment variable
can be a string in the format:

__
|
	  4mprotocol24m/4mhostname24m:4mnumber24m.4mscreen_number0m


4mprotocol24m  Specifies a protocol family or an alias for a pro-
	  tocol family.	 Supported protocol families are
	  implementation dependent.  The protocol entry is
	  optional.  If protocol is not specified, the /
	  separating protocol and hostname must also not be
	  specified.

4mhostname24m  Specifies the name of the host machine on which
	  the display is physically attached.  You follow
	  the hostname with either a single colon (:) or a
	  double colon (::).

4mnumber24m    Specifies the number of the display server on that
	  host machine.	 You may optionally follow this dis-
	  play number with a period (.).  A single CPU can
	  have more than one display.  Multiple displays are
	  usually numbered starting with zero.

4mscreen_number0m
	  Specifies the screen to be used on that server.
	  Multiple screens can be controlled by a single X
	  server.  The screen_number sets an internal vari-
	  able that can be accessed by using the 4mDefault-0m
	  4mScreen24m macro or the 4mXDefaultScreen24m function if you
	  are using languages other than C (see section
	  2.2.1).
|__

For example, the following would specify screen 1 of display
0 on the machine named ``dual-headed'':


     dual-headed:0.1


The 4mXOpenDisplay24m function returns a 4mDisplay24m structure that
serves as the connection to the X server and that contains
all the information about that X server.  4mXOpenDisplay24m con-
nects your application to the X server through TCP or DECnet
communications protocols, or through some local inter-
process communication protocol.	 If the protocol is speci-
fied as "tcp", "inet", or "inet6", or if no protocol is
specified and the hostname is a host machine name and a sin-
gle colon (:) separates the hostname and display number,
4mXOpenDisplay24m connects using TCP streams.  (If the protocol
is specified as "inet", TCP over IPv4 is used.	If the



			     1m120m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


protocol is specified as "inet6", TCP over IPv6 is used.
Otherwise, the implementation determines which IP version is
used.)	If the hostname and protocol are both not specified,
Xlib uses whatever it believes is the fastest transport.  If
the hostname is a host machine name and a double colon (::)
separates the hostname and display number, 4mXOpenDisplay24m con-
nects using DECnet.  A single X server can support any or
all of these transport mechanisms simultaneously.  A partic-
ular Xlib implementation can support many more of these
transport mechanisms.

If successful, 4mXOpenDisplay24m returns a pointer to a 4mDisplay0m
structure, which is defined in <4mX11/Xlib.h24m>.  If 4mXOpenDis-0m
4mplay24m does not succeed, it returns NULL.  After a successful
call to 4mXOpenDisplay24m, all of the screens in the display can
be used by the client.	The screen number specified in the
display_name argument is returned by the 4mDefaultScreen24m macro
(or the 4mXDefaultScreen24m function).	You can access elements
of the 4mDisplay24m and 4mScreen24m structures only by using the
information macros or functions.  For information about
using macros and functions to obtain information from the
4mDisplay24m structure, see section 2.2.1.

X servers may implement various types of access control
mechanisms (see section 9.8).

1m2.2.	Obtaining Information about the Display, Image For-0m
1mmats, or Screens0m

The Xlib library provides a number of useful macros and cor-
responding functions that return data from the 4mDisplay0m
structure.  The macros are used for C programming, and their
corresponding function equivalents are for other language
bindings.  This section discusses the:

·    Display macros

·    Image format functions and macros

·    Screen information macros

All other members of the 4mDisplay24m structure (that is, those
for which no macros are defined) are private to Xlib and
must not be used.  Applications must never directly modify
or inspect these private members of the 4mDisplay24m structure.

			    Note

     The 4mXDisplayWidth24m, 4mXDisplayHeight24m, 4mXDisplayCells24m,
     4mXDisplayPlanes24m, 4mXDisplayWidthMM24m, and 4mXDisplay-0m
     4mHeightMM24m functions in the next sections are mis-
     named.  These functions really should be named
     Screen4mwhatever24m and XScreen4mwhatever24m, not Display-
     4mwhatever24m or XDisplay4mwhatever24m.  Our apologies for



			     1m130m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


     the resulting confusion.


1m2.2.1.  Display Macros0m

Applications should not directly modify any part of the 4mDis-0m
4mplay24m and 4mScreen24m structures.  The members should be consid-
ered read-only, although they may change as the result of
other operations on the display.

The following lists the C language macros, their correspond-
ing function equivalents that are for other language bind-
ings, and what data both can return.


__
|
AllPlanes

unsigned long XAllPlanes()

|__

Both return a value with all bits set to 1 suitable for use
in a plane argument to a procedure.


Both 4mBlackPixel24m and 4mWhitePixel24m can be used in implementing a
monochrome application.	 These pixel values are for perma-
nently allocated entries in the default colormap.  The
actual RGB (red, green, and blue) values are settable on
some screens and, in any case, may not actually be black or
white.	The names are intended to convey the expected rela-
tive intensity of the colors.
__
|
BlackPixel(4mdisplay24m, 4mscreen_number24m)

unsigned long XBlackPixel(4mdisplay24m, 4mscreen_number24m)
      Display *4mdisplay24m;
      int 4mscreen_number24m;


4mdisplay24m   Specifies the connection to the X server.

4mscreen_number0m
	  Specifies the appropriate screen number on the
	  host server.
|__

Both return the black pixel value for the specified screen.






			     1m140m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
WhitePixel(4mdisplay24m, 4mscreen_number24m)

unsigned long XWhitePixel(4mdisplay24m, 4mscreen_number24m)
      Display *4mdisplay24m;
      int 4mscreen_number24m;


4mdisplay24m   Specifies the connection to the X server.

4mscreen_number0m
	  Specifies the appropriate screen number on the
	  host server.
|__

Both return the white pixel value for the specified screen.


__
|
ConnectionNumber(4mdisplay24m)

int XConnectionNumber(4mdisplay24m)
      Display *4mdisplay24m;


4mdisplay24m   Specifies the connection to the X server.
|__

Both return a connection number for the specified display.
On a POSIX-conformant system, this is the file descriptor of
the connection.


__
|
DefaultColormap(4mdisplay24m, 4mscreen_number24m)

Colormap XDefaultColormap(4mdisplay24m, 4mscreen_number24m)
      Display *4mdisplay24m;
      int 4mscreen_number24m;


4mdisplay24m   Specifies the connection to the X server.

4mscreen_number0m
	  Specifies the appropriate screen number on the
	  host server.
|__

Both return the default colormap ID for allocation on the
specified screen.  Most routine allocations of color should
be made out of this colormap.




			     1m150m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
DefaultDepth(4mdisplay24m, 4mscreen_number24m)

int XDefaultDepth(4mdisplay24m, 4mscreen_number24m)
      Display *4mdisplay24m;
      int 4mscreen_number24m;


4mdisplay24m   Specifies the connection to the X server.

4mscreen_number0m
	  Specifies the appropriate screen number on the
	  host server.
|__

Both return the depth (number of planes) of the default root
window for the specified screen.  Other depths may also be
supported on this screen (see 4mXMatchVisualInfo24m).


To determine the number of depths that are available on a
given screen, use 4mXListDepths24m.
__
|
int *XListDepths(4mdisplay24m, 4mscreen_number24m, 4mcount_return24m)
      Display *4mdisplay24m;
      int 4mscreen_number24m;
      int *4mcount_return24m;


4mdisplay24m   Specifies the connection to the X server.

4mscreen_number0m
	  Specifies the appropriate screen number on the
	  host server.

4mcount_return0m
	  Returns the number of depths.
|__

The 4mXListDepths24m function returns the array of depths that
are available on the specified screen.	If the specified
screen_number is valid and sufficient memory for the array
can be allocated, 4mXListDepths24m sets count_return to the num-
ber of available depths.  Otherwise, it does not set
count_return and returns NULL.	To release the memory allo-
cated for the array of depths, use 4mXFree24m.










			     1m160m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
DefaultGC(4mdisplay24m, 4mscreen_number24m)

GC XDefaultGC(4mdisplay24m, 4mscreen_number24m)
      Display *4mdisplay24m;
      int 4mscreen_number24m;


4mdisplay24m   Specifies the connection to the X server.

4mscreen_number0m
	  Specifies the appropriate screen number on the
	  host server.
|__

Both return the default graphics context for the root window
of the specified screen.  This GC is created for the conve-
nience of simple applications and contains the default GC
components with the foreground and background pixel values
initialized to the black and white pixels for the screen,
respectively.  You can modify its contents freely because it
is not used in any Xlib function.  This GC should never be
freed.


__
|
DefaultRootWindow(4mdisplay24m)

Window XDefaultRootWindow(4mdisplay24m)
      Display *4mdisplay24m;


4mdisplay24m   Specifies the connection to the X server.
|__

Both return the root window for the default screen.


__
|
DefaultScreenOfDisplay(4mdisplay24m)

Screen *XDefaultScreenOfDisplay(4mdisplay24m)
      Display *4mdisplay24m;


4mdisplay24m   Specifies the connection to the X server.
|__

Both return a pointer to the default screen.






			     1m170m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
ScreenOfDisplay(4mdisplay24m, 4mscreen_number24m)

Screen *XScreenOfDisplay(4mdisplay24m, 4mscreen_number24m)
      Display *4mdisplay24m;
      int 4mscreen_number24m;


4mdisplay24m   Specifies the connection to the X server.

4mscreen_number0m
	  Specifies the appropriate screen number on the
	  host server.
|__

Both return a pointer to the indicated screen.


__
|
DefaultScreen(4mdisplay24m)

int XDefaultScreen(4mdisplay24m)
      Display *4mdisplay24m;


4mdisplay24m   Specifies the connection to the X server.
|__

Both return the default screen number referenced by the
4mXOpenDisplay24m function.  This macro or function should be
used to retrieve the screen number in applications that will
use only a single screen.


__
|
DefaultVisual(4mdisplay24m, 4mscreen_number24m)

Visual *XDefaultVisual(4mdisplay24m, 4mscreen_number24m)
      Display *4mdisplay24m;
      int 4mscreen_number24m;


4mdisplay24m   Specifies the connection to the X server.

4mscreen_number0m
	  Specifies the appropriate screen number on the
	  host server.
|__

Both return the default visual type for the specified
screen.	 For further information about visual types, see
section 3.1.



			     1m180m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
DisplayCells(4mdisplay24m, 4mscreen_number24m)

int XDisplayCells(4mdisplay24m, 4mscreen_number24m)
      Display *4mdisplay24m;
      int 4mscreen_number24m;


4mdisplay24m   Specifies the connection to the X server.

4mscreen_number0m
	  Specifies the appropriate screen number on the
	  host server.
|__

Both return the number of entries in the default colormap.


__
|
DisplayPlanes(4mdisplay24m, 4mscreen_number24m)

int XDisplayPlanes(4mdisplay24m, 4mscreen_number24m)
      Display *4mdisplay24m;
      int 4mscreen_number24m;


4mdisplay24m   Specifies the connection to the X server.

4mscreen_number0m
	  Specifies the appropriate screen number on the
	  host server.
|__

Both return the depth of the root window of the specified
screen.	 For an explanation of depth, see the glossary.


__
|
DisplayString(4mdisplay24m)

char *XDisplayString(4mdisplay24m)
      Display *4mdisplay24m;


4mdisplay24m   Specifies the connection to the X server.
|__

Both return the string that was passed to 4mXOpenDisplay24m when
the current display was opened.	 On POSIX-conformant sys-
tems, if the passed string was NULL, these return the value
of the DISPLAY environment variable when the current display
was opened.  These are useful to applications that invoke



			     1m190m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


the 4mfork24m system call and want to open a new connection to
the same display from the child process as well as for
printing error messages.


__
|
long XExtendedMaxRequestSize(4mdisplay24m)
     Display *4mdisplay24m;


4mdisplay24m   Specifies the connection to the X server.
|__

The 4mXExtendedMaxRequestSize24m function returns zero if the
specified display does not support an extended-length proto-
col encoding; otherwise, it returns the maximum request size
(in 4-byte units) supported by the server using the
extended-length encoding.  The Xlib functions 4mXDrawLines24m,
4mXDrawArcs24m, 4mXFillPolygon24m, 4mXChangeProperty24m, 4mXSetClipRectan-0m
4mgles24m, and 4mXSetRegion24m will use the extended-length encoding
as necessary, if supported by the server.  Use of the
extended-length encoding in other Xlib functions (for exam-
ple, 4mXDrawPoints24m, 4mXDrawRectangles24m, 4mXDrawSegments24m, 4mXFillArcs24m,
4mXFillRectangles24m, 4mXPutImage24m) is permitted but not required;
an Xlib implementation may choose to split the data across
multiple smaller requests instead.


__
|
long XMaxRequestSize(4mdisplay24m)
     Display *4mdisplay24m;


4mdisplay24m   Specifies the connection to the X server.
|__

The 4mXMaxRequestSize24m function returns the maximum request
size (in 4-byte units) supported by the server without using
an extended-length protocol encoding.  Single protocol
requests to the server can be no larger than this size
unless an extended-length protocol encoding is supported by
the server.  The protocol guarantees the size to be no
smaller than 4096 units (16384 bytes).	Xlib automatically
breaks data up into multiple protocol requests as necessary
for the following functions: 4mXDrawPoints24m, 4mXDrawRectangles24m,
4mXDrawSegments24m, 4mXFillArcs24m, 4mXFillRectangles24m, and 4mXPutImage24m.









			     1m200m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
LastKnownRequestProcessed(4mdisplay24m)

unsigned long XLastKnownRequestProcessed(4mdisplay24m)
     Display *4mdisplay24m;


4mdisplay24m   Specifies the connection to the X server.
|__

Both extract the full serial number of the last request
known by Xlib to have been processed by the X server.  Xlib
automatically sets this number when replies, events, and
errors are received.


__
|
NextRequest(4mdisplay24m)

unsigned long XNextRequest(4mdisplay24m)
     Display *4mdisplay24m;


4mdisplay24m   Specifies the connection to the X server.
|__

Both extract the full serial number that is to be used for
the next request.  Serial numbers are maintained separately
for each display connection.


__
|
ProtocolVersion(4mdisplay24m)

int XProtocolVersion(4mdisplay24m)
      Display *4mdisplay24m;


4mdisplay24m   Specifies the connection to the X server.
|__

Both return the major version number (11) of the X protocol
associated with the connected display.












			     1m210m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
ProtocolRevision(4mdisplay24m)

int XProtocolRevision(4mdisplay24m)
      Display *4mdisplay24m;


4mdisplay24m   Specifies the connection to the X server.
|__

Both return the minor protocol revision number of the X
server.


__
|
QLength(4mdisplay24m)

int XQLength(4mdisplay24m)
      Display *4mdisplay24m;


4mdisplay24m   Specifies the connection to the X server.
|__

Both return the length of the event queue for the connected
display.  Note that there may be more events that have not
been read into the queue yet (see 4mXEventsQueued24m).


__
|
RootWindow(4mdisplay24m, 4mscreen_number24m)

Window XRootWindow(4mdisplay24m, 4mscreen_number24m)
      Display *4mdisplay24m;
      int 4mscreen_number24m;


4mdisplay24m   Specifies the connection to the X server.

4mscreen_number0m
	  Specifies the appropriate screen number on the
	  host server.
|__

Both return the root window.  These are useful with func-
tions that need a drawable of a particular screen and for
creating top-level windows.








			     1m220m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
ScreenCount(4mdisplay24m)

int XScreenCount(4mdisplay24m)
      Display *4mdisplay24m;


4mdisplay24m   Specifies the connection to the X server.
|__

Both return the number of available screens.


__
|
ServerVendor(4mdisplay24m)

char *XServerVendor(4mdisplay24m)
      Display *4mdisplay24m;


4mdisplay24m   Specifies the connection to the X server.
|__

Both return a pointer to a null-terminated string that pro-
vides some identification of the owner of the X server
implementation.	 If the data returned by the server is in
the Latin Portable Character Encoding, then the string is in
the Host Portable Character Encoding.  Otherwise, the con-
tents of the string are implementation-dependent.


__
|
VendorRelease(4mdisplay24m)

int XVendorRelease(4mdisplay24m)
      Display *4mdisplay24m;


4mdisplay24m   Specifies the connection to the X server.
|__

Both return a number related to a vendor's release of the X
server.

1m2.2.2.  Image Format Functions and Macros0m

Applications are required to present data to the X server in
a format that the server demands.  To help simplify applica-
tions, most of the work required to convert the data is pro-
vided by Xlib (see sections 8.7 and 16.8).





			     1m230m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


The 4mXPixmapFormatValues24m structure provides an interface to
the pixmap format information that is returned at the time
of a connection setup.	It contains:

__
|
typedef struct {
     int depth;
     int bits_per_pixel;
     int scanline_pad;
} XPixmapFormatValues;

|__


To obtain the pixmap format information for a given display,
use 4mXListPixmapFormats24m.
__
|
XPixmapFormatValues *XListPixmapFormats(4mdisplay24m, 4mcount_return24m)
      Display *4mdisplay24m;
      int *4mcount_return24m;


4mdisplay24m   Specifies the connection to the X server.

4mcount_return0m
	  Returns the number of pixmap formats that are sup-
	  ported by the display.
|__

The 4mXListPixmapFormats24m function returns an array of 4mXPixmap-0m
4mFormatValues24m structures that describe the types of Z format
images supported by the specified display.  If insufficient
memory is available, 4mXListPixmapFormats24m returns NULL.  To
free the allocated storage for the 4mXPixmapFormatValues0m
structures, use 4mXFree24m.

The following lists the C language macros, their correspond-
ing function equivalents that are for other language bind-
ings, and what data they both return for the specified
server and screen.  These are often used by toolkits as well
as by simple applications.














			     1m240m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
ImageByteOrder(4mdisplay24m)

int XImageByteOrder(4mdisplay24m)
      Display *4mdisplay24m;


4mdisplay24m   Specifies the connection to the X server.
|__

Both specify the required byte order for images for each
scanline unit in XY format (bitmap) or for each pixel value
in Z format.  The macro or function can return either 4mLSB-0m
4mFirst24m or 4mMSBFirst24m.


__
|
BitmapUnit(4mdisplay24m)

int XBitmapUnit(4mdisplay24m)
      Display *4mdisplay24m;


4mdisplay24m   Specifies the connection to the X server.
|__

Both return the size of a bitmap's scanline unit in bits.
The scanline is calculated in multiples of this value.


__
|
BitmapBitOrder(4mdisplay24m)

int XBitmapBitOrder(4mdisplay24m)
      Display *4mdisplay24m;


4mdisplay24m   Specifies the connection to the X server.
|__

Within each bitmap unit, the left-most bit in the bitmap as
displayed on the screen is either the least significant or
most significant bit in the unit.  This macro or function
can return 4mLSBFirst24m or 4mMSBFirst24m.











			     1m250m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
BitmapPad(4mdisplay24m)

int XBitmapPad(4mdisplay24m)
      Display *4mdisplay24m;


4mdisplay24m   Specifies the connection to the X server.
|__

Each scanline must be padded to a multiple of bits returned
by this macro or function.


__
|
DisplayHeight(4mdisplay24m, 4mscreen_number24m)

int XDisplayHeight(4mdisplay24m, 4mscreen_number24m)
      Display *4mdisplay24m;
      int 4mscreen_number24m;


4mdisplay24m   Specifies the connection to the X server.

4mscreen_number0m
	  Specifies the appropriate screen number on the
	  host server.
|__

Both return an integer that describes the height of the
screen in pixels.


__
|
DisplayHeightMM(4mdisplay24m, 4mscreen_number24m)

int XDisplayHeightMM(4mdisplay24m, 4mscreen_number24m)
      Display *4mdisplay24m;
      int 4mscreen_number24m;


4mdisplay24m   Specifies the connection to the X server.

4mscreen_number0m
	  Specifies the appropriate screen number on the
	  host server.
|__

Both return the height of the specified screen in millime-
ters.





			     1m260m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
DisplayWidth(4mdisplay24m, 4mscreen_number24m)

int XDisplayWidth(4mdisplay24m, 4mscreen_number24m)
      Display *4mdisplay24m;
      int 4mscreen_number24m;


4mdisplay24m   Specifies the connection to the X server.

4mscreen_number0m
	  Specifies the appropriate screen number on the
	  host server.
|__

Both return the width of the screen in pixels.


__
|
DisplayWidthMM(4mdisplay24m, 4mscreen_number24m)

int XDisplayWidthMM(4mdisplay24m, 4mscreen_number24m)
      Display *4mdisplay24m;
      int 4mscreen_number24m;


4mdisplay24m   Specifies the connection to the X server.

4mscreen_number0m
	  Specifies the appropriate screen number on the
	  host server.
|__

Both return the width of the specified screen in millime-
ters.

1m2.2.3.  Screen Information Macros0m

The following lists the C language macros, their correspond-
ing function equivalents that are for other language bind-
ings, and what data they both can return.  These macros or
functions all take a pointer to the appropriate screen
structure.













			     1m270m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
BlackPixelOfScreen(4mscreen24m)

unsigned long XBlackPixelOfScreen(4mscreen24m)
      Screen *4mscreen24m;


4mscreen24m    Specifies the appropriate 4mScreen24m structure.
|__

Both return the black pixel value of the specified screen.


__
|
WhitePixelOfScreen(4mscreen24m)

unsigned long XWhitePixelOfScreen(4mscreen24m)
      Screen *4mscreen24m;


4mscreen24m    Specifies the appropriate 4mScreen24m structure.
|__

Both return the white pixel value of the specified screen.


__
|
CellsOfScreen(4mscreen24m)

int XCellsOfScreen(4mscreen24m)
      Screen *4mscreen24m;


4mscreen24m    Specifies the appropriate 4mScreen24m structure.
|__

Both return the number of colormap cells in the default col-
ormap of the specified screen.


__
|
DefaultColormapOfScreen(4mscreen24m)

Colormap XDefaultColormapOfScreen(4mscreen24m)
      Screen *4mscreen24m;


4mscreen24m    Specifies the appropriate 4mScreen24m structure.
|__

Both return the default colormap of the specified screen.



			     1m280m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
DefaultDepthOfScreen(4mscreen24m)

int XDefaultDepthOfScreen(4mscreen24m)
      Screen *4mscreen24m;


4mscreen24m    Specifies the appropriate 4mScreen24m structure.
|__

Both return the depth of the root window.


__
|
DefaultGCOfScreen(4mscreen24m)

GC XDefaultGCOfScreen(4mscreen24m)
      Screen *4mscreen24m;


4mscreen24m    Specifies the appropriate 4mScreen24m structure.
|__

Both return a default graphics context (GC) of the specified
screen, which has the same depth as the root window of the
screen.	 The GC must never be freed.


__
|
DefaultVisualOfScreen(4mscreen24m)

Visual *XDefaultVisualOfScreen(4mscreen24m)
      Screen *4mscreen24m;


4mscreen24m    Specifies the appropriate 4mScreen24m structure.
|__

Both return the default visual of the specified screen.	 For
information on visual types, see section 3.1.















			     1m290m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
DoesBackingStore(4mscreen24m)

int XDoesBackingStore(4mscreen24m)
      Screen *4mscreen24m;


4mscreen24m    Specifies the appropriate 4mScreen24m structure.
|__

Both return a value indicating whether the screen supports
backing stores.	 The value returned can be one of 4mWhen-0m
4mMapped24m, 4mNotUseful24m, or 4mAlways24m (see section 3.2.4).


__
|
DoesSaveUnders(4mscreen24m)

Bool XDoesSaveUnders(4mscreen24m)
      Screen *4mscreen24m;


4mscreen24m    Specifies the appropriate 4mScreen24m structure.
|__

Both return a Boolean value indicating whether the screen
supports save unders.  If 4mTrue24m, the screen supports save
unders.	 If 4mFalse24m, the screen does not support save unders
(see section 3.2.5).


__
|
DisplayOfScreen(4mscreen24m)

Display *XDisplayOfScreen(4mscreen24m)
      Screen *4mscreen24m;


4mscreen24m    Specifies the appropriate 4mScreen24m structure.
|__

Both return the display of the specified screen.













			     1m300m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
int XScreenNumberOfScreen(4mscreen24m)
      Screen *4mscreen24m;


4mscreen24m    Specifies the appropriate 4mScreen24m structure.
|__

The 4mXScreenNumberOfScreen24m function returns the screen index
number of the specified screen.


__
|
EventMaskOfScreen(4mscreen24m)

long XEventMaskOfScreen(4mscreen24m)
      Screen *4mscreen24m;


4mscreen24m    Specifies the appropriate 4mScreen24m structure.
|__

Both return the event mask of the root window for the speci-
fied screen at connection setup time.


__
|
WidthOfScreen(4mscreen24m)

int XWidthOfScreen(4mscreen24m)
      Screen *4mscreen24m;


4mscreen24m    Specifies the appropriate 4mScreen24m structure.
|__

Both return the width of the specified screen in pixels.


__
|
HeightOfScreen(4mscreen24m)

int XHeightOfScreen(4mscreen24m)
      Screen *4mscreen24m;


4mscreen24m    Specifies the appropriate 4mScreen24m structure.
|__

Both return the height of the specified screen in pixels.




			     1m310m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
WidthMMOfScreen(4mscreen24m)

int XWidthMMOfScreen(4mscreen24m)
      Screen *4mscreen24m;


4mscreen24m    Specifies the appropriate 4mScreen24m structure.
|__

Both return the width of the specified screen in millime-
ters.


__
|
HeightMMOfScreen(4mscreen24m)

int XHeightMMOfScreen(4mscreen24m)
      Screen *4mscreen24m;


4mscreen24m    Specifies the appropriate 4mScreen24m structure.
|__

Both return the height of the specified screen in millime-
ters.


__
|
MaxCmapsOfScreen(4mscreen24m)

int XMaxCmapsOfScreen(4mscreen24m)
      Screen *4mscreen24m;


4mscreen24m    Specifies the appropriate 4mScreen24m structure.
|__

Both return the maximum number of installed colormaps sup-
ported by the specified screen (see section 9.3).















			     1m320m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
MinCmapsOfScreen(4mscreen24m)

int XMinCmapsOfScreen(4mscreen24m)
      Screen *4mscreen24m;


4mscreen24m    Specifies the appropriate 4mScreen24m structure.
|__

Both return the minimum number of installed colormaps sup-
ported by the specified screen (see section 9.3).


__
|
PlanesOfScreen(4mscreen24m)

int XPlanesOfScreen(4mscreen24m)
      Screen *4mscreen24m;


4mscreen24m    Specifies the appropriate 4mScreen24m structure.
|__

Both return the depth of the root window.


__
|
RootWindowOfScreen(4mscreen24m)

Window XRootWindowOfScreen(4mscreen24m)
      Screen *4mscreen24m;


4mscreen24m    Specifies the appropriate 4mScreen24m structure.
|__

Both return the root window of the specified screen.

1m2.3.	Generating a NoOperation Protocol Request0m

To execute a 4mNoOperation24m protocol request, use 4mXNoOp24m.
__
|
XNoOp(4mdisplay24m)
      Display *4mdisplay24m;


4mdisplay24m   Specifies the connection to the X server.
|__

The 4mXNoOp24m function sends a 4mNoOperation24m protocol request to



			     1m330m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


the X server, thereby exercising the connection.

1m2.4.	Freeing Client-Created Data0m

To free in-memory data that was created by an Xlib function,
use 4mXFree24m.
__
|
XFree(4mdata24m)
     void *4mdata24m;


4mdata24m      Specifies the data that is to be freed.
|__

The 4mXFree24m function is a general-purpose Xlib routine that
frees the specified data.  You must use it to free any
objects that were allocated by Xlib, unless an alternate
function is explicitly specified for the object.  A NULL
pointer cannot be passed to this function.

1m2.5.	Closing the Display0m

To close a display or disconnect from the X server, use
4mXCloseDisplay24m.

__
|
XCloseDisplay(4mdisplay24m)
      Display *4mdisplay24m;


4mdisplay24m   Specifies the connection to the X server.
|__

The 4mXCloseDisplay24m function closes the connection to the X
server for the display specified in the 4mDisplay24m structure
and destroys all windows, resource IDs (4mWindow24m, 4mFont24m,
4mPixmap24m, 4mColormap24m, 4mCursor24m, and 4mGContext24m), or other resources
that the client has created on this display, unless the
close-down mode of the resource has been changed (see 4mXSet-0m
4mCloseDownMode24m).  Therefore, these windows, resource IDs, and
other resources should never be referenced again or an error
will be generated.  Before exiting, you should call
4mXCloseDisplay24m explicitly so that any pending errors are
reported as 4mXCloseDisplay24m performs a final 4mXSync24m operation.

4mXCloseDisplay24m can generate a 4mBadGC24m error.


Xlib provides a function to permit the resources owned by a
client to survive after the client's connection is closed.
To change a client's close-down mode, use 4mXSetCloseDownMode24m.




			     1m340m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
XSetCloseDownMode(4mdisplay24m, 4mclose_mode24m)
      Display *4mdisplay24m;
      int 4mclose_mode24m;


4mdisplay24m   Specifies the connection to the X server.

4mclose_mode0m
	  Specifies the client close-down mode.	 You can
	  pass 4mDestroyAll24m, 4mRetainPermanent24m, or 4mRetainTempo-0m
	  4mrary24m.
|__

The 4mXSetCloseDownMode24m defines what will happen to the
client's resources at connection close.	 A connection starts
in 4mDestroyAll24m mode.  For information on what happens to the
client's resources when the close_mode argument is 4mRetain-0m
4mPermanent24m or 4mRetainTemporary24m, see section 2.6.

4mXSetCloseDownMode24m can generate a 4mBadValue24m error.

1m2.6.	Using X Server Connection Close Operations0m

When the X server's connection to a client is closed either
by an explicit call to 4mXCloseDisplay24m or by a process that
exits, the X server performs the following automatic opera-
tions:

·    It disowns all selections owned by the client (see
     4mXSetSelectionOwner24m).

·    It performs an 4mXUngrabPointer24m and 4mXUngrabKeyboard24m if
     the client has actively grabbed the pointer or the key-
     board.

·    It performs an 4mXUngrabServer24m if the client has grabbed
     the server.

·    It releases all passive grabs made by the client.

·    It marks all resources (including colormap entries)
     allocated by the client either as permanent or tempo-
     rary, depending on whether the close-down mode is
     4mRetainPermanent24m or 4mRetainTemporary24m.  However, this does
     not prevent other client applications from explicitly
     destroying the resources (see 4mXSetCloseDownMode24m).

When the close-down mode is 4mDestroyAll24m, the X server
destroys all of a client's resources as follows:

·    It examines each window in the client's save-set to
     determine if it is an inferior (subwindow) of a window
     created by the client.  (The save-set is a list of



			     1m350m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


     other clients' windows that are referred to as save-set
     windows.)	If so, the X server reparents the save-set
     window to the closest ancestor so that the save-set
     window is not an inferior of a window created by the
     client.  The reparenting leaves unchanged the absolute
     coordinates (with respect to the root window) of the
     upper-left outer corner of the save-set window.

·    It performs a 4mMapWindow24m request on the save-set window
     if the save-set window is unmapped.  The X server does
     this even if the save-set window was not an inferior of
     a window created by the client.

·    It destroys all windows created by the client.

·    It performs the appropriate free request on each non-
     window resource created by the client in the server
     (for example, 4mFont24m, 4mPixmap24m, 4mCursor24m, 4mColormap24m, and 4mGCon-0m
     4mtext24m).

·    It frees all colors and colormap entries allocated by a
     client application.

Additional processing occurs when the last connection to the
X server closes.  An X server goes through a cycle of having
no connections and having some connections.  When the last
connection to the X server closes as a result of a connec-
tion closing with the close_mode of 4mDestroyAll24m, the X server
does the following:

·    It resets its state as if it had just been started.
     The X server begins by destroying all lingering
     resources from clients that have terminated in 4mRetain-0m
     4mPermanent24m or 4mRetainTemporary24m mode.

·    It deletes all but the predefined atom identifiers.

·    It deletes all properties on all root windows (see sec-
     tion 4.3).

·    It resets all device maps and attributes (for example,
     key click, bell volume, and acceleration) as well as
     the access control list.

·    It restores the standard root tiles and cursors.

·    It restores the default font path.

·    It restores the input focus to state 4mPointerRoot24m.

However, the X server does not reset if you close a connec-
tion with a close-down mode set to 4mRetainPermanent24m or
4mRetainTemporary24m.




			     1m360m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


1m2.7.	Using Xlib with Threads0m

On systems that have threads, support may be provided to
permit multiple threads to use Xlib concurrently.


To initialize support for concurrent threads, use 4mXInit-0m
4mThreads24m.
__
|
Status XInitThreads();

|__

The 4mXInitThreads24m function initializes Xlib support for con-
current threads.  This function must be the first Xlib func-
tion a multi-threaded program calls, and it must complete
before any other Xlib call is made.  This function returns a
nonzero status if initialization was successful; otherwise,
it returns zero.  On systems that do not support threads,
this function always returns zero.

It is only necessary to call this function if multiple
threads might use Xlib concurrently.  If all calls to Xlib
functions are protected by some other access mechanism (for
example, a mutual exclusion lock in a toolkit or through
explicit client programming), Xlib thread initialization is
not required.  It is recommended that single-threaded pro-
grams not call this function.



To lock a display across several Xlib calls, use 4mXLockDis-0m
4mplay24m.
__
|
void XLockDisplay(4mdisplay24m)
      Display *4mdisplay24m;


4mdisplay24m   Specifies the connection to the X server.
|__

The 4mXLockDisplay24m function locks out all other threads from
using the specified display.  Other threads attempting to
use the display will block until the display is unlocked by
this thread.  Nested calls to 4mXLockDisplay24m work correctly;
the display will not actually be unlocked until 4mXUnlockDis-0m
4mplay24m has been called the same number of times as 4mXLockDis-0m
4mplay24m.  This function has no effect unless Xlib was success-
fully initialized for threads using 4mXInitThreads24m.


To unlock a display, use 4mXUnlockDisplay24m.



			     1m370m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
void XUnlockDisplay(4mdisplay24m)
      Display *4mdisplay24m;


4mdisplay24m   Specifies the connection to the X server.
|__

The 4mXUnlockDisplay24m function allows other threads to use the
specified display again.  Any threads that have blocked on
the display are allowed to continue.  Nested locking works
correctly; if 4mXLockDisplay24m has been called multiple times by
a thread, then 4mXUnlockDisplay24m must be called an equal number
of times before the display is actually unlocked.  This
function has no effect unless Xlib was successfully initial-
ized for threads using 4mXInitThreads24m.

1m2.8.	Using Internal Connections0m

In addition to the connection to the X server, an Xlib
implementation may require connections to other kinds of
servers (for example, to input method servers as described
in chapter 13).	 Toolkits and clients that use multiple dis-
plays, or that use displays in combination with other
inputs, need to obtain these additional connections to cor-
rectly block until input is available and need to process
that input when it is available.  Simple clients that use a
single display and block for input in an Xlib event function
do not need to use these facilities.

To track internal connections for a display, use 4mXAddConnec-0m
4mtionWatch24m.

























			     1m380m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
typedef void (*XConnectionWatchProc)(4mdisplay24m, 4mclient_data24m, 4mfd24m, 4mopening24m, 4mwatch_data24m)
      Display *4mdisplay24m;
      XPointer 4mclient_data24m;
      int 4mfd24m;
      Bool 4mopening24m;
      XPointer *4mwatch_data24m;

Status XAddConnectionWatch(4mdisplay24m, 4mprocedure24m, 4mclient_data24m)
      Display *4mdisplay24m;
      XWatchProc 4mprocedure24m;
      XPointer 4mclient_data24m;


4mdisplay24m   Specifies the connection to the X server.

4mprocedure24m Specifies the procedure to be called.

4mclient_data0m
	  Specifies the additional client data.
|__

The 4mXAddConnectionWatch24m function registers a procedure to be
called each time Xlib opens or closes an internal connection
for the specified display.  The procedure is passed the dis-
play, the specified client_data, the file descriptor for the
connection, a Boolean indicating whether the connection is
being opened or closed, and a pointer to a location for pri-
vate watch data.  If opening is 4mTrue24m, the procedure can
store a pointer to private data in the location pointed to
by watch_data; when the procedure is later called for this
same connection and opening is 4mFalse24m, the location pointed
to by watch_data will hold this same private data pointer.

This function can be called at any time after a display is
opened.	 If internal connections already exist, the regis-
tered procedure will immediately be called for each of them,
before 4mXAddConnectionWatch24m returns.  4mXAddConnectionWatch0m
returns a nonzero status if the procedure is successfully
registered; otherwise, it returns zero.

The registered procedure should not call any Xlib functions.
If the procedure directly or indirectly causes the state of
internal connections or watch procedures to change, the
result is not defined.	If Xlib has been initialized for
threads, the procedure is called with the display locked and
the result of a call by the procedure to any Xlib function
that locks the display is not defined unless the executing
thread has externally locked the display using 4mXLockDisplay24m.


To stop tracking internal connections for a display, use
4mXRemoveConnectionWatch24m.




			     1m390m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
Status XRemoveConnectionWatch(4mdisplay24m, 4mprocedure24m, 4mclient_data24m)
      Display *4mdisplay24m;
      XWatchProc 4mprocedure24m;
      XPointer 4mclient_data24m;


4mdisplay24m   Specifies the connection to the X server.

4mprocedure24m Specifies the procedure to be called.

4mclient_data0m
	  Specifies the additional client data.
|__

The 4mXRemoveConnectionWatch24m function removes a previously
registered connection watch procedure.	The client_data must
match the client_data used when the procedure was initially
registered.



To process input on an internal connection, use 4mXProcessIn-0m
4mternalConnection24m.
__
|
void XProcessInternalConnection(4mdisplay24m, 4mfd24m)
      Display *4mdisplay24m;
      int 4mfd24m;


4mdisplay24m   Specifies the connection to the X server.

4mfd24m	       Specifies the file descriptor.
|__

The 4mXProcessInternalConnection24m function processes input
available on an internal connection.  This function should
be called for an internal connection only after an operating
system facility (for example, 4mselect24m or 4mpoll24m) has indicated
that input is available; otherwise, the effect is not
defined.


To obtain all of the current internal connections for a dis-
play, use 4mXInternalConnectionNumbers24m.











			     1m400m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
Status XInternalConnectionNumbers(4mdisplay24m, 4mfd_return24m, 4mcount_return24m)
      Display *4mdisplay24m;
      int **4mfd_return24m;
      int *4mcount_return24m;


4mdisplay24m   Specifies the connection to the X server.

4mfd_return24m Returns the file descriptors.

4mcount_return0m
	  Returns the number of file descriptors.
|__

The 4mXInternalConnectionNumbers24m function returns a list of
the file descriptors for all internal connections currently
open for the specified display.	 When the allocated list is
no longer needed, free it by using 4mXFree24m.	This functions
returns a nonzero status if the list is successfully allo-
cated; otherwise, it returns zero.




































			     1m410m





1mXlib - C Library			X11, Release 6.7 DRAFT0m




			 1mChapter 30m

		      1mWindow Functions0m



In the X Window System, a window is a rectangular area on
the screen that lets you view graphic output.  Client appli-
cations can display overlapping and nested windows on one or
more screens that are driven by X servers on one or more
machines.  Clients who want to create windows must first
connect their program to the X server by calling 4mXOpenDis-0m
4mplay24m.  This chapter begins with a discussion of visual types
and window attributes.	The chapter continues with a discus-
sion of the Xlib functions you can use to:

·    Create windows

·    Destroy windows

·    Map windows

·    Unmap windows

·    Configure windows

·    Change window stacking order

·    Change window attributes

This chapter also identifies the window actions that may
generate events.

Note that it is vital that your application conform to the
established conventions for communicating with window man-
agers for it to work well with the various window managers
in use (see section 14.1).  Toolkits generally adhere to
these conventions for you, relieving you of the burden.
Toolkits also often supersede many functions in this chapter
with versions of their own.  For more information, refer to
the documentation for the toolkit that you are using.

1m3.1.	Visual Types0m

On some display hardware, it may be possible to deal with
color resources in more than one way.  For example, you may
be able to deal with a screen of either 12-bit depth with
arbitrary mapping of pixel to color (pseudo-color) or 24-bit
depth with 8 bits of the pixel dedicated to each of red,
green, and blue.  These different ways of dealing with the
visual aspects of the screen are called visuals.  For each
screen of the display, there may be a list of valid visual



			     1m420m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


types supported at different depths of the screen.  Because
default windows and visual types are defined for each
screen, most simple applications need not deal with this
complexity.  Xlib provides macros and functions that return
the default root window, the default depth of the default
root window, and the default visual type (see sections 2.2.1
and 16.7).

Xlib uses an opaque 4mVisual24m structure that contains informa-
tion about the possible color mapping.	The visual utility
functions (see section 16.7) use an 4mXVisualInfo24m structure to
return this information to an application.  The members of
this structure pertinent to this discussion are class,
red_mask, green_mask, blue_mask, bits_per_rgb, and col-
ormap_size.  The class member specifies one of the possible
visual classes of the screen and can be 4mStaticGray24m, 4mStatic-0m
4mColor24m, 4mTrueColor24m, 4mGrayScale24m, 4mPseudoColor24m, or 4mDirectColor24m.

The following concepts may serve to make the explanation of
visual types clearer.  The screen can be color or grayscale,
can have a colormap that is writable or read-only, and can
also have a colormap whose indices are decomposed into sepa-
rate RGB pieces, provided one is not on a grayscale screen.
This leads to the following diagram:



			     Color	    Gray-scale
			 R/O	  R/W	   R/O	    R/W
	+-------------+--------+--------+--------+-------+
	|Undecomposed | Static | Pseudo | Static | Gray	 |
	|  Colormap   | Color  | Color	|  Gray	 | Scale |
	+-------------+--------+--------+--------+-------+
	| Decomposed  |	 True  | Direct |
	|  Colormap   | Color  | Color	|
	+-------------+--------+--------+



Conceptually, as each pixel is read out of video memory for
display on the screen, it goes through a look-up stage by
indexing into a colormap.  Colormaps can be manipulated
arbitrarily on some hardware, in limited ways on other hard-
ware, and not at all on other hardware.	 The visual types
affect the colormap and the RGB values in the following
ways:


·    For 4mPseudoColor24m, a pixel value indexes a colormap to
     produce independent RGB values, and the RGB values can
     be changed dynamically.

·    4mGrayScale24m is treated the same way as 4mPseudoColor24m except
     that the primary that drives the screen is undefined.



			     1m430m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


     Thus, the client should always store the same value for
     red, green, and blue in the colormaps.

·    For 4mDirectColor24m, a pixel value is decomposed into sepa-
     rate RGB subfields, and each subfield separately
     indexes the colormap for the corresponding value.	The
     RGB values can be changed dynamically.

·    4mTrueColor24m is treated the same way as 4mDirectColor24m except
     that the colormap has predefined, read-only RGB values.
     These RGB values are server dependent but provide lin-
     ear or near-linear ramps in each primary.

·    4mStaticColor24m is treated the same way as 4mPseudoColor0m
     except that the colormap has predefined, read-only,
     server-dependent RGB values.

·    4mStaticGray24m is treated the same way as 4mStaticColor0m
     except that the RGB values are equal for any single
     pixel value, thus resulting in shades of gray.  4mStat-0m
     4micGray24m with a two-entry colormap can be thought of as
     monochrome.

The red_mask, green_mask, and blue_mask members are only
defined for 4mDirectColor24m and 4mTrueColor24m.  Each has one con-
tiguous set of bits with no intersections.  The bits_per_rgb
member specifies the log base 2 of the number of distinct
color values (individually) of red, green, and blue.  Actual
RGB values are unsigned 16-bit numbers.	 The colormap_size
member defines the number of available colormap entries in a
newly created colormap.	 For 4mDirectColor24m and 4mTrueColor24m, this
is the size of an individual pixel subfield.


To obtain the visual ID from a 4mVisual24m, use 4mXVisualIDFromVi-0m
4msual24m.
__
|
VisualID XVisualIDFromVisual(4mvisual24m)
       Visual *4mvisual24m;


4mvisual24m    Specifies the visual type.
|__

The 4mXVisualIDFromVisual24m function returns the visual ID for
the specified visual type.

1m3.2.	Window Attributes0m

All 4mInputOutput24m windows have a border width of zero or more
pixels, an optional background, an event suppression mask
(which suppresses propagation of events from children), and
a property list (see section 4.3).  The window border and



			     1m440m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


background can be a solid color or a pattern, called a tile.
All windows except the root have a parent and are clipped by
their parent.  If a window is stacked on top of another win-
dow, it obscures that other window for the purpose of input.
If a window has a background (almost all do), it obscures
the other window for purposes of output.  Attempts to output
to the obscured area do nothing, and no input events (for
example, pointer motion) are generated for the obscured
area.

Windows also have associated property lists (see section
4.3).

Both 4mInputOutput24m and 4mInputOnly24m windows have the following
common attributes, which are the only attributes of an 4mInpu-0m
4mtOnly24m window:

·    win-gravity

·    event-mask

·    do-not-propagate-mask

·    override-redirect

·    cursor

If you specify any other attributes for an 4mInputOnly24m window,
a 4mBadMatch24m error results.

4mInputOnly24m windows are used for controlling input events in
situations where 4mInputOutput24m windows are unnecessary.  4mInpu-0m
4mtOnly24m windows are invisible; can only be used to control
such things as cursors, input event generation, and grab-
bing; and cannot be used in any graphics requests.  Note
that 4mInputOnly24m windows cannot have 4mInputOutput24m windows as
inferiors.

Windows have borders of a programmable width and pattern as
well as a background pattern or tile.  Pixel values can be
used for solid colors.	The background and border pixmaps
can be destroyed immediately after creating the window if no
further explicit references to them are to be made.  The
pattern can either be relative to the parent or absolute.
If 4mParentRelative24m, the parent's background is used.

When windows are first created, they are not visible (not
mapped) on the screen.	Any output to a window that is not
visible on the screen and that does not have backing store
will be discarded.  An application may wish to create a win-
dow long before it is mapped to the screen.  When a window
is eventually mapped to the screen (using 4mXMapWindow24m), the X
server generates an 4mExpose24m event for the window if backing
store has not been maintained.



			     1m450m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


A window manager can override your choice of size, border
width, and position for a top-level window.  Your program
must be prepared to use the actual size and position of the
top window.  It is not acceptable for a client application
to resize itself unless in direct response to a human com-
mand to do so.	Instead, either your program should use the
space given to it, or if the space is too small for any use-
ful work, your program might ask the user to resize the win-
dow.  The border of your top-level window is considered fair
game for window managers.

To set an attribute of a window, set the appropriate member
of the 4mXSetWindowAttributes24m structure and OR in the corre-
sponding value bitmask in your subsequent calls to 4mXCre-0m
4mateWindow24m and 4mXChangeWindowAttributes24m, or use one of the
other convenience functions that set the appropriate
attribute.  The symbols for the value mask bits and the
4mXSetWindowAttributes24m structure are:







































			     1m460m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
/* Window attribute value mask bits */

#define	  4mCWBackPixmap24m		   (1L<<0)
#define	  4mCWBackPixel24m		   (1L<<1)
#define	  4mCWBorderPixmap24m		   (1L<<2)
#define	  4mCWBorderPixel24m		   (1L<<3)
#define	  4mCWBitGravity24m		   (1L<<4)
#define	  4mCWWinGravity24m		   (1L<<5)
#define	  4mCWBackingStore24m		   (1L<<6)
#define	  4mCWBackingPlanes24m		   (1L<<7)
#define	  4mCWBackingPixel24m		   (1L<<8)
#define	  4mCWOverrideRedirect24m	   (1L<<9)
#define	  4mCWSaveUnder24m		   (1L<<10)
#define	  4mCWEventMask24m		   (1L<<11)
#define	  4mCWDontPropagate24m		   (1L<<12)
#define	  4mCWColormap24m		   (1L<<13)
#define	  4mCWCursor24m			   (1L<<14)


/* Values */

typedef struct {
     Pixmap background_pixmap;/* background, None, or ParentRelative */
     unsigned long background_pixel;/* background pixel */
     Pixmap border_pixmap;    /* border of the window or CopyFromParent */
     unsigned long border_pixel;/* border pixel value */
     int bit_gravity;	      /* one of bit gravity values */
     int win_gravity;	      /* one of the window gravity values */
     int backing_store;	      /* NotUseful, WhenMapped, Always */
     unsigned long backing_planes;/* planes to be preserved if possible */
     unsigned long backing_pixel;/* value to use in restoring planes */
     Bool save_under;	      /* should bits under be saved? (popups) */
     long event_mask;	      /* set of events that should be saved */
     long do_not_propagate_mask;/* set of events that should not propagate */
     Bool override_redirect;  /* boolean value for override_redirect */
     Colormap colormap;	      /* color map to be associated with window */
     Cursor cursor;	      /* cursor to be displayed (or None) */
} XSetWindowAttributes;

|__

The following lists the defaults for each window attribute
and indicates whether the attribute is applicable to
4mInputOutput24m and 4mInputOnly24m windows:

-------------------------------------------------------------
1mAttribute		  Default	  4m22mInputOut-24m   4mInpu-0m
					4mput24m	 4mtOnly0m
-------------------------------------------------------------
background-pixmap	4mNone24m		Yes	    No
background-pixel	Undefined	   Yes	       No





			     1m470m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


-------------------------------------------------------------
1mAttribute		  Default	  4m22mInputOut-24m   4mInpu-0m
					4mput24m	 4mtOnly0m
-------------------------------------------------------------
border-pixmap		4mCopyFromPar-24m	Yes	    No
			4ment0m
border-pixel		Undefined	   Yes	       No
bit-gravity		4mForgetGravity24m	Yes	    No
win-gravity		4mNorthWest-24m		Yes	   Yes
			4mGravity0m
backing-store		4mNotUseful24m		Yes	    No
backing-planes		All ones	   Yes	       No
backing-pixel		zero		   Yes	       No
save-under		4mFalse24m		Yes	    No
event-mask		empty set	   Yes	      Yes
do-not-propagate-mask	empty set	   Yes	      Yes
override-redirect	4mFalse24m		Yes	   Yes
colormap		4mCopyFromPar-24m	Yes	    No
			4ment0m
cursor			4mNone24m		Yes	   Yes
-------------------------------------------------------------


1m3.2.1.  Background Attribute0m

Only 4mInputOutput24m windows can have a background.  You can set
the background of an 4mInputOutput24m window by using a pixel or
a pixmap.

The background-pixmap attribute of a window specifies the
pixmap to be used for a window's background.  This pixmap
can be of any size, although some sizes may be faster than
others.	 The background-pixel attribute of a window speci-
fies a pixel value used to paint a window's background in a
single color.

You can set the background-pixmap to a pixmap, 4mNone0m
(default), or 4mParentRelative24m.  You can set the background-
pixel of a window to any pixel value (no default).  If you
specify a background-pixel, it overrides either the default
background-pixmap or any value you may have set in the back-
ground-pixmap.	A pixmap of an undefined size that is filled
with the background-pixel is used for the background.  Range
checking is not performed on the background pixel; it simply
is truncated to the appropriate number of bits.

If you set the background-pixmap, it overrides the default.
The background-pixmap and the window must have the same
depth, or a 4mBadMatch24m error results.  If you set background-
pixmap to 4mNone24m, the window has no defined background.  If
you set the background-pixmap to 4mParentRelative24m:

·    The parent window's background-pixmap is used.  The
     child window, however, must have the same depth as its



			     1m480m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


     parent, or a 4mBadMatch24m error results.

·    If the parent window has a background-pixmap of 4mNone24m,
     the window also has a background-pixmap of 4mNone24m.

·    A copy of the parent window's background-pixmap is not
     made.  The parent's background-pixmap is examined each
     time the child window's background-pixmap is required.

·    The background tile origin always aligns with the par-
     ent window's background tile origin.  If the back-
     ground-pixmap is not 4mParentRelative24m, the background
     tile origin is the child window's origin.

Setting a new background, whether by setting background-
pixmap or background-pixel, overrides any previous back-
ground.	 The background-pixmap can be freed immediately if
no further explicit reference is made to it (the X server
will keep a copy to use when needed).  If you later draw
into the pixmap used for the background, what happens is
undefined because the X implementation is free to make a
copy of the pixmap or to use the same pixmap.

When no valid contents are available for regions of a window
and either the regions are visible or the server is main-
taining backing store, the server automatically tiles the
regions with the window's background unless the window has a
background of 4mNone24m.  If the background is 4mNone24m, the previous
screen contents from other windows of the same depth as the
window are simply left in place as long as the contents come
from the parent of the window or an inferior of the parent.
Otherwise, the initial contents of the exposed regions are
undefined.  4mExpose24m events are then generated for the
regions, even if the background-pixmap is 4mNone24m (see section
10.9).

1m3.2.2.  Border Attribute0m

Only 4mInputOutput24m windows can have a border.  You can set the
border of an 4mInputOutput24m window by using a pixel or a
pixmap.

The border-pixmap attribute of a window specifies the pixmap
to be used for a window's border.  The border-pixel
attribute of a window specifies a pixmap of undefined size
filled with that pixel be used for a window's border.  Range
checking is not performed on the background pixel; it simply
is truncated to the appropriate number of bits.	 The border
tile origin is always the same as the background tile ori-
gin.

You can also set the border-pixmap to a pixmap of any size
(some may be faster than others) or to 4mCopyFromParent0m
(default).  You can set the border-pixel to any pixel value



			     1m490m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


(no default).

If you set a border-pixmap, it overrides the default.  The
border-pixmap and the window must have the same depth, or a
4mBadMatch24m error results.  If you set the border-pixmap to
4mCopyFromParent24m, the parent window's border-pixmap is copied.
Subsequent changes to the parent window's border attribute
do not affect the child window.	 However, the child window
must have the same depth as the parent window, or a 4mBadMatch0m
error results.

The border-pixmap can be freed immediately if no further
explicit reference is made to it.  If you later draw into
the pixmap used for the border, what happens is undefined
because the X implementation is free either to make a copy
of the pixmap or to use the same pixmap.  If you specify a
border-pixel, it overrides either the default border-pixmap
or any value you may have set in the border-pixmap.  All
pixels in the window's border will be set to the border-
pixel.	Setting a new border, whether by setting border-
pixel or by setting border-pixmap, overrides any previous
border.

Output to a window is always clipped to the inside of the
window.	 Therefore, graphics operations never affect the
window border.

1m3.2.3.  Gravity Attributes0m

The bit gravity of a window defines which region of the win-
dow should be retained when an 4mInputOutput24m window is
resized.  The default value for the bit-gravity attribute is
4mForgetGravity24m.  The window gravity of a window allows you to
define how the 4mInputOutput24m or 4mInputOnly24m window should be
repositioned if its parent is resized.	The default value
for the win-gravity attribute is 4mNorthWestGravity24m.

If the inside width or height of a window is not changed and
if the window is moved or its border is changed, then the
contents of the window are not lost but move with the win-
dow.  Changing the inside width or height of the window
causes its contents to be moved or lost (depending on the
bit-gravity of the window) and causes children to be recon-
figured (depending on their win-gravity).  For a change of
width and height, the (x, y) pairs are defined:


----------------------------------------
1mGravity Direction   Coordinates0m
----------------------------------------
4mNorthWestGravity24m	 (0, 0)
4mNorthGravity24m	 (Width/2, 0)
4mNorthEastGravity24m	 (Width, 0)




			     1m500m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


4mWestGravity24m	 (0, Height/2)
4mCenterGravity24m	 (Width/2, Height/2)
4mEastGravity24m	 (Width, Height/2)
4mSouthWestGravity24m	 (0, Height)
4mSouthGravity24m	 (Width/2, Height)
4mSouthEastGravity24m	 (Width, Height)
----------------------------------------


When a window with one of these bit-gravity values is
resized, the corresponding pair defines the change in posi-
tion of each pixel in the window.  When a window with one of
these win-gravities has its parent window resized, the cor-
responding pair defines the change in position of the window
within the parent.  When a window is so repositioned, a
4mGravityNotify24m event is generated (see section 10.10.5).

A bit-gravity of 4mStaticGravity24m indicates that the contents
or origin should not move relative to the origin of the root
window.	 If the change in size of the window is coupled with
a change in position (x, y), then for bit-gravity the change
in position of each pixel is (-x, -y), and for win-gravity
the change in position of a child when its parent is so
resized is (-x, -y).  Note that 4mStaticGravity24m still only
takes effect when the width or height of the window is
changed, not when the window is moved.

A bit-gravity of 4mForgetGravity24m indicates that the window's
contents are always discarded after a size change, even if a
backing store or save under has been requested.	 The window
is tiled with its background and zero or more 4mExpose24m events
are generated.	If no background is defined, the existing
screen contents are not altered.  Some X servers may also
ignore the specified bit-gravity and always generate 4mExpose0m
events.

The contents and borders of inferiors are not affected by
their parent's bit-gravity.  A server is permitted to ignore
the specified bit-gravity and use 4mForget24m instead.

A win-gravity of 4mUnmapGravity24m is like 4mNorthWestGravity24m (the
window is not moved), except the child is also unmapped when
the parent is resized, and an 4mUnmapNotify24m event is gener-
ated.

1m3.2.4.  Backing Store Attribute0m

Some implementations of the X server may choose to maintain
the contents of 4mInputOutput24m windows.  If the X server main-
tains the contents of a window, the off-screen saved pixels
are known as backing store.  The backing store advises the X
server on what to do with the contents of a window.  The
backing-store attribute can be set to 4mNotUseful24m (default),
4mWhenMapped24m, or 4mAlways24m.



			     1m510m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


A backing-store attribute of 4mNotUseful24m advises the X server
that maintaining contents is unnecessary, although some X
implementations may still choose to maintain contents and,
therefore, not generate 4mExpose24m events.  A backing-store
attribute of 4mWhenMapped24m advises the X server that maintain-
ing contents of obscured regions when the window is mapped
would be beneficial.  In this case, the server may generate
an 4mExpose24m event when the window is created.  A backing-store
attribute of 4mAlways24m advises the X server that maintaining
contents even when the window is unmapped would be benefi-
cial.  Even if the window is larger than its parent, this is
a request to the X server to maintain complete contents, not
just the region within the parent window boundaries.  While
the X server maintains the window's contents, 4mExpose24m events
normally are not generated, but the X server may stop main-
taining contents at any time.

When the contents of obscured regions of a window are being
maintained, regions obscured by noninferior windows are
included in the destination of graphics requests (and
source, when the window is the source).	 However, regions
obscured by inferior windows are not included.

1m3.2.5.  Save Under Flag0m

Some server implementations may preserve contents of
4mInputOutput24m windows under other 4mInputOutput24m windows.	This
is not the same as preserving the contents of a window for
you.  You may get better visual appeal if transient windows
(for example, pop-up menus) request that the system preserve
the screen contents under them, so the temporarily obscured
applications do not have to repaint.

You can set the save-under flag to 4mTrue24m or 4mFalse24m (default).
If save-under is 4mTrue24m, the X server is advised that, when
this window is mapped, saving the contents of windows it
obscures would be beneficial.

1m3.2.6.  Backing Planes and Backing Pixel Attributes0m

You can set backing planes to indicate (with bits set to 1)
which bit planes of an 4mInputOutput24m window hold dynamic data
that must be preserved in backing store and during save
unders.	 The default value for the backing-planes attribute
is all bits set to 1.  You can set backing pixel to specify
what bits to use in planes not covered by backing planes.
The default value for the backing-pixel attribute is all
bits set to 0.	The X server is free to save only the speci-
fied bit planes in the backing store or the save under and
is free to regenerate the remaining planes with the speci-
fied pixel value.  Any extraneous bits in these values (that
is, those bits beyond the specified depth of the window) may
be simply ignored.  If you request backing store or save
unders, you should use these members to minimize the amount



			     1m520m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


of off-screen memory required to store your window.

1m3.2.7.  Event Mask and Do Not Propagate Mask Attributes0m

The event mask defines which events the client is interested
in for this 4mInputOutput24m or 4mInputOnly24m window (or, for some
event types, inferiors of this window).	 The event mask is
the bitwise inclusive OR of zero or more of the valid event
mask bits.  You can specify that no maskable events are
reported by setting 4mNoEventMask24m (default).

The do-not-propagate-mask attribute defines which events
should not be propagated to ancestor windows when no client
has the event type selected in this 4mInputOutput24m or 4mInputOnly0m
window.	 The do-not-propagate-mask is the bitwise inclusive
OR of zero or more of the following masks: 4mKeyPress24m, 4mKeyRe-0m
4mlease24m, 4mButtonPress24m, 4mButtonRelease24m, 4mPointerMotion24m, 4mBut-0m
4mton1Motion24m, 4mButton2Motion24m, 4mButton3Motion24m, 4mButton4Motion24m,
4mButton5Motion24m, and 4mButtonMotion24m.  You can specify that all
events are propagated by setting 4mNoEventMask24m (default).

1m3.2.8.  Override Redirect Flag0m

To control window placement or to add decoration, a window
manager often needs to intercept (redirect) any map or con-
figure request.	 Pop-up windows, however, often need to be
mapped without a window manager getting in the way.  To con-
trol whether an 4mInputOutput24m or 4mInputOnly24m window is to ignore
these structure control facilities, use the override-redi-
rect flag.

The override-redirect flag specifies whether map and config-
ure requests on this window should override a 4mSubstructur-0m
4meRedirectMask24m on the parent.  You can set the override-redi-
rect flag to 4mTrue24m or 4mFalse24m (default).	 Window managers use
this information to avoid tampering with pop-up windows (see
also chapter 14).

1m3.2.9.  Colormap Attribute0m

The colormap attribute specifies which colormap best
reflects the true colors of the 4mInputOutput24m window.  The
colormap must have the same visual type as the window, or a
4mBadMatch24m error results.  X servers capable of supporting
multiple hardware colormaps can use this information, and
window managers can use it for calls to 4mXInstallColormap24m.
You can set the colormap attribute to a colormap or to 4mCopy-0m
4mFromParent24m (default).

If you set the colormap to 4mCopyFromParent24m, the parent win-
dow's colormap is copied and used by its child.	 However,
the child window must have the same visual type as the par-
ent, or a 4mBadMatch24m error results.	The parent window must
not have a colormap of 4mNone24m, or a 4mBadMatch24m error results.



			     1m530m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


The colormap is copied by sharing the colormap object
between the child and parent, not by making a complete copy
of the colormap contents.  Subsequent changes to the parent
window's colormap attribute do not affect the child window.

1m3.2.10.  Cursor Attribute0m

The cursor attribute specifies which cursor is to be used
when the pointer is in the 4mInputOutput24m or 4mInputOnly24m window.
You can set the cursor to a cursor or 4mNone24m (default).

If you set the cursor to 4mNone24m, the parent's cursor is used
when the pointer is in the 4mInputOutput24m or 4mInputOnly24m window,
and any change in the parent's cursor will cause an immedi-
ate change in the displayed cursor.  By calling 4mXFreeCursor24m,
the cursor can be freed immediately as long as no further
explicit reference to it is made.

1m3.3.	Creating Windows0m

Xlib provides basic ways for creating windows, and toolkits
often supply higher-level functions specifically for creat-
ing and placing top-level windows, which are discussed in
the appropriate toolkit documentation.	If you do not use a
toolkit, however, you must provide some standard information
or hints for the window manager by using the Xlib inter-
client communication functions (see chapter 14).

If you use Xlib to create your own top-level windows (direct
children of the root window), you must observe the following
rules so that all applications interact reasonably across
the different styles of window management:

·    You must never fight with the window manager for the
     size or placement of your top-level window.

·    You must be able to deal with whatever size window you
     get, even if this means that your application just
     prints a message like ``Please make me bigger'' in its
     window.

·    You should only attempt to resize or move top-level
     windows in direct response to a user request.  If a
     request to change the size of a top-level window fails,
     you must be prepared to live with what you get.  You
     are free to resize or move the children of top-level
     windows as necessary.  (Toolkits often have facilities
     for automatic relayout.)

·    If you do not use a toolkit that automatically sets
     standard window properties, you should set these prop-
     erties for top-level windows before mapping them.





			     1m540m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


For further information, see chapter 14 and the 4mInter-Client0m
4mCommunication24m 4mConventions24m 4mManual24m.

4mXCreateWindow24m is the more general function that allows you
to set specific window attributes when you create a window.
4mXCreateSimpleWindow24m creates a window that inherits its
attributes from its parent window.

The X server acts as if 4mInputOnly24m windows do not exist for
the purposes of graphics requests, exposure processing, and
4mVisibilityNotify24m events.  An 4mInputOnly24m window cannot be used
as a drawable (that is, as a source or destination for
graphics requests).  4mInputOnly24m and 4mInputOutput24m windows act
identically in other respects (properties, grabs, input con-
trol, and so on).  Extension packages can define other
classes of windows.

To create an unmapped window and set its window attributes,
use 4mXCreateWindow24m.






































			     1m550m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
Window XCreateWindow(4mdisplay24m, 4mparent24m, 4mx24m, 4my24m, 4mwidth24m, 4mheight24m, 4mborder_width24m, 4mdepth24m,
		       4mclass24m, 4mvisual24m, 4mvaluemask24m, 4mattributes24m)
      Display *4mdisplay24m;
      Window 4mparent24m;
      int 4mx24m, 4my24m;
      unsigned int 4mwidth24m, 4mheight24m;
      unsigned int 4mborder_width24m;
      int 4mdepth24m;
      unsigned int 4mclass24m;
      Visual *4mvisual24m;
      unsigned long 4mvaluemask24m;
      XSetWindowAttributes *4mattributes24m;


4mdisplay24m   Specifies the connection to the X server.

4mparent24m    Specifies the parent window.

4mx0m
4my24m	       Specify the x and y coordinates, which are the
	  top-left outside corner of the created window's
	  borders and are relative to the inside of the par-
	  ent window's borders.

4mwidth0m
4mheight24m    Specify the width and height, which are the cre-
	  ated window's inside dimensions and do not include
	  the created window's borders.	 The dimensions must
	  be nonzero, or a 4mBadValue24m error results.

4mborder_width0m
	  Specifies the width of the created window's border
	  in pixels.

4mdepth24m     Specifies the window's depth.  A depth of 4mCopy-0m
	  4mFromParent24m means the depth is taken from the par-
	  ent.

4mclass24m     Specifies the created window's class.  You can
	  pass 4mInputOutput24m, 4mInputOnly24m, or 4mCopyFromParent24m.  A
	  class of 4mCopyFromParent24m means the class is taken
	  from the parent.

4mvisual24m    Specifies the visual type.  A visual of 4mCopy-0m
	  4mFromParent24m means the visual type is taken from the
	  parent.

4mvaluemask24m Specifies which window attributes are defined in
	  the attributes argument.  This mask is the bitwise
	  inclusive OR of the valid attribute mask bits.  If
	  valuemask is zero, the attributes are ignored and
	  are not referenced.




			     1m560m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


4mattributes0m
	  Specifies the structure from which the values (as
	  specified by the value mask) are to be taken.	 The
	  value mask should have the appropriate bits set to
	  indicate which attributes have been set in the
	  structure.
|__

The 4mXCreateWindow24m function creates an unmapped subwindow for
a specified parent window, returns the window ID of the cre-
ated window, and causes the X server to generate a 4mCreateNo-0m
4mtify24m event.  The created window is placed on top in the
stacking order with respect to siblings.

The coordinate system has the X axis horizontal and the Y
axis vertical with the origin [0, 0] at the upper-left cor-
ner.  Coordinates are integral, in terms of pixels, and
coincide with pixel centers.  Each window and pixmap has its
own coordinate system.	For a window, the origin is inside
the border at the inside, upper-left corner.

The border_width for an 4mInputOnly24m window must be zero, or a
4mBadMatch24m error results.  For class 4mInputOutput24m, the visual
type and depth must be a combination supported for the
screen, or a 4mBadMatch24m error results.  The depth need not be
the same as the parent, but the parent must not be a window
of class 4mInputOnly24m, or a 4mBadMatch24m error results.  For an
4mInputOnly24m window, the depth must be zero, and the visual
must be one supported by the screen.  If either condition is
not met, a 4mBadMatch24m error results.	 The parent window, how-
ever, may have any depth and class.  If you specify any
invalid window attribute for a window, a 4mBadMatch24m error
results.

The created window is not yet displayed (mapped) on the
user's display.	 To display the window, call 4mXMapWindow24m.
The new window initially uses the same cursor as its parent.
A new cursor can be defined for the new window by calling
4mXDefineCursor24m.  The window will not be visible on the screen
unless it and all of its ancestors are mapped and it is not
obscured by any of its ancestors.

4mXCreateWindow24m can generate 4mBadAlloc24m, 4mBadColor24m, 4mBadCursor24m,
4mBadMatch24m, 4mBadPixmap24m, 4mBadValue24m, and 4mBadWindow24m errors.


To create an unmapped 4mInputOutput24m subwindow of a given par-
ent window, use 4mXCreateSimpleWindow24m.









			     1m570m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
Window XCreateSimpleWindow(4mdisplay24m, 4mparent24m, 4mx24m, 4my24m, 4mwidth24m, 4mheight24m, 4mborder_width24m,
			     4mborder24m, 4mbackground24m)
      Display *4mdisplay24m;
      Window 4mparent24m;
      int 4mx24m, 4my24m;
      unsigned int 4mwidth24m, 4mheight24m;
      unsigned int 4mborder_width24m;
      unsigned long 4mborder24m;
      unsigned long 4mbackground24m;


4mdisplay24m   Specifies the connection to the X server.

4mparent24m    Specifies the parent window.

4mx0m
4my24m	       Specify the x and y coordinates, which are the
	  top-left outside corner of the new window's bor-
	  ders and are relative to the inside of the parent
	  window's borders.

4mwidth0m
4mheight24m    Specify the width and height, which are the cre-
	  ated window's inside dimensions and do not include
	  the created window's borders.	 The dimensions must
	  be nonzero, or a 4mBadValue24m error results.

4mborder_width0m
	  Specifies the width of the created window's border
	  in pixels.

4mborder24m    Specifies the border pixel value of the window.

4mbackground0m
	  Specifies the background pixel value of the win-
	  dow.

|__

The 4mXCreateSimpleWindow24m function creates an unmapped
4mInputOutput24m subwindow for a specified parent window, returns
the window ID of the created window, and causes the X server
to generate a 4mCreateNotify24m event.	The created window is
placed on top in the stacking order with respect to sib-
lings.	Any part of the window that extends outside its par-
ent window is clipped.	The border_width for an 4mInputOnly0m
window must be zero, or a 4mBadMatch24m error results.	4mXCreateS-0m
4mimpleWindow24m inherits its depth, class, and visual from its
parent.	 All other window attributes, except background and
border, have their default values.

4mXCreateSimpleWindow24m can generate 4mBadAlloc24m, 4mBadMatch24m, 4mBad-0m
4mValue24m, and 4mBadWindow24m errors.



			     1m580m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


1m3.4.	Destroying Windows0m

Xlib provides functions that you can use to destroy a window
or destroy all subwindows of a window.


To destroy a window and all of its subwindows, use 4mXDestroy-0m
4mWindow24m.
__
|
XDestroyWindow(4mdisplay24m, 4mw24m)
      Display *4mdisplay24m;
      Window 4mw24m;


4mdisplay24m   Specifies the connection to the X server.

4mw24m	       Specifies the window.
|__

The 4mXDestroyWindow24m function destroys the specified window as
well as all of its subwindows and causes the X server to
generate a 4mDestroyNotify24m event for each window.  The window
should never be referenced again.  If the window specified
by the w argument is mapped, it is unmapped automatically.
The ordering of the 4mDestroyNotify24m events is such that for
any given window being destroyed, 4mDestroyNotify24m is generated
on any inferiors of the window before being generated on the
window itself.	The ordering among siblings and across sub-
hierarchies is not otherwise constrained.  If the window you
specified is a root window, no windows are destroyed.
Destroying a mapped window will generate 4mExpose24m events on
other windows that were obscured by the window being
destroyed.

4mXDestroyWindow24m can generate a 4mBadWindow24m error.


To destroy all subwindows of a specified window, use 4mXDe-0m
4mstroySubwindows24m.
__
|
XDestroySubwindows(4mdisplay24m, 4mw24m)
      Display *4mdisplay24m;
      Window 4mw24m;


4mdisplay24m   Specifies the connection to the X server.

4mw24m	       Specifies the window.
|__

The 4mXDestroySubwindows24m function destroys all inferior win-
dows of the specified window, in bottom-to-top stacking



			     1m590m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


order.	It causes the X server to generate a 4mDestroyNotify0m
event for each window.	If any mapped subwindows were actu-
ally destroyed, 4mXDestroySubwindows24m causes the X server to
generate 4mExpose24m events on the specified window.  This is
much more efficient than deleting many windows one at a time
because much of the work need be performed only once for all
of the windows, rather than for each window.  The subwindows
should never be referenced again.

4mXDestroySubwindows24m can generate a 4mBadWindow24m error.

1m3.5.	Mapping Windows0m

A window is considered mapped if an 4mXMapWindow24m call has been
made on it.  It may not be visible on the screen for one of
the following reasons:

·    It is obscured by another opaque window.

·    One of its ancestors is not mapped.

·    It is entirely clipped by an ancestor.

4mExpose24m events are generated for the window when part or all
of it becomes visible on the screen.  A client receives the
4mExpose24m events only if it has asked for them.  Windows retain
their position in the stacking order when they are unmapped.

A window manager may want to control the placement of sub-
windows.  If 4mSubstructureRedirectMask24m has been selected by a
window manager on a parent window (usually a root window), a
map request initiated by other clients on a child window is
not performed, and the window manager is sent a 4mMapRequest0m
event.	However, if the override-redirect flag on the child
had been set to 4mTrue24m (usually only on pop-up menus), the map
request is performed.

A tiling window manager might decide to reposition and
resize other clients' windows and then decide to map the
window to its final location.  A window manager that wants
to provide decoration might reparent the child into a frame
first.	For further information, see sections 3.2.8 and
10.10.	Only a single client at a time can select for 4mSub-0m
4mstructureRedirectMask24m.

Similarly, a single client can select for 4mResizeRedirectMask0m
on a parent window.  Then, any attempt to resize the window
by another client is suppressed, and the client receives a
4mResizeRequest24m event.


To map a given window, use 4mXMapWindow24m.





			     1m600m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
XMapWindow(4mdisplay24m, 4mw24m)
      Display *4mdisplay24m;
      Window 4mw24m;


4mdisplay24m   Specifies the connection to the X server.

4mw24m	       Specifies the window.
|__

The 4mXMapWindow24m function maps the window and all of its sub-
windows that have had map requests.  Mapping a window that
has an unmapped ancestor does not display the window but
marks it as eligible for display when the ancestor becomes
mapped.	 Such a window is called unviewable.  When all its
ancestors are mapped, the window becomes viewable and will
be visible on the screen if it is not obscured by another
window.	 This function has no effect if the window is
already mapped.

If the override-redirect of the window is 4mFalse24m and if some
other client has selected 4mSubstructureRedirectMask24m on the
parent window, then the X server generates a 4mMapRequest0m
event, and the 4mXMapWindow24m function does not map the window.
Otherwise, the window is mapped, and the X server generates
a 4mMapNotify24m event.

If the window becomes viewable and no earlier contents for
it are remembered, the X server tiles the window with its
background.  If the window's background is undefined, the
existing screen contents are not altered, and the X server
generates zero or more 4mExpose24m events.  If backing-store was
maintained while the window was unmapped, no 4mExpose24m events
are generated.	If backing-store will now be maintained, a
full-window exposure is always generated.  Otherwise, only
visible regions may be reported.  Similar tiling and expo-
sure take place for any newly viewable inferiors.

If the window is an 4mInputOutput24m window, 4mXMapWindow24m generates
4mExpose24m events on each 4mInputOutput24m window that it causes to
be displayed.  If the client maps and paints the window and
if the client begins processing events, the window is
painted twice.	To avoid this, first ask for 4mExpose24m events
and then map the window, so the client processes input
events as usual.  The event list will include 4mExpose24m for
each window that has appeared on the screen.  The client's
normal response to an 4mExpose24m event should be to repaint the
window.	 This method usually leads to simpler programs and
to proper interaction with window managers.

4mXMapWindow24m can generate a 4mBadWindow24m error.





			     1m610m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


To map and raise a window, use 4mXMapRaised24m.
__
|
XMapRaised(4mdisplay24m, 4mw24m)
      Display *4mdisplay24m;
      Window 4mw24m;


4mdisplay24m   Specifies the connection to the X server.

4mw24m	       Specifies the window.
|__

The 4mXMapRaised24m function essentially is similar to 4mXMapWindow0m
in that it maps the window and all of its subwindows that
have had map requests.	However, it also raises the speci-
fied window to the top of the stack.  For additional infor-
mation, see 4mXMapWindow24m.

4mXMapRaised24m can generate multiple 4mBadWindow24m errors.


To map all subwindows for a specified window, use 4mXMapSub-0m
4mwindows24m.
__
|
XMapSubwindows(4mdisplay24m, 4mw24m)
      Display *4mdisplay24m;
      Window 4mw24m;


4mdisplay24m   Specifies the connection to the X server.

4mw24m	       Specifies the window.
|__

The 4mXMapSubwindows24m function maps all subwindows for a speci-
fied window in top-to-bottom stacking order.  The X server
generates 4mExpose24m events on each newly displayed window.
This may be much more efficient than mapping many windows
one at a time because the server needs to perform much of
the work only once, for all of the windows, rather than for
each window.

4mXMapSubwindows24m can generate a 4mBadWindow24m error.

1m3.6.	Unmapping Windows0m

Xlib provides functions that you can use to unmap a window
or all subwindows.


To unmap a window, use 4mXUnmapWindow24m.




			     1m620m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
XUnmapWindow(4mdisplay24m, 4mw24m)
      Display *4mdisplay24m;
      Window 4mw24m;


4mdisplay24m   Specifies the connection to the X server.

4mw24m	       Specifies the window.
|__

The 4mXUnmapWindow24m function unmaps the specified window and
causes the X server to generate an 4mUnmapNotify24m event.  If
the specified window is already unmapped, 4mXUnmapWindow24m has
no effect.  Normal exposure processing on formerly obscured
windows is performed.  Any child window will no longer be
visible until another map call is made on the parent.  In
other words, the subwindows are still mapped but are not
visible until the parent is mapped.  Unmapping a window will
generate 4mExpose24m events on windows that were formerly
obscured by it.

4mXUnmapWindow24m can generate a 4mBadWindow24m error.


To unmap all subwindows for a specified window, use 4mXUnmap-0m
4mSubwindows24m.
__
|
XUnmapSubwindows(4mdisplay24m, 4mw24m)
      Display *4mdisplay24m;
      Window 4mw24m;


4mdisplay24m   Specifies the connection to the X server.

4mw24m	       Specifies the window.
|__

The 4mXUnmapSubwindows24m function unmaps all subwindows for the
specified window in bottom-to-top stacking order.  It causes
the X server to generate an 4mUnmapNotify24m event on each sub-
window and 4mExpose24m events on formerly obscured windows.
Using this function is much more efficient than unmapping
multiple windows one at a time because the server needs to
perform much of the work only once, for all of the windows,
rather than for each window.

4mXUnmapSubwindows24m can generate a 4mBadWindow24m error.

1m3.7.	Configuring Windows0m






			     1m630m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


Xlib provides functions that you can use to move a window,
resize a window, move and resize a window, or change a win-
dow's border width.  To change one of these parameters, set
the appropriate member of the 4mXWindowChanges24m structure and
OR in the corresponding value mask in subsequent calls to
4mXConfigureWindow24m.	The symbols for the value mask bits and
the 4mXWindowChanges24m structure are:
__
|
/* Configure window value mask bits */

#define	  4mCWX24m			   (1<<0)
#define	  4mCWY24m			   (1<<1)
#define	  4mCWWidth24m			   (1<<2)
#define	  4mCWHeight24m			   (1<<3)
#define	  4mCWBorderWidth24m		   (1<<4)
#define	  4mCWSibling24m		   (1<<5)
#define	  4mCWStackMode24m		   (1<<6)


/* Values */

typedef struct {
     int x, y;
     int width, height;
     int border_width;
     Window sibling;
     int stack_mode;
} XWindowChanges;

|__

The x and y members are used to set the window's x and y
coordinates, which are relative to the parent's origin and
indicate the position of the upper-left outer corner of the
window.	 The width and height members are used to set the
inside size of the window, not including the border, and
must be nonzero, or a 4mBadValue24m error results.  Attempts to
configure a root window have no effect.

The border_width member is used to set the width of the bor-
der in pixels.	Note that setting just the border width
leaves the outer-left corner of the window in a fixed posi-
tion but moves the absolute position of the window's origin.
If you attempt to set the border-width attribute of an 4mInpu-0m
4mtOnly24m window nonzero, a 4mBadMatch24m error results.

The sibling member is used to set the sibling window for
stacking operations.  The stack_mode member is used to set
how the window is to be restacked and can be set to 4mAbove24m,
4mBelow24m, 4mTopIf24m, 4mBottomIf24m, or 4mOpposite24m.

If the override-redirect flag of the window is 4mFalse24m and if
some other client has selected 4mSubstructureRedirectMask24m on



			     1m640m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


the parent, the X server generates a 4mConfigureRequest24m event,
and no further processing is performed.	 Otherwise, if some
other client has selected 4mResizeRedirectMask24m on the window
and the inside width or height of the window is being
changed, a 4mResizeRequest24m event is generated, and the current
inside width and height are used instead.  Note that the
override-redirect flag of the window has no effect on 4mResiz-0m
4meRedirectMask24m and that 4mSubstructureRedirectMask24m on the par-
ent has precedence over 4mResizeRedirectMask24m on the window.

When the geometry of the window is changed as specified, the
window is restacked among siblings, and a 4mConfigureNotify0m
event is generated if the state of the window actually
changes.  4mGravityNotify24m events are generated after 4mConfig-0m
4mureNotify24m events.	If the inside width or height of the win-
dow has actually changed, children of the window are
affected as specified.

If a window's size actually changes, the window's subwindows
move according to their window gravity.	 Depending on the
window's bit gravity, the contents of the window also may be
moved (see section 3.2.3).

If regions of the window were obscured but now are not,
exposure processing is performed on these formerly obscured
windows, including the window itself and its inferiors.	 As
a result of increasing the width or height, exposure pro-
cessing is also performed on any new regions of the window
and any regions where window contents are lost.

The restack check (specifically, the computation for 4mBot-0m
4mtomIf24m, 4mTopIf24m, and 4mOpposite24m) is performed with respect to the
window's final size and position (as controlled by the other
arguments of the request), not its initial position.  If a
sibling is specified without a stack_mode, a 4mBadMatch24m error
results.

If a sibling and a stack_mode are specified, the window is
restacked as follows:

4mAbove24m	  The window is placed just above the sibling.
4mBelow24m	  The window is placed just below the sibling.
4mTopIf24m	  If the sibling occludes the window, the window is
	     placed at the top of the stack.
4mBottomIf24m	  If the window occludes the sibling, the window is
	     placed at the bottom of the stack.
4mOpposite24m	  If the sibling occludes the window, the window is
	     placed at the top of the stack.  If the window
	     occludes the sibling, the window is placed at the
	     bottom of the stack.


If a stack_mode is specified but no sibling is specified,
the window is restacked as follows:



			     1m650m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


4mAbove24m	  The window is placed at the top of the stack.
4mBelow24m	  The window is placed at the bottom of the stack.
4mTopIf24m	  If any sibling occludes the window, the window is
	     placed at the top of the stack.
4mBottomIf24m	  If the window occludes any sibling, the window is
	     placed at the bottom of the stack.
4mOpposite24m	  If any sibling occludes the window, the window is
	     placed at the top of the stack.  If the window
	     occludes any sibling, the window is placed at the
	     bottom of the stack.


Attempts to configure a root window have no effect.


To configure a window's size, location, stacking, or border,
use 4mXConfigureWindow24m.
__
|
XConfigureWindow(4mdisplay24m, 4mw24m, 4mvalue_mask24m, 4mvalues24m)
      Display *4mdisplay24m;
      Window 4mw24m;
      unsigned int 4mvalue_mask24m;
      XWindowChanges *4mvalues24m;


4mdisplay24m   Specifies the connection to the X server.

4mw24m	       Specifies the window to be reconfigured.

4mvalue_mask0m
	  Specifies which values are to be set using infor-
	  mation in the values structure.  This mask is the
	  bitwise inclusive OR of the valid configure window
	  values bits.

4mvalues24m    Specifies the 4mXWindowChanges24m structure.
|__

The 4mXConfigureWindow24m function uses the values specified in
the 4mXWindowChanges24m structure to reconfigure a window's size,
position, border, and stacking order.  Values not specified
are taken from the existing geometry of the window.

If a sibling is specified without a stack_mode or if the
window is not actually a sibling, a 4mBadMatch24m error results.
Note that the computations for 4mBottomIf24m, 4mTopIf24m, and 4mOpposite0m
are performed with respect to the window's final geometry
(as controlled by the other arguments passed to 4mXConfig-0m
4mureWindow24m), not its initial geometry.  Any backing store
contents of the window, its inferiors, and other newly visi-
ble windows are either discarded or changed to reflect the
current screen contents (depending on the implementation).




			     1m660m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


4mXConfigureWindow24m can generate 4mBadMatch24m, 4mBadValue24m, and 4mBad-0m
4mWindow24m errors.


To move a window without changing its size, use 4mXMoveWindow24m.
__
|
XMoveWindow(4mdisplay24m, 4mw24m, 4mx24m, 4my24m)
      Display *4mdisplay24m;
      Window 4mw24m;
      int 4mx24m, 4my24m;


4mdisplay24m   Specifies the connection to the X server.

4mw24m	       Specifies the window to be moved.

4mx0m
4my24m	       Specify the x and y coordinates, which define the
	  new location of the top-left pixel of the window's
	  border or the window itself if it has no border.
|__

The 4mXMoveWindow24m function moves the specified window to the
specified x and y coordinates, but it does not change the
window's size, raise the window, or change the mapping state
of the window.	Moving a mapped window may or may not lose
the window's contents depending on if the window is obscured
by nonchildren and if no backing store exists.	If the con-
tents of the window are lost, the X server generates 4mExpose0m
events.	 Moving a mapped window generates 4mExpose24m events on
any formerly obscured windows.

If the override-redirect flag of the window is 4mFalse24m and
some other client has selected 4mSubstructureRedirectMask24m on
the parent, the X server generates a 4mConfigureRequest24m event,
and no further processing is performed.	 Otherwise, the win-
dow is moved.

4mXMoveWindow24m can generate a 4mBadWindow24m error.


To change a window's size without changing the upper-left
coordinate, use 4mXResizeWindow24m.













			     1m670m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
XResizeWindow(4mdisplay24m, 4mw24m, 4mwidth24m, 4mheight24m)
      Display *4mdisplay24m;
      Window 4mw24m;
      unsigned int 4mwidth24m, 4mheight24m;


4mdisplay24m   Specifies the connection to the X server.

4mw24m	       Specifies the window.

4mwidth0m
4mheight24m    Specify the width and height, which are the inte-
	  rior dimensions of the window after the call com-
	  pletes.
|__

The 4mXResizeWindow24m function changes the inside dimensions of
the specified window, not including its borders.  This func-
tion does not change the window's upper-left coordinate or
the origin and does not restack the window.  Changing the
size of a mapped window may lose its contents and generate
4mExpose24m events.  If a mapped window is made smaller, changing
its size generates 4mExpose24m events on windows that the mapped
window formerly obscured.

If the override-redirect flag of the window is 4mFalse24m and
some other client has selected 4mSubstructureRedirectMask24m on
the parent, the X server generates a 4mConfigureRequest24m event,
and no further processing is performed.	 If either width or
height is zero, a 4mBadValue24m error results.

4mXResizeWindow24m can generate 4mBadValue24m and 4mBadWindow24m errors.


To change the size and location of a window, use 4mXMoveRe-0m
4msizeWindow24m.




















			     1m680m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
XMoveResizeWindow(4mdisplay24m, 4mw24m, 4mx24m, 4my24m, 4mwidth24m, 4mheight24m)
      Display *4mdisplay24m;
      Window 4mw24m;
      int 4mx24m, 4my24m;
      unsigned int 4mwidth24m, 4mheight24m;


4mdisplay24m   Specifies the connection to the X server.

4mw24m	       Specifies the window to be reconfigured.

4mx0m
4my24m	       Specify the x and y coordinates, which define the
	  new position of the window relative to its parent.

4mwidth0m
4mheight24m    Specify the width and height, which define the
	  interior size of the window.
|__

The 4mXMoveResizeWindow24m function changes the size and location
of the specified window without raising it.  Moving and
resizing a mapped window may generate an 4mExpose24m event on the
window.	 Depending on the new size and location parameters,
moving and resizing a window may generate 4mExpose24m events on
windows that the window formerly obscured.

If the override-redirect flag of the window is 4mFalse24m and
some other client has selected 4mSubstructureRedirectMask24m on
the parent, the X server generates a 4mConfigureRequest24m event,
and no further processing is performed.	 Otherwise, the win-
dow size and location are changed.

4mXMoveResizeWindow24m can generate 4mBadValue24m and 4mBadWindow0m
errors.


To change the border width of a given window, use 4mXSetWin-0m
4mdowBorderWidth24m.

















			     1m690m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
XSetWindowBorderWidth(4mdisplay24m, 4mw24m, 4mwidth24m)
      Display *4mdisplay24m;
      Window 4mw24m;
      unsigned int 4mwidth24m;


4mdisplay24m   Specifies the connection to the X server.

4mw24m	       Specifies the window.

4mwidth24m     Specifies the width of the window border.
|__

The 4mXSetWindowBorderWidth24m function sets the specified win-
dow's border width to the specified width.

4mXSetWindowBorderWidth24m can generate a 4mBadWindow24m error.

1m3.8.	Changing Window Stacking Order0m


Xlib provides functions that you can use to raise, lower,
circulate, or restack windows.


To raise a window so that no sibling window obscures it, use
4mXRaiseWindow24m.
__
|
XRaiseWindow(4mdisplay24m, 4mw24m)
      Display *4mdisplay24m;
      Window 4mw24m;


4mdisplay24m   Specifies the connection to the X server.

4mw24m	       Specifies the window.
|__

The 4mXRaiseWindow24m function raises the specified window to the
top of the stack so that no sibling window obscures it.	 If
the windows are regarded as overlapping sheets of paper
stacked on a desk, then raising a window is analogous to
moving the sheet to the top of the stack but leaving its x
and y location on the desk constant.  Raising a mapped win-
dow may generate 4mExpose24m events for the window and any mapped
subwindows that were formerly obscured.

If the override-redirect attribute of the window is 4mFalse0m
and some other client has selected 4mSubstructureRedirectMask0m
on the parent, the X server generates a 4mConfigureRequest0m
event, and no processing is performed.	Otherwise, the win-
dow is raised.



			     1m700m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


4mXRaiseWindow24m can generate a 4mBadWindow24m error.


To lower a window so that it does not obscure any sibling
windows, use 4mXLowerWindow24m.
__
|
XLowerWindow(4mdisplay24m, 4mw24m)
      Display *4mdisplay24m;
      Window 4mw24m;


4mdisplay24m   Specifies the connection to the X server.

4mw24m	       Specifies the window.
|__

The 4mXLowerWindow24m function lowers the specified window to the
bottom of the stack so that it does not obscure any sibling
windows.  If the windows are regarded as overlapping sheets
of paper stacked on a desk, then lowering a window is analo-
gous to moving the sheet to the bottom of the stack but
leaving its x and y location on the desk constant.  Lowering
a mapped window will generate 4mExpose24m events on any windows
it formerly obscured.

If the override-redirect attribute of the window is 4mFalse0m
and some other client has selected 4mSubstructureRedirectMask0m
on the parent, the X server generates a 4mConfigureRequest0m
event, and no processing is performed.	Otherwise, the win-
dow is lowered to the bottom of the stack.

4mXLowerWindow24m can generate a 4mBadWindow24m error.


To circulate a subwindow up or down, use 4mXCirculateSubwin-0m
4mdows24m.




















			     1m710m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
XCirculateSubwindows(4mdisplay24m, 4mw24m, 4mdirection24m)
      Display *4mdisplay24m;
      Window 4mw24m;
      int 4mdirection24m;


4mdisplay24m   Specifies the connection to the X server.

4mw24m	       Specifies the window.

4mdirection24m Specifies the direction (up or down) that you want
	  to circulate the window.  You can pass 4mRaiseLowest0m
	  or 4mLowerHighest24m.
|__

The 4mXCirculateSubwindows24m function circulates children of the
specified window in the specified direction.  If you specify
4mRaiseLowest24m, 4mXCirculateSubwindows24m raises the lowest mapped
child (if any) that is occluded by another child to the top
of the stack.  If you specify 4mLowerHighest24m, 4mXCirculateSub-0m
4mwindows24m lowers the highest mapped child (if any) that
occludes another child to the bottom of the stack.  Exposure
processing is then performed on formerly obscured windows.
If some other client has selected 4mSubstructureRedirectMask0m
on the window, the X server generates a 4mCirculateRequest0m
event, and no further processing is performed.	If a child
is actually restacked, the X server generates a 4mCirculateNo-0m
4mtify24m event.

4mXCirculateSubwindows24m can generate 4mBadValue24m and 4mBadWindow0m
errors.


To raise the lowest mapped child of a window that is par-
tially or completely occluded by another child, use 4mXCircu-0m
4mlateSubwindowsUp24m.
__
|
XCirculateSubwindowsUp(4mdisplay24m, 4mw24m)
      Display *4mdisplay24m;
      Window 4mw24m;


4mdisplay24m   Specifies the connection to the X server.

4mw24m	       Specifies the window.
|__

The 4mXCirculateSubwindowsUp24m function raises the lowest mapped
child of the specified window that is partially or com-
pletely occluded by another child.  Completely unobscured
children are not affected.  This is a convenience function
equivalent to 4mXCirculateSubwindows24m with 4mRaiseLowest0m



			     1m720m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


specified.

4mXCirculateSubwindowsUp24m can generate a 4mBadWindow24m error.


To lower the highest mapped child of a window that partially
or completely occludes another child, use 4mXCirculateSubwin-0m
4mdowsDown24m.
__
|
XCirculateSubwindowsDown(4mdisplay24m, 4mw24m)
      Display *4mdisplay24m;
      Window 4mw24m;


4mdisplay24m   Specifies the connection to the X server.

4mw24m	       Specifies the window.
|__

The 4mXCirculateSubwindowsDown24m function lowers the highest
mapped child of the specified window that partially or com-
pletely occludes another child.	 Completely unobscured chil-
dren are not affected.	This is a convenience function
equivalent to 4mXCirculateSubwindows24m with 4mLowerHighest24m speci-
fied.

4mXCirculateSubwindowsDown24m can generate a 4mBadWindow24m error.


To restack a set of windows from top to bottom, use
4mXRestackWindows24m.
__
|
XRestackWindows(4mdisplay24m, 4mwindows24m, 4mnwindows24m);
      Display *4mdisplay24m;
      Window 4mwindows24m[];
      int 4mnwindows24m;


4mdisplay24m   Specifies the connection to the X server.

4mwindows24m   Specifies an array containing the windows to be
	  restacked.

4mnwindows24m  Specifies the number of windows to be restacked.
|__

The 4mXRestackWindows24m function restacks the windows in the
order specified, from top to bottom.  The stacking order of
the first window in the windows array is unaffected, but the
other windows in the array are stacked underneath the first
window, in the order of the array.  The stacking order of
the other windows is not affected.  For each window in the



			     1m730m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


window array that is not a child of the specified window, a
4mBadMatch24m error results.

If the override-redirect attribute of a window is 4mFalse24m and
some other client has selected 4mSubstructureRedirectMask24m on
the parent, the X server generates 4mConfigureRequest24m events
for each window whose override-redirect flag is not set, and
no further processing is performed.  Otherwise, the windows
will be restacked in top-to-bottom order.

4mXRestackWindows24m can generate a 4mBadWindow24m error.

1m3.9.	Changing Window Attributes0m


Xlib provides functions that you can use to set window
attributes.  4mXChangeWindowAttributes24m is the more general
function that allows you to set one or more window
attributes provided by the 4mXSetWindowAttributes24m structure.
The other functions described in this section allow you to
set one specific window attribute, such as a window's back-
ground.


To change one or more attributes for a given window, use
4mXChangeWindowAttributes24m.































			     1m740m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
XChangeWindowAttributes(4mdisplay24m, 4mw24m, 4mvaluemask24m, 4mattributes24m)
      Display *4mdisplay24m;
      Window 4mw24m;
      unsigned long 4mvaluemask24m;
      XSetWindowAttributes *4mattributes24m;


4mdisplay24m   Specifies the connection to the X server.

4mw24m	       Specifies the window.

4mvaluemask24m Specifies which window attributes are defined in
	  the attributes argument.  This mask is the bitwise
	  inclusive OR of the valid attribute mask bits.  If
	  valuemask is zero, the attributes are ignored and
	  are not referenced.  The values and restrictions
	  are the same as for 4mXCreateWindow24m.


4mattributes0m
	  Specifies the structure from which the values (as
	  specified by the value mask) are to be taken.	 The
	  value mask should have the appropriate bits set to
	  indicate which attributes have been set in the
	  structure (see section 3.2).
|__

Depending on the valuemask, the 4mXChangeWindowAttributes0m
function uses the window attributes in the 4mXSetWindowAt-0m
4mtributes24m structure to change the specified window
attributes.  Changing the background does not cause the win-
dow contents to be changed.  To repaint the window and its
background, use 4mXClearWindow24m.  Setting the border or chang-
ing the background such that the border tile origin changes
causes the border to be repainted.  Changing the background
of a root window to 4mNone24m or 4mParentRelative24m restores the
default background pixmap.  Changing the border of a root
window to 4mCopyFromParent24m restores the default border pixmap.
Changing the win-gravity does not affect the current posi-
tion of the window.  Changing the backing-store of an
obscured window to 4mWhenMapped24m or 4mAlways24m, or changing the
backing-planes, backing-pixel, or save-under of a mapped
window may have no immediate effect.  Changing the colormap
of a window (that is, defining a new map, not changing the
contents of the existing map) generates a 4mColormapNotify0m
event.	Changing the colormap of a visible window may have
no immediate effect on the screen because the map may not be
installed (see 4mXInstallColormap24m).	Changing the cursor of a
root window to 4mNone24m restores the default cursor.  Whenever
possible, you are encouraged to share colormaps.

Multiple clients can select input on the same window.  Their
event masks are maintained separately.	When an event is



			     1m750m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


generated, it is reported to all interested clients.  How-
ever, only one client at a time can select for 4mSubstructur-0m
4meRedirectMask24m, 4mResizeRedirectMask24m, and 4mButtonPressMask24m.	If
a client attempts to select any of these event masks and
some other client has already selected one, a 4mBadAccess0m
error results.	There is only one do-not-propagate-mask for
a window, not one per client.

4mXChangeWindowAttributes24m can generate 4mBadAccess24m, 4mBadColor24m,
4mBadCursor24m, 4mBadMatch24m, 4mBadPixmap24m, 4mBadValue24m, and 4mBadWindow0m
errors.


To set the background of a window to a given pixel, use
4mXSetWindowBackground24m.
__
|
XSetWindowBackground(4mdisplay24m, 4mw24m, 4mbackground_pixel24m)
      Display *4mdisplay24m;
      Window 4mw24m;
      unsigned long 4mbackground_pixel24m;


4mdisplay24m   Specifies the connection to the X server.

4mw24m	       Specifies the window.

4mbackground_pixel0m
	  Specifies the pixel that is to be used for the
	  background.
|__

The 4mXSetWindowBackground24m function sets the background of the
window to the specified pixel value.  Changing the back-
ground does not cause the window contents to be changed.
4mXSetWindowBackground24m uses a pixmap of undefined size filled
with the pixel value you passed.  If you try to change the
background of an 4mInputOnly24m window, a 4mBadMatch24m error results.

4mXSetWindowBackground24m can generate 4mBadMatch24m and 4mBadWindow0m
errors.



To set the background of a window to a given pixmap, use
4mXSetWindowBackgroundPixmap24m.











			     1m760m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
XSetWindowBackgroundPixmap(4mdisplay24m, 4mw24m, 4mbackground_pixmap24m)
      Display *4mdisplay24m;
      Window 4mw24m;
      Pixmap 4mbackground_pixmap24m;


4mdisplay24m   Specifies the connection to the X server.

4mw24m	       Specifies the window.

4mbackground_pixmap0m
	  Specifies the background pixmap, 4mParentRelative24m,
	  or 4mNone24m.
|__

The 4mXSetWindowBackgroundPixmap24m function sets the background
pixmap of the window to the specified pixmap.  The back-
ground pixmap can immediately be freed if no further
explicit references to it are to be made.  If 4mParentRelative0m
is specified, the background pixmap of the window's parent
is used, or on the root window, the default background is
restored.  If you try to change the background of an 4mInpu-0m
4mtOnly24m window, a 4mBadMatch24m error results.  If the background
is set to 4mNone24m, the window has no defined background.

4mXSetWindowBackgroundPixmap24m can generate 4mBadMatch24m, 4mBadPixmap24m,
and 4mBadWindow24m errors.

			    Note

     4mXSetWindowBackground24m and 4mXSetWindowBackground-0m
     4mPixmap24m do not change the current contents of the
     window.



To change and repaint a window's border to a given pixel,
use 4mXSetWindowBorder24m.


















			     1m770m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
XSetWindowBorder(4mdisplay24m, 4mw24m, 4mborder_pixel24m)
      Display *4mdisplay24m;
      Window 4mw24m;
      unsigned long 4mborder_pixel24m;


4mdisplay24m   Specifies the connection to the X server.

4mw24m	       Specifies the window.

4mborder_pixel0m
	  Specifies the entry in the colormap.
|__

The 4mXSetWindowBorder24m function sets the border of the window
to the pixel value you specify.	 If you attempt to perform
this on an 4mInputOnly24m window, a 4mBadMatch24m error results.

4mXSetWindowBorder24m can generate 4mBadMatch24m and 4mBadWindow24m errors.


To change and repaint the border tile of a given window, use
4mXSetWindowBorderPixmap24m.
__
|
XSetWindowBorderPixmap(4mdisplay24m, 4mw24m, 4mborder_pixmap24m)
      Display *4mdisplay24m;
      Window 4mw24m;
      Pixmap 4mborder_pixmap24m;


4mdisplay24m   Specifies the connection to the X server.

4mw24m	       Specifies the window.

4mborder_pixmap0m
	  Specifies the border pixmap or 4mCopyFromParent24m.
|__

The 4mXSetWindowBorderPixmap24m function sets the border pixmap
of the window to the pixmap you specify.  The border pixmap
can be freed immediately if no further explicit references
to it are to be made.  If you specify 4mCopyFromParent24m, a copy
of the parent window's border pixmap is used.  If you
attempt to perform this on an 4mInputOnly24m window, a 4mBadMatch0m
error results.

4mXSetWindowBorderPixmap24m can generate 4mBadMatch24m, 4mBadPixmap24m, and
4mBadWindow24m errors.


To set the colormap of a given window, use 4mXSetWindowCol-0m
4mormap24m.



			     1m780m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
XSetWindowColormap(4mdisplay24m, 4mw24m, 4mcolormap24m)
      Display *4mdisplay24m;
      Window 4mw24m;
      Colormap 4mcolormap24m;


4mdisplay24m   Specifies the connection to the X server.

4mw24m	       Specifies the window.

4mcolormap24m  Specifies the colormap.
|__

The 4mXSetWindowColormap24m function sets the specified colormap
of the specified window.  The colormap must have the same
visual type as the window, or a 4mBadMatch24m error results.

4mXSetWindowColormap24m can generate 4mBadColor24m, 4mBadMatch24m, and 4mBad-0m
4mWindow24m errors.


To define which cursor will be used in a window, use 4mXDe-0m
4mfineCursor24m.
__
|
XDefineCursor(4mdisplay24m, 4mw24m, 4mcursor24m)
      Display *4mdisplay24m;
      Window 4mw24m;
      Cursor 4mcursor24m;


4mdisplay24m   Specifies the connection to the X server.

4mw24m	       Specifies the window.

4mcursor24m    Specifies the cursor that is to be displayed or
	  4mNone24m.
|__

If a cursor is set, it will be used when the pointer is in
the window.  If the cursor is 4mNone24m, it is equivalent to 4mXUn-0m
4mdefineCursor24m.

4mXDefineCursor24m can generate 4mBadCursor24m and 4mBadWindow24m errors.


To undefine the cursor in a given window, use 4mXUndefineCur-0m
4msor24m.








			     1m790m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
XUndefineCursor(4mdisplay24m, 4mw24m)
      Display *4mdisplay24m;
      Window 4mw24m;


4mdisplay24m   Specifies the connection to the X server.

4mw24m	       Specifies the window.
|__

The 4mXUndefineCursor24m function undoes the effect of a previous
4mXDefineCursor24m for this window.  When the pointer is in the
window, the parent's cursor will now be used.  On the root
window, the default cursor is restored.

4mXUndefineCursor24m can generate a 4mBadWindow24m error.








































			     1m800m





1mXlib - C Library			X11, Release 6.7 DRAFT0m




			 1mChapter 40m

		1mWindow Information Functions0m



After you connect the display to the X server and create a
window, you can use the Xlib window information functions
to:

·    Obtain information about a window

·    Translate screen coordinates

·    Manipulate property lists

·    Obtain and change window properties

·    Manipulate selections

1m4.1.	Obtaining Window Information0m

Xlib provides functions that you can use to obtain informa-
tion about the window tree, the window's current attributes,
the window's current geometry, or the current pointer coor-
dinates.  Because they are most frequently used by window
managers, these functions all return a status to indicate
whether the window still exists.


To obtain the parent, a list of children, and number of
children for a given window, use 4mXQueryTree24m.























			     1m810m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
Status XQueryTree(4mdisplay24m, 4mw24m, 4mroot_return24m, 4mparent_return24m, 4mchildren_return24m, 4mnchildren_return24m)
      Display *4mdisplay24m;
      Window 4mw24m;
      Window *4mroot_return24m;
      Window *4mparent_return24m;
      Window **4mchildren_return24m;
      unsigned int *4mnchildren_return24m;


4mdisplay24m   Specifies the connection to the X server.

4mw24m	       Specifies the window whose list of children, root,
	  parent, and number of children you want to obtain.

4mroot_return0m
	  Returns the root window.

4mparent_return0m
	  Returns the parent window.

4mchildren_return0m
	  Returns the list of children.

4mnchildren_return0m
	  Returns the number of children.
|__

The 4mXQueryTree24m function returns the root ID, the parent win-
dow ID, a pointer to the list of children windows (NULL when
there are no children), and the number of children in the
list for the specified window.	The children are listed in
current stacking order, from bottom-most (first) to top-most
(last).	 4mXQueryTree24m returns zero if it fails and nonzero if
it succeeds.  To free a non-NULL children list when it is no
longer needed, use 4mXFree24m.

4mXQueryTree24m can generate a 4mBadWindow24m error.


To obtain the current attributes of a given window, use
4mXGetWindowAttributes24m.















			     1m820m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
Status XGetWindowAttributes(4mdisplay24m, 4mw24m, 4mwindow_attributes_return24m)
      Display *4mdisplay24m;
      Window 4mw24m;
      XWindowAttributes *4mwindow_attributes_return24m;


4mdisplay24m   Specifies the connection to the X server.

4mw24m	       Specifies the window whose current attributes you
	  want to obtain.

4mwindow_attributes_return0m
	  Returns the specified window's attributes in the
	  4mXWindowAttributes24m structure.
|__

The 4mXGetWindowAttributes24m function returns the current
attributes for the specified window to an 4mXWindowAttributes0m
structure.

__
|
typedef struct {
     int x, y;		      /* location of window */
     int width, height;	      /* width and height of window */
     int border_width;	      /* border width of window */
     int depth;		      /* depth of window */
     Visual *visual;	      /* the associated visual structure */
     Window root;	      /* root of screen containing window */
     int class;		      /* InputOutput, InputOnly*/
     int bit_gravity;	      /* one of the bit gravity values */
     int win_gravity;	      /* one of the window gravity values */
     int backing_store;	      /* NotUseful, WhenMapped, Always */
     unsigned long backing_planes;/* planes to be preserved if possible */
     unsigned long backing_pixel;/* value to be used when restoring planes */
     Bool save_under;	      /* boolean, should bits under be saved? */
     Colormap colormap;	      /* color map to be associated with window */
     Bool map_installed;      /* boolean, is color map currently installed*/
     int map_state;	      /* IsUnmapped, IsUnviewable, IsViewable */
     long all_event_masks;    /* set of events all people have interest in*/
     long your_event_mask;    /* my event mask */
     long do_not_propagate_mask;/* set of events that should not propagate */
     Bool override_redirect;  /* boolean value for override-redirect */
     Screen *screen;	      /* back pointer to correct screen */
} XWindowAttributes;

|__

The x and y members are set to the upper-left outer corner
relative to the parent window's origin.	 The width and
height members are set to the inside size of the window, not
including the border.  The border_width member is set to the
window's border width in pixels.  The depth member is set to



			     1m830m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


the depth of the window (that is, bits per pixel for the
object).  The visual member is a pointer to the screen's
associated 4mVisual24m structure.  The root member is set to the
root window of the screen containing the window.  The class
member is set to the window's class and can be either
4mInputOutput24m or 4mInputOnly24m.

The bit_gravity member is set to the window's bit gravity
and can be one of the following:


4mForgetGravity24m     4mEastGravity0m
4mNorthWestGrav-24m    4mSouthWestGrav-0m
4mity24m	       4mity0m
4mNorthGravity24m      4mSouthGravity0m
4mNorthEastGrav-24m    4mSouthEastGrav-0m
4mity24m	       4mity0m
4mWestGravity24m       4mStaticGravity0m
4mCenterGravity0m


The win_gravity member is set to the window's window gravity
and can be one of the following:


4mUnmapGravity24m      4mEastGravity0m
4mNorthWestGrav-24m    4mSouthWestGrav-0m
4mity24m	       4mity0m
4mNorthGravity24m      4mSouthGravity0m
4mNorthEastGrav-24m    4mSouthEastGrav-0m
4mity24m	       4mity0m
4mWestGravity24m       4mStaticGravity0m
4mCenterGravity0m


For additional information on gravity, see section 3.2.3.

The backing_store member is set to indicate how the X server
should maintain the contents of a window and can be 4mWhen-0m
4mMapped24m, 4mAlways24m, or 4mNotUseful24m.  The backing_planes member is
set to indicate (with bits set to 1) which bit planes of the
window hold dynamic data that must be preserved in back-
ing_stores and during save_unders.  The backing_pixel member
is set to indicate what values to use for planes not set in
backing_planes.

The save_under member is set to 4mTrue24m or 4mFalse24m.  The colormap
member is set to the colormap for the specified window and
can be a colormap ID or 4mNone24m.  The map_installed member is
set to indicate whether the colormap is currently installed
and can be 4mTrue24m or 4mFalse24m.  The map_state member is set to
indicate the state of the window and can be 4mIsUnmapped24m,
4mIsUnviewable24m, or 4mIsViewable24m.	4mIsUnviewable24m is used if the
window is mapped but some ancestor is unmapped.



			     1m840m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


The all_event_masks member is set to the bitwise inclusive
OR of all event masks selected on the window by all clients.
The your_event_mask member is set to the bitwise inclusive
OR of all event masks selected by the querying client.	The
do_not_propagate_mask member is set to the bitwise inclusive
OR of the set of events that should not propagate.

The override_redirect member is set to indicate whether this
window overrides structure control facilities and can be
4mTrue24m or 4mFalse24m.  Window manager clients should ignore the
window if this member is 4mTrue24m.

The screen member is set to a screen pointer that gives you
a back pointer to the correct screen.  This makes it easier
to obtain the screen information without having to loop over
the root window fields to see which field matches.

4mXGetWindowAttributes24m can generate 4mBadDrawable24m and 4mBadWindow0m
errors.


To obtain the current geometry of a given drawable, use
4mXGetGeometry24m.


































			     1m850m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
Status XGetGeometry(4mdisplay24m, 4md24m, 4mroot_return24m, 4mx_return24m, 4my_return24m, 4mwidth_return24m,
		      4mheight_return24m, 4mborder_width_return24m, 4mdepth_return24m)
	Display *4mdisplay24m;
	Drawable 4md24m;
	Window *4mroot_return24m;
	int *4mx_return24m, *4my_return24m;
	unsigned int *4mwidth_return24m, *4mheight_return24m;
	unsigned int *4mborder_width_return24m;
	unsigned int *4mdepth_return24m;


4mdisplay24m   Specifies the connection to the X server.

4md24m	       Specifies the drawable, which can be a window or a
	  pixmap.

4mroot_return0m
	  Returns the root window.

4mx_return0m
4my_return24m  Return the x and y coordinates that define the
	  location of the drawable.  For a window, these
	  coordinates specify the upper-left outer corner
	  relative to its parent's origin.  For pixmaps,
	  these coordinates are always zero.

4mwidth_return0m
4mheight_return0m
	  Return the drawable's dimensions (width and
	  height).  For a window, these dimensions specify
	  the inside size, not including the border.

4mborder_width_return0m
	  Returns the border width in pixels.  If the draw-
	  able is a pixmap, it returns zero.

4mdepth_return0m
	  Returns the depth of the drawable (bits per pixel
	  for the object).
|__

The 4mXGetGeometry24m function returns the root window and the
current geometry of the drawable.  The geometry of the draw-
able includes the x and y coordinates, width and height,
border width, and depth.  These are described in the argu-
ment list.  It is legal to pass to this function a window
whose class is 4mInputOnly24m.

4mXGetGeometry24m can generate a 4mBadDrawable24m error.







			     1m860m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


1m4.2.	Translating Screen Coordinates0m

Applications sometimes need to perform a coordinate trans-
formation from the coordinate space of one window to another
window or need to determine which window the pointing device
is in.	4mXTranslateCoordinates24m and 4mXQueryPointer24m fulfill
these needs (and avoid any race conditions) by asking the X
server to perform these operations.


To translate a coordinate in one window to the coordinate
space of another window, use 4mXTranslateCoordinates24m.
__
|
Bool XTranslateCoordinates(4mdisplay24m, 4msrc_w24m, 4mdest_w24m, 4msrc_x24m, 4msrc_y24m, 4mdest_x_return24m,
			    4mdest_y_return24m, 4mchild_return24m)
      Display *4mdisplay24m;
      Window 4msrc_w24m, 4mdest_w24m;
      int 4msrc_x24m, 4msrc_y24m;
      int *4mdest_x_return24m, *4mdest_y_return24m;
      Window *4mchild_return24m;


4mdisplay24m   Specifies the connection to the X server.

4msrc_w24m     Specifies the source window.

4mdest_w24m    Specifies the destination window.

4msrc_x0m
4msrc_y24m     Specify the x and y coordinates within the source
	  window.

4mdest_x_return0m
4mdest_y_return0m
	  Return the x and y coordinates within the destina-
	  tion window.

4mchild_return0m
	  Returns the child if the coordinates are contained
	  in a mapped child of the destination window.
|__

If 4mXTranslateCoordinates24m returns 4mTrue24m, it takes the src_x
and src_y coordinates relative to the source window's origin
and returns these coordinates to dest_x_return and
dest_y_return relative to the destination window's origin.
If 4mXTranslateCoordinates24m returns 4mFalse24m, src_w and dest_w are
on different screens, and dest_x_return and dest_y_return
are zero.  If the coordinates are contained in a mapped
child of dest_w, that child is returned to child_return.
Otherwise, child_return is set to 4mNone24m.





			     1m870m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


4mXTranslateCoordinates24m can generate a 4mBadWindow24m error.


To obtain the screen coordinates of the pointer or to deter-
mine the pointer coordinates relative to a specified window,
use 4mXQueryPointer24m.
__
|
Bool XQueryPointer(4mdisplay24m, 4mw24m, 4mroot_return24m, 4mchild_return24m, 4mroot_x_return24m, 4mroot_y_return24m,
		     4mwin_x_return24m, 4mwin_y_return24m, 4mmask_return24m)
      Display *4mdisplay24m;
      Window 4mw24m;
      Window *4mroot_return24m, *4mchild_return24m;
      int *4mroot_x_return24m, *4mroot_y_return24m;
      int *4mwin_x_return24m, *4mwin_y_return24m;
      unsigned int *4mmask_return24m;


4mdisplay24m   Specifies the connection to the X server.

4mw24m	       Specifies the window.

4mroot_return0m
	  Returns the root window that the pointer is in.

4mchild_return0m
	  Returns the child window that the pointer is
	  located in, if any.

4mroot_x_return0m
4mroot_y_return0m
	  Return the pointer coordinates relative to the
	  root window's origin.

4mwin_x_return0m
4mwin_y_return0m
	  Return the pointer coordinates relative to the
	  specified window.

4mmask_return0m
	  Returns the current state of the modifier keys and
	  pointer buttons.
|__

The 4mXQueryPointer24m function returns the root window the
pointer is logically on and the pointer coordinates relative
to the root window's origin.  If 4mXQueryPointer24m returns
4mFalse24m, the pointer is not on the same screen as the speci-
fied window, and 4mXQueryPointer24m returns 4mNone24m to child_return
and zero to win_x_return and win_y_return.  If 4mXQueryPointer0m
returns 4mTrue24m, the pointer coordinates returned to
win_x_return and win_y_return are relative to the origin of
the specified window.  In this case, 4mXQueryPointer24m returns
the child that contains the pointer, if any, or else 4mNone24m to



			     1m880m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


child_return.

4mXQueryPointer24m returns the current logical state of the key-
board buttons and the modifier keys in mask_return.  It sets
mask_return to the bitwise inclusive OR of one or more of
the button or modifier key bitmasks to match the current
state of the mouse buttons and the modifier keys.

Note that the logical state of a device (as seen through
Xlib) may lag the physical state if device event processing
is frozen (see section 12.1).

4mXQueryPointer24m can generate a 4mBadWindow24m error.

1m4.3.	Properties and Atoms0m

A property is a collection of named, typed data.  The window
system has a set of predefined properties (for example, the
name of a window, size hints, and so on), and users can
define any other arbitrary information and associate it with
windows.  Each property has a name, which is an ISO Latin-1
string.	 For each named property, a unique identifier (atom)
is associated with it.	A property also has a type, for
example, string or integer.  These types are also indicated
using atoms, so arbitrary new types can be defined.  Data of
only one type may be associated with a single property name.
Clients can store and retrieve properties associated with
windows.  For efficiency reasons, an atom is used rather
than a character string.  4mXInternAtom24m can be used to obtain
the atom for property names.

A property is also stored in one of several possible for-
mats.  The X server can store the information as 8-bit quan-
tities, 16-bit quantities, or 32-bit quantities.  This per-
mits the X server to present the data in the byte order that
the client expects.

			    Note

     If you define further properties of complex type,
     you must encode and decode them yourself.	These
     functions must be carefully written if they are to
     be portable.  For further information about how to
     write a library extension, see appendix C.

The type of a property is defined by an atom, which allows
for arbitrary extension in this type scheme.

Certain property names are predefined in the server for com-
monly used functions.  The atoms for these properties are
defined in <4mX11/Xatom.h24m>.	To avoid name clashes with user
symbols, the 4m#define24m name for each atom has the XA_ prefix.
For an explanation of the functions that let you get and set
much of the information stored in these predefined



			     1m890m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


properties, see chapter 14.

The core protocol imposes no semantics on these property
names, but semantics are specified in other X Consortium
standards, such as the 4mInter-Client24m 4mCommunication24m 4mConven-0m
4mtions24m 4mManual24m and the 4mX24m 4mLogical24m 4mFont24m 4mDescription24m 4mConventions24m.

You can use properties to communicate other information
between applications.  The functions described in this sec-
tion let you define new properties and get the unique atom
IDs in your applications.

Although any particular atom can have some client interpre-
tation within each of the name spaces, atoms occur in five
distinct name spaces within the protocol:

·    Selections

·    Property names

·    Property types

·    Font properties

·    Type of a 4mClientMessage24m event (none are built into the
     X server)


The built-in selection property names are:


PRIMARY
SECONDARY


The built-in property names are:

CUT_BUFFER0	       RESOURCE_MANAGER
CUT_BUFFER1	       WM_CLASS
CUT_BUFFER2	       WM_CLIENT_MACHINE
CUT_BUFFER3	       WM_COLORMAP_WINDOWS
CUT_BUFFER4	       WM_COMMAND
CUT_BUFFER5	       WM_HINTS
CUT_BUFFER6	       WM_ICON_NAME
CUT_BUFFER7	       WM_ICON_SIZE
RGB_BEST_MAP	       WM_NAME
RGB_BLUE_MAP	       WM_NORMAL_HINTS
RGB_DEFAULT_MAP	       WM_PROTOCOLS
RGB_GRAY_MAP	       WM_STATE
RGB_GREEN_MAP	       WM_TRANSIENT_FOR
RGB_RED_MAP	       WM_ZOOM_HINTS






			     1m900m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


The built-in property types are:


ARC		       POINT
ATOM		       RGB_COLOR_MAP
BITMAP		       RECTANGLE
CARDINAL	       STRING
COLORMAP	       VISUALID
CURSOR		       WINDOW
DRAWABLE	       WM_HINTS
FONT		       WM_SIZE_HINTS
INTEGER
PIXMAP


The built-in font property names are:

MIN_SPACE	       STRIKEOUT_DESCENT
NORM_SPACE	       STRIKEOUT_ASCENT
MAX_SPACE	       ITALIC_ANGLE
END_SPACE	       X_HEIGHT
SUPERSCRIPT_X	       QUAD_WIDTH
SUPERSCRIPT_Y	       WEIGHT
SUBSCRIPT_X	       POINT_SIZE
SUBSCRIPT_Y	       RESOLUTION
UNDERLINE_POSITION     COPYRIGHT
UNDERLINE_THICKNESS    NOTICE
FONT_NAME	       FAMILY_NAME
FULL_NAME	       CAP_HEIGHT


For further information about font properties, see section
8.5.


To return an atom for a given name, use 4mXInternAtom24m.





















			     1m910m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
Atom XInternAtom(4mdisplay24m, 4matom_name24m, 4monly_if_exists24m)
      Display *4mdisplay24m;
      char *4matom_name24m;
      Bool 4monly_if_exists24m;


4mdisplay24m   Specifies the connection to the X server.

4matom_name24m Specifies the name associated with the atom you
	  want returned.

4monly_if_exists0m
	  Specifies a Boolean value that indicates whether
	  the atom must be created.
|__

The 4mXInternAtom24m function returns the atom identifier associ-
ated with the specified atom_name string.  If only_if_exists
is 4mFalse24m, the atom is created if it does not exist.  There-
fore, 4mXInternAtom24m can return 4mNone24m.  If the atom name is not
in the Host Portable Character Encoding, the result is
implementation-dependent.  Uppercase and lowercase matter;
the strings ``thing'', ``Thing'', and ``thinG'' all desig-
nate different atoms.  The atom will remain defined even
after the client's connection closes.  It will become unde-
fined only when the last connection to the X server closes.

4mXInternAtom24m can generate 4mBadAlloc24m and 4mBadValue24m errors.


To return atoms for an array of names, use 4mXInternAtoms24m.

























			     1m920m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
Status XInternAtoms(4mdisplay24m, 4mnames24m, 4mcount24m, 4monly_if_exists24m, 4matoms_return24m)
      Display *4mdisplay24m;
      char **4mnames24m;
      int 4mcount24m;
      Bool 4monly_if_exists24m;
      Atom *4matoms_return24m;


4mdisplay24m   Specifies the connection to the X server.

4mnames24m     Specifies the array of atom names.

4mcount24m     Specifies the number of atom names in the array.

4monly_if_exists0m
	  Specifies a Boolean value that indicates whether
	  the atom must be created.

4matoms_return0m
	  Returns the atoms.
|__

The 4mXInternAtoms24m function returns the atom identifiers asso-
ciated with the specified names.  The atoms are stored in
the atoms_return array supplied by the caller.	Calling this
function is equivalent to calling 4mXInternAtom24m for each of
the names in turn with the specified value of
only_if_exists, but this function minimizes the number of
round-trip protocol exchanges between the client and the X
server.

This function returns a nonzero status if atoms are returned
for all of the names; otherwise, it returns zero.

4mXInternAtoms24m can generate 4mBadAlloc24m and 4mBadValue24m errors.


To return a name for a given atom identifier, use 4mXGetAtom-0m
4mName24m.
__
|
char *XGetAtomName(4mdisplay24m, 4matom24m)
      Display *4mdisplay24m;
      Atom 4matom24m;


4mdisplay24m   Specifies the connection to the X server.

4matom24m      Specifies the atom for the property name you want
	  returned.
|__

The 4mXGetAtomName24m function returns the name associated with



			     1m930m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


the specified atom.  If the data returned by the server is
in the Latin Portable Character Encoding, then the returned
string is in the Host Portable Character Encoding.  Other-
wise, the result is implementation-dependent.  To free the
resulting string, call 4mXFree24m.

4mXGetAtomName24m can generate a 4mBadAtom24m error.


To return the names for an array of atom identifiers, use
4mXGetAtomNames24m.
__
|
Status XGetAtomNames(4mdisplay24m, 4matoms24m, 4mcount24m, 4mnames_return24m)
      Display *4mdisplay24m;
      Atom *4matoms24m;
      int 4mcount24m;
      char **4mnames_return24m;


4mdisplay24m   Specifies the connection to the X server.

4matoms24m     Specifies the array of atoms.

4mcount24m     Specifies the number of atoms in the array.

4mnames_return0m
	  Returns the atom names.
|__

The 4mXGetAtomNames24m function returns the names associated with
the specified atoms.  The names are stored in the
names_return array supplied by the caller.  Calling this
function is equivalent to calling 4mXGetAtomName24m for each of
the atoms in turn, but this function minimizes the number of
round-trip protocol exchanges between the client and the X
server.

This function returns a nonzero status if names are returned
for all of the atoms; otherwise, it returns zero.

4mXGetAtomNames24m can generate a 4mBadAtom24m error.

1m4.4.	Obtaining and Changing Window Properties0m

You can attach a property list to every window.	 Each prop-
erty has a name, a type, and a value (see section 4.3).	 The
value is an array of 8-bit, 16-bit, or 32-bit quantities,
whose interpretation is left to the clients.  The type 4mchar0m
is used to represent 8-bit quantities, the type 4mshort24m is
used to represent 16-bit quantities, and the type 4mlong24m is
used to represent 32-bit quantities.





			     1m940m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


Xlib provides functions that you can use to obtain, change,
update, or interchange window properties.  In addition, Xlib
provides other utility functions for inter-client communica-
tion (see chapter 14).


To obtain the type, format, and value of a property of a
given window, use 4mXGetWindowProperty24m.

















































			     1m950m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
int XGetWindowProperty(4mdisplay24m, 4mw24m, 4mproperty24m, 4mlong_offset24m, 4mlong_length24m, 4mdelete24m, 4mreq_type24m,
			4mactual_type_return24m, 4mactual_format_return24m, 4mnitems_return24m, 4mbytes_after_return24m,
			4mprop_return24m)
      Display *4mdisplay24m;
      Window 4mw24m;
      Atom 4mproperty24m;
      long 4mlong_offset24m, 4mlong_length24m;
      Bool 4mdelete24m;
      Atom 4mreq_type24m;
      Atom *4mactual_type_return24m;
      int *4mactual_format_return24m;
      unsigned long *4mnitems_return24m;
      unsigned long *4mbytes_after_return24m;
      unsigned char **4mprop_return24m;


4mdisplay24m   Specifies the connection to the X server.

4mw24m	       Specifies the window whose property you want to
	  obtain.

4mproperty24m  Specifies the property name.

4mlong_offset0m
	  Specifies the offset in the specified property (in
	  32-bit quantities) where the data is to be
	  retrieved.

4mlong_length0m
	  Specifies the length in 32-bit multiples of the
	  data to be retrieved.

4mdelete24m    Specifies a Boolean value that determines whether
	  the property is deleted.

4mreq_type24m  Specifies the atom identifier associated with the
	  property type or 4mAnyPropertyType24m.

4mactual_type_return0m
	  Returns the atom identifier  that defines the
	  actual type of the property.

4mactual_format_return0m
	  Returns the actual format of the property.

4mnitems_return0m
	  Returns the actual number of 8-bit, 16-bit, or
	  32-bit items stored in the prop_return data.

4mbytes_after_return0m
	  Returns the number of bytes remaining to be read
	  in the property if a partial read was performed.




			     1m960m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


4mprop_return0m
	  Returns the data in the specified format.
|__

The 4mXGetWindowProperty24m function returns the actual type of
the property; the actual format of the property; the number
of 8-bit, 16-bit, or 32-bit items transferred; the number of
bytes remaining to be read in the property; and a pointer to
the data actually returned.  4mXGetWindowProperty24m sets the
return arguments as follows:

·    If the specified property does not exist for the speci-
     fied window, 4mXGetWindowProperty24m returns 4mNone24m to
     actual_type_return and the value zero to actual_for-
     mat_return and bytes_after_return.	 The nitems_return
     argument is empty.	 In this case, the delete argument
     is ignored.

·    If the specified property exists but its type does not
     match the specified type, 4mXGetWindowProperty24m returns
     the actual property type to actual_type_return, the
     actual property format (never zero) to actual_for-
     mat_return, and the property length in bytes (even if
     the actual_format_return is 16 or 32) to
     bytes_after_return.  It also ignores the delete argu-
     ment.  The nitems_return argument is empty.

·    If the specified property exists and either you assign
     4mAnyPropertyType24m to the req_type argument or the speci-
     fied type matches the actual property type, 4mXGetWindow-0m
     4mProperty24m returns the actual property type to
     actual_type_return and the actual property format
     (never zero) to actual_format_return.  It also returns
     a value to bytes_after_return and nitems_return, by
     defining the following values:

	  N = actual length of the stored property in bytes
	       (even if the format is 16 or 32)
	  I = 4 * long_offset
	  T = N - I
	  L = MINIMUM(T, 4 * long_length)
	  A = N - (I + L)

     The returned value starts at byte index I in the prop-
     erty (indexing from zero), and its length in bytes is
     L.	 If the value for long_offset causes L to be nega-
     tive, a 4mBadValue24m error results.  The value of
     bytes_after_return is A, giving the number of trailing
     unread bytes in the stored property.

If the returned format is 8, the returned data is repre-
sented as a 4mchar24m array.  If the returned format is 16, the
returned data is represented as a 4mshort24m array and should be
cast to that type to obtain the elements.  If the returned



			     1m970m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


format is 32, the returned data is represented as a 4mlong0m
array and should be cast to that type to obtain the ele-
ments.

4mXGetWindowProperty24m always allocates one extra byte in
prop_return (even if the property is zero length) and sets
it to zero so that simple properties consisting of charac-
ters do not have to be copied into yet another string before
use.

If delete is 4mTrue24m and bytes_after_return is zero, 4mXGetWin-0m
4mdowProperty24m deletes the property from the window and gener-
ates a 4mPropertyNotify24m event on the window.

The function returns 4mSuccess24m if it executes successfully.
To free the resulting data, use 4mXFree24m.

4mXGetWindowProperty24m can generate 4mBadAtom24m, 4mBadValue24m, and 4mBad-0m
4mWindow24m errors.


To obtain a given window's property list, use 4mXListProper-0m
4mties24m.
__
|
Atom *XListProperties(4mdisplay24m, 4mw24m, 4mnum_prop_return24m)
      Display *4mdisplay24m;
      Window 4mw24m;
      int *4mnum_prop_return24m;


4mdisplay24m   Specifies the connection to the X server.

4mw24m	       Specifies the window whose property list you want
	  to obtain.

4mnum_prop_return0m
	  Returns the length of the properties array.
|__

The 4mXListProperties24m function returns a pointer to an array
of atom properties that are defined for the specified window
or returns NULL if no properties were found.  To free the
memory allocated by this function, use 4mXFree24m.

4mXListProperties24m can generate a 4mBadWindow24m error.


To change a property of a given window, use 4mXChangeProperty24m.








			     1m980m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
XChangeProperty(4mdisplay24m, 4mw24m, 4mproperty24m, 4mtype24m, 4mformat24m, 4mmode24m, 4mdata24m, 4mnelements24m)
      Display *4mdisplay24m;
      Window 4mw24m;
      Atom 4mproperty24m, 4mtype24m;
      int 4mformat24m;
      int 4mmode24m;
      unsigned char *4mdata24m;
      int 4mnelements24m;


4mdisplay24m   Specifies the connection to the X server.

4mw24m	       Specifies the window whose property you want to
	  change.

4mproperty24m  Specifies the property name.

4mtype24m      Specifies the type of the property.  The X server
	  does not interpret the type but simply passes it
	  back to an application that later calls 4mXGetWin-0m
	  4mdowProperty24m.

4mformat24m    Specifies whether the data should be viewed as a
	  list of 8-bit, 16-bit, or 32-bit quantities.	Pos-
	  sible values are 8, 16, and 32.  This information
	  allows the X server to correctly perform byte-swap
	  operations as necessary.  If the format is 16-bit
	  or 32-bit, you must explicitly cast your data
	  pointer to an (unsigned char *) in the call to
	  4mXChangeProperty24m.

4mmode24m      Specifies the mode of the operation.  You can pass
	  4mPropModeReplace24m, 4mPropModePrepend24m, or 4mPropModeAp-0m
	  4mpend24m.

4mdata24m      Specifies the property data.

4mnelements24m Specifies the number of elements of the specified
	  data format.
|__

The 4mXChangeProperty24m function alters the property for the
specified window and causes the X server to generate a 4mProp-0m
4mertyNotify24m event on that window.  4mXChangeProperty24m performs
the following:

·    If mode is 4mPropModeReplace24m, 4mXChangeProperty24m discards
     the previous property value and stores the new data.

·    If mode is 4mPropModePrepend24m or 4mPropModeAppend24m, 4mXChange-0m
     4mProperty24m inserts the specified data before the begin-
     ning of the existing data or onto the end of the exist-
     ing data, respectively.  The type and format must match



			     1m990m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


     the existing property value, or a 4mBadMatch24m error
     results.  If the property is undefined, it is treated
     as defined with the correct type and format with zero-
     length data.

If the specified format is 8, the property data must be a
4mchar24m array.  If the specified format is 16, the property
data must be a 4mshort24m array.  If the specified format is 32,
the property data must be a 4mlong24m array.

The lifetime of a property is not tied to the storing
client.	 Properties remain until explicitly deleted, until
the window is destroyed, or until the server resets.  For a
discussion of what happens when the connection to the X
server is closed, see section 2.6.  The maximum size of a
property is server dependent and can vary dynamically
depending on the amount of memory the server has available.
(If there is insufficient space, a 4mBadAlloc24m error results.)

4mXChangeProperty24m can generate 4mBadAlloc24m, 4mBadAtom24m, 4mBadMatch24m,
4mBadValue24m, and 4mBadWindow24m errors.


To rotate a window's property list, use 4mXRotateWindowProper-0m
4mties24m.

__
|
XRotateWindowProperties(4mdisplay24m, 4mw24m, 4mproperties24m, 4mnum_prop24m, 4mnpositions24m)
      Display *4mdisplay24m;
      Window 4mw24m;
      Atom 4mproperties24m[];
      int 4mnum_prop24m;
      int 4mnpositions24m;


4mdisplay24m   Specifies the connection to the X server.

4mw24m	       Specifies the window.

4mproperties0m
	  Specifies the array of properties that are to be
	  rotated.

4mnum_prop24m  Specifies the length of the properties array.

4mnpositions0m
	  Specifies the rotation amount.
|__

The 4mXRotateWindowProperties24m function allows you to rotate
properties on a window and causes the X server to generate
4mPropertyNotify24m events.  If the property names in the proper-
ties array are viewed as being numbered starting from zero



			     1m1000m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


and if there are num_prop property names in the list, then
the value associated with property name I becomes the value
associated with property name (I + npositions) mod N for all
I from zero to N - 1.  The effect is to rotate the states by
npositions places around the virtual ring of property names
(right for positive npositions, left for negative nposi-
tions).	 If npositions mod N is nonzero, the X server gener-
ates a 4mPropertyNotify24m event for each property in the order
that they are listed in the array.  If an atom occurs more
than once in the list or no property with that name is
defined for the window, a 4mBadMatch24m error results.	If a
4mBadAtom24m or 4mBadMatch24m error results, no properties are
changed.

4mXRotateWindowProperties24m can generate 4mBadAtom24m, 4mBadMatch24m, and
4mBadWindow24m errors.


To delete a property on a given window, use 4mXDeleteProperty24m.
__
|
XDeleteProperty(4mdisplay24m, 4mw24m, 4mproperty24m)
      Display *4mdisplay24m;
      Window 4mw24m;
      Atom 4mproperty24m;


4mdisplay24m   Specifies the connection to the X server.

4mw24m	       Specifies the window whose property you want to
	  delete.

4mproperty24m  Specifies the property name.
|__

The 4mXDeleteProperty24m function deletes the specified property
only if the property was defined on the specified window and
causes the X server to generate a 4mPropertyNotify24m event on
the window unless the property does not exist.

4mXDeleteProperty24m can generate 4mBadAtom24m and 4mBadWindow24m errors.

1m4.5.	Selections0m

Selections are one method used by applications to exchange
data.  By using the property mechanism, applications can
exchange data of arbitrary types and can negotiate the type
of the data.  A selection can be thought of as an indirect
property with a dynamic type.  That is, rather than having
the property stored in the X server, the property is main-
tained by some client (the owner).  A selection is global in
nature (considered to belong to the user but be maintained
by clients) rather than being private to a particular window
subhierarchy or a particular set of clients.



			     1m1010m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


Xlib provides functions that you can use to set, get, or
request conversion of selections.  This allows applications
to implement the notion of current selection, which requires
that notification be sent to applications when they no
longer own the selection.  Applications that support selec-
tion often highlight the current selection and so must be
informed when another application has acquired the selection
so that they can unhighlight the selection.

When a client asks for the contents of a selection, it spec-
ifies a selection target type.	This target type can be used
to control the transmitted representation of the contents.
For example, if the selection is ``the last thing the user
clicked on'' and that is currently an image, then the target
type might specify whether the contents of the image should
be sent in XY format or Z format.

The target type can also be used to control the class of
contents transmitted, for example, asking for the ``looks''
(fonts, line spacing, indentation, and so forth) of a para-
graph selection, not the text of the paragraph.	 The target
type can also be used for other purposes.  The protocol does
not constrain the semantics.


To set the selection owner, use 4mXSetSelectionOwner24m.
__
|
XSetSelectionOwner(4mdisplay24m, 4mselection24m, 4mowner24m, 4mtime24m)
      Display *4mdisplay24m;
      Atom 4mselection24m;
      Window 4mowner24m;
      Time 4mtime24m;


4mdisplay24m   Specifies the connection to the X server.

4mselection24m Specifies the selection atom.

4mowner24m     Specifies the owner of the specified selection
	  atom.	 You can pass a window or 4mNone24m.

4mtime24m      Specifies the time.  You can pass either a time-
	  stamp or 4mCurrentTime24m.
|__

The 4mXSetSelectionOwner24m function changes the owner and last-
change time for the specified selection and has no effect if
the specified time is earlier than the current last-change
time of the specified selection or is later than the current
X server time.	Otherwise, the last-change time is set to
the specified time, with 4mCurrentTime24m replaced by the current
server time.  If the owner window is specified as 4mNone24m, then
the owner of the selection becomes 4mNone24m (that is, no owner).



			     1m1020m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


Otherwise, the owner of the selection becomes the client
executing the request.

If the new owner (whether a client or 4mNone24m) is not the same
as the current owner of the selection and the current owner
is not 4mNone24m, the current owner is sent a 4mSelectionClear0m
event.	If the client that is the owner of a selection is
later terminated (that is, its connection is closed) or if
the owner window it has specified in the request is later
destroyed, the owner of the selection automatically reverts
to 4mNone24m, but the last-change time is not affected.	 The
selection atom is uninterpreted by the X server.  4mXGetSelec-0m
4mtionOwner24m returns the owner window, which is reported in
4mSelectionRequest24m and 4mSelectionClear24m events.  Selections are
global to the X server.

4mXSetSelectionOwner24m can generate 4mBadAtom24m and 4mBadWindow0m
errors.


To return the selection owner, use 4mXGetSelectionOwner24m.
__
|
Window XGetSelectionOwner(4mdisplay24m, 4mselection24m)
      Display *4mdisplay24m;
      Atom 4mselection24m;


4mdisplay24m   Specifies the connection to the X server.

4mselection24m Specifies the selection atom whose owner you want
	  returned.
|__

The 4mXGetSelectionOwner24m function returns the window ID asso-
ciated with the window that currently owns the specified
selection.  If no selection was specified, the function
returns the constant 4mNone24m.	 If 4mNone24m is returned, there is no
owner for the selection.

4mXGetSelectionOwner24m can generate a 4mBadAtom24m error.


To request conversion of a selection, use 4mXConvertSelection24m.













			     1m1030m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
XConvertSelection(4mdisplay24m, 4mselection24m, 4mtarget24m, 4mproperty24m, 4mrequestor24m, 4mtime24m)
      Display *4mdisplay24m;
      Atom 4mselection24m, 4mtarget24m;
      Atom 4mproperty24m;
      Window 4mrequestor24m;
      Time 4mtime24m;


4mdisplay24m   Specifies the connection to the X server.

4mselection24m Specifies the selection atom.

4mtarget24m    Specifies the target atom.

4mproperty24m  Specifies the property name.  You also can pass
	  4mNone24m.

4mrequestor24m Specifies the requestor.

4mtime24m      Specifies the time.  You can pass either a time-
	  stamp or 4mCurrentTime24m.
|__

4mXConvertSelection24m requests that the specified selection be
converted to the specified target type:

·    If the specified selection has an owner, the X server
     sends a 4mSelectionRequest24m event to that owner.

·    If no owner for the specified selection exists, the X
     server generates a 4mSelectionNotify24m event to the
     requestor with property 4mNone24m.

The arguments are passed on unchanged in either of the
events.	 There are two predefined selection atoms: PRIMARY
and SECONDARY.

4mXConvertSelection24m can generate 4mBadAtom24m and 4mBadWindow24m errors.


















			     1m1040m





1mXlib - C Library			X11, Release 6.7 DRAFT0m




			 1mChapter 50m

		1mPixmap and Cursor Functions0m



Once you have connected to an X server, you can use the Xlib
functions to:

·    Create and free pixmaps

·    Create, recolor, and free cursors

1m5.1.	Creating and Freeing Pixmaps0m

Pixmaps can only be used on the screen on which they were
created.  Pixmaps are off-screen resources that are used for
various operations, such as defining cursors as tiling pat-
terns or as the source for certain raster operations.  Most
graphics requests can operate either on a window or on a
pixmap.	 A bitmap is a single bit-plane pixmap.


To create a pixmap of a given size, use 4mXCreatePixmap24m.
__
|
Pixmap XCreatePixmap(4mdisplay24m, 4md24m, 4mwidth24m, 4mheight24m, 4mdepth24m)
      Display *4mdisplay24m;
      Drawable 4md24m;
      unsigned int 4mwidth24m, 4mheight24m;
      unsigned int 4mdepth24m;


4mdisplay24m   Specifies the connection to the X server.

4md24m	       Specifies which screen the pixmap is created on.

4mwidth0m
4mheight24m    Specify the width and height, which define the
	  dimensions of the pixmap.

4mdepth24m     Specifies the depth of the pixmap.
|__

The 4mXCreatePixmap24m function creates a pixmap of the width,
height, and depth you specified and returns a pixmap ID that
identifies it.	It is valid to pass an 4mInputOnly24m window to
the drawable argument.	The width and height arguments must
be nonzero, or a 4mBadValue24m error results.  The depth argument
must be one of the depths supported by the screen of the
specified drawable, or a 4mBadValue24m error results.




			     1m1050m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


The server uses the specified drawable to determine on which
screen to create the pixmap.  The pixmap can be used only on
this screen and only with other drawables of the same depth
(see 4mXCopyPlane24m for an exception to this rule).  The initial
contents of the pixmap are undefined.

4mXCreatePixmap24m can generate 4mBadAlloc24m, 4mBadDrawable24m, and 4mBad-0m
4mValue24m errors.


To free all storage associated with a specified pixmap, use
4mXFreePixmap24m.
__
|
XFreePixmap(4mdisplay24m, 4mpixmap24m)
      Display *4mdisplay24m;
      Pixmap 4mpixmap24m;


4mdisplay24m   Specifies the connection to the X server.

4mpixmap24m    Specifies the pixmap.
|__

The 4mXFreePixmap24m function first deletes the association
between the pixmap ID and the pixmap.  Then, the X server
frees the pixmap storage when there are no references to it.
The pixmap should never be referenced again.

4mXFreePixmap24m can generate a 4mBadPixmap24m error.

1m5.2.	Creating, Recoloring, and Freeing Cursors0m

Each window can have a different cursor defined for it.
Whenever the pointer is in a visible window, it is set to
the cursor defined for that window.  If no cursor was
defined for that window, the cursor is the one defined for
the parent window.

From X's perspective, a cursor consists of a cursor source,
mask, colors, and a hotspot.  The mask pixmap determines the
shape of the cursor and must be a depth of one.	 The source
pixmap must have a depth of one, and the colors determine
the colors of the source.  The hotspot defines the point on
the cursor that is reported when a pointer event occurs.
There may be limitations imposed by the hardware on cursors
as to size and whether a mask is implemented.
4mXQueryBestCursor24m can be used to find out what sizes are pos-
sible.	There is a standard font for creating cursors, but
Xlib provides functions that you can use to create cursors
from an arbitrary font or from bitmaps.


To create a cursor from the standard cursor font, use



			     1m1060m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


4mXCreateFontCursor24m.
__
|
#include <X11/cursorfont.h>
Cursor XCreateFontCursor(4mdisplay24m, 4mshape24m)
      Display *4mdisplay24m;
      unsigned int 4mshape24m;


4mdisplay24m   Specifies the connection to the X server.

4mshape24m     Specifies the shape of the cursor.
|__

X provides a set of standard cursor shapes in a special font
named cursor.  Applications are encouraged to use this
interface for their cursors because the font can be cus-
tomized for the individual display type.  The shape argument
specifies which glyph of the standard fonts to use.

The hotspot comes from the information stored in the cursor
font.  The initial colors of a cursor are a black foreground
and a white background (see 4mXRecolorCursor24m).  For further
information about cursor shapes, see appendix B.

4mXCreateFontCursor24m can generate 4mBadAlloc24m and 4mBadValue24m errors.


To create a cursor from font glyphs, use 4mXCreateGlyphCursor24m.




























			     1m1070m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
Cursor XCreateGlyphCursor(4mdisplay24m, 4msource_font24m, 4mmask_font24m, 4msource_char24m, 4mmask_char24m,
			   4mforeground_color24m, 4mbackground_color24m)
      Display *4mdisplay24m;
      Font 4msource_font24m, 4mmask_font24m;
      unsigned int 4msource_char24m, 4mmask_char24m;
      XColor *4mforeground_color24m;
      XColor *4mbackground_color24m;


4mdisplay24m   Specifies the connection to the X server.

4msource_font0m
	  Specifies the font for the source glyph.

4mmask_font24m Specifies the font for the mask glyph or 4mNone24m.

4msource_char0m
	  Specifies the character glyph for the source.

4mmask_char24m Specifies the glyph character for the mask.

4mforeground_color0m
	  Specifies the RGB values for the foreground of the
	  source.

4mbackground_color0m
	  Specifies the RGB values for the background of the
	  source.
|__

The 4mXCreateGlyphCursor24m function is similar to 4mXCre-0m
4matePixmapCursor24m except that the source and mask bitmaps are
obtained from the specified font glyphs.  The source_char
must be a defined glyph in source_font, or a 4mBadValue24m error
results.  If mask_font is given, mask_char must be a defined
glyph in mask_font, or a 4mBadValue24m error results.  The
mask_font and character are optional.  The origins of the
source_char and mask_char (if defined) glyphs are positioned
coincidently and define the hotspot.  The source_char and
mask_char need not have the same bounding box metrics, and
there is no restriction on the placement of the hotspot rel-
ative to the bounding boxes.  If no mask_char is given, all
pixels of the source are displayed.  You can free the fonts
immediately by calling 4mXFreeFont24m if no further explicit ref-
erences to them are to be made.

For 2-byte matrix fonts, the 16-bit value should be formed
with the byte1 member in the most significant byte and the
byte2 member in the least significant byte.

4mXCreateGlyphCursor24m can generate 4mBadAlloc24m, 4mBadFont24m, and 4mBad-0m
4mValue24m errors.




			     1m1080m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


To create a cursor from two bitmaps, use 4mXCreatePixmapCur-0m
4msor24m.
__
|
Cursor XCreatePixmapCursor(4mdisplay24m, 4msource24m, 4mmask24m, 4mforeground_color24m, 4mbackground_color24m, 4mx24m, 4my24m)
      Display *4mdisplay24m;
      Pixmap 4msource24m;
      Pixmap 4mmask24m;
      XColor *4mforeground_color24m;
      XColor *4mbackground_color24m;
      unsigned int 4mx24m, 4my24m;


4mdisplay24m   Specifies the connection to the X server.

4msource24m    Specifies the shape of the source cursor.

4mmask24m      Specifies the cursor's source bits to be displayed
	  or 4mNone24m.

4mforeground_color0m
	  Specifies the RGB values for the foreground of the
	  source.

4mbackground_color0m
	  Specifies the RGB values for the background of the
	  source.

4mx0m
4my24m	       Specify the x and y coordinates, which indicate
	  the hotspot relative to the source's origin.
|__

The 4mXCreatePixmapCursor24m function creates a cursor and
returns the cursor ID associated with it.  The foreground
and background RGB values must be specified using fore-
ground_color and background_color, even if the X server only
has a 4mStaticGray24m or 4mGrayScale24m screen.	 The foreground color
is used for the pixels set to 1 in the source, and the back-
ground color is used for the pixels set to 0.  Both source
and mask, if specified, must have depth one (or a 4mBadMatch0m
error results) but can have any root.  The mask argument
defines the shape of the cursor.  The pixels set to 1 in the
mask define which source pixels are displayed, and the pix-
els set to 0 define which pixels are ignored.  If no mask is
given, all pixels of the source are displayed.	The mask, if
present, must be the same size as the pixmap defined by the
source argument, or a 4mBadMatch24m error results.  The hotspot
must be a point within the source, or a 4mBadMatch24m error
results.

The components of the cursor can be transformed arbitrarily
to meet display limitations.  The pixmaps can be freed imme-
diately if no further explicit references to them are to be



			     1m1090m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


made.  Subsequent drawing in the source or mask pixmap has
an undefined effect on the cursor.  The X server might or
might not make a copy of the pixmap.

4mXCreatePixmapCursor24m can generate 4mBadAlloc24m and 4mBadPixmap0m
errors.


To determine useful cursor sizes, use 4mXQueryBestCursor24m.
__
|
Status XQueryBestCursor(4mdisplay24m, 4md24m, 4mwidth24m, 4mheight24m, 4mwidth_return24m, 4mheight_return24m)
      Display *4mdisplay24m;
      Drawable 4md24m;
      unsigned int 4mwidth24m, 4mheight24m;
      unsigned int *4mwidth_return24m, *4mheight_return24m;


4mdisplay24m   Specifies the connection to the X server.

4md24m	       Specifies the drawable, which indicates the
	  screen.

4mwidth0m
4mheight24m    Specify the width and height of the cursor that
	  you want the size information for.

4mwidth_return0m
4mheight_return0m
	  Return the best width and height that is closest
	  to the specified width and height.
|__

Some displays allow larger cursors than other displays.	 The
4mXQueryBestCursor24m function provides a way to find out what
size cursors are actually possible on the display.  It
returns the largest size that can be displayed.	 Applica-
tions should be prepared to use smaller cursors on displays
that cannot support large ones.

4mXQueryBestCursor24m can generate a 4mBadDrawable24m error.


To change the color of a given cursor, use 4mXRecolorCursor24m.













			     1m1100m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
XRecolorCursor(4mdisplay24m, 4mcursor24m, 4mforeground_color24m, 4mbackground_color24m)
      Display *4mdisplay24m;
      Cursor 4mcursor24m;
      XColor *4mforeground_color24m, *4mbackground_color24m;


4mdisplay24m   Specifies the connection to the X server.

4mcursor24m    Specifies the cursor.

4mforeground_color0m
	  Specifies the RGB values for the foreground of the
	  source.

4mbackground_color0m
	  Specifies the RGB values for the background of the
	  source.
|__

The 4mXRecolorCursor24m function changes the color of the speci-
fied cursor, and if the cursor is being displayed on a
screen, the change is visible immediately.  The pixel mem-
bers of the 4mXColor24m structures are ignored; only the RGB val-
ues are used.

4mXRecolorCursor24m can generate a 4mBadCursor24m error.


To free (destroy) a given cursor, use 4mXFreeCursor24m.
__
|
XFreeCursor(4mdisplay24m, 4mcursor24m)
      Display *4mdisplay24m;
      Cursor 4mcursor24m;


4mdisplay24m   Specifies the connection to the X server.

4mcursor24m    Specifies the cursor.
|__

The 4mXFreeCursor24m function deletes the association between the
cursor resource ID and the specified cursor.  The cursor
storage is freed when no other resource references it.	The
specified cursor ID should not be referred to again.

4mXFreeCursor24m can generate a 4mBadCursor24m error.









			     1m1110m





1mXlib - C Library			X11, Release 6.7 DRAFT0m




			 1mChapter 60m

		 1mColor Management Functions0m



Each X window always has an associated colormap that pro-
vides a level of indirection between pixel values and colors
displayed on the screen.  Xlib provides functions that you
can use to manipulate a colormap.  The X protocol defines
colors using values in the RGB color space.  The RGB color
space is device dependent; rendering an RGB value on differ-
ing output devices typically results in different colors.
Xlib also provides a means for clients to specify color
using device-independent color spaces for consistent results
across devices.	 Xlib supports device-independent color spa-
ces derivable from the CIE XYZ color space.  This includes
the CIE XYZ, xyY, L*u*v*, and L*a*b* color spaces as well as
the TekHVC color space.

This chapter discusses how to:

·    Create, copy, and destroy a colormap

·    Specify colors by name or value

·    Allocate, modify, and free color cells

·    Read entries in a colormap

·    Convert between color spaces

·    Control aspects of color conversion

·    Query the color gamut of a screen

·    Add new color spaces

All functions, types, and symbols in this chapter with the
prefix ``Xcms'' are defined in <4mX11/Xcms.h24m>.  The remaining
functions and types are defined in <4mX11/Xlib.h24m>.

Functions in this chapter manipulate the representation of
color on the screen.  For each possible value that a pixel
can take in a window, there is a color cell in the colormap.
For example, if a window is 4 bits deep, pixel values 0
through 15 are defined.	 A colormap is a collection of color
cells.	A color cell consists of a triple of red, green, and
blue (RGB) values.  The hardware imposes limits on the num-
ber of significant bits in these values.  As each pixel is
read out of display memory, the pixel is looked up in a col-
ormap.	The RGB value of the cell determines what color is



			     1m1120m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


displayed on the screen.  On a grayscale display with a
black-and-white monitor, the values are combined to deter-
mine the brightness on the screen.

Typically, an application allocates color cells or sets of
color cells to obtain the desired colors.  The client can
allocate read-only cells.  In which case, the pixel values
for these colors can be shared among multiple applications,
and the RGB value of the cell cannot be changed.  If the
client allocates read/write cells, they are exclusively
owned by the client, and the color associated with the pixel
value can be changed at will.  Cells must be allocated (and,
if read/write, initialized with an RGB value) by a client to
obtain desired colors.	The use of pixel value for an unal-
located cell results in an undefined color.

Because colormaps are associated with windows, X supports
displays with multiple colormaps and, indeed, different
types of colormaps.  If there are insufficient colormap
resources in the display, some windows will display in their
true colors, and others will display with incorrect colors.
A window manager usually controls which windows are dis-
played in their true colors if more than one colormap is
required for the color resources the applications are using.
At any time, there is a set of installed colormaps for a
screen.	 Windows using one of the installed colormaps dis-
play with true colors, and windows using other colormaps
generally display with incorrect colors.  You can control
the set of installed colormaps by using 4mXInstallColormap24m and
4mXUninstallColormap24m.

Colormaps are local to a particular screen.  Screens always
have a default colormap, and programs typically allocate
cells out of this colormap.  Generally, you should not write
applications that monopolize color resources.  Although some
hardware supports multiple colormaps installed at one time,
many of the hardware displays built today support only a
single installed colormap, so the primitives are written to
encourage sharing of colormap entries between applications.

The 4mDefaultColormap24m macro returns the default colormap.  The
4mDefaultVisual24m macro returns the default visual type for the
specified screen.  Possible visual types are 4mStaticGray24m,
4mGrayScale24m, 4mStaticColor24m, 4mPseudoColor24m, 4mTrueColor24m, or 4mDirect-0m
4mColor24m (see section 3.1).

1m6.1.	Color Structures0m

Functions that operate only on RGB color space values use an
4mXColor24m structure, which contains:







			     1m1130m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
typedef struct {
     unsigned long pixel;/* pixel value */
     unsigned short red, green, blue;/* rgb values */
     char flags;	 /* DoRed, DoGreen, DoBlue */
     char pad;
} XColor;

|__

The red, green, and blue values are always in the range 0 to
65535 inclusive, independent of the number of bits actually
used in the display hardware.  The server scales these val-
ues down to the range used by the hardware.  Black is repre-
sented by (0,0,0), and white is represented by
(65535,65535,65535).  In some functions, the flags member
controls which of the red, green, and blue members is used
and can be the inclusive OR of zero or more of 4mDoRed24m,
4mDoGreen24m, and 4mDoBlue24m.


Functions that operate on all color space values use an 4mXcm-0m
4msColor24m structure.	This structure contains a union of sub-
structures, each supporting color specification encoding for
a particular color space.  Like the 4mXColor24m structure, the
4mXcmsColor24m structure contains pixel and color specification
information (the spec member in the 4mXcmsColor24m structure).
__
|

typedef unsigned long XcmsColorFormat;/* Color Specification Format */

typedef struct {
     union {
	  XcmsRGB RGB;
	  XcmsRGBi RGBi;
	  XcmsCIEXYZ CIEXYZ;
	  XcmsCIEuvY CIEuvY;
	  XcmsCIExyY CIExyY;
	  XcmsCIELab CIELab;
	  XcmsCIELuv CIELuv;
	  XcmsTekHVC TekHVC;
	  XcmsPad Pad;
     } spec;
     unsigned long pixel;
     XcmsColorFormat format;
} XcmsColor;		 /* Xcms Color Structure */

|__

Because the color specification can be encoded for the vari-
ous color spaces, encoding for the spec member is identified
by the format member, which is of type 4mXcmsColorFormat24m.  The
following macros define standard formats.



			     1m1140m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
#define	  4mXcmsUndefined-24m	  0x00000000
	  4mFormat0m
#define	  4mXcmsCIEXYZFormat24m	  0x00000001	   /* CIE XYZ */
#define	  4mXcmsCIEuvYFormat24m	  0x00000002	   /* CIE u'v'Y */
#define	  4mXcmsCIExyYFormat24m	  0x00000003	   /* CIE xyY */
#define	  4mXcmsCIELabFormat24m	  0x00000004	   /* CIE L*a*b*
					      */
#define	  4mXcmsCIELuvFormat24m	  0x00000005	   /* CIE L*u*v*
					      */
#define	  4mXcmsTekHVCFormat24m	  0x00000006	   /* TekHVC */
#define	  4mXcmsRGBFormat24m	  0x80000000	   /* RGB Device
					      */
#define	  4mXcmsRGBiFormat24m	  0x80000001	   /* RGB Inten-
					      sity */

|__

Formats for device-independent color spaces are distinguish-
able from those for device-dependent spaces by the 32nd bit.
If this bit is set, it indicates that the color specifica-
tion is in a device-dependent form; otherwise, it is in a
device-independent form.  If the 31st bit is set, this indi-
cates that the color space has been added to Xlib at run
time (see section 6.12.4).  The format value for a color
space added at run time may be different each time the pro-
gram is executed.  If references to such a color space must
be made outside the client (for example, storing a color
specification in a file), then reference should be made by
color space string prefix (see 4mXcmsFormatOfPrefix24m and 4mXcm-0m
4msPrefixOfFormat24m).

Data types that describe the color specification encoding
for the various color spaces are defined as follows:























			     1m1150m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|

typedef double XcmsFloat;

typedef struct {
     unsigned short red; /* 0x0000 to 0xffff */
     unsigned short green;/* 0x0000 to 0xffff */
     unsigned short blue;/* 0x0000 to 0xffff */
} XcmsRGB;		 /* RGB Device */



typedef struct {
     XcmsFloat red;	 /* 0.0 to 1.0 */
     XcmsFloat green;	 /* 0.0 to 1.0 */
     XcmsFloat blue;	 /* 0.0 to 1.0 */
} XcmsRGBi;		 /* RGB Intensity */



typedef struct {
     XcmsFloat X;
     XcmsFloat Y;	 /* 0.0 to 1.0 */
     XcmsFloat Z;
} XcmsCIEXYZ;		 /* CIE XYZ */



typedef struct {
     XcmsFloat u_prime;	 /* 0.0 to ~0.6 */
     XcmsFloat v_prime;	 /* 0.0 to ~0.6 */
     XcmsFloat Y;	 /* 0.0 to 1.0 */
} XcmsCIEuvY;		 /* CIE u'v'Y */



typedef struct {
     XcmsFloat x;	 /* 0.0 to ~.75 */
     XcmsFloat y;	 /* 0.0 to ~.85 */
     XcmsFloat Y;	 /* 0.0 to 1.0 */
} XcmsCIExyY;		 /* CIE xyY */



typedef struct {
     XcmsFloat L_star;	 /* 0.0 to 100.0 */
     XcmsFloat a_star;
     XcmsFloat b_star;
} XcmsCIELab;		 /* CIE L*a*b* */



typedef struct {
     XcmsFloat L_star;	 /* 0.0 to 100.0 */



			     1m1160m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


     XcmsFloat u_star;
     XcmsFloat v_star;
} XcmsCIELuv;		 /* CIE L*u*v* */



typedef struct {
     XcmsFloat H;	 /* 0.0 to 360.0 */
     XcmsFloat V;	 /* 0.0 to 100.0 */
     XcmsFloat C;	 /* 0.0 to 100.0 */
} XcmsTekHVC;		 /* TekHVC */



typedef struct {
     XcmsFloat pad0;
     XcmsFloat pad1;
     XcmsFloat pad2;
     XcmsFloat pad3;
} XcmsPad;		 /* four doubles */

|__

The device-dependent formats provided allow color specifica-
tion in:

·    RGB Intensity (4mXcmsRGBi24m)

     Red, green, and blue linear intensity values, floating-
     point values from 0.0 to 1.0, where 1.0 indicates full
     intensity, 0.5 half intensity, and so on.

·    RGB Device (4mXcmsRGB24m)

     Red, green, and blue values appropriate for the speci-
     fied output device.  4mXcmsRGB24m values are of type
     unsigned short, scaled from 0 to 65535 inclusive, and
     are interchangeable with the red, green, and blue val-
     ues in an 4mXColor24m structure.

It is important to note that RGB Intensity values are not
gamma corrected values.	 In contrast, RGB Device values gen-
erated as a result of converting color specifications are
always gamma corrected, and RGB Device values acquired as a
result of querying a colormap or passed in by the client are
assumed by Xlib to be gamma corrected.	The term 4mRGB24m 4mvalue0m
in this manual always refers to an RGB Device value.

1m6.2.	Color Strings0m

Xlib provides a mechanism for using string names for colors.
A color string may either contain an abstract color name or
a numerical color specification.  Color strings are case-
insensitive.



			     1m1170m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


Color strings are used in the following functions:

·    4mXAllocNamedColor0m

·    4mXcmsAllocNamedColor0m

·    4mXLookupColor0m

·    4mXcmsLookupColor0m

·    4mXParseColor0m

·    4mXStoreNamedColor0m

Xlib supports the use of abstract color names, for example,
red or blue.  A value for this abstract name is obtained by
searching one or more color name databases.  Xlib first
searches zero or more client-side databases; the number,
location, and content of these databases is implementation-
dependent and might depend on the current locale.  If the
name is not found, Xlib then looks for the color in the X
server's database.  If the color name is not in the Host
Portable Character Encoding, the result is implementation-
dependent.

A numerical color specification consists of a color space
name and a set of values in the following syntax:

__
|
4m<color_space_name>24m:4m<value>/.../<value>0m

|__

The following are examples of valid color strings.


"CIEXYZ:0.3227/0.28133/0.2493"
"RGBi:1.0/0.0/0.0"
"rgb:00/ff/00"
"CIELuv:50.0/0.0/0.0"

The syntax and semantics of numerical specifications are
given for each standard color space in the following sec-
tions.

1m6.2.1.  RGB Device String Specification0m

An RGB Device specification is identified by the prefix
``rgb:'' and conforms to the following syntax:


rgb:4m<red>/<green>/<blue>0m




			     1m1180m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


    4m<red>24m, 4m<green>24m, 4m<blue>24m := 4mh24m | 4mhh24m | 4mhhh24m | 4mhhhh0m
    4mh24m := single hexadecimal digits (case insignificant)


Note that 4mh24m indicates the value scaled in 4 bits, 4mhh24m the
value scaled in 8 bits, 4mhhh24m the value scaled in 12 bits, and
4mhhhh24m the value scaled in 16 bits, respectively.

Typical examples are the strings ``rgb:ea/75/52'' and
``rgb:ccc/320/320'', but mixed numbers of hexadecimal digit
strings (``rgb:ff/a5/0'' and ``rgb:ccc/32/0'') are also
allowed.

For backward compatibility, an older syntax for RGB Device
is supported, but its continued use is not encouraged.	The
syntax is an initial sharp sign character followed by a
numeric specification, in one of the following formats:


#RGB		    (4 bits each)
#RRGGBB		    (8 bits each)
#RRRGGGBBB	    (12 bits each)
#RRRRGGGGBBBB	    (16 bits each)


The R, G, and B represent single hexadecimal digits.  When
fewer than 16 bits each are specified, they represent the
most significant bits of the value (unlike the ``rgb:'' syn-
tax, in which values are scaled).  For example, the string
``#3a7'' is the same as ``#3000a0007000''.

1m6.2.2.  RGB Intensity String Specification0m

An RGB intensity specification is identified by the prefix
``rgbi:'' and conforms to the following syntax:


rgbi:4m<red>/<green>/<blue>0m


Note that red, green, and blue are floating-point values
between 0.0 and 1.0, inclusive.	 The input format for these
values is an optional sign, a string of numbers possibly
containing a decimal point, and an optional exponent field
containing an E or e followed by a possibly signed integer
string.

1m6.2.3.  Device-Independent String Specifications0m

The standard device-independent string specifications have
the following syntax:


CIEXYZ:4m<X>/<Y>/<Z>0m



			     1m1190m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


CIEuvY:4m<u>/<v>/<Y>0m
CIExyY:4m<x>/<y>/<Y>0m
CIELab:4m<L>/<a>/<b>0m
CIELuv:4m<L>/<u>/<v>0m
TekHVC:4m<H>/<V>/<C>0m


All of the values (C, H, V, X, Y, Z, a, b, u, v, y, x) are
floating-point values.	The syntax for these values is an
optional plus or minus sign, a string of digits possibly
containing a decimal point, and an optional exponent field
consisting of an ``E'' or ``e'' followed by an optional plus
or minus followed by a string of digits.

1m6.3.	Color Conversion Contexts and Gamut Mapping0m

When Xlib converts device-independent color specifications
into device-dependent specifications and vice versa, it uses
knowledge about the color limitations of the screen hard-
ware.  This information, typically called the device pro-
file, is available in a Color Conversion Context (CCC).

Because a specified color may be outside the color gamut of
the target screen and the white point associated with the
color specification may differ from the white point inherent
to the screen, Xlib applies gamut mapping when it encounters
certain conditions:

·    Gamut compression occurs when conversion of device-
     independent color specifications to device-dependent
     color specifications results in a color out of the tar-
     get screen's gamut.

·    White adjustment occurs when the inherent white point
     of the screen differs from the white point assumed by
     the client.

Gamut handling methods are stored as callbacks in the CCC,
which in turn are used by the color space conversion rou-
tines.	Client data is also stored in the CCC for each call-
back.  The CCC also contains the white point the client
assumes to be associated with color specifications (that is,
the Client White Point).  The client can specify the gamut
handling callbacks and client data as well as the Client
White Point.  Xlib does not preclude the X client from per-
forming other forms of gamut handling (for example, gamut
expansion); however, Xlib does not provide direct support
for gamut handling other than white adjustment and gamut
compression.

Associated with each colormap is an initial CCC transpar-
ently generated by Xlib.  Therefore, when you specify a col-
ormap as an argument to an Xlib function, you are indirectly
specifying a CCC.  There is a default CCC associated with



			     1m1200m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


each screen.  Newly created CCCs inherit attributes from the
default CCC, so the default CCC attributes can be modified
to affect new CCCs.

Xcms functions in which gamut mapping can occur return 4mSta-0m
4mtus24m and have specific status values defined for them, as
follows:

·    4mXcmsFailure24m indicates that the function failed.

·    4mXcmsSuccess24m indicates that the function succeeded.  In
     addition, if the function performed any color conver-
     sion, the colors did not need to be compressed.

·    4mXcmsSuccessWithCompression24m indicates the function per-
     formed color conversion and at least one of the colors
     needed to be compressed.  The gamut compression method
     is determined by the gamut compression procedure in the
     CCC that is specified directly as a function argument
     or in the CCC indirectly specified by means of the col-
     ormap argument.

1m6.4.	Creating, Copying, and Destroying Colormaps0m

To create a colormap for a screen, use 4mXCreateColormap24m.
__
|
Colormap XCreateColormap(4mdisplay24m, 4mw24m, 4mvisual24m, 4malloc24m)
      Display *4mdisplay24m;
      Window 4mw24m;
      Visual *4mvisual24m;
      int 4malloc24m;


4mdisplay24m   Specifies the connection to the X server.

4mw24m	       Specifies the window on whose screen you want to
	  create a colormap.

4mvisual24m    Specifies a visual type supported on the screen.
	  If the visual type is not one supported by the
	  screen, a 4mBadMatch24m error results.

4malloc24m     Specifies the colormap entries to be allocated.
	  You can pass 4mAllocNone24m or 4mAllocAll24m.
|__

The 4mXCreateColormap24m function creates a colormap of the spec-
ified visual type for the screen on which the specified win-
dow resides and returns the colormap ID associated with it.
Note that the specified window is only used to determine the
screen.





			     1m1210m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


The initial values of the colormap entries are undefined for
the visual classes 4mGrayScale24m, 4mPseudoColor24m, and 4mDirectColor24m.
For 4mStaticGray24m, 4mStaticColor24m, and 4mTrueColor24m, the entries have
defined values, but those values are specific to the visual
and are not defined by X.  For 4mStaticGray24m, 4mStaticColor24m, and
4mTrueColor24m, alloc must be 4mAllocNone24m, or a 4mBadMatch24m error
results.  For the other visual classes, if alloc is 4mAlloc-0m
4mNone24m, the colormap initially has no allocated entries, and
clients can allocate them.  For information about the visual
types, see section 3.1.

If alloc is 4mAllocAll24m, the entire colormap is allocated
writable.  The initial values of all allocated entries are
undefined.  For 4mGrayScale24m and 4mPseudoColor24m, the effect is as
if an 4mXAllocColorCells24m call returned all pixel values from
zero to N - 1, where N is the colormap entries value in the
specified visual.  For 4mDirectColor24m, the effect is as if an
4mXAllocColorPlanes24m call returned a pixel value of zero and
red_mask, green_mask, and blue_mask values containing the
same bits as the corresponding masks in the specified
visual.	 However, in all cases, none of these entries can be
freed by using 4mXFreeColors24m.

4mXCreateColormap24m can generate 4mBadAlloc24m, 4mBadMatch24m, 4mBadValue24m,
and 4mBadWindow24m errors.


To create a new colormap when the allocation out of a previ-
ously shared colormap has failed because of resource exhaus-
tion, use 4mXCopyColormapAndFree24m.
__
|
Colormap XCopyColormapAndFree(4mdisplay24m, 4mcolormap24m)
      Display *4mdisplay24m;
      Colormap 4mcolormap24m;


4mdisplay24m   Specifies the connection to the X server.

4mcolormap24m  Specifies the colormap.
|__

The 4mXCopyColormapAndFree24m function creates a colormap of the
same visual type and for the same screen as the specified
colormap and returns the new colormap ID.  It also moves all
of the client's existing allocation from the specified col-
ormap to the new colormap with their color values intact and
their read-only or writable characteristics intact and frees
those entries in the specified colormap.  Color values in
other entries in the new colormap are undefined.  If the
specified colormap was created by the client with alloc set
to 4mAllocAll24m, the new colormap is also created with 4mAllocAll24m,
all color values for all entries are copied from the speci-
fied colormap, and then all entries in the specified



			     1m1220m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


colormap are freed.  If the specified colormap was not cre-
ated by the client with 4mAllocAll24m, the allocations to be
moved are all those pixels and planes that have been allo-
cated by the client using 4mXAllocColor24m, 4mXAllocNamedColor24m,
4mXAllocColorCells24m, or 4mXAllocColorPlanes24m and that have not
been freed since they were allocated.

4mXCopyColormapAndFree24m can generate 4mBadAlloc24m and 4mBadColor0m
errors.


To destroy a colormap, use 4mXFreeColormap24m.
__
|
XFreeColormap(4mdisplay24m, 4mcolormap24m)
      Display *4mdisplay24m;
      Colormap 4mcolormap24m;


4mdisplay24m   Specifies the connection to the X server.

4mcolormap24m  Specifies the colormap that you want to destroy.
|__

The 4mXFreeColormap24m function deletes the association between
the colormap resource ID and the colormap and frees the col-
ormap storage.	However, this function has no effect on the
default colormap for a screen.	If the specified colormap is
an installed map for a screen, it is uninstalled (see 4mXUnin-0m
4mstallColormap24m).  If the specified colormap is defined as the
colormap for a window (by 4mXCreateWindow24m, 4mXSetWindowColormap24m,
or 4mXChangeWindowAttributes24m), 4mXFreeColormap24m changes the col-
ormap associated with the window to 4mNone24m and generates a
4mColormapNotify24m event.  X does not define the colors dis-
played for a window with a colormap of 4mNone24m.

4mXFreeColormap24m can generate a 4mBadColor24m error.

1m6.5.	Mapping Color Names to Values0m


To map a color name to an RGB value, use 4mXLookupColor24m.















			     1m1230m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
Status XLookupColor(4mdisplay24m, 4mcolormap24m, 4mcolor_name24m, 4mexact_def_return24m, 4mscreen_def_return24m)
      Display *4mdisplay24m;
      Colormap 4mcolormap24m;
      char *4mcolor_name24m;
      XColor *4mexact_def_return24m, *4mscreen_def_return24m;


4mdisplay24m   Specifies the connection to the X server.

4mcolormap24m  Specifies the colormap.

4mcolor_name0m
	  Specifies the color name string (for example, red)
	  whose color definition structure you want
	  returned.

4mexact_def_return0m
	  Returns the exact RGB values.

4mscreen_def_return0m
	  Returns the closest RGB values provided by the
	  hardware.
|__

The 4mXLookupColor24m function looks up the string name of a
color with respect to the screen associated with the speci-
fied colormap.	It returns both the exact color values and
the closest values provided by the screen with respect to
the visual type of the specified colormap.  If the color
name is not in the Host Portable Character Encoding, the
result is implementation-dependent.  Use of uppercase or
lowercase does not matter.  4mXLookupColor24m returns nonzero if
the name is resolved; otherwise, it returns zero.

4mXLookupColor24m can generate a 4mBadColor24m error.


To map a color name to the exact RGB value, use 4mXParseColor24m.


















			     1m1240m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
Status XParseColor(4mdisplay24m, 4mcolormap24m, 4mspec24m, 4mexact_def_return24m)
	Display *4mdisplay24m;
	Colormap 4mcolormap24m;
	char *4mspec24m;
	XColor *4mexact_def_return24m;


4mdisplay24m   Specifies the connection to the X server.

4mcolormap24m  Specifies the colormap.

4mspec24m      Specifies the color name string; case is ignored.

4mexact_def_return0m
	  Returns the exact color value for later use and
	  sets the 4mDoRed24m, 4mDoGreen24m, and 4mDoBlue24m flags.
|__

The 4mXParseColor24m function looks up the string name of a color
with respect to the screen associated with the specified
colormap.  It returns the exact color value.  If the color
name is not in the Host Portable Character Encoding, the
result is implementation-dependent.  Use of uppercase or
lowercase does not matter.  4mXParseColor24m returns nonzero if
the name is resolved; otherwise, it returns zero.

4mXParseColor24m can generate a 4mBadColor24m error.


To map a color name to a value in an arbitrary color space,
use 4mXcmsLookupColor24m.

























			     1m1250m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
Status XcmsLookupColor(4mdisplay24m, 4mcolormap24m, 4mcolor_string24m, 4mcolor_exact_return24m, 4mcolor_screen_return24m,
			       4mresult_format24m)
      Display *4mdisplay24m;
      Colormap 4mcolormap24m;
      char *4mcolor_string24m;
      XcmsColor *4mcolor_exact_return24m, *4mcolor_screen_return24m;
      XcmsColorFormat 4mresult_format24m;


4mdisplay24m   Specifies the connection to the X server.

4mcolormap24m  Specifies the colormap.

4mcolor_string0m
	  Specifies the color string.

4mcolor_exact_return0m
	  Returns the color specification parsed from the
	  color string or parsed from the corresponding
	  string found in a color-name database.

4mcolor_screen_return0m
	  Returns the color that can be reproduced on the
	  screen.

4mresult_format0m
	  Specifies the color format for the returned color
	  specifications (color_screen_return and
	  color_exact_return arguments).  If the format is
	  4mXcmsUndefinedFormat24m and the color string contains
	  a numerical color specification, the specification
	  is returned in the format used in that numerical
	  color specification.	If the format is 4mXcmsUnde-0m
	  4mfinedFormat24m and the color string contains a color
	  name, the specification is returned in the format
	  used to store the color in the database.
|__

The 4mXcmsLookupColor24m function looks up the string name of a
color with respect to the screen associated with the speci-
fied colormap.	It returns both the exact color values and
the closest values provided by the screen with respect to
the visual type of the specified colormap.  The values are
returned in the format specified by result_format.  If the
color name is not in the Host Portable Character Encoding,
the result is implementation-dependent.	 Use of uppercase or
lowercase does not matter.  4mXcmsLookupColor24m returns 4mXcmsSuc-0m
4mcess24m or 4mXcmsSuccessWithCompression24m if the name is resolved;
otherwise, it returns 4mXcmsFailure24m.	 If 4mXcmsSuccessWithCom-0m
4mpression24m is returned, the color specification returned in
color_screen_return is the result of gamut compression.





			     1m1260m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


1m6.6.	Allocating and Freeing Color Cells0m

There are two ways of allocating color cells: explicitly as
read-only entries, one pixel value at a time, or read/write,
where you can allocate a number of color cells and planes
simultaneously.	 A read-only cell has its RGB value set by
the server.  Read/write cells do not have defined colors
initially; functions described in the next section must be
used to store values into them.	 Although it is possible for
any client to store values into a read/write cell allocated
by another client, read/write cells normally should be con-
sidered private to the client that allocated them.

Read-only colormap cells are shared among clients.  The
server counts each allocation and freeing of the cell by
clients.  When the last client frees a shared cell, the cell
is finally deallocated.	 If a single client allocates the
same read-only cell multiple times, the server counts each
such allocation, not just the first one.


To allocate a read-only color cell with an RGB value, use
4mXAllocColor24m.
__
|
Status XAllocColor(4mdisplay24m, 4mcolormap24m, 4mscreen_in_out24m)
      Display *4mdisplay24m;
      Colormap 4mcolormap24m;
      XColor *4mscreen_in_out24m;


4mdisplay24m   Specifies the connection to the X server.

4mcolormap24m  Specifies the colormap.

4mscreen_in_out0m
	  Specifies and returns the values actually used in
	  the colormap.
|__

The 4mXAllocColor24m function allocates a read-only colormap
entry corresponding to the closest RGB value supported by
the hardware.  4mXAllocColor24m returns the pixel value of the
color closest to the specified RGB elements supported by the
hardware and returns the RGB value actually used.  The cor-
responding colormap cell is read-only.	In addition, 4mXAlloc-0m
4mColor24m returns nonzero if it succeeded or zero if it failed.
Multiple clients that request the same effective RGB value
can be assigned the same read-only entry, thus allowing
entries to be shared.  When the last client deallocates a
shared cell, it is deallocated.	 4mXAllocColor24m does not use or
affect the flags in the 4mXColor24m structure.





			     1m1270m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


4mXAllocColor24m can generate a 4mBadColor24m error.



To allocate a read-only color cell with a color in arbitrary
format, use 4mXcmsAllocColor24m.
__
|
Status XcmsAllocColor(4mdisplay24m, 4mcolormap24m, 4mcolor_in_out24m, 4mresult_format24m)
      Display *4mdisplay24m;
      Colormap 4mcolormap24m;
      XcmsColor *4mcolor_in_out24m;
      XcmsColorFormat 4mresult_format24m;


4mdisplay24m   Specifies the connection to the X server.

4mcolormap24m  Specifies the colormap.

4mcolor_in_out0m
	  Specifies the color to allocate and returns the
	  pixel and color that is actually used in the col-
	  ormap.

4mresult_format0m
	  Specifies the color format for the returned color
	  specification.
|__

The 4mXcmsAllocColor24m function is similar to 4mXAllocColor24m except
the color can be specified in any format.  The 4mXcmsAlloc-0m
4mColor24m function ultimately calls 4mXAllocColor24m to allocate a
read-only color cell (colormap entry) with the specified
color.	4mXcmsAllocColor24m first converts the color specified to
an RGB value and then passes this to 4mXAllocColor24m.	4mXcmsAl-0m
4mlocColor24m returns the pixel value of the color cell and the
color specification actually allocated.	 This returned color
specification is the result of converting the RGB value
returned by 4mXAllocColor24m into the format specified with the
result_format argument.	 If there is no interest in a
returned color specification, unnecessary computation can be
bypassed if result_format is set to 4mXcmsRGBFormat24m.	 The cor-
responding colormap cell is read-only.	If this routine
returns 4mXcmsFailure24m, the color_in_out color specification is
left unchanged.

4mXcmsAllocColor24m can generate a 4mBadColor24m error.


To allocate a read-only color cell using a color name and
return the closest color supported by the hardware in RGB
format, use 4mXAllocNamedColor24m.





			     1m1280m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
Status XAllocNamedColor(4mdisplay24m, 4mcolormap24m, 4mcolor_name24m, 4mscreen_def_return24m, 4mexact_def_return24m)
      Display *4mdisplay24m;
      Colormap 4mcolormap24m;
      char *4mcolor_name24m;
      XColor *4mscreen_def_return24m, *4mexact_def_return24m;


4mdisplay24m   Specifies the connection to the X server.

4mcolormap24m  Specifies the colormap.

4mcolor_name0m
	  Specifies the color name string (for example, red)
	  whose color definition structure you want
	  returned.

4mscreen_def_return0m
	  Returns the closest RGB values provided by the
	  hardware.

4mexact_def_return0m
	  Returns the exact RGB values.
|__

The 4mXAllocNamedColor24m function looks up the named color with
respect to the screen that is associated with the specified
colormap.  It returns both the exact database definition and
the closest color supported by the screen.  The allocated
color cell is read-only.  The pixel value is returned in
screen_def_return.  If the color name is not in the Host
Portable Character Encoding, the result is implementation-
dependent.  Use of uppercase or lowercase does not matter.
If screen_def_return and exact_def_return point to the same
structure, the pixel field will be set correctly, but the
color values are undefined.  4mXAllocNamedColor24m returns
nonzero if a cell is allocated; otherwise, it returns zero.

4mXAllocNamedColor24m can generate a 4mBadColor24m error.


To allocate a read-only color cell using a color name and
return the closest color supported by the hardware in an
arbitrary format, use 4mXcmsAllocNamedColor24m.













			     1m1290m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
Status XcmsAllocNamedColor(4mdisplay24m, 4mcolormap24m, 4mcolor_string24m, 4mcolor_screen_return24m, 4mcolor_exact_return24m,
			    4mresult_format24m)
      Display *4mdisplay24m;
      Colormap 4mcolormap24m;
      char *4mcolor_string24m;
      XcmsColor *4mcolor_screen_return24m;
      XcmsColor *4mcolor_exact_return24m;
      XcmsColorFormat 4mresult_format24m;


4mdisplay24m   Specifies the connection to the X server.

4mcolormap24m  Specifies the colormap.

4mcolor_string0m
	  Specifies the color string whose color definition
	  structure is to be returned.

4mcolor_screen_return0m
	  Returns the pixel value of the color cell and
	  color specification that actually is stored for
	  that cell.

4mcolor_exact_return0m
	  Returns the color specification parsed from the
	  color string or parsed from the corresponding
	  string found in a color-name database.

4mresult_format0m
	  Specifies the color format for the returned color
	  specifications (color_screen_return and
	  color_exact_return arguments).  If the format is
	  4mXcmsUndefinedFormat24m and the color string contains
	  a numerical color specification, the specification
	  is returned in the format used in that numerical
	  color specification.	If the format is 4mXcmsUnde-0m
	  4mfinedFormat24m and the color string contains a color
	  name, the specification is returned in the format
	  used to store the color in the database.
|__

The 4mXcmsAllocNamedColor24m function is similar to 4mXAllocNamed-0m
4mColor24m except that the color returned can be in any format
specified.  This function ultimately calls 4mXAllocColor24m to
allocate a read-only color cell with the color specified by
a color string.	 The color string is parsed into an 4mXcms-0m
4mColor24m structure (see 4mXcmsLookupColor24m), converted to an RGB
value, and finally passed to 4mXAllocColor24m.	If the color name
is not in the Host Portable Character Encoding, the result
is implementation-dependent.  Use of uppercase or lowercase
does not matter.





			     1m1300m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


This function returns both the color specification as a
result of parsing (exact specification) and the actual color
specification stored (screen specification).  This screen
specification is the result of converting the RGB value
returned by 4mXAllocColor24m into the format specified in
result_format.	If there is no interest in a returned color
specification, unnecessary computation can be bypassed if
result_format is set to 4mXcmsRGBFormat24m.  If
color_screen_return and color_exact_return point to the same
structure, the pixel field will be set correctly, but the
color values are undefined.

4mXcmsAllocNamedColor24m can generate a 4mBadColor24m error.


To allocate read/write color cell and color plane combina-
tions for a 4mPseudoColor24m model, use 4mXAllocColorCells24m.
__
|
Status XAllocColorCells(4mdisplay24m, 4mcolormap24m, 4mcontig24m, 4mplane_masks_return24m, 4mnplanes24m,
			  4mpixels_return24m, 4mnpixels24m)
      Display *4mdisplay24m;
      Colormap 4mcolormap24m;
      Bool 4mcontig24m;
      unsigned long 4mplane_masks_return24m[];
      unsigned int 4mnplanes24m;
      unsigned long 4mpixels_return24m[];
      unsigned int 4mnpixels24m;


4mdisplay24m   Specifies the connection to the X server.

4mcolormap24m  Specifies the colormap.

4mcontig24m    Specifies a Boolean value that indicates whether
	  the planes must be contiguous.

4mplane_mask_return0m
	  Returns an array of plane masks.

4mnplanes24m   Specifies the number of plane masks that are to be
	  returned in the plane masks array.

4mpixels_return0m
	  Returns an array of pixel values.

4mnpixels24m   Specifies the number of pixel values that are to
	  be returned in the pixels_return array.
|__


The 4mXAllocColorCells24m function allocates read/write color
cells.	The number of colors must be positive and the number
of planes nonnegative, or a 4mBadValue24m error results.  If



			     1m1310m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


ncolors and nplanes are requested, then ncolors pixels and
nplane plane masks are returned.  No mask will have any bits
set to 1 in common with any other mask or with any of the
pixels.	 By ORing together each pixel with zero or more
masks, ncolors * 24mnplanes24m distinct pixels can be produced.
All of these are allocated writable by the request.  For
4mGrayScale24m or 4mPseudoColor24m, each mask has exactly one bit set
to 1.  For 4mDirectColor24m, each has exactly three bits set to
1.  If contig is 4mTrue24m and if all masks are ORed together, a
single contiguous set of bits set to 1 will be formed for
4mGrayScale24m or 4mPseudoColor24m and three contiguous sets of bits
set to 1 (one within each pixel subfield) for 4mDirectColor24m.
The RGB values of the allocated entries are undefined.	4mXAl-0m
4mlocColorCells24m returns nonzero if it succeeded or zero if it
failed.

4mXAllocColorCells24m can generate 4mBadColor24m and 4mBadValue24m errors.


To allocate read/write color resources for a 4mDirectColor0m
model, use 4mXAllocColorPlanes24m.




































			     1m1320m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
Status XAllocColorPlanes(4mdisplay24m, 4mcolormap24m, 4mcontig24m, 4mpixels_return24m, 4mncolors24m, 4mnreds24m, 4mngreens24m,
			   4mnblues24m, 4mrmask_return24m, 4mgmask_return24m, 4mbmask_return24m)
      Display *4mdisplay24m;
      Colormap 4mcolormap24m;
      Bool 4mcontig24m;
      unsigned long 4mpixels_return24m[];
      int 4mncolors24m;
      int 4mnreds24m, 4mngreens24m, 4mnblues24m;
      unsigned long *4mrmask_return24m, *4mgmask_return24m, *4mbmask_return24m;


4mdisplay24m   Specifies the connection to the X server.

4mcolormap24m  Specifies the colormap.

4mcontig24m    Specifies a Boolean value that indicates whether
	  the planes must be contiguous.

4mpixels_return0m
	  Returns an array of pixel values.  4mXAllocColor-0m
	  4mPlanes24m returns the pixel values in this array.

4mncolors24m   Specifies the number of pixel values that are to
	  be returned in the pixels_return array.

4mnreds0m
4mngreens0m
4mnblues0m
	  Specify the number of red, green, and blue planes.
	  The value you pass must be nonnegative.

4mrmask_return0m
4mgmask_return0m
4mbmask_return0m
	  Return bit masks for the red, green, and blue
	  planes.
|__


The specified ncolors must be positive; and nreds, ngreens,
and nblues must be nonnegative, or a 4mBadValue24m error results.
If ncolors colors, nreds reds, ngreens greens, and nblues
blues are requested, ncolors pixels are returned; and the
masks have nreds, ngreens, and nblues bits set to 1, respec-
tively.	 If contig is 4mTrue24m, each mask will have a contiguous
set of bits set to 1.  No mask will have any bits set to 1
in common with any other mask or with any of the pixels.
For 4mDirectColor24m, each mask will lie within the corresponding
pixel subfield.	 By ORing together subsets of masks with
each pixel value, ncolors * 2(4mnreds24m+4mngreens24m+4mnblues24m) distinct
pixel values can be produced.  All of these are allocated by
the request.  However, in the colormap, there are only ncol-
ors * 24mnreds24m independent red entries, ncolors * 24mngreens0m



			     1m1330m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


independent green entries, and ncolors * 24mnblues24m independent
blue entries.  This is true even for 4mPseudoColor24m.	When the
colormap entry of a pixel value is changed (using 4mXStoreCol-0m
4mors24m, 4mXStoreColor24m, or 4mXStoreNamedColor24m), the pixel is decom-
posed according to the masks, and the corresponding indepen-
dent entries are updated.  4mXAllocColorPlanes24m returns nonzero
if it succeeded or zero if it failed.

4mXAllocColorPlanes24m can generate 4mBadColor24m and 4mBadValue24m errors.


To free colormap cells, use 4mXFreeColors24m.
__
|
XFreeColors(4mdisplay24m, 4mcolormap24m, 4mpixels24m, 4mnpixels24m, 4mplanes24m)
      Display *4mdisplay24m;
      Colormap 4mcolormap24m;
      unsigned long 4mpixels24m[];
      int 4mnpixels24m;
      unsigned long 4mplanes24m;


4mdisplay24m   Specifies the connection to the X server.

4mcolormap24m  Specifies the colormap.

4mpixels24m    Specifies an array of pixel values that map to the
	  cells in the specified colormap.

4mnpixels24m   Specifies the number of pixels.

4mplanes24m    Specifies the planes you want to free.
|__

The 4mXFreeColors24m function frees the cells represented by pix-
els whose values are in the pixels array.  The planes argu-
ment should not have any bits set to 1 in common with any of
the pixels.  The set of all pixels is produced by ORing
together subsets of the planes argument with the pixels.
The request frees all of these pixels that were allocated by
the client (using 4mXAllocColor24m, 4mXAllocNamedColor24m, 4mXAllocCol-0m
4morCells24m, and 4mXAllocColorPlanes24m).  Note that freeing an indi-
vidual pixel obtained from 4mXAllocColorPlanes24m may not actu-
ally allow it to be reused until all of its related pixels
are also freed.	 Similarly, a read-only entry is not actu-
ally freed until it has been freed by all clients, and if a
client allocates the same read-only entry multiple times, it
must free the entry that many times before the entry is
actually freed.

All specified pixels that are allocated by the client in the
colormap are freed, even if one or more pixels produce an
error.	If a specified pixel is not a valid index into the
colormap, a 4mBadValue24m error results.  If a specified pixel is



			     1m1340m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


not allocated by the client (that is, is unallocated or is
only allocated by another client) or if the colormap was
created with all entries writable (by passing 4mAllocAll24m to
4mXCreateColormap24m), a 4mBadAccess24m error results.	If more than
one pixel is in error, the one that gets reported is arbi-
trary.

4mXFreeColors24m can generate 4mBadAccess24m, 4mBadColor24m, and 4mBadValue0m
errors.

1m6.7.	Modifying and Querying Colormap Cells0m


To store an RGB value in a single colormap cell, use 4mXStore-0m
4mColor24m.
__
|
XStoreColor(4mdisplay24m, 4mcolormap24m, 4mcolor24m)
      Display *4mdisplay24m;
      Colormap 4mcolormap24m;
      XColor *4mcolor24m;


4mdisplay24m   Specifies the connection to the X server.

4mcolormap24m  Specifies the colormap.

4mcolor24m     Specifies the pixel and RGB values.
|__

The 4mXStoreColor24m function changes the colormap entry of the
pixel value specified in the pixel member of the 4mXColor0m
structure.  You specified this value in the pixel member of
the 4mXColor24m structure.  This pixel value must be a read/write
cell and a valid index into the colormap.  If a specified
pixel is not a valid index into the colormap, a 4mBadValue0m
error results.	4mXStoreColor24m also changes the red, green,
and/or blue color components.  You specify which color com-
ponents are to be changed by setting 4mDoRed24m, 4mDoGreen24m, and/or
4mDoBlue24m in the flags member of the 4mXColor24m structure.  If the
colormap is an installed map for its screen, the changes are
visible immediately.

4mXStoreColor24m can generate 4mBadAccess24m, 4mBadColor24m, and 4mBadValue0m
errors.


To store multiple RGB values in multiple colormap cells, use
4mXStoreColors24m.








			     1m1350m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
XStoreColors(4mdisplay24m, 4mcolormap24m, 4mcolor24m, 4mncolors24m)
      Display *4mdisplay24m;
      Colormap 4mcolormap24m;
      XColor 4mcolor24m[];
      int 4mncolors24m;


4mdisplay24m   Specifies the connection to the X server.

4mcolormap24m  Specifies the colormap.

4mcolor24m     Specifies an array of color definition structures
	  to be stored.

4mncolors24m   Specifies the number of 4mXColor24m structures in the
	  color definition array.
|__

The 4mXStoreColors24m function changes the colormap entries of
the pixel values specified in the pixel members of the
4mXColor24m structures.	 You specify which color components are
to be changed by setting 4mDoRed24m, 4mDoGreen24m, and/or 4mDoBlue24m in
the flags member of the 4mXColor24m structures.	 If the colormap
is an installed map for its screen, the changes are visible
immediately.  4mXStoreColors24m changes the specified pixels if
they are allocated writable in the colormap by any client,
even if one or more pixels generates an error.	If a speci-
fied pixel is not a valid index into the colormap, a 4mBad-0m
4mValue24m error results.  If a specified pixel either is unallo-
cated or is allocated read-only, a 4mBadAccess24m error results.
If more than one pixel is in error, the one that gets
reported is arbitrary.

4mXStoreColors24m can generate 4mBadAccess24m, 4mBadColor24m, and 4mBadValue0m
errors.


To store a color of arbitrary format in a single colormap
cell, use 4mXcmsStoreColor24m.

















			     1m1360m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
Status XcmsStoreColor(4mdisplay24m, 4mcolormap24m, 4mcolor24m)
      Display *4mdisplay24m;
      Colormap 4mcolormap24m;
      XcmsColor *4mcolor24m;


4mdisplay24m   Specifies the connection to the X server.

4mcolormap24m  Specifies the colormap.

4mcolor24m     Specifies the color cell and the color to store.
	  Values specified in this 4mXcmsColor24m structure
	  remain unchanged on return.
|__

The 4mXcmsStoreColor24m function converts the color specified in
the 4mXcmsColor24m structure into RGB values.  It then uses this
RGB specification in an 4mXColor24m structure, whose three flags
(4mDoRed24m, 4mDoGreen24m, and 4mDoBlue24m) are set, in a call to 4mXStore-0m
4mColor24m to change the color cell specified by the pixel member
of the 4mXcmsColor24m structure.  This pixel value must be a
valid index for the specified colormap, and the color cell
specified by the pixel value must be a read/write cell.	 If
the pixel value is not a valid index, a 4mBadValue24m error
results.  If the color cell is unallocated or is allocated
read-only, a 4mBadAccess24m error results.  If the colormap is an
installed map for its screen, the changes are visible imme-
diately.

Note that 4mXStoreColor24m has no return value; therefore, an
4mXcmsSuccess24m return value from this function indicates that
the conversion to RGB succeeded and the call to 4mXStoreColor0m
was made.  To obtain the actual color stored, use 4mXcmsQuery-0m
4mColor24m.  Because of the screen's hardware limitations or
gamut compression, the color stored in the colormap may not
be identical to the color specified.

4mXcmsStoreColor24m can generate 4mBadAccess24m, 4mBadColor24m, and 4mBad-0m
4mValue24m errors.


To store multiple colors of arbitrary format in multiple
colormap cells, use 4mXcmsStoreColors24m.













			     1m1370m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
Status XcmsStoreColors(4mdisplay24m, 4mcolormap24m, 4mcolors24m, 4mncolors24m, 4mcompression_flags_return24m)
      Display *4mdisplay24m;
      Colormap 4mcolormap24m;
      XcmsColor 4mcolors24m[];
      int 4mncolors24m;
      Bool 4mcompression_flags_return24m[];


4mdisplay24m   Specifies the connection to the X server.

4mcolormap24m  Specifies the colormap.

4mcolors24m    Specifies the color specification array of 4mXcms-0m
	  4mColor24m structures, each specifying a color cell and
	  the color to store in that cell.  Values specified
	  in the array remain unchanged upon return.

4mncolors24m   Specifies the number of 4mXcmsColor24m structures in
	  the color-specification array.

4mcompression_flags_return0m
	  Returns an array of Boolean values indicating com-
	  pression status.  If a non-NULL pointer is sup-
	  plied, each element of the array is set to 4mTrue24m if
	  the corresponding color was compressed and 4mFalse0m
	  otherwise.  Pass NULL if the compression status is
	  not useful.
|__

The 4mXcmsStoreColors24m function converts the colors specified
in the array of 4mXcmsColor24m structures into RGB values and
then uses these RGB specifications in 4mXColor24m structures,
whose three flags (4mDoRed24m, 4mDoGreen24m, and 4mDoBlue24m) are set, in a
call to 4mXStoreColors24m to change the color cells specified by
the pixel member of the corresponding 4mXcmsColor24m structure.
Each pixel value must be a valid index for the specified
colormap, and the color cell specified by each pixel value
must be a read/write cell.  If a pixel value is not a valid
index, a 4mBadValue24m error results.  If a color cell is unallo-
cated or is allocated read-only, a 4mBadAccess24m error results.
If more than one pixel is in error, the one that gets
reported is arbitrary.	If the colormap is an installed map
for its screen, the changes are visible immediately.

Note that 4mXStoreColors24m has no return value; therefore, an
4mXcmsSuccess24m return value from this function indicates that
conversions to RGB succeeded and the call to 4mXStoreColors0m
was made.  To obtain the actual colors stored, use 4mXcms-0m
4mQueryColors24m.  Because of the screen's hardware limitations
or gamut compression, the colors stored in the colormap may
not be identical to the colors specified.





			     1m1380m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


4mXcmsStoreColors24m can generate 4mBadAccess24m, 4mBadColor24m, and 4mBad-0m
4mValue24m errors.


To store a color specified by name in a single colormap
cell, use 4mXStoreNamedColor24m.
__
|
XStoreNamedColor(4mdisplay24m, 4mcolormap24m, 4mcolor24m, 4mpixel24m, 4mflags24m)
      Display *4mdisplay24m;
      Colormap 4mcolormap24m;
      char *4mcolor24m;
      unsigned long 4mpixel24m;
      int 4mflags24m;


4mdisplay24m   Specifies the connection to the X server.

4mcolormap24m  Specifies the colormap.

4mcolor24m     Specifies the color name string (for example,
	  red).

4mpixel24m     Specifies the entry in the colormap.

4mflags24m     Specifies which red, green, and blue components
	  are set.
|__

The 4mXStoreNamedColor24m function looks up the named color with
respect to the screen associated with the colormap and
stores the result in the specified colormap.  The pixel
argument determines the entry in the colormap.	The flags
argument determines which of the red, green, and blue compo-
nents are set.	You can set this member to the bitwise
inclusive OR of the bits 4mDoRed24m, 4mDoGreen24m, and 4mDoBlue24m.  If the
color name is not in the Host Portable Character Encoding,
the result is implementation-dependent.	 Use of uppercase or
lowercase does not matter.  If the specified pixel is not a
valid index into the colormap, a 4mBadValue24m error results.  If
the specified pixel either is unallocated or is allocated
read-only, a 4mBadAccess24m error results.

4mXStoreNamedColor24m can generate 4mBadAccess24m, 4mBadColor24m, 4mBadName24m,
and 4mBadValue24m errors.

The 4mXQueryColor24m and 4mXQueryColors24m functions take pixel values
in the pixel member of 4mXColor24m structures and store in the
structures the RGB values for those pixels from the speci-
fied colormap.	The values returned for an unallocated entry
are undefined.	These functions also set the flags member in
the 4mXColor24m structure to all three colors.	If a pixel is not
a valid index into the specified colormap, a 4mBadValue24m error
results.  If more than one pixel is in error, the one that



			     1m1390m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


gets reported is arbitrary.


To query the RGB value of a single colormap cell, use
4mXQueryColor24m.
__
|
XQueryColor(4mdisplay24m, 4mcolormap24m, 4mdef_in_out24m)
      Display *4mdisplay24m;
      Colormap 4mcolormap24m;
      XColor *4mdef_in_out24m;


4mdisplay24m   Specifies the connection to the X server.

4mcolormap24m  Specifies the colormap.

4mdef_in_out0m
	  Specifies and returns the RGB values for the pixel
	  specified in the structure.
|__

The 4mXQueryColor24m function returns the current RGB value for
the pixel in the 4mXColor24m structure and sets the 4mDoRed24m,
4mDoGreen24m, and 4mDoBlue24m flags.

4mXQueryColor24m can generate 4mBadColor24m and 4mBadValue24m errors.


To query the RGB values of multiple colormap cells, use
4mXQueryColors24m.
__
|
XQueryColors(4mdisplay24m, 4mcolormap24m, 4mdefs_in_out24m, 4mncolors24m)
      Display *4mdisplay24m;
      Colormap 4mcolormap24m;
      XColor 4mdefs_in_out24m[];
      int 4mncolors24m;


4mdisplay24m   Specifies the connection to the X server.

4mcolormap24m  Specifies the colormap.

4mdefs_in_out0m
	  Specifies and returns an array of color definition
	  structures for the pixel specified in the struc-
	  ture.

4mncolors24m   Specifies the number of 4mXColor24m structures in the
	  color definition array.
|__

The 4mXQueryColors24m function returns the RGB value for each



			     1m1400m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


pixel in each 4mXColor24m structure and sets the 4mDoRed24m, 4mDoGreen24m,
and 4mDoBlue24m flags in each structure.


4mXQueryColors24m can generate 4mBadColor24m and 4mBadValue24m errors.


To query the color of a single colormap cell in an arbitrary
format, use 4mXcmsQueryColor24m.
__
|
Status XcmsQueryColor(4mdisplay24m, 4mcolormap24m, 4mcolor_in_out24m, 4mresult_format24m)
      Display *4mdisplay24m;
      Colormap 4mcolormap24m;
      XcmsColor *4mcolor_in_out24m;
      XcmsColorFormat 4mresult_format24m;


4mdisplay24m   Specifies the connection to the X server.

4mcolormap24m  Specifies the colormap.

4mcolor_in_out0m
	  Specifies the pixel member that indicates the
	  color cell to query.	The color specification
	  stored for the color cell is returned in this 4mXcm-0m
	  4msColor24m structure.

4mresult_format0m
	  Specifies the color format for the returned color
	  specification.
|__

The 4mXcmsQueryColor24m function obtains the RGB value for the
pixel value in the pixel member of the specified 4mXcmsColor0m
structure and then converts the value to the target format
as specified by the result_format argument.  If the pixel is
not a valid index in the specified colormap, a 4mBadValue0m
error results.

4mXcmsQueryColor24m can generate 4mBadColor24m and 4mBadValue24m errors.


To query the color of multiple colormap cells in an arbi-
trary format, use 4mXcmsQueryColors24m.












			     1m1410m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
Status XcmsQueryColors(4mdisplay24m, 4mcolormap24m, 4mcolors_in_out24m, 4mncolors24m, 4mresult_format24m)
      Display *4mdisplay24m;
      Colormap 4mcolormap24m;
      XcmsColor 4mcolors_in_out24m[];
      unsigned int 4mncolors24m;
      XcmsColorFormat 4mresult_format24m;


4mdisplay24m   Specifies the connection to the X server.

4mcolormap24m  Specifies the colormap.

4mcolors_in_out0m
	  Specifies an array of 4mXcmsColor24m structures, each
	  pixel member indicating the color cell to query.
	  The color specifications for the color cells are
	  returned in these structures.

4mncolors24m   Specifies the number of 4mXcmsColor24m structures in
	  the color-specification array.

4mresult_format0m
	  Specifies the color format for the returned color
	  specification.
|__

The 4mXcmsQueryColors24m function obtains the RGB values for
pixel values in the pixel members of 4mXcmsColor24m structures
and then converts the values to the target format as speci-
fied by the result_format argument.  If a pixel is not a
valid index into the specified colormap, a 4mBadValue24m error
results.  If more than one pixel is in error, the one that
gets reported is arbitrary.

4mXcmsQueryColors24m can generate 4mBadColor24m and 4mBadValue24m errors.

1m6.8.	Color Conversion Context Functions0m

This section describes functions to create, modify, and
query Color Conversion Contexts (CCCs).

Associated with each colormap is an initial CCC transpar-
ently generated by Xlib.  Therefore, when you specify a col-
ormap as an argument to a function, you are indirectly spec-
ifying a CCC.  The CCC attributes that can be modified by
the X client are:

·    Client White Point

·    Gamut compression procedure and client data

·    White point adjustment procedure and client data




			     1m1420m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


The initial values for these attributes are implementation
specific.  The CCC attributes for subsequently created CCCs
can be defined by changing the CCC attributes of the default
CCC.  There is a default CCC associated with each screen.

1m6.8.1.  Getting and Setting the Color Conversion Context of0m
1ma Colormap0m


To obtain the CCC associated with a colormap, use 4mXcmsCCCOf-0m
4mColormap24m.
__
|
XcmsCCC XcmsCCCOfColormap(4mdisplay24m, 4mcolormap24m)
      Display *4mdisplay24m;
      Colormap 4mcolormap24m;


4mdisplay24m   Specifies the connection to the X server.

4mcolormap24m  Specifies the colormap.
|__

The 4mXcmsCCCOfColormap24m function returns the CCC associated
with the specified colormap.  Once obtained, the CCC
attributes can be queried or modified.	Unless the CCC asso-
ciated with the specified colormap is changed with 4mXcmsSetC-0m
4mCCOfColormap24m, this CCC is used when the specified colormap
is used as an argument to color functions.


To change the CCC associated with a colormap, use 4mXcmsSetCC-0m
4mCOfColormap24m.
__
|
XcmsCCC XcmsSetCCCOfColormap(4mdisplay24m, 4mcolormap24m, 4mccc24m)
      Display *4mdisplay24m;
      Colormap 4mcolormap24m;
      XcmsCCC 4mccc24m;


4mdisplay24m   Specifies the connection to the X server.

4mcolormap24m  Specifies the colormap.

4mccc24m       Specifies the CCC.
|__

The 4mXcmsSetCCCOfColormap24m function changes the CCC associated
with the specified colormap.  It returns the CCC previously
associated with the colormap.  If they are not used again in
the application, CCCs should be freed by calling 4mXcms-0m
4mFreeCCC24m.  Several colormaps may share the same CCC without
restriction; this includes the CCCs generated by Xlib with



			     1m1430m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


each colormap.	Xlib, however, creates a new CCC with each
new colormap.

1m6.8.2.  Obtaining the Default Color Conversion Context0m

You can change the default CCC attributes for subsequently
created CCCs by changing the CCC attributes of the default
CCC.  A default CCC is associated with each screen.


To obtain the default CCC for a screen, use 4mXcmsDefaultCCC24m.
__
|
XcmsCCC XcmsDefaultCCC(4mdisplay24m, 4mscreen_number24m)
      Display *4mdisplay24m;
      int 4mscreen_number24m;


4mdisplay24m   Specifies the connection to the X server.

4mscreen_number0m
	  Specifies the appropriate screen number on the
	  host server.
|__

The 4mXcmsDefaultCCC24m function returns the default CCC for the
specified screen.  Its visual is the default visual of the
screen.	 Its initial gamut compression and white point
adjustment procedures as well as the associated client data
are implementation specific.

1m6.8.3.  Color Conversion Context Macros0m

Applications should not directly modify any part of the 4mXcm-0m
4msCCC24m.  The following lists the C language macros, their cor-
responding function equivalents for other language bindings,
and what data they both can return.


__
|
DisplayOfCCC(4mccc24m)
     XcmsCCC 4mccc24m;

Display *XcmsDisplayOfCCC(4mccc24m)
     XcmsCCC 4mccc24m;


4mccc24m       Specifies the CCC.
|__

Both return the display associated with the specified CCC.





			     1m1440m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
VisualOfCCC(4mccc24m)
     XcmsCCC 4mccc24m;

Visual *XcmsVisualOfCCC(4mccc24m)
     XcmsCCC 4mccc24m;


4mccc24m       Specifies the CCC.
|__

Both return the visual associated with the specified CCC.


__
|
ScreenNumberOfCCC(4mccc24m)
     XcmsCCC 4mccc24m;

int XcmsScreenNumberOfCCC(4mccc24m)
     XcmsCCC 4mccc24m;


4mccc24m       Specifies the CCC.
|__

Both return the number of the screen associated with the
specified CCC.


__
|
ScreenWhitePointOfCCC(4mccc24m)
     XcmsCCC 4mccc24m;

XcmsColor *XcmsScreenWhitePointOfCCC(4mccc24m)
     XcmsCCC 4mccc24m;


4mccc24m       Specifies the CCC.
|__

Both return the white point of the screen associated with
the specified CCC.













			     1m1450m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
ClientWhitePointOfCCC(4mccc24m)
     XcmsCCC 4mccc24m;

XcmsColor *XcmsClientWhitePointOfCCC(4mccc24m)
     XcmsCCC 4mccc24m;


4mccc24m       Specifies the CCC.
|__

Both return the Client White Point of the specified CCC.

1m6.8.4.  Modifying Attributes of a Color Conversion Context0m

To set the Client White Point in the CCC, use 4mXcmsSetWhite-0m
4mPoint24m.
__
|
Status XcmsSetWhitePoint(4mccc24m, 4mcolor24m)
      XcmsCCC 4mccc24m;
      XcmsColor *4mcolor24m;


4mccc24m       Specifies the CCC.

4mcolor24m     Specifies the new Client White Point.
|__

The 4mXcmsSetWhitePoint24m function changes the Client White
Point in the specified CCC.  Note that the pixel member is
ignored and that the color specification is left unchanged
upon return.  The format for the new white point must be
4mXcmsCIEXYZFormat24m, 4mXcmsCIEuvYFormat24m, 4mXcmsCIExyYFormat24m, or
4mXcmsUndefinedFormat24m.  If the color argument is NULL, this
function sets the format component of the Client White Point
specification to 4mXcmsUndefinedFormat24m, indicating that the
Client White Point is assumed to be the same as the Screen
White Point.

This function returns nonzero status if the format for the
new white point is valid; otherwise, it returns zero.



To set the gamut compression procedure and corresponding
client data in a specified CCC, use 4mXcmsSetCompressionProc24m.










			     1m1460m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
XcmsCompressionProc XcmsSetCompressionProc(4mccc24m, 4mcompression_proc24m, 4mclient_data24m)
      XcmsCCC 4mccc24m;
      XcmsCompressionProc 4mcompression_proc24m;
      XPointer 4mclient_data24m;


4mccc24m       Specifies the CCC.

4mcompression_proc0m
	  Specifies the gamut compression procedure that is
	  to be applied when a color lies outside the
	  screen's color gamut.	 If NULL is specified and a
	  function using this CCC must convert a color spec-
	  ification to a device-dependent format and encoun-
	  ters a color that lies outside the screen's color
	  gamut, that function will return 4mXcmsFailure24m.

4mclient_data0m
	  Specifies client data for the gamut compression
	  procedure or NULL.
|__

The 4mXcmsSetCompressionProc24m function first sets the gamut
compression procedure and client data in the specified CCC
with the newly specified procedure and client data and then
returns the old procedure.


To set the white point adjustment procedure and correspond-
ing client data in a specified CCC, use 4mXcmsSetWhiteAdjust-0m
4mProc24m.

__
|    XcmsWhiteAdjustProc XcmsSetWhiteAdjustProc(4mccc24m, 4mwhite_adjust_proc24m, 4mclient_data24m)
      XcmsCCC 4mccc24m;
      XcmsWhiteAdjustProc 4mwhite_adjust_proc24m;
      XPointer 4mclient_data24m;


4mccc24m       Specifies the CCC.

4mwhite_adjust_proc0m
	  Specifies the white point adjustment procedure.

4mclient_data0m
	  Specifies client data for the white point adjust-
	  ment procedure or NULL.
|__

The 4mXcmsSetWhiteAdjustProc24m function first sets the white
point adjustment procedure and client data in the specified
CCC with the newly specified procedure and client data and
then returns the old procedure.



			     1m1470m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


1m6.8.5.  Creating and Freeing a Color Conversion Context0m

You can explicitly create a CCC within your application by
calling 4mXcmsCreateCCC24m.  These created CCCs can then be used
by those functions that explicitly call for a CCC argument.
Old CCCs that will not be used by the application should be
freed using 4mXcmsFreeCCC24m.


To create a CCC, use 4mXcmsCreateCCC24m.















































			     1m1480m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
XcmsCCC XcmsCreateCCC(4mdisplay24m, 4mscreen_number24m, 4mvisual24m, 4mclient_white_point24m, 4mcompression_proc24m,
		    4mcompression_client_data24m, 4mwhite_adjust_proc24m, 4mwhite_adjust_client_data24m)
      Display *4mdisplay24m;
      int 4mscreen_number24m;
      Visual *4mvisual24m;
      XcmsColor *4mclient_white_point24m;
      XcmsCompressionProc 4mcompression_proc24m;
      XPointer 4mcompression_client_data24m;
      XcmsWhiteAdjustProc 4mwhite_adjust_proc24m;
      XPointer 4mwhite_adjust_client_data24m;


4mdisplay24m   Specifies the connection to the X server.

4mscreen_number0m
	  Specifies the appropriate screen number on the
	  host server.

4mvisual24m    Specifies the visual type.

4mclient_white_point0m
	  Specifies the Client White Point.  If NULL is
	  specified, the Client White Point is to be assumed
	  to be the same as the Screen White Point.  Note
	  that the pixel member is ignored.

4mcompression_proc0m
	  Specifies the gamut compression procedure that is
	  to be applied when a color lies outside the
	  screen's color gamut.	 If NULL is specified and a
	  function using this CCC must convert a color spec-
	  ification to a device-dependent format and encoun-
	  ters a color that lies outside the screen's color
	  gamut, that function will return 4mXcmsFailure24m.

4mcompression_client_data0m
	  Specifies client data for use by the gamut com-
	  pression procedure or NULL.

4mwhite_adjust_proc0m
	  Specifies the white adjustment procedure that is
	  to be applied when the Client White Point differs
	  from the Screen White Point.	NULL indicates that
	  no white point adjustment is desired.

4mwhite_adjust_client_data0m
	  Specifies client data for use with the white point
	  adjustment procedure or NULL.
|__

The 4mXcmsCreateCCC24m function creates a CCC for the specified
display, screen, and visual.




			     1m1490m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


To free a CCC, use 4mXcmsFreeCCC24m.
__
|
void XcmsFreeCCC(4mccc24m)
      XcmsCCC 4mccc24m;


4mccc24m       Specifies the CCC.
|__

The 4mXcmsFreeCCC24m function frees the memory used for the spec-
ified CCC.  Note that default CCCs and those currently asso-
ciated with colormaps are ignored.

1m6.9.	Converting between Color Spaces0m


To convert an array of color specifications in arbitrary
color formats to a single destination format, use 4mXcmsCon-0m
4mvertColors24m.





































			     1m1500m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
Status XcmsConvertColors(4mccc24m, 4mcolors_in_out24m, 4mncolors24m, 4mtarget_format24m, 4mcompression_flags_return24m)
      XcmsCCC 4mccc24m;
      XcmsColor 4mcolors_in_out24m[];
      unsigned int 4mncolors24m;
      XcmsColorFormat 4mtarget_format24m;
      Bool 4mcompression_flags_return24m[];


4mccc24m       Specifies the CCC.  If conversion is between
	  device-independent color spaces only (for example,
	  TekHVC to CIELuv), the CCC is necessary only to
	  specify the Client White Point.

4mcolors_in_out0m
	  Specifies an array of color specifications.  Pixel
	  members are ignored and remain unchanged upon
	  return.

4mncolors24m   Specifies the number of 4mXcmsColor24m structures in
	  the color-specification array.

4mtarget_format0m
	  Specifies the target color specification format.

4mcompression_flags_return0m
	  Returns an array of Boolean values indicating com-
	  pression status.  If a non-NULL pointer is sup-
	  plied, each element of the array is set to 4mTrue24m if
	  the corresponding color was compressed and 4mFalse0m
	  otherwise.  Pass NULL if the compression status is
	  not useful.
|__

The 4mXcmsConvertColors24m function converts the color specifica-
tions in the specified array of 4mXcmsColor24m structures from
their current format to a single target format, using the
specified CCC.	When the return value is 4mXcmsFailure24m, the
contents of the color specification array are left
unchanged.

The array may contain a mixture of color specification for-
mats (for example, 3 CIE XYZ, 2 CIE Luv, and so on).  When
the array contains both device-independent and device-depen-
dent color specifications and the target_format argument
specifies a device-dependent format (for example, 4mXcmsRGBi-0m
4mFormat24m, 4mXcmsRGBFormat24m), all specifications are converted to
CIE XYZ format and then to the target device-dependent for-
mat.

1m6.10.	 Callback Functions0m

This section describes the gamut compression and white point
adjustment callbacks.



			     1m1510m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


The gamut compression procedure specified in the CCC is
called when an attempt to convert a color specification from
4mXcmsCIEXYZ24m to a device-dependent format (typically 4mXcmsRGBi24m)
results in a color that lies outside the screen's color
gamut.	If the gamut compression procedure requires client
data, this data is passed via the gamut compression client
data in the CCC.

During color specification conversion between device-inde-
pendent and device-dependent color spaces, if a white point
adjustment procedure is specified in the CCC, it is trig-
gered when the Client White Point and Screen White Point
differ.	 If required, the client data is obtained from the
CCC.

1m6.10.1.  Prototype Gamut Compression Procedure0m

The gamut compression callback interface must adhere to the
following:






































			     1m1520m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
typedef Status (*XcmsCompressionProc)(4mccc24m, 4mcolors_in_out24m, 4mncolors24m, 4mindex24m, 4mcompression_flags_return24m)
      XcmsCCC 4mccc24m;
      XcmsColor 4mcolors_in_out[]24m;
      unsigned int 4mncolors24m;
      unsigned int 4mindex24m;
      Bool 4mcompression_flags_return[]24m;


4mccc24m       Specifies the CCC.

4mcolors_in_out0m
	  Specifies an array of color specifications.  Pixel
	  members should be ignored and must remain
	  unchanged upon return.

4mncolors24m   Specifies the number of 4mXcmsColor24m structures in
	  the color-specification array.

4mindex24m     Specifies the index into the array of 4mXcmsColor0m
	  structures for the encountered color specification
	  that lies outside the screen's color gamut.  Valid
	  values are 0 (for the first element) to ncolors -
	  1.

4mcompression_flags_return0m
	  Returns an array of Boolean values for indicating
	  compression status.  If a non-NULL pointer is sup-
	  plied and a color at a given index is compressed,
	  then 4mTrue24m should be stored at the corresponding
	  index in this array; otherwise, the array should
	  not be modified.
|__

When implementing a gamut compression procedure, consider
the following rules and assumptions:

·    The gamut compression procedure can attempt to compress
     one or multiple specifications at a time.

·    When called, elements 0 to index - 1 in the color spec-
     ification array can be assumed to fall within the
     screen's color gamut.  In addition, these color speci-
     fications are already in some device-dependent format
     (typically 4mXcmsRGBi24m).	 If any modifications are made to
     these color specifications, they must be in their ini-
     tial device-dependent format upon return.

·    When called, the element in the color specification
     array specified by the index argument contains the
     color specification outside the screen's color gamut
     encountered by the calling routine.  In addition, this
     color specification can be assumed to be in 4mXcmsCIEXYZ24m.
     Upon return, this color specification must be in



			     1m1530m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


     4mXcmsCIEXYZ24m.

·    When called, elements from index to ncolors - 1 in the
     color specification array may or may not fall within
     the screen's color gamut.	In addition, these color
     specifications can be assumed to be in 4mXcmsCIEXYZ24m.  If
     any modifications are made to these color specifica-
     tions, they must be in 4mXcmsCIEXYZ24m upon return.

·    The color specifications passed to the gamut compres-
     sion procedure have already been adjusted to the Screen
     White Point.  This means that at this point the color
     specification's white point is the Screen White Point.

·    If the gamut compression procedure uses a device-inde-
     pendent color space not initially accessible for use in
     the color management system, use 4mXcmsAddColorSpace24m to
     ensure that it is added.

1m6.10.2.  Supplied Gamut Compression Procedures0m

The following equations are useful in describing gamut com-
pression functions:



4mCIELabPsychometricChroma24m=4msqrt24m(4ma24m_4mstar24m2+4mb24m_4mstar24m2)

4mCIELabPsychometricHue24m=tan-1[4m_24m4m_____24m]

4mCIELuvPsychometricChroma24m=4msqrt24m(4mu24m_4mstar24m2+4mv24m_4mstar24m2)

4mCIELuvPsychometricHue24m=tan-1[4m_24m4m_____24m]


The gamut compression callback procedures provided by Xlib
are as follows:

·    4mXcmsCIELabClipL0m

     This brings the encountered out-of-gamut color specifi-
     cation into the screen's color gamut by reducing or
     increasing CIE metric lightness (L*) in the CIE L*a*b*
     color space until the color is within the gamut.  If
     the Psychometric Chroma of the color specification is
     beyond maximum for the Psychometric Hue Angle, then
     while maintaining the same Psychometric Hue Angle, the
     color will be clipped to the CIE L*a*b* coordinates of
     maximum Psychometric Chroma.  See 4mXcmsCIELabQueryMaxC24m.
     No client data is necessary.

·    4mXcmsCIELabClipab0m





			     1m1540m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


     This brings the encountered out-of-gamut color specifi-
     cation into the screen's color gamut by reducing Psy-
     chometric Chroma, while maintaining Psychometric Hue
     Angle, until the color is within the gamut.  No client
     data is necessary.

·    4mXcmsCIELabClipLab0m

     This brings the encountered out-of-gamut color specifi-
     cation into the screen's color gamut by replacing it
     with CIE L*a*b* coordinates that fall within the color
     gamut while maintaining the original Psychometric Hue
     Angle and whose vector to the original coordinates is
     the shortest attainable.  No client data is necessary.

·    4mXcmsCIELuvClipL0m

     This brings the encountered out-of-gamut color specifi-
     cation into the screen's color gamut by reducing or
     increasing CIE metric lightness (L*) in the CIE L*u*v*
     color space until the color is within the gamut.  If
     the Psychometric Chroma of the color specification is
     beyond maximum for the Psychometric Hue Angle, then,
     while maintaining the same Psychometric Hue Angle, the
     color will be clipped to the CIE L*u*v* coordinates of
     maximum Psychometric Chroma.  See 4mXcmsCIELuvQueryMaxC24m.
     No client data is necessary.

·    4mXcmsCIELuvClipuv0m

     This brings the encountered out-of-gamut color specifi-
     cation into the screen's color gamut by reducing Psy-
     chometric Chroma, while maintaining Psychometric Hue
     Angle, until the color is within the gamut.  No client
     data is necessary.

·    4mXcmsCIELuvClipLuv0m

     This brings the encountered out-of-gamut color specifi-
     cation into the screen's color gamut by replacing it
     with CIE L*u*v* coordinates that fall within the color
     gamut while maintaining the original Psychometric Hue
     Angle and whose vector to the original coordinates is
     the shortest attainable.  No client data is necessary.

·    4mXcmsTekHVCClipV0m

     This brings the encountered out-of-gamut color specifi-
     cation into the screen's color gamut by reducing or
     increasing the Value dimension in the TekHVC color
     space until the color is within the gamut.	 If Chroma
     of the color specification is beyond maximum for the
     particular Hue, then, while maintaining the same Hue,
     the color will be clipped to the Value and Chroma



			     1m1550m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


     coordinates that represent maximum Chroma for that par-
     ticular Hue.  No client data is necessary.

·    4mXcmsTekHVCClipC0m

     This brings the encountered out-of-gamut color specifi-
     cation into the screen's color gamut by reducing the
     Chroma dimension in the TekHVC color space until the
     color is within the gamut.	 No client data is neces-
     sary.

·    4mXcmsTekHVCClipVC0m

     This brings the encountered out-of-gamut color specifi-
     cation into the screen's color gamut by replacing it
     with TekHVC coordinates that fall within the color
     gamut while maintaining the original Hue and whose vec-
     tor to the original coordinates is the shortest attain-
     able.  No client data is necessary.

1m6.10.3.  Prototype White Point Adjustment Procedure0m

The white point adjustment procedure interface must adhere
to the following:

































			     1m1560m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
typedef Status (*XcmsWhiteAdjustProc)(4mccc24m, 4minitial_white_point24m, 4mtarget_white_point24m, 4mtarget_format24m,
		4mcolors_in_out24m, 4mncolors24m, 4mcompression_flags_return24m)
       XcmsCCC 4mccc24m;
       XcmsColor *4minitial_white_point24m;
       XcmsColor *4mtarget_white_point24m;
       XcmsColorFormat 4mtarget_format24m;
       XcmsColor 4mcolors_in_out[]24m;
       unsigned int 4mncolors24m;
       Bool 4mcompression_flags_return[]24m;


4mccc24m       Specifies the CCC.

4minitial_white_point0m
	  Specifies the initial white point.

4mtarget_white_point0m
	  Specifies the target white point.

4mtarget_format0m
	  Specifies the target color specification format.

4mcolors_in_out0m
	  Specifies an array of color specifications.  Pixel
	  members should be ignored and must remain
	  unchanged upon return.

4mncolors24m   Specifies the number of 4mXcmsColor24m structures in
	  the color-specification array.

4mcompression_flags_return0m
	  Returns an array of Boolean values for indicating
	  compression status.  If a non-NULL pointer is sup-
	  plied and a color at a given index is compressed,
	  then 4mTrue24m should be stored at the corresponding
	  index in this array; otherwise, the array should
	  not be modified.
|__


1m6.10.4.  Supplied White Point Adjustment Procedures0m

White point adjustment procedures provided by Xlib are as
follows:

·    4mXcmsCIELabWhiteShiftColors0m

     This uses the CIE L*a*b* color space for adjusting the
     chromatic character of colors to compensate for the
     chromatic differences between the source and destina-
     tion white points.	 This procedure simply converts the
     color specifications to 4mXcmsCIELab24m using the source
     white point and then converts to the target



			     1m1570m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


     specification format using the destination's white
     point.  No client data is necessary.

·    4mXcmsCIELuvWhiteShiftColors0m

     This uses the CIE L*u*v* color space for adjusting the
     chromatic character of colors to compensate for the
     chromatic differences between the source and destina-
     tion white points.	 This procedure simply converts the
     color specifications to 4mXcmsCIELuv24m using the source
     white point and then converts to the target specifica-
     tion format using the destination's white point.  No
     client data is necessary.

·    4mXcmsTekHVCWhiteShiftColors0m

     This uses the TekHVC color space for adjusting the
     chromatic character of colors to compensate for the
     chromatic differences between the source and destina-
     tion white points.	 This procedure simply converts the
     color specifications to 4mXcmsTekHVC24m using the source
     white point and then converts to the target specifica-
     tion format using the destination's white point.  An
     advantage of this procedure over those previously
     described is an attempt to minimize hue shift.  No
     client data is necessary.

From an implementation point of view, these white point
adjustment procedures convert the color specifications to a
device-independent but white-point-dependent color space
(for example, CIE L*u*v*, CIE L*a*b*, TekHVC) using one
white point and then converting those specifications to the
target color space using another white point.  In other
words, the specification goes in the color space with one
white point but comes out with another white point, result-
ing in a chromatic shift based on the chromatic displacement
between the initial white point and target white point.	 The
CIE color spaces that are assumed to be white-point-indepen-
dent are CIE u'v'Y, CIE XYZ, and CIE xyY.  When developing a
custom white point adjustment procedure that uses a device-
independent color space not initially accessible for use in
the color management system, use 4mXcmsAddColorSpace24m to ensure
that it is added.

As an example, if the CCC specifies a white point adjustment
procedure and if the Client White Point and Screen White
Point differ, the 4mXcmsAllocColor24m function will use the white
point adjustment procedure twice:

·    Once to convert to 4mXcmsRGB0m

·    A second time to convert from 4mXcmsRGB0m





			     1m1580m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


For example, assume the specification is in 4mXcmsCIEuvY24m and
the adjustment procedure is 4mXcmsCIELuvWhiteShiftColors24m.
During conversion to 4mXcmsRGB24m, the call to 4mXcmsAllocColor0m
results in the following series of color specification con-
versions:

·    From 4mXcmsCIEuvY24m to 4mXcmsCIELuv24m using the Client White
     Point

·    From 4mXcmsCIELuv24m to 4mXcmsCIEuvY24m using the Screen White
     Point

·    From 4mXcmsCIEuvY24m to 4mXcmsCIEXYZ24m (CIE u'v'Y and XYZ are
     white-point-independent color spaces)

·    From 4mXcmsCIEXYZ24m to 4mXcmsRGBi0m

·    From 4mXcmsRGBi24m to 4mXcmsRGB0m

The resulting RGB specification is passed to 4mXAllocColor24m,
and the RGB specification returned by 4mXAllocColor24m is con-
verted back to 4mXcmsCIEuvY24m by reversing the color conversion
sequence.

1m6.11.	 Gamut Querying Functions0m

This section describes the gamut querying functions that
Xlib provides.	These functions allow the client to query
the boundary of the screen's color gamut in terms of the CIE
L*a*b*, CIE L*u*v*, and TekHVC color spaces.  Functions are
also provided that allow you to query the color specifica-
tion of:

·    White (full-intensity red, green, and blue)

·    Red (full-intensity red while green and blue are zero)

·    Green (full-intensity green while red and blue are
     zero)

·    Blue (full-intensity blue while red and green are zero)

·    Black (zero-intensity red, green, and blue)

The white point associated with color specifications passed
to and returned from these gamut querying functions is
assumed to be the Screen White Point.  This is a reasonable
assumption, because the client is trying to query the
screen's color gamut.

The following naming convention is used for the Max and Min
functions:





			     1m1590m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


Xcms4m<color_space>24mQueryMax4m<dimensions>0m

Xcms4m<color_space>24mQueryMin4m<dimensions>0m


The <dimensions> consists of a letter or letters that iden-
tify the dimensions of the color space that are not fixed.
For example, 4mXcmsTekHVCQueryMaxC24m is given a fixed Hue and
Value for which maximum Chroma is found.

1m6.11.1.  Red, Green, and Blue Queries0m

To obtain the color specification for black (zero-intensity
red, green, and blue), use 4mXcmsQueryBlack24m.
__
|
Status XcmsQueryBlack(4mccc24m, 4mtarget_format24m, 4mcolor_return24m)
      XcmsCCC 4mccc24m;
      XcmsColorFormat 4mtarget_format24m;
      XcmsColor *4mcolor_return24m;


4mccc24m       Specifies the CCC.  The CCC's Client White Point
	  and white point adjustment procedures are ignored.

4mtarget_format0m
	  Specifies the target color specification format.

4mcolor_return0m
	  Returns the color specification in the specified
	  target format for zero-intensity red, green, and
	  blue.	 The white point associated with the
	  returned color specification is the Screen White
	  Point.  The value returned in the pixel member is
	  undefined.
|__

The 4mXcmsQueryBlack24m function returns the color specification
in the specified target format for zero-intensity red,
green, and blue.


To obtain the color specification for blue (full-intensity
blue while red and green are zero), use 4mXcmsQueryBlue24m.













			     1m1600m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
Status XcmsQueryBlue(4mccc24m, 4mtarget_format24m, 4mcolor_return24m)
      XcmsCCC 4mccc24m;
      XcmsColorFormat 4mtarget_format24m;
      XcmsColor *4mcolor_return24m;


4mccc24m       Specifies the CCC.  The CCC's Client White Point
	  and white point adjustment procedures are ignored.

4mtarget_format0m
	  Specifies the target color specification format.

4mcolor_return0m
	  Returns the color specification in the specified
	  target format for full-intensity blue while red
	  and green are zero.  The white point associated
	  with the returned color specification is the
	  Screen White Point.  The value returned in the
	  pixel member is undefined.
|__

The 4mXcmsQueryBlue24m function returns the color specification
in the specified target format for full-intensity blue while
red and green are zero.


To obtain the color specification for green (full-intensity
green while red and blue are zero), use 4mXcmsQueryGreen24m.
__
|
Status XcmsQueryGreen(4mccc24m, 4mtarget_format24m, 4mcolor_return24m)
      XcmsCCC 4mccc24m;
      XcmsColorFormat 4mtarget_format24m;
      XcmsColor *4mcolor_return24m;


4mccc24m       Specifies the CCC.  The CCC's Client White Point
	  and white point adjustment procedures are ignored.

4mtarget_format0m
	  Specifies the target color specification format.

4mcolor_return0m
	  Returns the color specification in the specified
	  target format for full-intensity green while red
	  and blue are zero.  The white point associated
	  with the returned color specification is the
	  Screen White Point.  The value returned in the
	  pixel member is undefined.
|__

The 4mXcmsQueryGreen24m function returns the color specification
in the specified target format for full-intensity green



			     1m1610m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


while red and blue are zero.


To obtain the color specification for red (full-intensity
red while green and blue are zero), use 4mXcmsQueryRed24m.
__
|
Status XcmsQueryRed(4mccc24m, 4mtarget_format24m, 4mcolor_return24m)
      XcmsCCC 4mccc24m;
      XcmsColorFormat 4mtarget_format24m;
      XcmsColor *4mcolor_return24m;


4mccc24m       Specifies the CCC.  The CCC's Client White Point
	  and white point adjustment procedures are ignored.

4mtarget_format0m
	  Specifies the target color specification format.

4mcolor_return0m
	  Returns the color specification in the specified
	  target format for full-intensity red while green
	  and blue are zero.  The white point associated
	  with the returned color specification is the
	  Screen White Point.  The value returned in the
	  pixel member is undefined.
|__

The 4mXcmsQueryRed24m function returns the color specification in
the specified target format for full-intensity red while
green and blue are zero.


To obtain the color specification for white (full-intensity
red, green, and blue), use 4mXcmsQueryWhite24m.






















			     1m1620m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
Status XcmsQueryWhite(4mccc24m, 4mtarget_format24m, 4mcolor_return24m)
      XcmsCCC 4mccc24m;
      XcmsColorFormat 4mtarget_format24m;
      XcmsColor *4mcolor_return24m;


4mccc24m       Specifies the CCC.  The CCC's Client White Point
	  and white point adjustment procedures are ignored.

4mtarget_format0m
	  Specifies the target color specification format.

4mcolor_return0m
	  Returns the color specification in the specified
	  target format for full-intensity red, green, and
	  blue.	 The white point associated with the
	  returned color specification is the Screen White
	  Point.  The value returned in the pixel member is
	  undefined.
|__

The 4mXcmsQueryWhite24m function returns the color specification
in the specified target format for full-intensity red,
green, and blue.

1m6.11.2.  CIELab Queries0m

The following equations are useful in describing the CIELab
query functions:



4mCIELabPsychometricChroma24m=4msqrt24m(4ma24m_4mstar24m2+4mb24m_4mstar24m2)

4mCIELabPsychometricHue24m=tan-1[4m_24m4m_____24m]


To obtain the CIE L*a*b* coordinates of maximum Psychometric
Chroma for a given Psychometric Hue Angle and CIE metric
lightness (L*), use 4mXcmsCIELabQueryMaxC24m.
















			     1m1630m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
Status XcmsCIELabQueryMaxC(4mccc24m, 4mhue_angle24m, 4mL_star24m, 4mcolor_return24m)
      XcmsCCC 4mccc24m;
      XcmsFloat 4mhue_angle24m;
      XcmsFloat 4mL_star24m;
      XcmsColor *4mcolor_return24m;


4mccc24m       Specifies the CCC.  The CCC's Client White Point
	  and white point adjustment procedures are ignored.

4mhue_angle24m Specifies the hue angle (in degrees) at which to
	  find maximum chroma.

4mL_star24m    Specifies the lightness (L*) at which to find max-
	  imum chroma.

4mcolor_return0m
	  Returns the CIE L*a*b* coordinates of maximum
	  chroma displayable by the screen for the given hue
	  angle and lightness.	The white point associated
	  with the returned color specification is the
	  Screen White Point.  The value returned in the
	  pixel member is undefined.
|__

The 4mXcmsCIELabQueryMaxC24m function, given a hue angle and
lightness, finds the point of maximum chroma displayable by
the screen.  It returns this point in CIE L*a*b* coordi-
nates.


To obtain the CIE L*a*b* coordinates of maximum CIE metric
lightness (L*) for a given Psychometric Hue Angle and Psy-
chometric Chroma, use 4mXcmsCIELabQueryMaxL24m.






















			     1m1640m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
Status XcmsCIELabQueryMaxL(4mccc24m, 4mhue_angle24m, 4mchroma24m, 4mcolor_return24m)
      XcmsCCC 4mccc24m;
      XcmsFloat 4mhue_angle24m;
      XcmsFloat 4mchroma24m;
      XcmsColor *4mcolor_return24m;


4mccc24m       Specifies the CCC.  The CCC's Client White Point
	  and white point adjustment procedures are ignored.

4mhue_angle24m Specifies the hue angle (in degrees) at which to
	  find maximum lightness.

4mchroma24m    Specifies the chroma at which to find maximum
	  lightness.

4mcolor_return0m
	  Returns the CIE L*a*b* coordinates of maximum
	  lightness displayable by the screen for the given
	  hue angle and chroma.	 The white point associated
	  with the returned color specification is the
	  Screen White Point.  The value returned in the
	  pixel member is undefined.
|__

The 4mXcmsCIELabQueryMaxL24m function, given a hue angle and
chroma, finds the point in CIE L*a*b* color space of maximum
lightness (L*) displayable by the screen.  It returns this
point in CIE L*a*b* coordinates.  An 4mXcmsFailure24m return
value usually indicates that the given chroma is beyond max-
imum for the given hue angle.


To obtain the CIE L*a*b* coordinates of maximum Psychometric
Chroma for a given Psychometric Hue Angle, use 4mXcmsCIELab-0m
4mQueryMaxLC24m.




















			     1m1650m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
Status XcmsCIELabQueryMaxLC(4mccc24m, 4mhue_angle24m, 4mcolor_return24m)
      XcmsCCC 4mccc24m;
      XcmsFloat 4mhue_angle24m;
      XcmsColor *4mcolor_return24m;


4mccc24m       Specifies the CCC.  The CCC's Client White Point
	  and white point adjustment procedures are ignored.

4mhue_angle24m Specifies the hue angle (in degrees) at which to
	  find maximum chroma.

4mcolor_return0m
	  Returns the CIE L*a*b* coordinates of maximum
	  chroma displayable by the screen for the given hue
	  angle.  The white point associated with the
	  returned color specification is the Screen White
	  Point.  The value returned in the pixel member is
	  undefined.
|__

The 4mXcmsCIELabQueryMaxLC24m function, given a hue angle, finds
the point of maximum chroma displayable by the screen.	It
returns this point in CIE L*a*b* coordinates.


To obtain the CIE L*a*b* coordinates of minimum CIE metric
lightness (L*) for a given Psychometric Hue Angle and Psy-
chometric Chroma, use 4mXcmsCIELabQueryMinL24m.



























			     1m1660m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
Status XcmsCIELabQueryMinL(4mccc24m, 4mhue_angle24m, 4mchroma24m, 4mcolor_return24m)
      XcmsCCC 4mccc24m;
      XcmsFloat 4mhue_angle24m;
      XcmsFloat 4mchroma24m;
      XcmsColor *4mcolor_return24m;


4mccc24m       Specifies the CCC.  The CCC's Client White Point
	  and white point adjustment procedures are ignored.

4mhue_angle24m Specifies the hue angle (in degrees) at which to
	  find minimum lightness.

4mchroma24m    Specifies the chroma at which to find minimum
	  lightness.

4mcolor_return0m
	  Returns the CIE L*a*b* coordinates of minimum
	  lightness displayable by the screen for the given
	  hue angle and chroma.	 The white point associated
	  with the returned color specification is the
	  Screen White Point.  The value returned in the
	  pixel member is undefined.
|__

The 4mXcmsCIELabQueryMinL24m function, given a hue angle and
chroma, finds the point of minimum lightness (L*) dis-
playable by the screen.	 It returns this point in CIE L*a*b*
coordinates.  An 4mXcmsFailure24m return value usually indicates
that the given chroma is beyond maximum for the given hue
angle.

1m6.11.3.  CIELuv Queries0m

The following equations are useful in describing the CIELuv
query functions:



4mCIELuvPsychometricChroma24m=4msqrt24m(4mu24m_4mstar24m2+4mv24m_4mstar24m2)

4mCIELuvPsychometricHue24m=tan-1[4m_24m4m_____24m]



To obtain the CIE L*u*v* coordinates of maximum Psychometric
Chroma for a given Psychometric Hue Angle and CIE metric
lightness (L*), use 4mXcmsCIELuvQueryMaxC24m.








			     1m1670m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
Status XcmsCIELuvQueryMaxC(4mccc24m, 4mhue_angle24m, 4mL_star24m, 4mcolor_return24m)
      XcmsCCC 4mccc24m;
      XcmsFloat 4mhue_angle24m;
      XcmsFloat 4mL_star24m;
      XcmsColor *4mcolor_return24m;


4mccc24m       Specifies the CCC.  The CCC's Client White Point
	  and white point adjustment procedures are ignored.

4mhue_angle24m Specifies the hue angle (in degrees) at which to
	  find maximum chroma.

4mL_star24m    Specifies the lightness (L*) at which to find max-
	  imum chroma.

4mcolor_return0m
	  Returns the CIE L*u*v* coordinates of maximum
	  chroma displayable by the screen for the given hue
	  angle and lightness.	The white point associated
	  with the returned color specification is the
	  Screen White Point.  The value returned in the
	  pixel member is undefined.
|__

The 4mXcmsCIELuvQueryMaxC24m function, given a hue angle and
lightness, finds the point of maximum chroma displayable by
the screen.  It returns this point in CIE L*u*v* coordi-
nates.


To obtain the CIE L*u*v* coordinates of maximum CIE metric
lightness (L*) for a given Psychometric Hue Angle and Psy-
chometric Chroma, use 4mXcmsCIELuvQueryMaxL24m.






















			     1m1680m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
Status XcmsCIELuvQueryMaxL(4mccc24m, 4mhue_angle24m, 4mchroma24m, 4mcolor_return24m)
      XcmsCCC 4mccc24m;
      XcmsFloat 4mhue_angle24m;
      XcmsFloat 4mchroma24m;
      XcmsColor *4mcolor_return24m;


4mccc24m       Specifies the CCC.  The CCC's Client White Point
	  and white point adjustment procedures are ignored.

4mhue_angle24m Specifies the hue angle (in degrees) at which to
	  find maximum lightness.

4mL_star24m    Specifies the lightness (L*) at which to find max-
	  imum lightness.

4mcolor_return0m
	  Returns the CIE L*u*v* coordinates of maximum
	  lightness displayable by the screen for the given
	  hue angle and chroma.	 The white point associated
	  with the returned color specification is the
	  Screen White Point.  The value returned in the
	  pixel member is undefined.
|__

The 4mXcmsCIELuvQueryMaxL24m function, given a hue angle and
chroma, finds the point in CIE L*u*v* color space of maximum
lightness (L*) displayable by the screen.  It returns this
point in CIE L*u*v* coordinates.  An 4mXcmsFailure24m return
value usually indicates that the given chroma is beyond max-
imum for the given hue angle.


To obtain the CIE L*u*v* coordinates of maximum Psychometric
Chroma for a given Psychometric Hue Angle, use 4mXcmsCIELuv-0m
4mQueryMaxLC24m.




















			     1m1690m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
Status XcmsCIELuvQueryMaxLC(4mccc24m, 4mhue_angle24m, 4mcolor_return24m)
      XcmsCCC 4mccc24m;
      XcmsFloat 4mhue_angle24m;
      XcmsColor *4mcolor_return24m;


4mccc24m       Specifies the CCC.  The CCC's Client White Point
	  and white point adjustment procedures are ignored.

4mhue_angle24m Specifies the hue angle (in degrees) at which to
	  find maximum chroma.

4mcolor_return0m
	  Returns the CIE L*u*v* coordinates of maximum
	  chroma displayable by the screen for the given hue
	  angle.  The white point associated with the
	  returned color specification is the Screen White
	  Point.  The value returned in the pixel member is
	  undefined.
|__

The 4mXcmsCIELuvQueryMaxLC24m function, given a hue angle, finds
the point of maximum chroma displayable by the screen.	It
returns this point in CIE L*u*v* coordinates.


To obtain the CIE L*u*v* coordinates of minimum CIE metric
lightness (L*) for a given Psychometric Hue Angle and Psy-
chometric Chroma, use 4mXcmsCIELuvQueryMinL24m.



























			     1m1700m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
Status XcmsCIELuvQueryMinL(4mccc24m, 4mhue_angle24m, 4mchroma24m, 4mcolor_return24m)
      XcmsCCC 4mccc24m;
      XcmsFloat 4mhue_angle24m;
      XcmsFloat 4mchroma24m;
      XcmsColor *4mcolor_return24m;


4mccc24m       Specifies the CCC.  The CCC's Client White Point
	  and white point adjustment procedures are ignored.

4mhue_angle24m Specifies the hue angle (in degrees) at which to
	  find minimum lightness.

4mchroma24m    Specifies the chroma at which to find minimum
	  lightness.

4mcolor_return0m
	  Returns the CIE L*u*v* coordinates of minimum
	  lightness displayable by the screen for the given
	  hue angle and chroma.	 The white point associated
	  with the returned color specification is the
	  Screen White Point.  The value returned in the
	  pixel member is undefined.
|__

The 4mXcmsCIELuvQueryMinL24m function, given a hue angle and
chroma, finds the point of minimum lightness (L*) dis-
playable by the screen.	 It returns this point in CIE L*u*v*
coordinates.  An 4mXcmsFailure24m return value usually indicates
that the given chroma is beyond maximum for the given hue
angle.

1m6.11.4.  TekHVC Queries0m

To obtain the maximum Chroma for a given Hue and Value, use
4mXcmsTekHVCQueryMaxC24m.




















			     1m1710m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
Status XcmsTekHVCQueryMaxC(4mccc24m, 4mhue24m, 4mvalue24m, 4mcolor_return24m)
      XcmsCCC 4mccc24m;
      XcmsFloat 4mhue24m;
      XcmsFloat 4mvalue24m;
      XcmsColor *4mcolor_return24m;


4mccc24m       Specifies the CCC.  The CCC's Client White Point
	  and white point adjustment procedures are ignored.

4mhue24m       Specifies the Hue in which to find the maximum
	  Chroma.

4mvalue24m     Specifies the Value in which to find the maximum
	  Chroma.

4mcolor_return0m
	  Returns the maximum Chroma along with the actual
	  Hue and Value	 at which the maximum Chroma was
	  found.  The white point associated with the
	  returned color specification is the Screen White
	  Point.  The value returned in the pixel member is
	  undefined.
|__

The 4mXcmsTekHVCQueryMaxC24m function, given a Hue and Value,
determines the maximum Chroma in TekHVC color space dis-
playable by the screen.	 It returns the maximum Chroma along
with the actual Hue and Value at which the maximum Chroma
was found.


To obtain the maximum Value for a given Hue and Chroma, use
4mXcmsTekHVCQueryMaxV24m.






















			     1m1720m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
Status XcmsTekHVCQueryMaxV(4mccc24m, 4mhue24m, 4mchroma24m, 4mcolor_return24m)
      XcmsCCC 4mccc24m;
      XcmsFloat 4mhue24m;
      XcmsFloat 4mchroma24m;
      XcmsColor *4mcolor_return24m;


4mccc24m       Specifies the CCC.  The CCC's Client White Point
	  and white point adjustment procedures are ignored.

4mhue24m       Specifies the Hue in which to find the maximum
	  Value.

4mchroma24m    Specifies the chroma at which to find maximum
	  Value.

4mcolor_return0m
	  Returns the maximum Value along with the Hue and
	  Chroma at which the maximum Value was found.	The
	  white point associated with the returned color
	  specification is the Screen White Point.  The
	  value returned in the pixel member is undefined.
|__

The 4mXcmsTekHVCQueryMaxV24m function, given a Hue and Chroma,
determines the maximum Value in TekHVC color space dis-
playable by the screen.	 It returns the maximum Value and
the actual Hue and Chroma at which the maximum Value was
found.


To obtain the maximum Chroma and Value at which it is
reached for a specified Hue, use 4mXcmsTekHVCQueryMaxVC24m.























			     1m1730m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
Status XcmsTekHVCQueryMaxVC(4mccc24m, 4mhue24m, 4mcolor_return24m)
      XcmsCCC 4mccc24m;
      XcmsFloat 4mhue24m;
      XcmsColor *4mcolor_return24m;


4mccc24m       Specifies the CCC.  The CCC's Client White Point
	  and white point adjustment procedures are ignored.

4mhue24m       Specifies the Hue in which to find the maximum
	  Chroma.

4mcolor_return0m
	  Returns the color specification in XcmsTekHVC for
	  the maximum Chroma, the Value at which that maxi-
	  mum Chroma is reached, and the actual Hue at which
	  the maximum Chroma was found.	 The white point
	  associated with the returned color specification
	  is the Screen White Point.  The value returned in
	  the pixel member is undefined.
|__

The 4mXcmsTekHVCQueryMaxVC24m function, given a Hue, determines
the maximum Chroma in TekHVC color space displayable by the
screen and the Value at which that maximum Chroma is
reached.  It returns the maximum Chroma, the Value at which
that maximum Chroma is reached, and the actual Hue for which
the maximum Chroma was found.


To obtain a specified number of TekHVC specifications such
that they contain maximum Values for a specified Hue and the
Chroma at which the maximum Values are reached, use 4mXcm-0m
4msTekHVCQueryMaxVSamples24m.






















			     1m1740m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
Status XcmsTekHVCQueryMaxVSamples(4mccc24m, 4mhue24m, 4mcolors_return24m, 4mnsamples24m)
      XcmsCCC 4mccc24m;
      XcmsFloat 4mhue24m;
      XcmsColor 4mcolors_return[]24m;
      unsigned int 4mnsamples24m;


4mccc24m       Specifies the CCC.  The CCC's Client White Point
	  and white point adjustment procedures are ignored.

4mhue24m       Specifies the Hue for maximum Chroma/Value sam-
	  ples.

4mnsamples24m  Specifies the number of samples.

4mcolors_return0m
	  Returns nsamples of color specifications in Xcm-
	  sTekHVC such that the Chroma is the maximum
	  attainable for the Value and Hue.  The white point
	  associated with the returned color specification
	  is the Screen White Point.  The value returned in
	  the pixel member is undefined.
|__

The 4mXcmsTekHVCQueryMaxVSamples24m returns nsamples of maximum
Value, the Chroma at which that maximum Value is reached,
and the actual Hue for which the maximum Chroma was found.
These sample points may then be used to plot the maximum
Value/Chroma boundary of the screen's color gamut for the
specified Hue in TekHVC color space.


To obtain the minimum Value for a given Hue and Chroma, use
4mXcmsTekHVCQueryMinV24m.






















			     1m1750m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
Status XcmsTekHVCQueryMinV(4mccc24m, 4mhue24m, 4mchroma24m, 4mcolor_return24m)
      XcmsCCC 4mccc24m;
      XcmsFloat 4mhue24m;
      XcmsFloat 4mchroma24m;
      XcmsColor *4mcolor_return24m;


4mccc24m       Specifies the CCC.  The CCC's Client White Point
	  and white point adjustment procedures are ignored.

4mhue24m       Specifies the Hue in which to find the minimum
	  Value.

4mvalue24m     Specifies the Value in which to find the minimum
	  Value.

4mcolor_return0m
	  Returns the minimum Value and the actual Hue and
	  Chroma at which the minimum Value was found.	The
	  white point associated with the returned color
	  specification is the Screen White Point.  The
	  value returned in the pixel member is undefined.
|__

The 4mXcmsTekHVCQueryMinV24m function, given a Hue and Chroma,
determines the minimum Value in TekHVC color space dis-
playable by the screen.	 It returns the minimum Value and
the actual Hue and Chroma at which the minimum Value was
found.

1m6.12.	 Color Management Extensions0m

The Xlib color management facilities can be extended in two
ways:

·    Device-Independent Color Spaces

     Device-independent color spaces that are derivable to
     CIE XYZ space can be added using the 4mXcmsAddColorSpace0m
     function.

·    Color Characterization Function Set

     A Color Characterization Function Set consists of
     device-dependent color spaces and their functions that
     convert between these color spaces and the CIE XYZ
     color space, bundled together for a specific class of
     output devices.  A function set can be added using the
     4mXcmsAddFunctionSet24m function.







			     1m1760m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


1m6.12.1.  Color Spaces0m

The CIE XYZ color space serves as the hub for all conver-
sions between device-independent and device-dependent color
spaces.	 Therefore, the knowledge to convert an 4mXcmsColor0m
structure to and from CIE XYZ format is associated with each
color space.  For example, conversion from CIE L*u*v* to RGB
requires the knowledge to convert from CIE L*u*v* to CIE XYZ
and from CIE XYZ to RGB.  This knowledge is stored as an
array of functions that, when applied in series, will con-
vert the 4mXcmsColor24m structure to or from CIE XYZ format.
This color specification conversion mechanism facilitates
the addition of color spaces.

Of course, when converting between only device-independent
color spaces or only device-dependent color spaces, short-
cuts are taken whenever possible.  For example, conversion
from TekHVC to CIE L*u*v* is performed by intermediate con-
version to CIE u*v*Y and then to CIE L*u*v*, thus bypassing
conversion between CIE u*v*Y and CIE XYZ.

1m6.12.2.  Adding Device-Independent Color Spaces0m

To add a device-independent color space, use 4mXcmsAddCol-0m
4morSpace24m.
__
|
Status XcmsAddColorSpace(4mcolor_space24m)
      XcmsColorSpace *4mcolor_space24m;


4mcolor_space0m
	  Specifies the device-independent color space to
	  add.
|__

The 4mXcmsAddColorSpace24m function makes a device-independent
color space (actually an 4mXcmsColorSpace24m structure) accessi-
ble by the color management system.  Because format values
for unregistered color spaces are assigned at run time, they
should be treated as private to the client.  If references
to an unregistered color space must be made outside the
client (for example, storing color specifications in a file
using the unregistered color space), then reference should
be made by color space prefix (see 4mXcmsFormatOfPrefix24m and
4mXcmsPrefixOfFormat24m).

If the 4mXcmsColorSpace24m structure is already accessible in the
color management system, 4mXcmsAddColorSpace24m returns 4mXcmsSuc-0m
4mcess24m.

Note that added 4mXcmsColorSpaces24m must be retained for refer-
ence by Xlib.




			     1m1770m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


1m6.12.3.  Querying Color Space Format and Prefix0m

To obtain the format associated with the color space associ-
ated with a specified color string prefix, use 4mXcmsFormatOf-0m
4mPrefix24m.
__
|
XcmsColorFormat XcmsFormatOfPrefix(4mprefix24m)
      char *4mprefix24m;


4mprefix24m    Specifies the string that contains the color space
	  prefix.
|__

The 4mXcmsFormatOfPrefix24m function returns the format for the
specified color space prefix (for example, the string
``CIEXYZ'').  The prefix is case-insensitive.  If the color
space is not accessible in the color management system,
4mXcmsFormatOfPrefix24m returns 4mXcmsUndefinedFormat24m.


To obtain the color string prefix associated with the color
space specified by a color format, use 4mXcmsPrefixOfFormat24m.
__
|
char *XcmsPrefixOfFormat(4mformat24m)
      XcmsColorFormat 4mformat24m;


4mformat24m    Specifies the color specification format.
|__

The 4mXcmsPrefixOfFormat24m function returns the string prefix
associated with the color specification encoding specified
by the format argument.	 Otherwise, if no encoding is found,
it returns NULL.  The returned string must be treated as
read-only.

1m6.12.4.  Creating Additional Color Spaces0m

Color space specific information necessary for color space
conversion and color string parsing is stored in an 4mXcmsCol-0m
4morSpace24m structure.	 Therefore, a new structure containing
this information is required for each additional color
space.	In the case of device-independent color spaces, a
handle to this new structure (that is, by means of a global
variable) is usually made accessible to the client program
for use with the 4mXcmsAddColorSpace24m function.

If a new 4mXcmsColorSpace24m structure specifies a color space
not registered with the X Consortium, they should be treated
as private to the client because format values for unregis-
tered color spaces are assigned at run time.  If references



			     1m1780m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


to an unregistered color space must be made outside the
client (for example, storing color specifications in a file
using the unregistered color space), then reference should
be made by color space prefix (see 4mXcmsFormatOfPrefix24m and
4mXcmsPrefixOfFormat24m).
__
|

typedef (*XcmsConversionProc)();
typedef XcmsConversionProc *XcmsFuncListPtr;
			 /* A NULL terminated list of function pointers*/

typedef struct _XcmsColorSpace {
     char *prefix;
     XcmsColorFormat format;
     XcmsParseStringProc parseString;
     XcmsFuncListPtr to_CIEXYZ;
     XcmsFuncListPtr from_CIEXYZ;
     int inverse_flag;
} XcmsColorSpace;

|__

The prefix member specifies the prefix that indicates a
color string is in this color space's string format.  For
example, the strings ``ciexyz'' or ``CIEXYZ'' for CIE XYZ,
and ``rgb'' or ``RGB'' for RGB.	 The prefix is case insensi-
tive.  The format member specifies the color specification
format.	 Formats for unregistered color spaces are assigned
at run time.  The parseString member contains a pointer to
the function that can parse a color string into an 4mXcmsColor0m
structure.  This function returns an integer (int): nonzero
if it succeeded and zero otherwise.  The to_CIEXYZ and
from_CIEXYZ members contain pointers, each to a NULL termi-
nated list of function pointers.  When the list of functions
is executed in series, it will convert the color specified
in an 4mXcmsColor24m structure from/to the current color space
format to/from the CIE XYZ format.  Each function returns an
integer (int): nonzero if it succeeded and zero otherwise.
The white point to be associated with the colors is speci-
fied explicitly, even though white points can be found in
the CCC.  The inverse_flag member, if nonzero, specifies
that for each function listed in to_CIEXYZ, its inverse
function can be found in from_CIEXYZ such that:


Given:	n = number of functions in each list

for each i, such that 0 <= i < n
    from_CIEXYZ[n - i - 1] is the inverse of to_CIEXYZ[i].


This allows Xlib to use the shortest conversion path, thus
bypassing CIE XYZ if possible (for example, TekHVC to CIE



			     1m1790m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


L*u*v*).

1m6.12.5.  Parse String Callback0m

The callback in the 4mXcmsColorSpace24m structure for parsing a
color string for the particular color space must adhere to
the following software interface specification:
__
|
typedef int (*XcmsParseStringProc)(4mcolor_string24m, 4mcolor_return24m)
      char *4mcolor_string24m;
      XcmsColor *4mcolor_return24m;


4mcolor_string0m
	  Specifies the color string to parse.

4mcolor_return0m
	  Returns the color specification in the color
	  space's format.
|__


1m6.12.6.  Color Specification Conversion Callback0m

Callback functions in the 4mXcmsColorSpace24m structure for con-
verting a color specification between device-independent
spaces must adhere to the following software interface spec-
ification:




























			     1m1800m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
Status ConversionProc(4mccc24m, 4mwhite_point24m, 4mcolors_in_out24m, 4mncolors24m)
      XcmsCCC 4mccc24m;
      XcmsColor *4mwhite_point24m;
      XcmsColor *4mcolors_in_out24m;
      unsigned int 4mncolors24m;


4mccc24m       Specifies the CCC.

4mwhite_point0m
	  Specifies the white point associated with color
	  specifications.  The pixel member should be
	  ignored, and the entire structure remain unchanged
	  upon return.

4mcolors_in_out0m
	  Specifies an array of color specifications.  Pixel
	  members should be ignored and must remain
	  unchanged upon return.

4mncolors24m   Specifies the number of 4mXcmsColor24m structures in
	  the color-specification array.
|__


Callback functions in the 4mXcmsColorSpace24m structure for con-
verting a color specification to or from a device-dependent
space must adhere to the following software interface speci-
fication:



























			     1m1810m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
Status ConversionProc(4mccc24m, 4mcolors_in_out24m, 4mncolors24m, 4mcompression_flags_return24m)
      XcmsCCC 4mccc24m;
      XcmsColor *4mcolors_in_out24m;
      unsigned int 4mncolors24m;
      Bool 4mcompression_flags_return24m[];


4mccc24m       Specifies the CCC.

4mcolors_in_out0m
	  Specifies an array of color specifications.  Pixel
	  members should be ignored and must remain
	  unchanged upon return.

4mncolors24m   Specifies the number of 4mXcmsColor24m structures in
	  the color-specification array.

4mcompression_flags_return0m
	  Returns an array of Boolean values for indicating
	  compression status.  If a non-NULL pointer is sup-
	  plied and a color at a given index is compressed,
	  then 4mTrue24m should be stored at the corresponding
	  index in this array; otherwise, the array should
	  not be modified.
|__

Conversion functions are available globally for use by other
color spaces.  The conversion functions provided by Xlib
are:

-------------------------------------------------------------
1mFunction	       Converts from	    Converts to0m
-------------------------------------------------------------
4mXcmsCIELabToCIEXYZ24m	  4mXcmsCIELabFormat24m	    4mXcmsCIEXYZFormat0m
4mXcmsCIELuvToCIEuvY24m	  4mXcmsCIELuvFormat24m	    4mXcmsCIEuvYFormat0m
4mXcmsCIEXYZToCIELab24m	  4mXcmsCIEXYZFormat24m	    4mXcmsCIELabFormat0m
4mXcmsCIEXYZToCIEuvY24m	  4mXcmsCIEXYZFormat24m	    4mXcmsCIEuvYFormat0m
4mXcmsCIEXYZToCIExyY24m	  4mXcmsCIEXYZFormat24m	    4mXcmsCIExyYFormat0m
4mXcmsCIEXYZToRGBi24m	  4mXcmsCIEXYZFormat24m	    4mXcmsRGBiFormat0m
4mXcmsCIEuvYToCIELuv24m	  4mXcmsCIEuvYFormat24m	    4mXcmsCIELabFormat0m
4mXcmsCIEuvYToCIEXYZ24m	  4mXcmsCIEuvYFormat24m	    4mXcmsCIEXYZFormat0m
4mXcmsCIEuvYToTekHVC24m	  4mXcmsCIEuvYFormat24m	    4mXcmsTekHVCFormat0m
4mXcmsCIExyYToCIEXYZ24m	  4mXcmsCIExyYFormat24m	    4mXcmsCIEXYZFormat0m
4mXcmsRGBToRGBi24m	  4mXcmsRGBFormat24m	    4mXcmsRGBiFormat0m
4mXcmsRGBiToCIEXYZ24m	  4mXcmsRGBiFormat24m	    4mXcmsCIEXYZFormat0m
4mXcmsRGBiToRGB24m	  4mXcmsRGBiFormat24m	    4mXcmsRGBFormat0m
4mXcmsTekHVCToCIEuvY24m	  4mXcmsTekHVCFormat24m	    4mXcmsCIEuvYFormat0m
-------------------------------------------------------------








			     1m1820m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


1m6.12.7.  Function Sets0m

Functions to convert between device-dependent color spaces
and CIE XYZ may differ for different classes of output
devices (for example, color versus gray monitors).  There-
fore, the notion of a Color Characterization Function Set
has been developed.  A function set consists of device-
dependent color spaces and the functions that convert color
specifications between these device-dependent color spaces
and the CIE XYZ color space appropriate for a particular
class of output devices.  The function set also contains a
function that reads color characterization data off root
window properties.  It is this characterization data that
will differ between devices within a class of output
devices.  For details about how color characterization data
is stored in root window properties, see the section on
Device Color Characterization in the 4mInter-Client24m 4mCommunica-0m
4mtion24m 4mConventions24m 4mManual24m.	 The LINEAR_RGB function set is
provided by Xlib and will support most color monitors.
Function sets may require data that differs from those
needed for the LINEAR_RGB function set.	 In that case, its
corresponding data may be stored on different root window
properties.

1m6.12.8.  Adding Function Sets0m

To add a function set, use 4mXcmsAddFunctionSet24m.
__
|
Status XcmsAddFunctionSet(4mfunction_set24m)
      XcmsFunctionSet *4mfunction_set24m;


4mfunction_set0m
	  Specifies the function set to add.
|__

The 4mXcmsAddFunctionSet24m function adds a function set to the
color management system.  If the function set uses device-
dependent 4mXcmsColorSpace24m structures not accessible in the
color management system, 4mXcmsAddFunctionSet24m adds them.  If
an added 4mXcmsColorSpace24m structure is for a device-dependent
color space not registered with the X Consortium, they
should be treated as private to the client because format
values for unregistered color spaces are assigned at run
time.  If references to an unregistered color space must be
made outside the client (for example, storing color specifi-
cations in a file using the unregistered color space), then
reference should be made by color space prefix (see 4mXcmsFor-0m
4mmatOfPrefix24m and 4mXcmsPrefixOfFormat24m).

Additional function sets should be added before any calls to
other Xlib routines are made.  If not, the 4mXcmsPerScrnInfo0m
member of a previously created 4mXcmsCCC24m does not have the



			     1m1830m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


opportunity to initialize with the added function set.

1m6.12.9.  Creating Additional Function Sets0m

The creation of additional function sets should be required
only when an output device does not conform to existing
function sets or when additional device-dependent color spa-
ces are necessary.  A function set consists primarily of a
collection of device-dependent 4mXcmsColorSpace24m structures and
a means to read and store a screen's color characterization
data.  This data is stored in an 4mXcmsFunctionSet24m structure.
A handle to this structure (that is, by means of global
variable) is usually made accessible to the client program
for use with 4mXcmsAddFunctionSet24m.

If a function set uses new device-dependent 4mXcmsColorSpace0m
structures, they will be transparently processed into the
color management system.  Function sets can share an 4mXcms-0m
4mColorSpace24m structure for a device-dependent color space.  In
addition, multiple 4mXcmsColorSpace24m structures are allowed for
a device-dependent color space; however, a function set can
reference only one of them.  These 4mXcmsColorSpace24m structures
will differ in the functions to convert to and from CIE XYZ,
thus tailored for the specific function set.
__
|

typedef struct _XcmsFunctionSet {
     XcmsColorSpace **DDColorSpaces;
     XcmsScreenInitProc screenInitProc;
     XcmsScreenFreeProc screenFreeProc;
} XcmsFunctionSet;

|__

The DDColorSpaces member is a pointer to a NULL terminated
list of pointers to 4mXcmsColorSpace24m structures for the
device-dependent color spaces that are supported by the
function set.  The screenInitProc member is set to the call-
back procedure (see the following interface specification)
that initializes the 4mXcmsPerScrnInfo24m structure for a partic-
ular screen.

The screen initialization callback must adhere to the fol-
lowing software interface specification:












			     1m1840m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
typedef Status (*XcmsScreenInitProc)(4mdisplay24m, 4mscreen_number24m, 4mscreen_info24m)
      Display *4mdisplay24m;
      int 4mscreen_number24m;
      XcmsPerScrnInfo *4mscreen_info24m;


4mdisplay24m   Specifies the connection to the X server.

4mscreen_number0m
	  Specifies the appropriate screen number on the
	  host server.

4mscreen_info0m
	  Specifies the 4mXcmsPerScrnInfo24m structure, which
	  contains the per screen information.
|__

The screen initialization callback in the 4mXcmsFunctionSet0m
structure fetches the color characterization data (device
profile) for the specified screen, typically off properties
on the screen's root window.  It then initializes the speci-
fied 4mXcmsPerScrnInfo24m structure.  If successful, the proce-
dure fills in the 4mXcmsPerScrnInfo24m structure as follows:

·    It sets the screenData member to the address of the
     created device profile data structure (contents known
     only by the function set).

·    It next sets the screenWhitePoint member.

·    It next sets the functionSet member to the address of
     the 4mXcmsFunctionSet24m structure.

·    It then sets the state member to 4mXcmsInitSuccess24m and
     finally returns 4mXcmsSuccess24m.

If unsuccessful, the procedure sets the state member to 4mXcm-0m
4msInitFailure24m and returns 4mXcmsFailure24m.

The 4mXcmsPerScrnInfo24m structure contains:
















			     1m1850m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|

typedef struct _XcmsPerScrnInfo {
     XcmsColor screenWhitePoint;
     XPointer functionSet;
     XPointer screenData;
     unsigned char state;
     char pad[3];
} XcmsPerScrnInfo;

|__

The screenWhitePoint member specifies the white point inher-
ent to the screen.  The functionSet member specifies the
appropriate function set.  The screenData member specifies
the device profile.  The state member is set to one of the
following:

·    4mXcmsInitNone24m indicates initialization has not been pre-
     viously attempted.

·    4mXcmsInitFailure24m indicates initialization has been pre-
     viously attempted but failed.

·    4mXcmsInitSuccess24m indicates initialization has been pre-
     viously attempted and succeeded.

The screen free callback must adhere to the following soft-
ware interface specification:
__
|
typedef void (*XcmsScreenFreeProc)(4mscreenData24m)
      XPointer 4mscreenData24m;


4mscreenData0m
	  Specifies the data to be freed.
|__

This function is called to free the screenData stored in an
4mXcmsPerScrnInfo24m structure.
















			     1m1860m





1mXlib - C Library			X11, Release 6.7 DRAFT0m




			 1mChapter 70m

		 1mGraphics Context Functions0m



A number of resources are used when performing graphics
operations in X.  Most information about performing graphics
(for example, foreground color, background color, line
style, and so on) is stored in resources called graphics
contexts (GCs).	 Most graphics operations (see chapter 8)
take a GC as an argument.  Although in theory the X protocol
permits sharing of GCs between applications, it is expected
that applications will use their own GCs when performing
operations.  Sharing of GCs is highly discouraged because
the library may cache GC state.

Graphics operations can be performed to either windows or
pixmaps, which collectively are called drawables.  Each
drawable exists on a single screen.  A GC is created for a
specific screen and drawable depth and can only be used with
drawables of matching screen and depth.

This chapter discusses how to:

·    Manipulate graphics context/state

·    Use graphics context convenience functions

1m7.1.	Manipulating Graphics Context/State0m

Most attributes of graphics operations are stored in GCs.
These include line width, line style, plane mask, fore-
ground, background, tile, stipple, clipping region, end
style, join style, and so on.  Graphics operations (for
example, drawing lines) use these values to determine the
actual drawing operation.  Extensions to X may add addi-
tional components to GCs.  The contents of a GC are private
to Xlib.

Xlib implements a write-back cache for all elements of a GC
that are not resource IDs to allow Xlib to implement the
transparent coalescing of changes to GCs.  For example, a
call to 4mXSetForeground24m of a GC followed by a call to 4mXSet-0m
4mLineAttributes24m results in only a single-change GC protocol
request to the server.	GCs are neither expected nor encour-
aged to be shared between client applications, so this
write-back caching should present no problems.	Applications
cannot share GCs without external synchronization.  There-
fore, sharing GCs between applications is highly discour-
aged.




			     1m1870m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


To set an attribute of a GC, set the appropriate member of
the 4mXGCValues24m structure and OR in the corresponding value
bitmask in your subsequent calls to 4mXCreateGC24m.  The symbols
for the value mask bits and the 4mXGCValues24m structure are:





















































			     1m1880m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
/* GC attribute value mask bits */

#define	  4mGCFunction24m		   (1L<<0)
#define	  4mGCPlaneMask24m		   (1L<<1)
#define	  4mGCForeground24m		   (1L<<2)
#define	  4mGCBackground24m		   (1L<<3)
#define	  4mGCLineWidth24m		   (1L<<4)
#define	  4mGCLineStyle24m		   (1L<<5)
#define	  4mGCCapStyle24m		   (1L<<6)
#define	  4mGCJoinStyle24m		   (1L<<7)
#define	  4mGCFillStyle24m		   (1L<<8)
#define	  4mGCFillRule24m		   (1L<<9)
#define	  4mGCTile24m			   (1L<<10)
#define	  4mGCStipple24m		   (1L<<11)
#define	  4mGCTileStipXOrigin24m	   (1L<<12)
#define	  4mGCTileStipYOrigin24m	   (1L<<13)
#define	  4mGCFont24m			   (1L<<14)
#define	  4mGCSubwindowMode24m		   (1L<<15)
#define	  4mGCGraphicsExposures24m	   (1L<<16)
#define	  4mGCClipXOrigin24m		   (1L<<17)
#define	  4mGCClipYOrigin24m		   (1L<<18)
#define	  4mGCClipMask24m		   (1L<<19)
#define	  4mGCDashOffset24m		   (1L<<20)
#define	  4mGCDashList24m		   (1L<<21)
#define	  4mGCArcMode24m		   (1L<<22)


/* Values */

typedef struct {
     int function;	      /* logical operation */
     unsigned long plane_mask;/* plane mask */
     unsigned long foreground;/* foreground pixel */
     unsigned long background;/* background pixel */
     int line_width;	      /* line width (in pixels) */
     int line_style;	      /* LineSolid, LineOnOffDash, LineDoubleDash */
     int cap_style;	      /* CapNotLast, CapButt, CapRound, CapProjecting */
     int join_style;	      /* JoinMiter, JoinRound, JoinBevel */
     int fill_style;	      /* FillSolid, FillTiled, FillStippled FillOpaqueStippled*/
     int fill_rule;	      /* EvenOddRule, WindingRule */
     int arc_mode;	      /* ArcChord, ArcPieSlice */
     Pixmap tile;	      /* tile pixmap for tiling operations */
     Pixmap stipple;	      /* stipple 1 plane pixmap for stippling */
     int ts_x_origin;	      /* offset for tile or stipple operations */
     int ts_y_origin;
     Font font;		      /* default text font for text operations */
     int subwindow_mode;      /* ClipByChildren, IncludeInferiors */
     Bool graphics_exposures; /* boolean, should exposures be generated */
     int clip_x_origin;	      /* origin for clipping */
     int clip_y_origin;
     Pixmap clip_mask;	      /* bitmap clipping; other calls for rects */
     int dash_offset;	      /* patterned/dashed line information */
     char dashes;



			     1m1890m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


} XGCValues;

|__

The default GC values are:

----------------------------------------------------------------------------------
1mComponent	       Default0m
----------------------------------------------------------------------------------
function	     4mGXcopy0m
plane_mask	     All ones
foreground	     0
background	     1
line_width	     0
line_style	     4mLineSolid0m
cap_style	     4mCapButt0m
join_style	     4mJoinMiter0m
fill_style	     4mFillSolid0m
fill_rule	     4mEvenOddRule0m
arc_mode	     4mArcPieSlice0m
tile		     Pixmap of unspecified size filled with foreground pixel
		     (that is, client specified pixel if any, else 0)
		     (subsequent changes to foreground do not affect this pixmap)
stipple		     Pixmap of unspecified size filled with ones
ts_x_origin	     0
ts_y_origin	     0
font		     <implementation dependent>
subwindow_mode	     4mClipByChildren0m
graphics_exposures   4mTrue0m
clip_x_origin	     0
clip_y_origin	     0
clip_mask	     4mNone0m
dash_offset	     0
dashes		     4 (that is, the list [4, 4])
----------------------------------------------------------------------------------


Note that foreground and background are not set to any val-
ues likely to be useful in a window.

The function attributes of a GC are used when you update a
section of a drawable (the destination) with bits from some-
where else (the source).  The function in a GC defines how
the new destination bits are to be computed from the source
bits and the old destination bits.  4mGXcopy24m is typically the
most useful because it will work on a color display, but
special applications may use other functions, particularly
in concert with particular planes of a color display.  The
16 GC functions, defined in <4mX11/X.h24m>, are:








			     1m1900m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


-----------------------------------------------
1mFunction Name	    Value   Operation0m
-----------------------------------------------
4mGXclear24m		0x0    0
4mGXand24m		0x1    src AND dst
4mGXandReverse24m	0x2    src AND NOT dst
4mGXcopy24m		0x3    src
4mGXandInverted24m	0x4    (NOT src) AND dst
4mGXnoop24m		0x5    dst
4mGXxor24m		0x6    src XOR dst
4mGXor24m		0x7    src OR dst
4mGXnor24m		0x8    (NOT src) AND (NOT
			  dst)
4mGXequiv24m		0x9    (NOT src) XOR dst
4mGXinvert24m		0xa    NOT dst
4mGXorReverse24m	0xb    src OR (NOT dst)
4mGXcopyInverted24m	0xc    NOT src
4mGXorInverted24m	0xd    (NOT src) OR dst
4mGXnand24m		0xe    (NOT src) OR (NOT
			  dst)
4mGXset24m		0xf    1
-----------------------------------------------


Many graphics operations depend on either pixel values or
planes in a GC.	 The planes attribute is of type long, and
it specifies which planes of the destination are to be modi-
fied, one bit per plane.  A monochrome display has only one
plane and will be the least significant bit of the word.  As
planes are added to the display hardware, they will occupy
more significant bits in the plane mask.

In graphics operations, given a source and destination
pixel, the result is computed bitwise on corresponding bits
of the pixels.	That is, a Boolean operation is performed in
each bit plane.	 The plane_mask restricts the operation to a
subset of planes.  A macro constant 4mAllPlanes24m can be used to
refer to all planes of the screen simultaneously.  The
result is computed by the following:


     ((src FUNC dst) AND plane-mask) OR (dst AND (NOT plane-mask))


Range checking is not performed on the values for fore-
ground, background, or plane_mask.  They are simply trun-
cated to the appropriate number of bits.  The line-width is
measured in pixels and either can be greater than or equal
to one (wide line) or can be the special value zero (thin
line).

Wide lines are drawn centered on the path described by the
graphics request.  Unless otherwise specified by the join-
style or cap-style, the bounding box of a wide line with



			     1m1910m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


endpoints [x1, y1], [x2, y2] and width w is a rectangle with
vertices at the following real coordinates:


     [x1-(w*sn/2), y1+(w*cs/2)], [x1+(w*sn/2), y1-(w*cs/2)],
     [x2-(w*sn/2), y2+(w*cs/2)], [x2+(w*sn/2), y2-(w*cs/2)]


Here sn is the sine of the angle of the line, and cs is the
cosine of the angle of the line.  A pixel is part of the
line and so is drawn if the center of the pixel is fully
inside the bounding box (which is viewed as having infinite-
ly thin edges).	 If the center of the pixel is exactly on
the bounding box, it is part of the line if and only if the
interior is immediately to its right (x increasing direc-
tion).	Pixels with centers on a horizontal edge are a spe-
cial case and are part of the line if and only if the inte-
rior or the boundary is immediately below (y increasing
direction) and the interior or the boundary is immediately
to the right (x increasing direction).

Thin lines (zero line-width) are one-pixel-wide lines drawn
using an unspecified, device-dependent algorithm.  There are
only two constraints on this algorithm.

1.   If a line is drawn unclipped from [x1,y1] to [x2,y2]
     and if another line is drawn unclipped from
     [x1+dx,y1+dy] to [x2+dx,y2+dy], a point [x,y] is
     touched by drawing the first line if and only if the
     point [x+dx,y+dy] is touched by drawing the second
     line.

2.   The effective set of points comprising a line cannot be
     affected by clipping.  That is, a point is touched in a
     clipped line if and only if the point lies inside the
     clipping region and the point would be touched by the
     line when drawn unclipped.

A wide line drawn from [x1,y1] to [x2,y2] always draws the
same pixels as a wide line drawn from [x2,y2] to [x1,y1],
not counting cap-style and join-style.	It is recommended
that this property be true for thin lines, but this is not
required.  A line-width of zero may differ from a line-width
of one in which pixels are drawn.  This permits the use of
many manufacturers' line drawing hardware, which may run
many times faster than the more precisely specified wide
lines.

In general, drawing a thin line will be faster than drawing
a wide line of width one.  However, because of their differ-
ent drawing algorithms, thin lines may not mix well aesthet-
ically with wide lines.	 If it is desirable to obtain pre-
cise and uniform results across all displays, a client
should always use a line-width of one rather than a line-



			     1m1920m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


width of zero.

The line-style defines which sections of a line are drawn:

4mLineSolid24m	     The full path of the line is drawn.
4mLineDou-24m	     The full path of the line is drawn, but the
4mbleDash24m	     even dashes are filled differently from the
		odd dashes (see fill-style) with 4mCapButt0m
		style used where even and odd dashes meet.
4mLineOnOffDash24m   Only the even dashes are drawn, and cap-style
		applies to all internal ends of the individ-
		ual dashes, except 4mCapNotLast24m is treated as
		4mCapButt24m.


The cap-style defines how the endpoints of a path are drawn:

4mCapNotLast24m	     This is equivalent to 4mCapButt24m except that for
		a line-width of zero the final endpoint is
		not drawn.
4mCapButt24m	     The line is square at the endpoint (perpen-
		dicular to the slope of the line) with no
		projection beyond.
4mCapRound24m	     The line has a circular arc with the diameter
		equal to the line-width, centered on the end-
		point.	(This is equivalent to 4mCapButt24m for
		line-width of zero).
4mCapProjecting24m   The line is square at the end, but the path
		continues beyond the endpoint for a distance
		equal to half the line-width.  (This is
		equivalent to 4mCapButt24m for line-width of
		zero).


The join-style defines how corners are drawn for wide lines:

4mJoinMiter24m	     The outer edges of two lines extend to meet
		at an angle.  However, if the angle is less
		than 11 degrees, then a 4mJoinBevel24m join-style
		is used instead.
4mJoinRound24m	     The corner is a circular arc with the diame-
		ter equal to the line-width, centered on the
		joinpoint.
4mJoinBevel24m	     The corner has 4mCapButt24m endpoint styles with
		the triangular notch filled.


For a line with coincident endpoints (x1=x2, y1=y2), when
the cap-style is applied to both endpoints, the semantics
depends on the line-width and the cap-style:







			     1m1930m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


4mCapNotLast24m	     thin    The results are device dependent, but
			the desired effect is that nothing is
			drawn.
4mCapButt24m	     thin    The results are device dependent, but
			the desired effect is that a single
			pixel is drawn.
4mCapRound24m	     thin    The results are the same as for 4mCap-0m
			4mButt24m/thin.
4mCapProjecting24m   thin    The results are the same as for 4mCap-0m
			4mButt24m/thin.
4mCapButt24m	     wide    Nothing is drawn.
4mCapRound24m	     wide    The closed path is a circle, centered at
			the endpoint, and with the diameter
			equal to the line-width.
4mCapProjecting24m   wide    The closed path is a square, aligned
			with the coordinate axes, centered at
			the endpoint, and with the sides equal
			to the line-width.


For a line with coincident endpoints (x1=x2, y1=y2), when
the join-style is applied at one or both endpoints, the
effect is as if the line was removed from the overall path.
However, if the total path consists of or is reduced to a
single point joined with itself, the effect is the same as
when the cap-style is applied at both endpoints.

The tile/stipple represents an infinite two-dimensional
plane, with the tile/stipple replicated in all dimensions.
When that plane is superimposed on the drawable for use in a
graphics operation, the upper-left corner of some instance
of the tile/stipple is at the coordinates within the draw-
able specified by the tile/stipple origin.  The tile/stipple
and clip origins are interpreted relative to the origin of
whatever destination drawable is specified in a graphics
request.  The tile pixmap must have the same root and depth
as the GC, or a 4mBadMatch24m error results.  The stipple pixmap
must have depth one and must have the same root as the GC,
or a 4mBadMatch24m error results.  For stipple operations where
the fill-style is 4mFillStippled24m but not 4mFillOpaqueStippled24m,
the stipple pattern is tiled in a single plane and acts as
an additional clip mask to be ANDed with the clip-mask.
Although some sizes may be faster to use than others, any
size pixmap can be used for tiling or stippling.

The fill-style defines the contents of the source for line,
text, and fill requests.  For all text and fill requests
(for example, 4mXDrawText24m, 4mXDrawText1624m, 4mXFillRectangle24m,
4mXFillPolygon24m, and 4mXFillArc24m); for line requests with line-
style 4mLineSolid24m (for example, 4mXDrawLine24m, 4mXDrawSegments24m,
4mXDrawRectangle24m, 4mXDrawArc24m); and for the even dashes for line
requests with line-style 4mLineOnOffDash24m or 4mLineDoubleDash24m,
the following apply:




			     1m1940m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


4mFillSolid24m		  Foreground
4mFillTiled24m		  Tile
4mFillOpaqueStippled24m	  A tile with the same width and height as
		     stipple, but with background everywhere
		     stipple has a zero and with foreground
		     everywhere stipple has a one
4mFillStippled24m	  Foreground masked by stipple


When drawing lines with line-style 4mLineDoubleDash24m, the odd
dashes are controlled by the fill-style in the following
manner:

4mFillSolid24m		  Background
4mFillTiled24m		  Same as for even dashes
4mFillOpaqueStippled24m	  Same as for even dashes
4mFillStippled24m	  Background masked by stipple


Storing a pixmap in a GC might or might not result in a copy
being made.  If the pixmap is later used as the destination
for a graphics request, the change might or might not be
reflected in the GC.  If the pixmap is used simultaneously
in a graphics request both as a destination and as a tile or
stipple, the results are undefined.

For optimum performance, you should draw as much as possible
with the same GC (without changing its components).  The
costs of changing GC components relative to using different
GCs depend on the display hardware and the server implemen-
tation.	 It is quite likely that some amount of GC informa-
tion will be cached in display hardware and that such hard-
ware can only cache a small number of GCs.

The dashes value is actually a simplified form of the more
general patterns that can be set with 4mXSetDashes24m.	Specify-
ing a value of N is equivalent to specifying the two-element
list [N, N] in 4mXSetDashes24m.	 The value must be nonzero, or a
4mBadValue24m error results.

The clip-mask restricts writes to the destination drawable.
If the clip-mask is set to a pixmap, it must have depth one
and have the same root as the GC, or a 4mBadMatch24m error
results.  If clip-mask is set to 4mNone24m, the pixels are always
drawn regardless of the clip origin.  The clip-mask also can
be set by calling the 4mXSetClipRectangles24m or 4mXSetRegion24m func-
tions.	Only pixels where the clip-mask has a bit set to 1
are drawn.  Pixels are not drawn outside the area covered by
the clip-mask or where the clip-mask has a bit set to 0.
The clip-mask affects all graphics requests.  The clip-mask
does not clip sources.	The clip-mask origin is interpreted
relative to the origin of whatever destination drawable is
specified in a graphics request.




			     1m1950m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


You can set the subwindow-mode to 4mClipByChildren24m or 4mInclude-0m
4mInferiors24m.	 For 4mClipByChildren24m, both source and destination
windows are additionally clipped by all viewable 4mInputOutput0m
children.  For 4mIncludeInferiors24m, neither source nor destina-
tion window is clipped by inferiors.  This will result in
including subwindow contents in the source and drawing
through subwindow boundaries of the destination.  The use of
4mIncludeInferiors24m on a window of one depth with mapped infe-
riors of differing depth is not illegal, but the semantics
are undefined by the core protocol.

The fill-rule defines what pixels are inside (drawn) for
paths given in 4mXFillPolygon24m requests and can be set to 4mEven-0m
4mOddRule24m or 4mWindingRule24m.  For 4mEvenOddRule24m, a point is inside
if an infinite ray with the point as origin crosses the path
an odd number of times.	 For 4mWindingRule24m, a point is inside
if an infinite ray with the point as origin crosses an
unequal number of clockwise and counterclockwise directed
path segments.	A clockwise directed path segment is one
that crosses the ray from left to right as observed from the
point.	A counterclockwise segment is one that crosses the
ray from right to left as observed from the point.  The case
where a directed line segment is coincident with the ray is
uninteresting because you can simply choose a different ray
that is not coincident with a segment.

For both 4mEvenOddRule24m and 4mWindingRule24m, a point is infinitely
small, and the path is an infinitely thin line.	 A pixel is
inside if the center point of the pixel is inside and the
center point is not on the boundary.  If the center point is
on the boundary, the pixel is inside if and only if the
polygon interior is immediately to its right (x increasing
direction).  Pixels with centers on a horizontal edge are a
special case and are inside if and only if the polygon inte-
rior is immediately below (y increasing direction).

The arc-mode controls filling in the 4mXFillArcs24m function and
can be set to 4mArcPieSlice24m or 4mArcChord24m.  For 4mArcPieSlice24m, the
arcs are pie-slice filled.  For 4mArcChord24m, the arcs are chord
filled.

The graphics-exposure flag controls 4mGraphicsExpose24m event
generation for 4mXCopyArea24m and 4mXCopyPlane24m requests (and any
similar requests defined by extensions).


To create a new GC that is usable on a given screen with a
depth of drawable, use 4mXCreateGC24m.









			     1m1960m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
GC XCreateGC(4mdisplay24m, 4md24m, 4mvaluemask24m, 4mvalues24m)
      Display *4mdisplay24m;
      Drawable 4md24m;
      unsigned long 4mvaluemask24m;
      XGCValues *4mvalues24m;


4mdisplay24m   Specifies the connection to the X server.

4md24m	       Specifies the drawable.

4mvaluemask24m Specifies which components in the GC are to be set
	  using the information in the specified values
	  structure.  This argument is the bitwise inclusive
	  OR of zero or more of the valid GC component mask
	  bits.

4mvalues24m    Specifies any values as specified by the value-
	  mask.
|__

The 4mXCreateGC24m function creates a graphics context and
returns a GC.  The GC can be used with any destination draw-
able having the same root and depth as the specified draw-
able.  Use with other drawables results in a 4mBadMatch24m error.

4mXCreateGC24m can generate 4mBadAlloc24m, 4mBadDrawable24m, 4mBadFont24m, 4mBad-0m
4mMatch24m, 4mBadPixmap24m, and 4mBadValue24m errors.


To copy components from a source GC to a destination GC, use
4mXCopyGC24m.
__
|
XCopyGC(4mdisplay24m, 4msrc24m, 4mvaluemask24m, 4mdest24m)
      Display *4mdisplay24m;
      GC 4msrc24m, 4mdest24m;
      unsigned long 4mvaluemask24m;


4mdisplay24m   Specifies the connection to the X server.

4msrc24m       Specifies the components of the source GC.

4mvaluemask24m Specifies which components in the GC are to be
	  copied to the destination GC.	 This argument is
	  the bitwise inclusive OR of zero or more of the
	  valid GC component mask bits.

4mdest24m      Specifies the destination GC.
|__

The 4mXCopyGC24m function copies the specified components from



			     1m1970m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


the source GC to the destination GC.  The source and desti-
nation GCs must have the same root and depth, or a 4mBadMatch0m
error results.	The valuemask specifies which component to
copy, as for 4mXCreateGC24m.

4mXCopyGC24m can generate 4mBadAlloc24m, 4mBadGC24m, and 4mBadMatch24m errors.


To change the components in a given GC, use 4mXChangeGC24m.
__
|
XChangeGC(4mdisplay24m, 4mgc24m, 4mvaluemask24m, 4mvalues24m)
      Display *4mdisplay24m;
      GC 4mgc24m;
      unsigned long 4mvaluemask24m;
      XGCValues *4mvalues24m;


4mdisplay24m   Specifies the connection to the X server.

4mgc24m	       Specifies the GC.

4mvaluemask24m Specifies which components in the GC are to be
	  changed using information in the specified values
	  structure.  This argument is the bitwise inclusive
	  OR of zero or more of the valid GC component mask
	  bits.

4mvalues24m    Specifies any values as specified by the value-
	  mask.
|__

The 4mXChangeGC24m function changes the components specified by
valuemask for the specified GC.	 The values argument con-
tains the values to be set.  The values and restrictions are
the same as for 4mXCreateGC24m.	 Changing the clip-mask overrides
any previous 4mXSetClipRectangles24m request on the context.
Changing the dash-offset or dash-list overrides any previous
4mXSetDashes24m request on the context.	 The order in which com-
ponents are verified and altered is server dependent.  If an
error is generated, a subset of the components may have been
altered.

4mXChangeGC24m can generate 4mBadAlloc24m, 4mBadFont24m, 4mBadGC24m, 4mBadMatch24m,
4mBadPixmap24m, and 4mBadValue24m errors.


To obtain components of a given GC, use 4mXGetGCValues24m.









			     1m1980m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
Status XGetGCValues(4mdisplay24m, 4mgc24m, 4mvaluemask24m, 4mvalues_return24m)
      Display *4mdisplay24m;
      GC 4mgc24m;
      unsigned long 4mvaluemask24m;
      XGCValues *4mvalues_return24m;


4mdisplay24m   Specifies the connection to the X server.

4mgc24m	       Specifies the GC.

4mvaluemask24m Specifies which components in the GC are to be
	  returned in the values_return argument.  This
	  argument is the bitwise inclusive OR of zero or
	  more of the valid GC component mask bits.

4mvalues_return0m
	  Returns the GC values in the specified 4mXGCValues0m
	  structure.
|__

The 4mXGetGCValues24m function returns the components specified
by valuemask for the specified GC.  If the valuemask con-
tains a valid set of GC mask bits (4mGCFunction24m, 4mGCPlaneMask24m,
4mGCForeground24m, 4mGCBackground24m, 4mGCLineWidth24m, 4mGCLineStyle24m, 4mGCCap-0m
4mStyle24m, 4mGCJoinStyle24m, 4mGCFillStyle24m, 4mGCFillRule24m, 4mGCTile24m, 4mGCStip-0m
4mple24m, 4mGCTileStipXOrigin24m, 4mGCTileStipYOrigin24m, 4mGCFont24m, 4mGCSubwin-0m
4mdowMode24m, 4mGCGraphicsExposures24m, 4mGCClipXOrigin24m, 4mGCCLipYOrigin24m,
4mGCDashOffset24m, or 4mGCArcMode24m) and no error occurs, 4mXGetGCVal-0m
4mues24m sets the requested components in values_return and
returns a nonzero status.  Otherwise, it returns a zero sta-
tus.  Note that the clip-mask and dash-list (represented by
the 4mGCClipMask24m and 4mGCDashList24m bits, respectively, in the
valuemask) cannot be requested.	 Also note that an invalid
resource ID (with one or more of the three most significant
bits set to 1) will be returned for 4mGCFont24m, 4mGCTile24m, and
4mGCStipple24m if the component has never been explicitly set by
the client.


To free a given GC, use 4mXFreeGC24m.















			     1m1990m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
XFreeGC(4mdisplay24m, 4mgc24m)
      Display *4mdisplay24m;
      GC 4mgc24m;


4mdisplay24m   Specifies the connection to the X server.

4mgc24m	       Specifies the GC.
|__

The 4mXFreeGC24m function destroys the specified GC as well as
all the associated storage.

4mXFreeGC24m can generate a 4mBadGC24m error.


To obtain the 4mGContext24m resource ID for a given GC, use
4mXGContextFromGC24m.
__
|
GContext XGContextFromGC(4mgc24m)
      GC 4mgc24m;


4mgc24m	       Specifies the GC for which you want the resource
	  ID.
|__


Xlib usually defers sending changes to the components of a
GC to the server until a graphics function is actually
called with that GC.  This permits batching of component
changes into a single server request.  In some circum-
stances, however, it may be necessary for the client to
explicitly force sending the changes to the server.  An
example might be when a protocol extension uses the GC indi-
rectly, in such a way that the extension interface cannot
know what GC will be used.  To force sending GC component
changes, use 4mXFlushGC24m.
__
|
void XFlushGC(4mdisplay24m, 4mgc24m)
      Display *4mdisplay24m;
      GC 4mgc24m;


4mdisplay24m   Specifies the connection to the X server.

4mgc24m	       Specifies the GC.
|__






			     1m2000m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


1m7.2.	Using Graphics Context Convenience Routines0m

This section discusses how to set the:

·    Foreground, background, plane mask, or function compo-
     nents

·    Line attributes and dashes components

·    Fill style and fill rule components

·    Fill tile and stipple components

·    Font component

·    Clip region component

·    Arc mode, subwindow mode, and graphics exposure compo-
     nents

1m7.2.1.  Setting the Foreground, Background, Function, or0m
1mPlane Mask0m

To set the foreground, background, plane mask, and function
components for a given GC, use 4mXSetState24m.
































			     1m2010m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
XSetState(4mdisplay24m, 4mgc24m, 4mforeground24m, 4mbackground24m, 4mfunction24m, 4mplane_mask24m)
      Display *4mdisplay24m;
      GC 4mgc24m;
      unsigned long 4mforeground24m, 4mbackground24m;
      int 4mfunction24m;
      unsigned long 4mplane_mask24m;


4mdisplay24m   Specifies the connection to the X server.

4mgc24m	       Specifies the GC.

4mforeground0m
	  Specifies the foreground you want to set for the
	  specified GC.

4mbackground0m
	  Specifies the background you want to set for the
	  specified GC.

4mfunction24m  Specifies the function you want to set for the
	  specified GC.

4mplane_mask0m
	  Specifies the plane mask.
|__

4mXSetState24m can generate 4mBadAlloc24m, 4mBadGC24m, and 4mBadValue24m errors.


To set the foreground of a given GC, use 4mXSetForeground24m.
__
|
XSetForeground(4mdisplay24m, 4mgc24m, 4mforeground24m)
      Display *4mdisplay24m;
      GC 4mgc24m;
      unsigned long 4mforeground24m;


4mdisplay24m   Specifies the connection to the X server.

4mgc24m	       Specifies the GC.

4mforeground0m
	  Specifies the foreground you want to set for the
	  specified GC.
|__

4mXSetForeground24m can generate 4mBadAlloc24m and 4mBadGC24m errors.


To set the background of a given GC, use 4mXSetBackground24m.




			     1m2020m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
XSetBackground(4mdisplay24m, 4mgc24m, 4mbackground24m)
      Display *4mdisplay24m;
      GC 4mgc24m;
      unsigned long 4mbackground24m;


4mdisplay24m   Specifies the connection to the X server.

4mgc24m	       Specifies the GC.

4mbackground0m
	  Specifies the background you want to set for the
	  specified GC.
|__

4mXSetBackground24m can generate 4mBadAlloc24m and 4mBadGC24m errors.


To set the display function in a given GC, use 4mXSetFunction24m.
__
|
XSetFunction(4mdisplay24m, 4mgc24m, 4mfunction24m)
      Display *4mdisplay24m;
      GC 4mgc24m;
      int 4mfunction24m;


4mdisplay24m   Specifies the connection to the X server.

4mgc24m	       Specifies the GC.

4mfunction24m  Specifies the function you want to set for the
	  specified GC.
|__

4mXSetFunction24m can generate 4mBadAlloc24m, 4mBadGC24m, and 4mBadValue0m
errors.


To set the plane mask of a given GC, use 4mXSetPlaneMask24m.
















			     1m2030m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
XSetPlaneMask(4mdisplay24m, 4mgc24m, 4mplane_mask24m)
      Display *4mdisplay24m;
      GC 4mgc24m;
      unsigned long 4mplane_mask24m;


4mdisplay24m   Specifies the connection to the X server.

4mgc24m	       Specifies the GC.

4mplane_mask0m
	  Specifies the plane mask.
|__

4mXSetPlaneMask24m can generate 4mBadAlloc24m and 4mBadGC24m errors.

1m7.2.2.  Setting the Line Attributes and Dashes0m

To set the line drawing components of a given GC, use 4mXSet-0m
4mLineAttributes24m.




































			     1m2040m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
XSetLineAttributes(4mdisplay24m, 4mgc24m, 4mline_width24m, 4mline_style24m, 4mcap_style24m, 4mjoin_style24m)
      Display *4mdisplay24m;
      GC 4mgc24m;
      unsigned int 4mline_width24m;
      int 4mline_style24m;
      int 4mcap_style24m;
      int 4mjoin_style24m;


4mdisplay24m   Specifies the connection to the X server.

4mgc24m	       Specifies the GC.

4mline_width0m
	  Specifies the line-width you want to set for the
	  specified GC.

4mline_style0m
	  Specifies the line-style you want to set for the
	  specified GC.	 You can pass 4mLineSolid24m, 4mLineOnOff-0m
	  4mDash24m, or 4mLineDoubleDash24m.

4mcap_style24m Specifies the line-style and cap-style you want to
	  set for the specified GC.  You can pass 4mCapNot-0m
	  4mLast24m, 4mCapButt24m, 4mCapRound24m, or 4mCapProjecting24m.

4mjoin_style0m
	  Specifies the line join-style you want to set for
	  the specified GC.  You can pass 4mJoinMiter24m, 4mJoin-0m
	  4mRound24m, or 4mJoinBevel24m.
|__

4mXSetLineAttributes24m can generate 4mBadAlloc24m, 4mBadGC24m, and 4mBad-0m
4mValue24m errors.


To set the dash-offset and dash-list for dashed line styles
of a given GC, use 4mXSetDashes24m.


















			     1m2050m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
XSetDashes(4mdisplay24m, 4mgc24m, 4mdash_offset24m, 4mdash_list24m, 4mn24m)
	Display *4mdisplay24m;
	GC 4mgc24m;
	int 4mdash_offset24m;
	char 4mdash_list24m[];
	int 4mn24m;


4mdisplay24m   Specifies the connection to the X server.

4mgc24m	       Specifies the GC.

4mdash_offset0m
	  Specifies the phase of the pattern for the dashed
	  line-style you want to set for the specified GC.

4mdash_list24m Specifies the dash-list for the dashed line-style
	  you want to set for the specified GC.

4mn24m	       Specifies the number of elements in dash_list.
|__

The 4mXSetDashes24m function sets the dash-offset and dash-list
attributes for dashed line styles in the specified GC.
There must be at least one element in the specified
dash_list, or a 4mBadValue24m error results.  The initial and
alternating elements (second, fourth, and so on) of the
dash_list are the even dashes, and the others are the odd
dashes.	 Each element specifies a dash length in pixels.
All of the elements must be nonzero, or a 4mBadValue24m error
results.  Specifying an odd-length list is equivalent to
specifying the same list concatenated with itself to produce
an even-length list.

The dash-offset defines the phase of the pattern, specifying
how many pixels into the dash-list the pattern should actu-
ally begin in any single graphics request.  Dashing is con-
tinuous through path elements combined with a join-style but
is reset to the dash-offset between each sequence of joined
lines.

The unit of measure for dashes is the same for the ordinary
coordinate system.  Ideally, a dash length is measured along
the slope of the line, but implementations are only required
to match this ideal for horizontal and vertical lines.
Failing the ideal semantics, it is suggested that the length
be measured along the major axis of the line.  The major
axis is defined as the x axis for lines drawn at an angle of
between -45 and +45 degrees or between 135 and 225 degrees
from the x axis.  For all other lines, the major axis is the
y axis.





			     1m2060m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


4mXSetDashes24m can generate 4mBadAlloc24m, 4mBadGC24m, and 4mBadValue0m
errors.

1m7.2.3.  Setting the Fill Style and Fill Rule0m

To set the fill-style of a given GC, use 4mXSetFillStyle24m.
__
|
XSetFillStyle(4mdisplay24m, 4mgc24m, 4mfill_style24m)
      Display *4mdisplay24m;
      GC 4mgc24m;
      int 4mfill_style24m;


4mdisplay24m   Specifies the connection to the X server.

4mgc24m	       Specifies the GC.

4mfill_style0m
	  Specifies the fill-style you want to set for the
	  specified GC.	 You can pass 4mFillSolid24m, 4mFillTiled24m,
	  4mFillStippled24m, or 4mFillOpaqueStippled24m.
|__

4mXSetFillStyle24m can generate 4mBadAlloc24m, 4mBadGC24m, and 4mBadValue0m
errors.


To set the fill-rule of a given GC, use 4mXSetFillRule24m.
__
|
XSetFillRule(4mdisplay24m, 4mgc24m, 4mfill_rule24m)
      Display *4mdisplay24m;
      GC 4mgc24m;
      int 4mfill_rule24m;


4mdisplay24m   Specifies the connection to the X server.

4mgc24m	       Specifies the GC.

4mfill_rule24m Specifies the fill-rule you want to set for the
	  specified GC.	 You can pass 4mEvenOddRule24m or 4mWindin-0m
	  4mgRule24m.
|__

4mXSetFillRule24m can generate 4mBadAlloc24m, 4mBadGC24m, and 4mBadValue0m
errors.

1m7.2.4.  Setting the Fill Tile and Stipple0m

Some displays have hardware support for tiling or stippling
with patterns of specific sizes.  Tiling and stippling oper-
ations that restrict themselves to those specific sizes run



			     1m2070m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


much faster than such operations with arbitrary size pat-
terns.	Xlib provides functions that you can use to deter-
mine the best size, tile, or stipple for the display as well
as to set the tile or stipple shape and the tile or stipple
origin.


To obtain the best size of a tile, stipple, or cursor, use
4mXQueryBestSize24m.
__
|
Status XQueryBestSize(4mdisplay24m, 4mclass24m, 4mwhich_screen24m, 4mwidth24m, 4mheight24m, 4mwidth_return24m, 4mheight_return24m)
      Display *4mdisplay24m;
      int 4mclass24m;
      Drawable 4mwhich_screen24m;
      unsigned int 4mwidth24m, 4mheight24m;
      unsigned int *4mwidth_return24m, *4mheight_return24m;


4mdisplay24m   Specifies the connection to the X server.

4mclass24m     Specifies the class that you are interested in.
	  You can pass 4mTileShape24m, 4mCursorShape24m, or 4mStipple-0m
	  4mShape24m.

4mwhich_screen0m
	  Specifies any drawable on the screen.

4mwidth0m
4mheight24m    Specify the width and height.

4mwidth_return0m
4mheight_return0m
	  Return the width and height of the object best
	  supported by the display hardware.
|__

The 4mXQueryBestSize24m function returns the best or closest size
to the specified size.	For 4mCursorShape24m, this is the largest
size that can be fully displayed on the screen specified by
which_screen.  For 4mTileShape24m, this is the size that can be
tiled fastest.	For 4mStippleShape24m, this is the size that can
be stippled fastest.  For 4mCursorShape24m, the drawable indi-
cates the desired screen.  For 4mTileShape24m and 4mStippleShape24m,
the drawable indicates the screen and possibly the window
class and depth.  An 4mInputOnly24m window cannot be used as the
drawable for 4mTileShape24m or 4mStippleShape24m, or a 4mBadMatch24m error
results.

4mXQueryBestSize24m can generate 4mBadDrawable24m, 4mBadMatch24m, and 4mBad-0m
4mValue24m errors.


To obtain the best fill tile shape, use 4mXQueryBestTile24m.



			     1m2080m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
Status XQueryBestTile(4mdisplay24m, 4mwhich_screen24m, 4mwidth24m, 4mheight24m, 4mwidth_return24m, 4mheight_return24m)
      Display *4mdisplay24m;
      Drawable 4mwhich_screen24m;
      unsigned int 4mwidth24m, 4mheight24m;
      unsigned int *4mwidth_return24m, *4mheight_return24m;


4mdisplay24m   Specifies the connection to the X server.

4mwhich_screen0m
	  Specifies any drawable on the screen.

4mwidth0m
4mheight24m    Specify the width and height.

4mwidth_return0m
4mheight_return0m
	  Return the width and height of the object best
	  supported by the display hardware.
|__

The 4mXQueryBestTile24m function returns the best or closest
size, that is, the size that can be tiled fastest on the
screen specified by which_screen.  The drawable indicates
the screen and possibly the window class and depth.  If an
4mInputOnly24m window is used as the drawable, a 4mBadMatch24m error
results.

4mXQueryBestTile24m can generate 4mBadDrawable24m and 4mBadMatch24m errors.


To obtain the best stipple shape, use 4mXQueryBestStipple24m.
























			     1m2090m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
Status XQueryBestStipple(4mdisplay24m, 4mwhich_screen24m, 4mwidth24m, 4mheight24m, 4mwidth_return24m, 4mheight_return24m)
      Display *4mdisplay24m;
      Drawable 4mwhich_screen24m;
      unsigned int 4mwidth24m, 4mheight24m;
      unsigned int *4mwidth_return24m, *4mheight_return24m;


4mdisplay24m   Specifies the connection to the X server.

4mwhich_screen0m
	  Specifies any drawable on the screen.

4mwidth0m
4mheight24m    Specify the width and height.

4mwidth_return0m
4mheight_return0m
	  Return the width and height of the object best
	  supported by the display hardware.
|__

The 4mXQueryBestStipple24m function returns the best or closest
size, that is, the size that can be stippled fastest on the
screen specified by which_screen.  The drawable indicates
the screen and possibly the window class and depth.  If an
4mInputOnly24m window is used as the drawable, a 4mBadMatch24m error
results.

4mXQueryBestStipple24m can generate 4mBadDrawable24m and 4mBadMatch0m
errors.


To set the fill tile of a given GC, use 4mXSetTile24m.
__
|
XSetTile(4mdisplay24m, 4mgc24m, 4mtile24m)
      Display *4mdisplay24m;
      GC 4mgc24m;
      Pixmap 4mtile24m;


4mdisplay24m   Specifies the connection to the X server.

4mgc24m	       Specifies the GC.

4mtile24m      Specifies the fill tile you want to set for the
	  specified GC.
|__

The tile and GC must have the same depth, or a 4mBadMatch0m
error results.





			     1m2100m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


4mXSetTile24m can generate 4mBadAlloc24m, 4mBadGC24m, 4mBadMatch24m, and 4mBad-0m
4mPixmap24m errors.


To set the stipple of a given GC, use 4mXSetStipple24m.
__
|
XSetStipple(4mdisplay24m, 4mgc24m, 4mstipple24m)
      Display *4mdisplay24m;
      GC 4mgc24m;
      Pixmap 4mstipple24m;


4mdisplay24m   Specifies the connection to the X server.

4mgc24m	       Specifies the GC.

4mstipple24m   Specifies the stipple you want to set for the
	  specified GC.
|__

The stipple must have a depth of one, or a 4mBadMatch24m error
results.

4mXSetStipple24m can generate 4mBadAlloc24m, 4mBadGC24m, 4mBadMatch24m, and 4mBad-0m
4mPixmap24m errors.


To set the tile or stipple origin of a given GC, use
4mXSetTSOrigin24m.
__
|
XSetTSOrigin(4mdisplay24m, 4mgc24m, 4mts_x_origin24m, 4mts_y_origin24m)
      Display *4mdisplay24m;
      GC 4mgc24m;
      int 4mts_x_origin24m, 4mts_y_origin24m;


4mdisplay24m   Specifies the connection to the X server.

4mgc24m	       Specifies the GC.

4mts_x_origin0m
4mts_y_origin0m
	  Specify the x and y coordinates of the tile and
	  stipple origin.
|__

When graphics requests call for tiling or stippling, the
parent's origin will be interpreted relative to whatever
destination drawable is specified in the graphics request.

4mXSetTSOrigin24m can generate 4mBadAlloc24m and 4mBadGC24m errors.




			     1m2110m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


1m7.2.5.  Setting the Current Font0m

To set the current font of a given GC, use 4mXSetFont24m.
__
|
XSetFont(4mdisplay24m, 4mgc24m, 4mfont24m)
      Display *4mdisplay24m;
      GC 4mgc24m;
      Font 4mfont24m;


4mdisplay24m   Specifies the connection to the X server.

4mgc24m	       Specifies the GC.

4mfont24m      Specifies the font.
|__

4mXSetFont24m can generate 4mBadAlloc24m, 4mBadFont24m, and 4mBadGC24m errors.

1m7.2.6.  Setting the Clip Region0m

Xlib provides functions that you can use to set the clip-
origin and the clip-mask or set the clip-mask to a list of
rectangles.


To set the clip-origin of a given GC, use 4mXSetClipOrigin24m.
__
|
XSetClipOrigin(4mdisplay24m, 4mgc24m, 4mclip_x_origin24m, 4mclip_y_origin24m)
      Display *4mdisplay24m;
      GC 4mgc24m;
      int 4mclip_x_origin24m, 4mclip_y_origin24m;


4mdisplay24m   Specifies the connection to the X server.

4mgc24m	       Specifies the GC.

4mclip_x_origin0m
4mclip_y_origin0m
	  Specify the x and y coordinates of the clip-mask
	  origin.
|__

The clip-mask origin is interpreted relative to the origin
of whatever destination drawable is specified in the graph-
ics request.

4mXSetClipOrigin24m can generate 4mBadAlloc24m and 4mBadGC24m errors.


To set the clip-mask of a given GC to the specified pixmap,



			     1m2120m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


use 4mXSetClipMask24m.
__
|
XSetClipMask(4mdisplay24m, 4mgc24m, 4mpixmap24m)
      Display *4mdisplay24m;
      GC 4mgc24m;
      Pixmap 4mpixmap24m;


4mdisplay24m   Specifies the connection to the X server.

4mgc24m	       Specifies the GC.

4mpixmap24m    Specifies the pixmap or 4mNone24m.
|__

If the clip-mask is set to 4mNone24m, the pixels are always drawn
(regardless of the clip-origin).

4mXSetClipMask24m can generate 4mBadAlloc24m, 4mBadGC24m, 4mBadMatch24m, and
4mBadPixmap24m errors.


To set the clip-mask of a given GC to the specified list of
rectangles, use 4mXSetClipRectangles24m.
































			     1m2130m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
XSetClipRectangles(4mdisplay24m, 4mgc24m, 4mclip_x_origin24m, 4mclip_y_origin24m, 4mrectangles24m, 4mn24m, 4mordering24m)
      Display *4mdisplay24m;
      GC 4mgc24m;
      int 4mclip_x_origin24m, 4mclip_y_origin24m;
      XRectangle 4mrectangles24m[];
      int 4mn24m;
      int 4mordering24m;


4mdisplay24m   Specifies the connection to the X server.

4mgc24m	       Specifies the GC.

4mclip_x_origin0m
4mclip_y_origin0m
	  Specify the x and y coordinates of the clip-mask
	  origin.

4mrectangles0m
	  Specifies an array of rectangles that define the
	  clip-mask.

4mn24m	       Specifies the number of rectangles.

4mordering24m  Specifies the ordering relations on the rectan-
	  gles.	 You can pass 4mUnsorted24m, 4mYSorted24m, 4mYXSorted24m,
	  or 4mYXBanded24m.
|__

The 4mXSetClipRectangles24m function changes the clip-mask in the
specified GC to the specified list of rectangles and sets
the clip origin.  The output is clipped to remain contained
within the rectangles.	The clip-origin is interpreted rela-
tive to the origin of whatever destination drawable is spec-
ified in a graphics request.  The rectangle coordinates are
interpreted relative to the clip-origin.  The rectangles
should be nonintersecting, or the graphics results will be
undefined.  Note that the list of rectangles can be empty,
which effectively disables output.  This is the opposite of
passing 4mNone24m as the clip-mask in 4mXCreateGC24m, 4mXChangeGC24m, and
4mXSetClipMask24m.

If known by the client, ordering relations on the rectangles
can be specified with the ordering argument.  This may pro-
vide faster operation by the server.  If an incorrect order-
ing is specified, the X server may generate a 4mBadMatch0m
error, but it is not required to do so.	 If no error is gen-
erated, the graphics results are undefined.  4mUnsorted24m means
the rectangles are in arbitrary order.	4mYSorted24m means that
the rectangles are nondecreasing in their Y origin.
4mYXSorted24m additionally constrains 4mYSorted24m order in that all
rectangles with an equal Y origin are nondecreasing in their
X origin.  4mYXBanded24m additionally constrains 4mYXSorted24m by



			     1m2140m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


requiring that, for every possible Y scanline, all rectan-
gles that include that scanline have an identical Y origins
and Y extents.

4mXSetClipRectangles24m can generate 4mBadAlloc24m, 4mBadGC24m, 4mBadMatch24m,
and 4mBadValue24m errors.

Xlib provides a set of basic functions for performing region
arithmetic.  For information about these functions, see sec-
tion 16.5.

1m7.2.7.  Setting the Arc Mode, Subwindow Mode, and Graphics0m
1mExposure0m

To set the arc mode of a given GC, use 4mXSetArcMode24m.
__
|
XSetArcMode(4mdisplay24m, 4mgc24m, 4marc_mode24m)
      Display *4mdisplay24m;
      GC 4mgc24m;
      int 4marc_mode24m;


4mdisplay24m   Specifies the connection to the X server.

4mgc24m	       Specifies the GC.

4marc_mode24m  Specifies the arc mode.	You can pass 4mArcChord24m or
	  4mArcPieSlice24m.
|__

4mXSetArcMode24m can generate 4mBadAlloc24m, 4mBadGC24m, and 4mBadValue0m
errors.


To set the subwindow mode of a given GC, use 4mXSetSubwindow-0m
4mMode24m.




















			     1m2150m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
XSetSubwindowMode(4mdisplay24m, 4mgc24m, 4msubwindow_mode24m)
      Display *4mdisplay24m;
      GC 4mgc24m;
      int 4msubwindow_mode24m;


4mdisplay24m   Specifies the connection to the X server.

4mgc24m	       Specifies the GC.

4msubwindow_mode0m
	  Specifies the subwindow mode.	 You can pass 4mClip-0m
	  4mByChildren24m or 4mIncludeInferiors24m.
|__

4mXSetSubwindowMode24m can generate 4mBadAlloc24m, 4mBadGC24m, and 4mBadValue0m
errors.


To set the graphics-exposures flag of a given GC, use 4mXSet-0m
4mGraphicsExposures24m.
__
|
XSetGraphicsExposures(4mdisplay24m, 4mgc24m, 4mgraphics_exposures24m)
      Display *4mdisplay24m;
      GC 4mgc24m;
      Bool 4mgraphics_exposures24m;


4mdisplay24m   Specifies the connection to the X server.

4mgc24m	       Specifies the GC.

4mgraphics_exposures0m
	  Specifies a Boolean value that indicates whether
	  you want 4mGraphicsExpose24m and 4mNoExpose24m events to be
	  reported when calling 4mXCopyArea24m and 4mXCopyPlane0m
	  with this GC.
|__

4mXSetGraphicsExposures24m can generate 4mBadAlloc24m, 4mBadGC24m, and 4mBad-0m
4mValue24m errors.














			     1m2160m





1mXlib - C Library			X11, Release 6.7 DRAFT0m




			 1mChapter 80m

		     1mGraphics Functions0m



Once you have established a connection to a display, you can
use the Xlib graphics functions to:

·    Clear and copy areas

·    Draw points, lines, rectangles, and arcs

·    Fill areas

·    Manipulate fonts

·    Draw text

·    Transfer images between clients and the server

If the same drawable and GC is used for each call, Xlib
batches back-to-back calls to 4mXDrawPoint24m, 4mXDrawLine24m,
4mXDrawRectangle24m, 4mXFillArc24m, and 4mXFillRectangle24m.  Note that
this reduces the total number of requests sent to the
server.

1m8.1.	Clearing Areas0m

Xlib provides functions that you can use to clear an area or
the entire window.  Because pixmaps do not have defined
backgrounds, they cannot be filled by using the functions
described in this section.  Instead, to accomplish an analo-
gous operation on a pixmap, you should use 4mXFillRectangle24m,
which sets the pixmap to a known value.


To clear a rectangular area of a given window, use 4mXClear-0m
4mArea24m.
















			     1m2170m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
XClearArea(4mdisplay24m, 4mw24m, 4mx24m, 4my24m, 4mwidth24m, 4mheight24m, 4mexposures24m)
      Display *4mdisplay24m;
      Window 4mw24m;
      int 4mx24m, 4my24m;
      unsigned int 4mwidth24m, 4mheight24m;
      Bool 4mexposures24m;


4mdisplay24m   Specifies the connection to the X server.

4mw24m	       Specifies the window.

4mx0m
4my24m	       Specify the x and y coordinates, which are rela-
	  tive to the origin of the window and specify the
	  upper-left corner of the rectangle.

4mwidth0m
4mheight24m    Specify the width and height, which are the dimen-
	  sions of the rectangle.

4mexposures24m Specifies a Boolean value that indicates if 4mExpose0m
	  events are to be generated.
|__

The 4mXClearArea24m function paints a rectangular area in the
specified window according to the specified dimensions with
the window's background pixel or pixmap.  The subwindow-mode
effectively is 4mClipByChildren24m.  If width is zero, it is
replaced with the current width of the window minus x.	If
height is zero, it is replaced with the current height of
the window minus y.  If the window has a defined background
tile, the rectangle clipped by any children is filled with
this tile.  If the window has background 4mNone24m, the contents
of the window are not changed.	In either case, if exposures
is 4mTrue24m, one or more 4mExpose24m events are generated for regions
of the rectangle that are either visible or are being
retained in a backing store.  If you specify a window whose
class is 4mInputOnly24m, a 4mBadMatch24m error results.

4mXClearArea24m can generate 4mBadMatch24m, 4mBadValue24m, and 4mBadWindow0m
errors.


To clear the entire area in a given window, use 4mXClearWin-0m
4mdow24m.










			     1m2180m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
XClearWindow(4mdisplay24m, 4mw24m)
      Display *4mdisplay24m;
      Window 4mw24m;


4mdisplay24m   Specifies the connection to the X server.

4mw24m	       Specifies the window.
|__

The 4mXClearWindow24m function clears the entire area in the
specified window and is equivalent to 4mXClearArea24m (display,
w, 0, 0, 0, 0, 4mFalse24m).  If the window has a defined back-
ground tile, the rectangle is tiled with a plane-mask of all
ones and 4mGXcopy24m function.	If the window has background
4mNone24m, the contents of the window are not changed.	If you
specify a window whose class is 4mInputOnly24m, a 4mBadMatch24m error
results.

4mXClearWindow24m can generate 4mBadMatch24m and 4mBadWindow24m errors.

1m8.2.	Copying Areas0m

Xlib provides functions that you can use to copy an area or
a bit plane.


To copy an area between drawables of the same root and
depth, use 4mXCopyArea24m.



























			     1m2190m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
XCopyArea(4mdisplay24m, 4msrc24m, 4mdest24m, 4mgc24m, 4msrc_x24m, 4msrc_y24m, 4mwidth24m, 4mheight24m,	4mdest_x24m, 4mdest_y24m)
      Display *4mdisplay24m;
      Drawable 4msrc24m, 4mdest24m;
      GC 4mgc24m;
      int 4msrc_x24m, 4msrc_y24m;
      unsigned int 4mwidth24m, 4mheight24m;
      int 4mdest_x24m, 4mdest_y24m;


4mdisplay24m   Specifies the connection to the X server.

4msrc0m
4mdest24m      Specify the source and destination rectangles to
	  be combined.

4mgc24m	       Specifies the GC.

4msrc_x0m
4msrc_y24m     Specify the x and y coordinates, which are rela-
	  tive to the origin of the source rectangle and
	  specify its upper-left corner.

4mwidth0m
4mheight24m    Specify the width and height, which are the dimen-
	  sions of both the source and destination rectan-
	  gles.

4mdest_x0m
4mdest_y24m    Specify the x and y coordinates, which are rela-
	  tive to the origin of the destination rectangle
	  and specify its upper-left corner.
|__

The 4mXCopyArea24m function combines the specified rectangle of
src with the specified rectangle of dest.  The drawables
must have the same root and depth, or a 4mBadMatch24m error
results.

If regions of the source rectangle are obscured and have not
been retained in backing store or if regions outside the
boundaries of the source drawable are specified, those
regions are not copied.	 Instead, the following occurs on
all corresponding destination regions that are either visi-
ble or are retained in backing store.  If the destination is
a window with a background other than 4mNone24m, corresponding
regions of the destination are tiled with that background
(with plane-mask of all ones and 4mGXcopy24m function).	 Regard-
less of tiling or whether the destination is a window or a
pixmap, if graphics-exposures is 4mTrue24m, then 4mGraphicsExpose0m
events for all corresponding destination regions are gener-
ated.  If graphics-exposures is 4mTrue24m but no 4mGraphicsExpose0m
events are generated, a 4mNoExpose24m event is generated.  Note
that by default graphics-exposures is 4mTrue24m in new GCs.



			     1m2200m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


This function uses these GC components: function, plane-
mask, subwindow-mode, graphics-exposures, clip-x-origin,
clip-y-origin, and clip-mask.

4mXCopyArea24m can generate 4mBadDrawable24m, 4mBadGC24m, and 4mBadMatch0m
errors.


To copy a single bit plane of a given drawable, use 4mXCopy-0m
4mPlane24m.
__
|
XCopyPlane(4mdisplay24m, 4msrc24m, 4mdest24m, 4mgc24m, 4msrc_x24m, 4msrc_y24m, 4mwidth24m, 4mheight24m, 4mdest_x24m, 4mdest_y24m, 4mplane24m)
      Display *4mdisplay24m;
      Drawable 4msrc24m, 4mdest24m;
      GC 4mgc24m;
      int 4msrc_x24m, 4msrc_y24m;
      unsigned int 4mwidth24m, 4mheight24m;
      int 4mdest_x24m, 4mdest_y24m;
      unsigned long 4mplane24m;


4mdisplay24m   Specifies the connection to the X server.

4msrc0m
4mdest24m      Specify the source and destination rectangles to
	  be combined.

4mgc24m	       Specifies the GC.

4msrc_x0m
4msrc_y24m     Specify the x and y coordinates, which are rela-
	  tive to the origin of the source rectangle and
	  specify its upper-left corner.

4mwidth0m
4mheight24m    Specify the width and height, which are the dimen-
	  sions of both the source and destination rectan-
	  gles.

4mdest_x0m
4mdest_y24m    Specify the x and y coordinates, which are rela-
	  tive to the origin of the destination rectangle
	  and specify its upper-left corner.

4mplane24m     Specifies the bit plane.	 You must set exactly one
	  bit to 1.
|__

The 4mXCopyPlane24m function uses a single bit plane of the spec-
ified source rectangle combined with the specified GC to
modify the specified rectangle of dest.	 The drawables must
have the same root but need not have the same depth.  If the
drawables do not have the same root, a 4mBadMatch24m error



			     1m2210m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


results.  If plane does not have exactly one bit set to 1
and the value of plane is not less than 24mn24m, where 4mn24m is the
depth of src, a 4mBadValue24m error results.

Effectively, 4mXCopyPlane24m forms a pixmap of the same depth as
the rectangle of dest and with a size specified by the
source region.	It uses the foreground/background pixels in
the GC (foreground everywhere the bit plane in src contains
a bit set to 1, background everywhere the bit plane in src
contains a bit set to 0) and the equivalent of a 4mCopyArea0m
protocol request is performed with all the same exposure
semantics.  This can also be thought of as using the speci-
fied region of the source bit plane as a stipple with a
fill-style of 4mFillOpaqueStippled24m for filling a rectangular
area of the destination.

This function uses these GC components: function, plane-
mask, foreground, background, subwindow-mode, graphics-expo-
sures, clip-x-origin, clip-y-origin, and clip-mask.

4mXCopyPlane24m can generate 4mBadDrawable24m, 4mBadGC24m, 4mBadMatch24m, and
4mBadValue24m errors.

1m8.3.	Drawing Points, Lines, Rectangles, and Arcs0m

Xlib provides functions that you can use to draw:

·    A single point or multiple points

·    A single line or multiple lines

·    A single rectangle or multiple rectangles

·    A single arc or multiple arcs

Some of the functions described in the following sections
use these structures:

__
|
typedef struct {
     short x1, y1, x2, y2;
} XSegment;

|__












			     1m2220m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
typedef struct {
     short x, y;
} XPoint;

|__

__
|
typedef struct {
     short x, y;
     unsigned short width, height;
} XRectangle;

|__

__
|
typedef struct {
     short x, y;
     unsigned short width, height;
     short angle1, angle2;	       /* Degrees * 64 */
} XArc;

|__

All x and y members are signed integers.  The width and
height members are 16-bit unsigned integers.  You should be
careful not to generate coordinates and sizes out of the
16-bit ranges, because the protocol only has 16-bit fields
for these values.

1m8.3.1.  Drawing Single and Multiple Points0m


To draw a single point in a given drawable, use 4mXDrawPoint24m.





















			     1m2230m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
XDrawPoint(4mdisplay24m, 4md24m, 4mgc24m, 4mx24m, 4my24m)
      Display *4mdisplay24m;
      Drawable 4md24m;
      GC 4mgc24m;
      int 4mx24m, 4my24m;


4mdisplay24m   Specifies the connection to the X server.

4md24m	       Specifies the drawable.

4mgc24m	       Specifies the GC.

4mx0m
4my24m	       Specify the x and y coordinates where you want the
	  point drawn.
|__


To draw multiple points in a given drawable, use 4mXDraw-0m
4mPoints24m.
__
|
XDrawPoints(4mdisplay24m, 4md24m, 4mgc24m, 4mpoints24m, 4mnpoints24m, 4mmode24m)
      Display *4mdisplay24m;
      Drawable 4md24m;
      GC 4mgc24m;
      XPoint *4mpoints24m;
      int 4mnpoints24m;
      int 4mmode24m;


4mdisplay24m   Specifies the connection to the X server.

4md24m	       Specifies the drawable.

4mgc24m	       Specifies the GC.

4mpoints24m    Specifies an array of points.

4mnpoints24m   Specifies the number of points in the array.

4mmode24m      Specifies the coordinate mode.  You can pass
	  4mCoordModeOrigin24m or 4mCoordModePrevious24m.
|__

The 4mXDrawPoint24m function uses the foreground pixel and func-
tion components of the GC to draw a single point into the
specified drawable; 4mXDrawPoints24m draws multiple points this
way.  4mCoordModeOrigin24m treats all coordinates as relative to
the origin, and 4mCoordModePrevious24m treats all coordinates
after the first as relative to the previous point.  4mXDraw-0m
4mPoints24m draws the points in the order listed in the array.



			     1m2240m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


Both functions use these GC components: function, plane-
mask, foreground, subwindow-mode, clip-x-origin, clip-y-ori-
gin, and clip-mask.

4mXDrawPoint24m can generate 4mBadDrawable24m, 4mBadGC24m, and 4mBadMatch0m
errors.	 4mXDrawPoints24m can generate 4mBadDrawable24m, 4mBadGC24m, 4mBad-0m
4mMatch24m, and 4mBadValue24m errors.

1m8.3.2.  Drawing Single and Multiple Lines0m


To draw a single line between two points in a given draw-
able, use 4mXDrawLine24m.
__
|
XDrawLine(4mdisplay24m, 4md24m, 4mgc24m, 4mx124m, 4my124m, 4mx224m, 4my224m)
      Display *4mdisplay24m;
      Drawable 4md24m;
      GC 4mgc24m;
      int 4mx124m, 4my124m, 4mx224m, 4my224m;


4mdisplay24m   Specifies the connection to the X server.

4md24m	       Specifies the drawable.

4mgc24m	       Specifies the GC.

4mx10m
4my10m
4mx20m
4my224m	       Specify the points (x1, y1) and (x2, y2) to be
	  connected.
|__


To draw multiple lines in a given drawable, use 4mXDrawLines24m.




















			     1m2250m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
XDrawLines(4mdisplay24m, 4md24m, 4mgc24m, 4mpoints24m, 4mnpoints24m, 4mmode24m)
      Display *4mdisplay24m;
      Drawable 4md24m;
      GC 4mgc24m;
      XPoint *4mpoints24m;
      int 4mnpoints24m;
      int 4mmode24m;


4mdisplay24m   Specifies the connection to the X server.

4md24m	       Specifies the drawable.

4mgc24m	       Specifies the GC.

4mpoints24m    Specifies an array of points.

4mnpoints24m   Specifies the number of points in the array.

4mmode24m      Specifies the coordinate mode.  You can pass
	  4mCoordModeOrigin24m or 4mCoordModePrevious24m.
|__


To draw multiple, unconnected lines in a given drawable, use
4mXDrawSegments24m.
__
|
XDrawSegments(4mdisplay24m, 4md24m, 4mgc24m, 4msegments24m, 4mnsegments24m)
      Display *4mdisplay24m;
      Drawable 4md24m;
      GC 4mgc24m;
      XSegment *4msegments24m;
      int 4mnsegments24m;


4mdisplay24m   Specifies the connection to the X server.

4md24m	       Specifies the drawable.

4mgc24m	       Specifies the GC.

4msegments24m  Specifies an array of segments.

4mnsegments24m Specifies the number of segments in the array.
|__

The 4mXDrawLine24m function uses the components of the specified
GC to draw a line between the specified set of points (x1,
y1) and (x2, y2).  It does not perform joining at coincident
endpoints.  For any given line, 4mXDrawLine24m does not draw a
pixel more than once.  If lines intersect, the intersecting
pixels are drawn multiple times.



			     1m2260m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


The 4mXDrawLines24m function uses the components of the specified
GC to draw npoints-1 lines between each pair of points
(point[i], point[i+1]) in the array of 4mXPoint24m structures.
It draws the lines in the order listed in the array.  The
lines join correctly at all intermediate points, and if the
first and last points coincide, the first and last lines
also join correctly.  For any given line, 4mXDrawLines24m does
not draw a pixel more than once.  If thin (zero line-width)
lines intersect, the intersecting pixels are drawn multiple
times.	If wide lines intersect, the intersecting pixels are
drawn only once, as though the entire 4mPolyLine24m protocol
request were a single, filled shape.  4mCoordModeOrigin24m treats
all coordinates as relative to the origin, and 4mCoordModePre-0m
4mvious24m treats all coordinates after the first as relative to
the previous point.

The 4mXDrawSegments24m function draws multiple, unconnected
lines.	For each segment, 4mXDrawSegments24m draws a line between
(x1, y1) and (x2, y2).	It draws the lines in the order
listed in the array of 4mXSegment24m structures and does not per-
form joining at coincident endpoints.  For any given line,
4mXDrawSegments24m does not draw a pixel more than once.  If
lines intersect, the intersecting pixels are drawn multiple
times.

All three functions use these GC components: function,
plane-mask, line-width, line-style, cap-style, fill-style,
subwindow-mode, clip-x-origin, clip-y-origin, and clip-mask.
The 4mXDrawLines24m function also uses the join-style GC compo-
nent.  All three functions also use these GC mode-dependent
components: foreground, background, tile, stipple, tile-
stipple-x-origin, tile-stipple-y-origin, dash-offset, and
dash-list.

4mXDrawLine24m, 4mXDrawLines24m, and 4mXDrawSegments24m can generate 4mBad-0m
4mDrawable24m, 4mBadGC24m, and 4mBadMatch24m errors.  4mXDrawLines24m also can
generate 4mBadValue24m errors.

1m8.3.3.  Drawing Single and Multiple Rectangles0m


To draw the outline of a single rectangle in a given draw-
able, use 4mXDrawRectangle24m.














			     1m2270m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
XDrawRectangle(4mdisplay24m, 4md24m, 4mgc24m, 4mx24m, 4my24m, 4mwidth24m, 4mheight24m)
      Display *4mdisplay24m;
      Drawable 4md24m;
      GC 4mgc24m;
      int 4mx24m, 4my24m;
      unsigned int 4mwidth24m, 4mheight24m;


4mdisplay24m   Specifies the connection to the X server.

4md24m	       Specifies the drawable.

4mgc24m	       Specifies the GC.

4mx0m
4my24m	       Specify the x and y coordinates, which specify the
	  upper-left corner of the rectangle.

4mwidth0m
4mheight24m    Specify the width and height, which specify the
	  dimensions of the rectangle.
|__


To draw the outline of multiple rectangles in a given draw-
able, use 4mXDrawRectangles24m.
__
|
XDrawRectangles(4mdisplay24m, 4md24m, 4mgc24m, 4mrectangles24m, 4mnrectangles24m)
      Display *4mdisplay24m;
      Drawable 4md24m;
      GC 4mgc24m;
      XRectangle 4mrectangles24m[];
      int 4mnrectangles24m;


4mdisplay24m   Specifies the connection to the X server.

4md24m	       Specifies the drawable.

4mgc24m	       Specifies the GC.

4mrectangles0m
	  Specifies an array of rectangles.

4mnrectangles0m
	  Specifies the number of rectangles in the array.
|__

The 4mXDrawRectangle24m and 4mXDrawRectangles24m functions draw the
outlines of the specified rectangle or rectangles as if a
five-point 4mPolyLine24m protocol request were specified for each
rectangle:



			     1m2280m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


     [x,y] [x+width,y] [x+width,y+height] [x,y+height] [x,y]

For the specified rectangle or rectangles, these functions
do not draw a pixel more than once.  4mXDrawRectangles24m draws
the rectangles in the order listed in the array.  If rectan-
gles intersect, the intersecting pixels are drawn multiple
times.

Both functions use these GC components: function, plane-
mask, line-width, line-style, cap-style, join-style, fill-
style, subwindow-mode, clip-x-origin, clip-y-origin, and
clip-mask.  They also use these GC mode-dependent compo-
nents: foreground, background, tile, stipple, tile-stipple-
x-origin, tile-stipple-y-origin, dash-offset, and dash-list.

4mXDrawRectangle24m and 4mXDrawRectangles24m can generate 4mBadDrawable24m,
4mBadGC24m, and 4mBadMatch24m errors.

1m8.3.4.  Drawing Single and Multiple Arcs0m



To draw a single arc in a given drawable, use 4mXDrawArc24m.


































			     1m2290m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
XDrawArc(4mdisplay24m, 4md24m, 4mgc24m, 4mx24m, 4my24m, 4mwidth24m, 4mheight24m, 4mangle124m, 4mangle224m)
      Display *4mdisplay24m;
      Drawable 4md24m;
      GC 4mgc24m;
      int 4mx24m, 4my24m;
      unsigned int 4mwidth24m, 4mheight24m;
      int 4mangle124m, 4mangle224m;


4mdisplay24m   Specifies the connection to the X server.

4md24m	       Specifies the drawable.

4mgc24m	       Specifies the GC.

4mx0m
4my24m	       Specify the x and y coordinates, which are rela-
	  tive to the origin of the drawable and specify the
	  upper-left corner of the bounding rectangle.

4mwidth0m
4mheight24m    Specify the width and height, which are the major
	  and minor axes of the arc.

4mangle124m    Specifies the start of the arc relative to the
	  three-o'clock position from the center, in units
	  of degrees * 64.

4mangle224m    Specifies the path and extent of the arc relative
	  to the start of the arc, in units of degrees * 64.
|__


To draw multiple arcs in a given drawable, use 4mXDrawArcs24m.






















			     1m2300m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
XDrawArcs(4mdisplay24m, 4md24m, 4mgc24m, 4marcs24m, 4mnarcs24m)
      Display *4mdisplay24m;
      Drawable 4md24m;
      GC 4mgc24m;
      XArc *4marcs24m;
      int 4mnarcs24m;


4mdisplay24m   Specifies the connection to the X server.

4md24m	       Specifies the drawable.

4mgc24m	       Specifies the GC.

4marcs24m      Specifies an array of arcs.

4mnarcs24m     Specifies the number of arcs in the array.
|__


4mXDrawArc24m draws a single circular or elliptical arc, and
4mXDrawArcs24m draws multiple circular or elliptical arcs.  Each
arc is specified by a rectangle and two angles.	 The center
of the circle or ellipse is the center of the rectangle, and
the major and minor axes are specified by the width and
height.	 Positive angles indicate counterclockwise motion,
and negative angles indicate clockwise motion.	If the mag-
nitude of angle2 is greater than 360 degrees, 4mXDrawArc24m or
4mXDrawArcs24m truncates it to 360 degrees.

For an arc specified as [4mx24m,4my24m,4mwidth24m,4mheight24m,4mangle24m1,4mangle24m2],
the origin of the major and minor axes is at
[4mx24m+4m__24m4m___24m,4my24m+4m___24m4m___24m], and the infinitely thin path describing
the entire circle or ellipse intersects the horizontal axis
at [4mx24m,4my24m+4m___24m4m___24m] and [4mx24m+4mwidth24m,4my24m+4m___24m4m___24m] and intersects the
vertical axis at [4mx24m+4m__24m4m___24m,4my24m] and [4mx24m+4m__24m4m___24m,4my24m+4mheight24m].  These
coordinates can be fractional and so are not truncated to
discrete coordinates.  The path should be defined by the
ideal mathematical path.  For a wide line with line-width
lw, the bounding outlines for filling are given by the two
infinitely thin paths consisting of all points whose perpen-
dicular distance from the path of the circle/ellipse is
equal to lw/2 (which may be a fractional value).  The cap-
style and join-style are applied the same as for a line cor-
responding to the tangent of the circle/ellipse at the end-
point.

For an arc specified as [4mx24m,4my24m,4mwidth24m,4mheight24m,4mangle24m1,4mangle24m2],
the angles must be specified in the effectively skewed coor-
dinate system of the ellipse (for a circle, the angles and
coordinate systems are identical).  The relationship between
these angles and angles expressed in the normal coordinate
system of the screen (as measured with a protractor) is as



			     1m2310m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


follows:


     skewed-angle=4matan24m(tan(normal-angle)*4m______24m)+4madjust0m


The skewed-angle and normal-angle are expressed in radians
(rather than in degrees scaled by 64) in the range [0,2n]
and where atan returns a value in the range [-4m_24m,4m_24m] and
adjust is:


     0	       for normal-angle in the range [0,4m_24m]
     n	       for normal-angle in the range [4m_24m,4m_24m4m_24m]
     2n	       for normal-angle in the range [4m_24m4m_24m,2n]


For any given arc, 4mXDrawArc24m and 4mXDrawArcs24m do not draw a
pixel more than once.  If two arcs join correctly and if the
line-width is greater than zero and the arcs intersect,
4mXDrawArc24m and 4mXDrawArcs24m do not draw a pixel more than once.
Otherwise, the intersecting pixels of intersecting arcs are
drawn multiple times.  Specifying an arc with one endpoint
and a clockwise extent draws the same pixels as specifying
the other endpoint and an equivalent counterclockwise
extent, except as it affects joins.

If the last point in one arc coincides with the first point
in the following arc, the two arcs will join correctly.	 If
the first point in the first arc coincides with the last
point in the last arc, the two arcs will join correctly.  By
specifying one axis to be zero, a horizontal or vertical
line can be drawn.  Angles are computed based solely on the
coordinate system and ignore the aspect ratio.

Both functions use these GC components: function, plane-
mask, line-width, line-style, cap-style, join-style, fill-
style, subwindow-mode, clip-x-origin, clip-y-origin, and
clip-mask.  They also use these GC mode-dependent compo-
nents: foreground, background, tile, stipple, tile-stipple-
x-origin, tile-stipple-y-origin, dash-offset, and dash-list.

4mXDrawArc24m and 4mXDrawArcs24m can generate 4mBadDrawable24m, 4mBadGC24m, and
4mBadMatch24m errors.

1m8.4.	Filling Areas0m

Xlib provides functions that you can use to fill:

·    A single rectangle or multiple rectangles

·    A single polygon





			     1m2320m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


·    A single arc or multiple arcs

1m8.4.1.  Filling Single and Multiple Rectangles0m



To fill a single rectangular area in a given drawable, use
4mXFillRectangle24m.
__
|
XFillRectangle(4mdisplay24m, 4md24m, 4mgc24m, 4mx24m, 4my24m, 4mwidth24m, 4mheight24m)
      Display *4mdisplay24m;
      Drawable 4md24m;
      GC 4mgc24m;
      int 4mx24m, 4my24m;
      unsigned int 4mwidth24m, 4mheight24m;


4mdisplay24m   Specifies the connection to the X server.

4md24m	       Specifies the drawable.

4mgc24m	       Specifies the GC.

4mx0m
4my24m	       Specify the x and y coordinates, which are rela-
	  tive to the origin of the drawable and specify the
	  upper-left corner of the rectangle.

4mwidth0m
4mheight24m    Specify the width and height, which are the dimen-
	  sions of the rectangle to be filled.
|__


To fill multiple rectangular areas in a given drawable, use
4mXFillRectangles24m.




















			     1m2330m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
XFillRectangles(4mdisplay24m, 4md24m, 4mgc24m, 4mrectangles24m, 4mnrectangles24m)
      Display *4mdisplay24m;
      Drawable 4md24m;
      GC 4mgc24m;
      XRectangle *4mrectangles24m;
      int 4mnrectangles24m;


4mdisplay24m   Specifies the connection to the X server.

4md24m	       Specifies the drawable.

4mgc24m	       Specifies the GC.

4mrectangles0m
	  Specifies an array of rectangles.

4mnrectangles0m
	  Specifies the number of rectangles in the array.
|__

The 4mXFillRectangle24m and 4mXFillRectangles24m functions fill the
specified rectangle or rectangles as if a four-point
4mFillPolygon24m protocol request were specified for each rectan-
gle:


     [x,y] [x+width,y] [x+width,y+height] [x,y+height]


Each function uses the x and y coordinates, width and height
dimensions, and GC you specify.

4mXFillRectangles24m fills the rectangles in the order listed in
the array.  For any given rectangle, 4mXFillRectangle24m and
4mXFillRectangles24m do not draw a pixel more than once.  If rec-
tangles intersect, the intersecting pixels are drawn multi-
ple times.

Both functions use these GC components: function, plane-
mask, fill-style, subwindow-mode, clip-x-origin, clip-y-ori-
gin, and clip-mask.  They also use these GC mode-dependent
components: foreground, background, tile, stipple, tile-
stipple-x-origin, and tile-stipple-y-origin.

4mXFillRectangle24m and 4mXFillRectangles24m can generate 4mBadDrawable24m,
4mBadGC24m, and 4mBadMatch24m errors.

1m8.4.2.  Filling a Single Polygon0m


To fill a polygon area in a given drawable, use 4mXFillPoly-0m
4mgon24m.



			     1m2340m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
XFillPolygon(4mdisplay24m, 4md24m, 4mgc24m, 4mpoints24m, 4mnpoints24m, 4mshape24m, 4mmode24m)
      Display *4mdisplay24m;
      Drawable 4md24m;
      GC 4mgc24m;
      XPoint *4mpoints24m;
      int 4mnpoints24m;
      int 4mshape24m;
      int 4mmode24m;


4mdisplay24m   Specifies the connection to the X server.

4md24m	       Specifies the drawable.

4mgc24m	       Specifies the GC.

4mpoints24m    Specifies an array of points.

4mnpoints24m   Specifies the number of points in the array.

4mshape24m     Specifies a shape that helps the server to improve
	  performance.	You can pass 4mComplex24m, 4mConvex24m, or
	  4mNonconvex24m.

4mmode24m      Specifies the coordinate mode.  You can pass
	  4mCoordModeOrigin24m or 4mCoordModePrevious24m.
|__

4mXFillPolygon24m fills the region closed by the specified path.
The path is closed automatically if the last point in the
list does not coincide with the first point.  4mXFillPolygon0m
does not draw a pixel of the region more than once.  4mCoord-0m
4mModeOrigin24m treats all coordinates as relative to the origin,
and 4mCoordModePrevious24m treats all coordinates after the first
as relative to the previous point.

Depending on the specified shape, the following occurs:

·    If shape is 4mComplex24m, the path may self-intersect.  Note
     that contiguous coincident points in the path are not
     treated as self-intersection.

·    If shape is 4mConvex24m, for every pair of points inside the
     polygon, the line segment connecting them does not
     intersect the path.  If known by the client, specifying
     4mConvex24m can improve performance.  If you specify 4mConvex0m
     for a path that is not convex, the graphics results are
     undefined.

·    If shape is 4mNonconvex24m, the path does not self-inter-
     sect, but the shape is not wholly convex.	If known by
     the client, specifying 4mNonconvex24m instead of 4mComplex24m may
     improve performance.  If you specify 4mNonconvex24m for a



			     1m2350m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


     self-intersecting path, the graphics results are unde-
     fined.

The fill-rule of the GC controls the filling behavior of
self-intersecting polygons.

This function uses these GC components: function, plane-
mask, fill-style, fill-rule, subwindow-mode, clip-x-origin,
clip-y-origin, and clip-mask.  It also uses these GC mode-
dependent components: foreground, background, tile, stipple,
tile-stipple-x-origin, and tile-stipple-y-origin.

4mXFillPolygon24m can generate 4mBadDrawable24m, 4mBadGC24m, 4mBadMatch24m, and
4mBadValue24m errors.

1m8.4.3.  Filling Single and Multiple Arcs0m

To fill a single arc in a given drawable, use 4mXFillArc24m.
__
|
XFillArc(4mdisplay24m, 4md24m, 4mgc24m,	 4mx24m, 4my24m, 4mwidth24m, 4mheight24m, 4mangle124m, 4mangle224m)
      Display *4mdisplay24m;
      Drawable 4md24m;
      GC 4mgc24m;
      int 4mx24m, 4my24m;
      unsigned int 4mwidth24m, 4mheight24m;
      int 4mangle124m, 4mangle224m;


4mdisplay24m   Specifies the connection to the X server.

4md24m	       Specifies the drawable.

4mgc24m	       Specifies the GC.

4mx0m
4my24m	       Specify the x and y coordinates, which are rela-
	  tive to the origin of the drawable and specify the
	  upper-left corner of the bounding rectangle.

4mwidth0m
4mheight24m    Specify the width and height, which are the major
	  and minor axes of the arc.

4mangle124m    Specifies the start of the arc relative to the
	  three-o'clock position from the center, in units
	  of degrees * 64.

4mangle224m    Specifies the path and extent of the arc relative
	  to the start of the arc, in units of degrees * 64.
|__


To fill multiple arcs in a given drawable, use 4mXFillArcs24m.



			     1m2360m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
XFillArcs(4mdisplay24m, 4md24m, 4mgc24m, 4marcs24m, 4mnarcs24m)
      Display *4mdisplay24m;
      Drawable 4md24m;
      GC 4mgc24m;
      XArc *4marcs24m;
      int 4mnarcs24m;


4mdisplay24m   Specifies the connection to the X server.

4md24m	       Specifies the drawable.

4mgc24m	       Specifies the GC.

4marcs24m      Specifies an array of arcs.

4mnarcs24m     Specifies the number of arcs in the array.
|__

For each arc, 4mXFillArc24m or 4mXFillArcs24m fills the region closed
by the infinitely thin path described by the specified arc
and, depending on the arc-mode specified in the GC, one or
two line segments.  For 4mArcChord24m, the single line segment
joining the endpoints of the arc is used.  For 4mArcPieSlice24m,
the two line segments joining the endpoints of the arc with
the center point are used.  4mXFillArcs24m fills the arcs in the
order listed in the array.  For any given arc, 4mXFillArc24m and
4mXFillArcs24m do not draw a pixel more than once.  If regions
intersect, the intersecting pixels are drawn multiple times.

Both functions use these GC components: function, plane-
mask, fill-style, arc-mode, subwindow-mode, clip-x-origin,
clip-y-origin, and clip-mask.  They also use these GC mode-
dependent components: foreground, background, tile, stipple,
tile-stipple-x-origin, and tile-stipple-y-origin.

4mXFillArc24m and 4mXFillArcs24m can generate 4mBadDrawable24m, 4mBadGC24m, and
4mBadMatch24m errors.

1m8.5.	Font Metrics0m

A font is a graphical description of a set of characters
that are used to increase efficiency whenever a set of
small, similar sized patterns are repeatedly used.

This section discusses how to:

·    Load and free fonts

·    Obtain and free font names

·    Compute character string sizes




			     1m2370m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


·    Compute logical extents

·    Query character string sizes

The X server loads fonts whenever a program requests a new
font.  The server can cache fonts for quick lookup.  Fonts
are global across all screens in a server.  Several levels
are possible when dealing with fonts.  Most applications
simply use 4mXLoadQueryFont24m to load a font and query the font
metrics.

Characters in fonts are regarded as masks.  Except for image
text requests, the only pixels modified are those in which
bits are set to 1 in the character.  This means that it
makes sense to draw text using stipples or tiles (for exam-
ple, many menus gray-out unusable entries).









































			     1m2380m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|    The 4mXFontStruct24m structure contains all of the information
for the font and consists of the font-specific information
as well as a pointer to an array of 4mXCharStruct24m structures
for the characters contained in the font.  The 4mXFontStruct24m,
4mXFontProp24m, and 4mXCharStruct24m structures contain:


typedef struct {
     short lbearing;	      /* origin to left edge of raster */
     short rbearing;	      /* origin to right edge of raster */
     short width;	      /* advance to next char's origin */
     short ascent;	      /* baseline to top edge of raster */
     short descent;	      /* baseline to bottom edge of raster */
     unsigned short attributes;/* per char flags (not predefined) */
} XCharStruct;



typedef struct {
     Atom name;
     unsigned long card32;
} XFontProp;



typedef struct {	      /* normal 16 bit characters are two bytes */
    unsigned char byte1;
    unsigned char byte2;
} XChar2b;



typedef struct {
     XExtData *ext_data;      /* hook for extension to hang data */
     Font fid;		      /* Font id for this font */
     unsigned direction;      /* hint about the direction font is painted */
     unsigned min_char_or_byte2;/* first character */
     unsigned max_char_or_byte2;/* last character */
     unsigned min_byte1;      /* first row that exists */
     unsigned max_byte1;      /* last row that exists */
     Bool all_chars_exist;    /* flag if all characters have nonzero size */
     unsigned default_char;   /* char to print for undefined character */
     int n_properties;	      /* how many properties there are */
     XFontProp *properties;   /* pointer to array of additional properties */
     XCharStruct min_bounds;  /* minimum bounds over all existing char */
     XCharStruct max_bounds;  /* maximum bounds over all existing char */
     XCharStruct *per_char;   /* first_char to last_char information */
     int ascent;	      /* logical extent above baseline for spacing */
     int descent;	      /* logical descent below baseline for spacing */
} XFontStruct;

|__

X supports single byte/character, two bytes/character



			     1m2390m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


matrix, and 16-bit character text operations.  Note that any
of these forms can be used with a font, but a single
byte/character text request can only specify a single byte
(that is, the first row of a 2-byte font).  You should view
2-byte fonts as a two-dimensional matrix of defined charac-
ters: byte1 specifies the range of defined rows and byte2
defines the range of defined columns of the font.  Single
byte/character fonts have one row defined, and the byte2
range specified in the structure defines a range of charac-
ters.

The bounding box of a character is defined by the
4mXCharStruct24m of that character.  When characters are absent
from a font, the default_char is used.	When fonts have all
characters of the same size, only the information in the
4mXFontStruct24m min and max bounds are used.

The members of the 4mXFontStruct24m have the following semantics:

·    The direction member can be either 4mFontLeftToRight24m or
     4mFontRightToLeft24m.  It is just a hint as to whether most
     4mXCharStruct24m elements have a positive (4mFontLeftToRight24m)
     or a negative (4mFontRightToLeft24m) character width metric.
     The core protocol defines no support for vertical text.

·    If the min_byte1 and max_byte1 members are both zero,
     min_char_or_byte2 specifies the linear character index
     corresponding to the first element of the per_char
     array, and max_char_or_byte2 specifies the linear char-
     acter index of the last element.

     If either min_byte1 or max_byte1 are nonzero, both
     min_char_or_byte2 and max_char_or_byte2 are less than
     256, and the 2-byte character index values correspond-
     ing to the per_char array element N (counting from 0)
     are:

	  byte1 = N/D + min_byte1
	  byte2 = N\D + min_char_or_byte2

     where:

	     D = max_char_or_byte2 - min_char_or_byte2 + 1
	     / = integer division
	     \ = integer modulus

·    If the per_char pointer is NULL, all glyphs between the
     first and last character indexes inclusive have the
     same information, as given by both min_bounds and
     max_bounds.

·    If all_chars_exist is 4mTrue24m, all characters in the
     per_char array have nonzero bounding boxes.




			     1m2400m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


·    The default_char member specifies the character that
     will be used when an undefined or nonexistent character
     is printed.  The default_char is a 16-bit character
     (not a 2-byte character).	For a font using 2-byte
     matrix format, the default_char has byte1 in the most-
     significant byte and byte2 in the least significant
     byte.  If the default_char itself specifies an unde-
     fined or nonexistent character, no printing is per-
     formed for an undefined or nonexistent character.

·    The min_bounds and max_bounds members contain the most
     extreme values of each individual 4mXCharStruct24m component
     over all elements of this array (and ignore nonexistent
     characters).  The bounding box of the font (the small-
     est rectangle enclosing the shape obtained by superim-
     posing all of the characters at the same origin [x,y])
     has its upper-left coordinate at:

	       [x + min_bounds.lbearing, y - max_bounds.ascent]


     Its width is:

	       max_bounds.rbearing - min_bounds.lbearing


     Its height is:

	       max_bounds.ascent + max_bounds.descent


·    The ascent member is the logical extent of the font
     above the baseline that is used for determining line
     spacing.  Specific characters may extend beyond this.

·    The descent member is the logical extent of the font at
     or below the baseline that is used for determining line
     spacing.  Specific characters may extend beyond this.

·    If the baseline is at Y-coordinate y, the logical
     extent of the font is inclusive between the Y-coordi-
     nate values (y - font.ascent) and (y + font.descent -
     1).  Typically, the minimum interline spacing between
     rows of text is given by ascent + descent.

For a character origin at [x,y], the bounding box of a char-
acter (that is, the smallest rectangle that encloses the
character's shape) described in terms of 4mXCharStruct24m compo-
nents is a rectangle with its upper-left corner at:


     [x + lbearing, y - ascent]





			     1m2410m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


Its width is:


     rbearing - lbearing


Its height is:


     ascent + descent


The origin for the next character is defined to be:


     [x + width, y]


The lbearing member defines the extent of the left edge of
the character ink from the origin.  The rbearing member
defines the extent of the right edge of the character ink
from the origin.  The ascent member defines the extent of
the top edge of the character ink from the origin.  The
descent member defines the extent of the bottom edge of the
character ink from the origin.	The width member defines the
logical width of the character.

Note that the baseline (the y position of the character ori-
gin) is logically viewed as being the scanline just below
nondescending characters.  When descent is zero, only pixels
with Y-coordinates less than y are drawn, and the origin is
logically viewed as being coincident with the left edge of a
nonkerned character.  When lbearing is zero, no pixels with
X-coordinate less than x are drawn.  Any of the 4mXCharStruct0m
metric members could be negative.  If the width is negative,
the next character will be placed to the left of the current
origin.

The X protocol does not define the interpretation of the
attributes member in the 4mXCharStruct24m structure.  A nonexis-
tent character is represented with all members of its
4mXCharStruct24m set to zero.

A font is not guaranteed to have any properties.  The inter-
pretation of the property value (for example, long or
unsigned long) must be derived from 4ma24m 4mpriori24m knowledge of
the property.  A basic set of font properties is specified
in the X Consortium standard 4mX24m 4mLogical24m 4mFont24m 4mDescription24m 4mCon-0m
4mventions24m.

1m8.5.1.  Loading and Freeing Fonts0m

Xlib provides functions that you can use to load fonts, get
font information, unload fonts, and free font information.



			     1m2420m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


A few font functions use a 4mGContext24m resource ID or a font ID
interchangeably.


To load a given font, use 4mXLoadFont24m.
__
|
Font XLoadFont(4mdisplay24m, 4mname24m)
      Display *4mdisplay24m;
      char *4mname24m;


4mdisplay24m   Specifies the connection to the X server.

4mname24m      Specifies the name of the font, which is a null-
	  terminated string.
|__

The 4mXLoadFont24m function loads the specified font and returns
its associated font ID.	 If the font name is not in the Host
Portable Character Encoding, the result is implementation-
dependent.  Use of uppercase or lowercase does not matter.
When the characters ``?'' and ``*'' are used in a font name,
a pattern match is performed and any matching font is used.
In the pattern, the ``?'' character will match any single
character, and the ``*'' character will match any number of
characters.  A structured format for font names is specified
in the X Consortium standard 4mX24m 4mLogical24m 4mFont24m 4mDescription24m 4mCon-0m
4mventions24m.	If 4mXLoadFont24m was unsuccessful at loading the
specified font, a 4mBadName24m error results.  Fonts are not
associated with a particular screen and can be stored as a
component of any GC.  When the font is no longer needed,
call 4mXUnloadFont24m.

4mXLoadFont24m can generate 4mBadAlloc24m and 4mBadName24m errors.


To return information about an available font, use 4mXQuery-0m
4mFont24m.
__
|
XFontStruct *XQueryFont(4mdisplay24m, 4mfont_ID24m)
      Display *4mdisplay24m;
      XID 4mfont_ID24m;


4mdisplay24m   Specifies the connection to the X server.

4mfont_ID24m   Specifies the font ID or the 4mGContext24m ID.
|__

The 4mXQueryFont24m function returns a pointer to the 4mXFontStruct0m
structure, which contains information associated with the
font.  You can query a font or the font stored in a GC.	 The



			     1m2430m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


font ID stored in the 4mXFontStruct24m structure will be the
4mGContext24m ID, and you need to be careful when using this ID
in other functions (see 4mXGContextFromGC24m).	If the font does
not exist, 4mXQueryFont24m returns NULL.  To free this data, use
4mXFreeFontInfo24m.


To perform a 4mXLoadFont24m and 4mXQueryFont24m in a single operation,
use 4mXLoadQueryFont24m.
__
|
XFontStruct *XLoadQueryFont(4mdisplay24m, 4mname24m)
      Display *4mdisplay24m;
      char *4mname24m;


4mdisplay24m   Specifies the connection to the X server.

4mname24m      Specifies the name of the font, which is a null-
	  terminated string.
|__

The 4mXLoadQueryFont24m function provides the most common way for
accessing a font.  4mXLoadQueryFont24m both opens (loads) the
specified font and returns a pointer to the appropriate
4mXFontStruct24m structure.  If the font name is not in the Host
Portable Character Encoding, the result is implementation-
dependent.  If the font does not exist, 4mXLoadQueryFont0m
returns NULL.

4mXLoadQueryFont24m can generate a 4mBadAlloc24m error.


To unload the font and free the storage used by the font
structure that was allocated by 4mXQueryFont24m or 4mXLoadQuery-0m
4mFont24m, use 4mXFreeFont24m.
__
|
XFreeFont(4mdisplay24m, 4mfont_struct24m)
      Display *4mdisplay24m;
      XFontStruct *4mfont_struct24m;


4mdisplay24m   Specifies the connection to the X server.

4mfont_struct0m
	  Specifies the storage associated with the font.
|__

The 4mXFreeFont24m function deletes the association between the
font resource ID and the specified font and frees the
4mXFontStruct24m structure.  The font itself will be freed when
no other resource references it.  The data and the font
should not be referenced again.



			     1m2440m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


4mXFreeFont24m can generate a 4mBadFont24m error.


To return a given font property, use 4mXGetFontProperty24m.
__
|
Bool XGetFontProperty(4mfont_struct24m, 4matom24m, 4mvalue_return24m)
      XFontStruct *4mfont_struct24m;
      Atom 4matom24m;
      unsigned long *4mvalue_return24m;


4mfont_struct0m
	  Specifies the storage associated with the font.

4matom24m      Specifies the atom for the property name you want
	  returned.

4mvalue_return0m
	  Returns the value of the font property.
|__

Given the atom for that property, the 4mXGetFontProperty24m func-
tion returns the value of the specified font property.
4mXGetFontProperty24m also returns 4mFalse24m if the property was not
defined or 4mTrue24m if it was defined.	 A set of predefined
atoms exists for font properties, which can be found in
<4mX11/Xatom.h24m>.  This set contains the standard properties
associated with a font.	 Although it is not guaranteed, it
is likely that the predefined font properties will be
present.


To unload a font that was loaded by 4mXLoadFont24m, use 4mXUnload-0m
4mFont24m.
__
|
XUnloadFont(4mdisplay24m, 4mfont24m)
      Display *4mdisplay24m;
      Font 4mfont24m;


4mdisplay24m   Specifies the connection to the X server.

4mfont24m      Specifies the font.
|__

The 4mXUnloadFont24m function deletes the association between the
font resource ID and the specified font.  The font itself
will be freed when no other resource references it.  The
font should not be referenced again.

4mXUnloadFont24m can generate a 4mBadFont24m error.




			     1m2450m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


1m8.5.2.  Obtaining and Freeing Font Names and Information0m

You obtain font names and information by matching a wildcard
specification when querying a font type for a list of avail-
able sizes and so on.


To return a list of the available font names, use 4mXList-0m
4mFonts24m.
__
|
char **XListFonts(4mdisplay24m, 4mpattern24m, 4mmaxnames24m, 4mactual_count_return24m)
      Display *4mdisplay24m;
      char *4mpattern24m;
      int 4mmaxnames24m;
      int *4mactual_count_return24m;


4mdisplay24m   Specifies the connection to the X server.

4mpattern24m   Specifies the null-terminated pattern string that
	  can contain wildcard characters.

4mmaxnames24m  Specifies the maximum number of names to be
	  returned.

4mactual_count_return0m
	  Returns the actual number of font names.
|__

The 4mXListFonts24m function returns an array of available font
names (as controlled by the font search path; see 4mXSetFont-0m
4mPath24m) that match the string you passed to the pattern argu-
ment.  The pattern string can contain any characters, but
each asterisk (*) is a wildcard for any number of charac-
ters, and each question mark (?) is a wildcard for a single
character.  If the pattern string is not in the Host Porta-
ble Character Encoding, the result is implementation-depen-
dent.  Use of uppercase or lowercase does not matter.  Each
returned string is null-terminated.  If the data returned by
the server is in the Latin Portable Character Encoding, then
the returned strings are in the Host Portable Character
Encoding.  Otherwise, the result is implementation-depen-
dent.  If there are no matching font names, 4mXListFonts0m
returns NULL.  The client should call 4mXFreeFontNames24m when
finished with the result to free the memory.


To free a font name array, use 4mXFreeFontNames24m.








			     1m2460m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
XFreeFontNames(4mlist24m)
      char *4mlist24m[];


4mlist24m      Specifies the array of strings you want to free.
|__

The 4mXFreeFontNames24m function frees the array and strings
returned by 4mXListFonts24m or 4mXListFontsWithInfo24m.


To obtain the names and information about available fonts,
use 4mXListFontsWithInfo24m.
__
|
char **XListFontsWithInfo(4mdisplay24m, 4mpattern24m, 4mmaxnames24m, 4mcount_return24m, 4minfo_return24m)
      Display *4mdisplay24m;
      char *4mpattern24m;
      int 4mmaxnames24m;
      int *4mcount_return24m;
      XFontStruct **4minfo_return24m;


4mdisplay24m   Specifies the connection to the X server.

4mpattern24m   Specifies the null-terminated pattern string that
	  can contain wildcard characters.

4mmaxnames24m  Specifies the maximum number of names to be
	  returned.

4mcount_return0m
	  Returns the actual number of matched font names.

4minfo_return0m
	  Returns the font information.
|__

The 4mXListFontsWithInfo24m function returns a list of font names
that match the specified pattern and their associated font
information.  The list of names is limited to size specified
by maxnames.  The information returned for each font is
identical to what 4mXLoadQueryFont24m would return except that
the per-character metrics are not returned.  The pattern
string can contain any characters, but each asterisk (*) is
a wildcard for any number of characters, and each question
mark (?) is a wildcard for a single character.	If the pat-
tern string is not in the Host Portable Character Encoding,
the result is implementation-dependent.	 Use of uppercase or
lowercase does not matter.  Each returned string is null-
terminated.  If the data returned by the server is in the
Latin Portable Character Encoding, then the returned strings
are in the Host Portable Character Encoding.  Otherwise, the



			     1m2470m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


result is implementation-dependent.  If there are no match-
ing font names, 4mXListFontsWithInfo24m returns NULL.

To free only the allocated name array, the client should
call 4mXFreeFontNames24m.  To free both the name array and the
font information array or to free just the font information
array, the client should call 4mXFreeFontInfo24m.


To free font structures and font names, use 4mXFreeFontInfo24m.
__
|
XFreeFontInfo(4mnames24m, 4mfree_info24m, 4mactual_count24m)
      char **4mnames24m;
      XFontStruct *4mfree_info24m;
      int 4mactual_count24m;


4mnames24m     Specifies the list of font names.


4mfree_info24m Specifies the font information.


4mactual_count0m
	  Specifies the actual number of font names.

|__

The 4mXFreeFontInfo24m function frees a font structure or an
array of font structures and optionally an array of font
names.	If NULL is passed for names, no font names are
freed.	If a font structure for an open font (returned by
4mXLoadQueryFont24m) is passed, the structure is freed, but the
font is not closed; use 4mXUnloadFont24m to close the font.

1m8.5.3.  Computing Character String Sizes0m

Xlib provides functions that you can use to compute the
width, the logical extents, and the server information about
8-bit and 2-byte text strings.	The width is computed by
adding the character widths of all the characters.  It does
not matter if the font is an 8-bit or 2-byte font.  These
functions return the sum of the character metrics in pixels.


To determine the width of an 8-bit character string, use
4mXTextWidth24m.









			     1m2480m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
int XTextWidth(4mfont_struct24m, 4mstring24m, 4mcount24m)
      XFontStruct *4mfont_struct24m;
      char *4mstring24m;
      int 4mcount24m;


4mfont_struct0m
	  Specifies the font used for the width computation.

4mstring24m    Specifies the character string.

4mcount24m     Specifies the character count in the specified
	  string.
|__


To determine the width of a 2-byte character string, use
4mXTextWidth1624m.
__
|
int XTextWidth16(4mfont_struct24m, 4mstring24m, 4mcount24m)
      XFontStruct *4mfont_struct24m;
      XChar2b *4mstring24m;
      int 4mcount24m;


4mfont_struct0m
	  Specifies the font used for the width computation.

4mstring24m    Specifies the character string.

4mcount24m     Specifies the character count in the specified
	  string.
|__


1m8.5.4.  Computing Logical Extents0m

To compute the bounding box of an 8-bit character string in
a given font, use 4mXTextExtents24m.
















			     1m2490m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
XTextExtents(4mfont_struct24m, 4mstring24m, 4mnchars24m, 4mdirection_return24m, 4mfont_ascent_return24m,
	      4mfont_descent_return24m, 4moverall_return24m)
      XFontStruct *4mfont_struct24m;
      char *4mstring24m;
      int 4mnchars24m;
      int *4mdirection_return24m;
      int *4mfont_ascent_return24m, *4mfont_descent_return24m;
      XCharStruct *4moverall_return24m;



4mfont_struct0m
	  Specifies the 4mXFontStruct24m structure.

4mstring24m    Specifies the character string.

4mnchars24m    Specifies the number of characters in the charac-
	  ter string.

4mdirection_return0m
	  Returns the value of the direction hint (4mFontLeft-0m
	  4mToRight24m or 4mFontRightToLeft24m).

4mfont_ascent_return0m
	  Returns the font ascent.

4mfont_descent_return0m
	  Returns the font descent.

4moverall_return0m
	  Returns the overall size in the specified
	  4mXCharStruct24m structure.
|__


To compute the bounding box of a 2-byte character string in
a given font, use 4mXTextExtents1624m.



















			     1m2500m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
XTextExtents16(4mfont_struct24m, 4mstring24m, 4mnchars24m, 4mdirection_return24m, 4mfont_ascent_return24m,
		4mfont_descent_return24m, 4moverall_return24m)
      XFontStruct *4mfont_struct24m;
      XChar2b *4mstring24m;
      int 4mnchars24m;
      int *4mdirection_return24m;
      int *4mfont_ascent_return24m, *4mfont_descent_return24m;
      XCharStruct *4moverall_return24m;



4mfont_struct0m
	  Specifies the 4mXFontStruct24m structure.

4mstring24m    Specifies the character string.

4mnchars24m    Specifies the number of characters in the charac-
	  ter string.

4mdirection_return0m
	  Returns the value of the direction hint (4mFontLeft-0m
	  4mToRight24m or 4mFontRightToLeft24m).

4mfont_ascent_return0m
	  Returns the font ascent.

4mfont_descent_return0m
	  Returns the font descent.

4moverall_return0m
	  Returns the overall size in the specified
	  4mXCharStruct24m structure.
|__

The 4mXTextExtents24m and 4mXTextExtents1624m functions perform the
size computation locally and, thereby, avoid the round-trip
overhead of 4mXQueryTextExtents24m and 4mXQueryTextExtents1624m.  Both
functions return an 4mXCharStruct24m structure, whose members are
set to the values as follows.

The ascent member is set to the maximum of the ascent met-
rics of all characters in the string.  The descent member is
set to the maximum of the descent metrics.  The width member
is set to the sum of the character-width metrics of all
characters in the string.  For each character in the string,
let W be the sum of the character-width metrics of all char-
acters preceding it in the string.  Let L be the left-side-
bearing metric of the character plus W.	 Let R be the right-
side-bearing metric of the character plus W.  The lbearing
member is set to the minimum L of all characters in the
string.	 The rbearing member is set to the maximum R.





			     1m2510m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


For fonts defined with linear indexing rather than 2-byte
matrix indexing, each 4mXChar2b24m structure is interpreted as a
16-bit number with byte1 as the most significant byte.	If
the font has no defined default character, undefined charac-
ters in the string are taken to have all zero metrics.

1m8.5.5.  Querying Character String Sizes0m

To query the server for the bounding box of an 8-bit charac-
ter string in a given font, use 4mXQueryTextExtents24m.
__
|
XQueryTextExtents(4mdisplay24m, 4mfont_ID24m, 4mstring24m, 4mnchars24m, 4mdirection_return24m, 4mfont_ascent_return24m,
		    4mfont_descent_return24m, 4moverall_return24m)
      Display *4mdisplay24m;
      XID 4mfont_ID24m;
      char *4mstring24m;
      int 4mnchars24m;
      int *4mdirection_return24m;
      int *4mfont_ascent_return24m, *4mfont_descent_return24m;
      XCharStruct *4moverall_return24m;


4mdisplay24m   Specifies the connection to the X server.

4mfont_ID24m   Specifies either the font ID or the 4mGContext24m ID
	  that contains the font.

4mstring24m    Specifies the character string.

4mnchars24m    Specifies the number of characters in the charac-
	  ter string.

4mdirection_return0m
	  Returns the value of the direction hint (4mFontLeft-0m
	  4mToRight24m or 4mFontRightToLeft24m).

4mfont_ascent_return0m
	  Returns the font ascent.

4mfont_descent_return0m
	  Returns the font descent.

4moverall_return0m
	  Returns the overall size in the specified
	  4mXCharStruct24m structure.
|__


To query the server for the bounding box of a 2-byte charac-
ter string in a given font, use 4mXQueryTextExtents1624m.






			     1m2520m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
XQueryTextExtents16(4mdisplay24m, 4mfont_ID24m, 4mstring24m, 4mnchars24m, 4mdirection_return24m, 4mfont_ascent_return24m,
			4mfont_descent_return24m, 4moverall_return24m)
      Display *4mdisplay24m;
      XID 4mfont_ID24m;
      XChar2b *4mstring24m;
      int 4mnchars24m;
      int *4mdirection_return24m;
      int *4mfont_ascent_return24m, *4mfont_descent_return24m;
      XCharStruct *4moverall_return24m;


4mdisplay24m   Specifies the connection to the X server.

4mfont_ID24m   Specifies either the font ID or the 4mGContext24m ID
	  that contains the font.

4mstring24m    Specifies the character string.

4mnchars24m    Specifies the number of characters in the charac-
	  ter string.

4mdirection_return0m
	  Returns the value of the direction hint (4mFontLeft-0m
	  4mToRight24m or 4mFontRightToLeft24m).

4mfont_ascent_return0m
	  Returns the font ascent.

4mfont_descent_return0m
	  Returns the font descent.

4moverall_return0m
	  Returns the overall size in the specified
	  4mXCharStruct24m structure.
|__

The 4mXQueryTextExtents24m and 4mXQueryTextExtents1624m functions
return the bounding box of the specified 8-bit and 16-bit
character string in the specified font or the font contained
in the specified GC.  These functions query the X server
and, therefore, suffer the round-trip overhead that is
avoided by 4mXTextExtents24m and 4mXTextExtents1624m.  Both functions
return a 4mXCharStruct24m structure, whose members are set to the
values as follows.

The ascent member is set to the maximum of the ascent met-
rics of all characters in the string.  The descent member is
set to the maximum of the descent metrics.  The width member
is set to the sum of the character-width metrics of all
characters in the string.  For each character in the string,
let W be the sum of the character-width metrics of all char-
acters preceding it in the string.  Let L be the left-side-
bearing metric of the character plus W.	 Let R be the right-



			     1m2530m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


side-bearing metric of the character plus W.  The lbearing
member is set to the minimum L of all characters in the
string.	 The rbearing member is set to the maximum R.

For fonts defined with linear indexing rather than 2-byte
matrix indexing, each 4mXChar2b24m structure is interpreted as a
16-bit number with byte1 as the most significant byte.	If
the font has no defined default character, undefined charac-
ters in the string are taken to have all zero metrics.

Characters with all zero metrics are ignored.  If the font
has no defined default_char, the undefined characters in the
string are also ignored.

4mXQueryTextExtents24m and 4mXQueryTextExtents1624m can generate 4mBad-0m
4mFont24m and 4mBadGC24m errors.

1m8.6.	Drawing Text0m

This section discusses how to draw:

·    Complex text

·    Text characters

·    Image text characters

The fundamental text functions 4mXDrawText24m and 4mXDrawText1624m use
the following structures:

__
|
typedef struct {
     char *chars;	      /* pointer to string */
     int nchars;	      /* number of characters */
     int delta;		      /* delta between strings */
     Font font;		      /* Font to print it in, None don't change */
} XTextItem;



typedef struct {
     XChar2b *chars;	      /* pointer to two-byte characters */
     int nchars;	      /* number of characters */
     int delta;		      /* delta between strings */
     Font font;		      /* font to print it in, None don't change */
} XTextItem16;

|__

If the font member is not 4mNone24m, the font is changed before
printing and also is stored in the GC.	If an error was gen-
erated during text drawing, the previous items may have been
drawn.	The baseline of the characters are drawn starting at



			     1m2540m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


the x and y coordinates that you pass in the text drawing
functions.

For example, consider the background rectangle drawn by
4mXDrawImageString24m.	If you want the upper-left corner of the
background rectangle to be at pixel coordinate (x,y), pass
the (x,y + ascent) as the baseline origin coordinates to the
text functions.	 The ascent is the font ascent, as given in
the 4mXFontStruct24m structure.	 If you want the lower-left cor-
ner of the background rectangle to be at pixel coordinate
(x,y), pass the (x,y - descent + 1) as the baseline origin
coordinates to the text functions.  The descent is the font
descent, as given in the 4mXFontStruct24m structure.

1m8.6.1.  Drawing Complex Text0m


To draw 8-bit characters in a given drawable, use 4mXDrawText24m.
__
|
XDrawText(4mdisplay24m, 4md24m, 4mgc24m, 4mx24m, 4my24m, 4mitems24m, 4mnitems24m)
      Display *4mdisplay24m;
      Drawable 4md24m;
      GC 4mgc24m;
      int 4mx24m, 4my24m;
      XTextItem *4mitems24m;
      int 4mnitems24m;


4mdisplay24m   Specifies the connection to the X server.

4md24m	       Specifies the drawable.

4mgc24m	       Specifies the GC.

4mx0m
4my24m	       Specify the x and y coordinates, which are rela-
	  tive to the origin of the specified drawable and
	  define the origin of the first character.

4mitems24m     Specifies an array of text items.

4mnitems24m    Specifies the number of text items in the array.
|__


To draw 2-byte characters in a given drawable, use 4mXDraw-0m
4mText1624m.









			     1m2550m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
XDrawText16(4mdisplay24m, 4md24m, 4mgc24m, 4mx24m, 4my24m, 4mitems24m, 4mnitems24m)
      Display *4mdisplay24m;
      Drawable 4md24m;
      GC 4mgc24m;
      int 4mx24m, 4my24m;
      XTextItem16 *4mitems24m;
      int 4mnitems24m;


4mdisplay24m   Specifies the connection to the X server.

4md24m	       Specifies the drawable.

4mgc24m	       Specifies the GC.

4mx0m
4my24m	       Specify the x and y coordinates, which are rela-
	  tive to the origin of the specified drawable and
	  define the origin of the first character.

4mitems24m     Specifies an array of text items.

4mnitems24m    Specifies the number of text items in the array.
|__

The 4mXDrawText1624m function is similar to 4mXDrawText24m except that
it uses 2-byte or 16-bit characters.  Both functions allow
complex spacing and font shifts between counted strings.

Each text item is processed in turn.  A font member other
than 4mNone24m in an item causes the font to be stored in the GC
and used for subsequent text.  A text element delta speci-
fies an additional change in the position along the x axis
before the string is drawn.  The delta is always added to
the character origin and is not dependent on any character-
istics of the font.  Each character image, as defined by the
font in the GC, is treated as an additional mask for a fill
operation on the drawable.  The drawable is modified only
where the font character has a bit set to 1.  If a text item
generates a 4mBadFont24m error, the previous text items may have
been drawn.

For fonts defined with linear indexing rather than 2-byte
matrix indexing, each 4mXChar2b24m structure is interpreted as a
16-bit number with byte1 as the most significant byte.

Both functions use these GC components: function, plane-
mask, fill-style, font, subwindow-mode, clip-x-origin, clip-
y-origin, and clip-mask.  They also use these GC mode-depen-
dent components: foreground, background, tile, stipple,
tile-stipple-x-origin, and tile-stipple-y-origin.





			     1m2560m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


4mXDrawText24m and 4mXDrawText1624m can generate 4mBadDrawable24m, 4mBadFont24m,
4mBadGC24m, and 4mBadMatch24m errors.

1m8.6.2.  Drawing Text Characters0m

To draw 8-bit characters in a given drawable, use 4mXDraw-0m
4mString24m.
__
|
XDrawString(4mdisplay24m, 4md24m, 4mgc24m, 4mx24m, 4my24m, 4mstring24m, 4mlength24m)
      Display *4mdisplay24m;
      Drawable 4md24m;
      GC 4mgc24m;
      int 4mx24m, 4my24m;
      char *4mstring24m;
      int 4mlength24m;


4mdisplay24m   Specifies the connection to the X server.

4md24m	       Specifies the drawable.

4mgc24m	       Specifies the GC.

4mx0m
4my24m	       Specify the x and y coordinates, which are rela-
	  tive to the origin of the specified drawable and
	  define the origin of the first character.

4mstring24m    Specifies the character string.

4mlength24m    Specifies the number of characters in the string
	  argument.
|__


To draw 2-byte characters in a given drawable, use 4mXDraw-0m
4mString1624m.



















			     1m2570m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
XDrawString16(4mdisplay24m, 4md24m, 4mgc24m, 4mx24m, 4my24m, 4mstring24m, 4mlength24m)
      Display *4mdisplay24m;
      Drawable 4md24m;
      GC 4mgc24m;
      int 4mx24m, 4my24m;
      XChar2b *4mstring24m;
      int 4mlength24m;


4mdisplay24m   Specifies the connection to the X server.

4md24m	       Specifies the drawable.

4mgc24m	       Specifies the GC.

4mx0m
4my24m	       Specify the x and y coordinates, which are rela-
	  tive to the origin of the specified drawable and
	  define the origin of the first character.

4mstring24m    Specifies the character string.

4mlength24m    Specifies the number of characters in the string
	  argument.
|__

Each character image, as defined by the font in the GC, is
treated as an additional mask for a fill operation on the
drawable.  The drawable is modified only where the font
character has a bit set to 1.  For fonts defined with 2-byte
matrix indexing and used with 4mXDrawString1624m, each byte is
used as a byte2 with a byte1 of zero.

Both functions use these GC components: function, plane-
mask, fill-style, font, subwindow-mode, clip-x-origin, clip-
y-origin, and clip-mask.  They also use these GC mode-depen-
dent components: foreground, background, tile, stipple,
tile-stipple-x-origin, and tile-stipple-y-origin.

4mXDrawString24m and 4mXDrawString1624m can generate 4mBadDrawable24m,
4mBadGC24m, and 4mBadMatch24m errors.

1m8.6.3.  Drawing Image Text Characters0m

Some applications, in particular terminal emulators, need to
print image text in which both the foreground and background
bits of each character are painted.  This prevents annoying
flicker on many displays.


To draw 8-bit image text characters in a given drawable, use
4mXDrawImageString24m.




			     1m2580m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
XDrawImageString(4mdisplay24m, 4md24m, 4mgc24m, 4mx24m, 4my24m, 4mstring24m, 4mlength24m)
      Display *4mdisplay24m;
      Drawable 4md24m;
      GC 4mgc24m;
      int 4mx24m, 4my24m;
      char *4mstring24m;
      int 4mlength24m;


4mdisplay24m   Specifies the connection to the X server.

4md24m	       Specifies the drawable.

4mgc24m	       Specifies the GC.

4mx0m
4my24m	       Specify the x and y coordinates, which are rela-
	  tive to the origin of the specified drawable and
	  define the origin of the first character.

4mstring24m    Specifies the character string.

4mlength24m    Specifies the number of characters in the string
	  argument.
|__


To draw 2-byte image text characters in a given drawable,
use 4mXDrawImageString1624m.



























			     1m2590m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
XDrawImageString16(4mdisplay24m, 4md24m, 4mgc24m, 4mx24m, 4my24m, 4mstring24m, 4mlength24m)
      Display *4mdisplay24m;
      Drawable 4md24m;
      GC 4mgc24m;
      int 4mx24m, 4my24m;
      XChar2b *4mstring24m;
      int 4mlength24m;


4mdisplay24m   Specifies the connection to the X server.

4md24m	       Specifies the drawable.

4mgc24m	       Specifies the GC.

4mx0m
4my24m	       Specify the x and y coordinates, which are rela-
	  tive to the origin of the specified drawable and
	  define the origin of the first character.

4mstring24m    Specifies the character string.

4mlength24m    Specifies the number of characters in the string
	  argument.
|__

The 4mXDrawImageString1624m function is similar to 4mXDrawIm-0m
4mageString24m except that it uses 2-byte or 16-bit characters.
Both functions also use both the foreground and background
pixels of the GC in the destination.

The effect is first to fill a destination rectangle with the
background pixel defined in the GC and then to paint the
text with the foreground pixel.	 The upper-left corner of
the filled rectangle is at:


     [x, y - font-ascent]


The width is:


     overall-width


The height is:


     font-ascent + font-descent






			     1m2600m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


The overall-width, font-ascent, and font-descent are as
would be returned by 4mXQueryTextExtents24m using gc and string.
The function and fill-style defined in the GC are ignored
for these functions.  The effective function is 4mGXcopy24m, and
the effective fill-style is 4mFillSolid24m.

For fonts defined with 2-byte matrix indexing and used with
4mXDrawImageString24m, each byte is used as a byte2 with a byte1
of zero.

Both functions use these GC components: plane-mask, fore-
ground, background, font, subwindow-mode, clip-x-origin,
clip-y-origin, and clip-mask.

4mXDrawImageString24m and 4mXDrawImageString1624m can generate 4mBad-0m
4mDrawable24m, 4mBadGC24m, and 4mBadMatch24m errors.


1m8.7.	Transferring Images between Client and Server0m

Xlib provides functions that you can use to transfer images
between a client and the server.  Because the server may
require diverse data formats, Xlib provides an image object
that fully describes the data in memory and that provides
for basic operations on that data.  You should reference the
data through the image object rather than referencing the
data directly.	However, some implementations of the Xlib
library may efficiently deal with frequently used data for-
mats by replacing functions in the procedure vector with
special case functions.	 Supported operations include
destroying the image, getting a pixel, storing a pixel,
extracting a subimage of an image, and adding a constant to
an image (see section 16.8).

All the image manipulation functions discussed in this sec-
tion make use of the 4mXImage24m structure, which describes an
image as it exists in the client's memory.




















			     1m2610m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
typedef struct _XImage {
     int width, height;	      /* size of image */
     int xoffset;	      /* number of pixels offset in X direction */
     int format;	      /* XYBitmap, XYPixmap, ZPixmap */
     char *data;	      /* pointer to image data */
     int byte_order;	      /* data byte order, LSBFirst, MSBFirst */
     int bitmap_unit;	      /* quant. of scanline 8, 16, 32 */
     int bitmap_bit_order;    /* LSBFirst, MSBFirst */
     int bitmap_pad;	      /* 8, 16, 32 either XY or ZPixmap */
     int depth;		      /* depth of image */
     int bytes_per_line;      /* accelerator to next scanline */
     int bits_per_pixel;      /* bits per pixel (ZPixmap) */
     unsigned long red_mask;  /* bits in z arrangement */
     unsigned long green_mask;
     unsigned long blue_mask;
     XPointer obdata;	      /* hook for the object routines to hang on */
     struct funcs {	      /* image manipulation routines */
	  struct _XImage *(*create_image)();
	  int (*destroy_image)();
	  unsigned long (*get_pixel)();
	  int (*put_pixel)();
	  struct _XImage *(*sub_image)();
	  int (*add_pixel)();
     } f;
} XImage;

|__


To initialize the image manipulation routines of an image
structure, use 4mXInitImage24m.
__
|
Status XInitImage(4mimage24m)
      XImage *4mimage24m;


4mximage24m    Specifies the image.
|__

The 4mXInitImage24m function initializes the internal image
manipulation routines of an image structure, based on the
values of the various structure members.  All fields other
than the manipulation routines must already be initialized.
If the bytes_per_line member is zero, 4mXInitImage24m will assume
the image data is contiguous in memory and set the
bytes_per_line member to an appropriate value based on the
other members; otherwise, the value of bytes_per_line is not
changed.  All of the manipulation routines are initialized
to functions that other Xlib image manipulation functions
need to operate on the type of image specified by the rest
of the structure.




			     1m2620m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


This function must be called for any image constructed by
the client before passing it to any other Xlib function.
Image structures created or returned by Xlib do not need to
be initialized in this fashion.

This function returns a nonzero status if initialization of
the structure is successful.  It returns zero if it detected
some error or inconsistency in the structure, in which case
the image is not changed.


To combine an image with a rectangle of a drawable on the
display, use 4mXPutImage24m.
__
|
XPutImage(4mdisplay24m, 4md24m, 4mgc24m, 4mimage24m, 4msrc_x24m, 4msrc_y24m, 4mdest_x24m, 4mdest_y24m, 4mwidth24m, 4mheight24m)
	Display *4mdisplay24m;
	Drawable 4md24m;
	GC 4mgc24m;
	XImage *4mimage24m;
	int 4msrc_x24m, 4msrc_y24m;
	int 4mdest_x24m, 4mdest_y24m;
	unsigned int 4mwidth24m, 4mheight24m;


4mdisplay24m   Specifies the connection to the X server.

4md24m	       Specifies the drawable.

4mgc24m	       Specifies the GC.

4mimage24m     Specifies the image you want combined with the
	  rectangle.

4msrc_x24m     Specifies the offset in X from the left edge of
	  the image defined by the 4mXImage24m structure.

4msrc_y24m     Specifies the offset in Y from the top edge of the
	  image defined by the 4mXImage24m structure.

4mdest_x0m
4mdest_y24m    Specify the x and y coordinates, which are rela-
	  tive to the origin of the drawable and are the
	  coordinates of the subimage.

4mwidth0m
4mheight24m    Specify the width and height of the subimage,
	  which define the dimensions of the rectangle.
|__

The 4mXPutImage24m function combines an image with a rectangle of
the specified drawable.	 The section of the image defined by
the src_x, src_y, width, and height arguments is drawn on
the specified part of the drawable.  If 4mXYBitmap24m format is



			     1m2630m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


used, the depth of the image must be one, or a 4mBadMatch0m
error results.	The foreground pixel in the GC defines the
source for the one bits in the image, and the background
pixel defines the source for the zero bits.  For 4mXYPixmap0m
and 4mZPixmap24m, the depth of the image must match the depth of
the drawable, or a 4mBadMatch24m error results.

If the characteristics of the image (for example, byte_order
and bitmap_unit) differ from what the server requires,
4mXPutImage24m automatically makes the appropriate conversions.

This function uses these GC components: function, plane-
mask, subwindow-mode, clip-x-origin, clip-y-origin, and
clip-mask.  It also uses these GC mode-dependent components:
foreground and background.

4mXPutImage24m can generate 4mBadDrawable24m, 4mBadGC24m, 4mBadMatch24m, and
4mBadValue24m errors.


To return the contents of a rectangle in a given drawable on
the display, use 4mXGetImage24m.  This function specifically sup-
ports rudimentary screen dumps.


































			     1m2640m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
XImage *XGetImage(4mdisplay24m, 4md24m, 4mx24m, 4my24m, 4mwidth24m, 4mheight24m, 4mplane_mask24m, 4mformat24m)
	Display *4mdisplay24m;
	Drawable 4md24m;
	int 4mx24m, 4my24m;
	unsigned int 4mwidth24m, 4mheight24m;
	unsigned long 4mplane_mask24m;
	int 4mformat24m;


4mdisplay24m   Specifies the connection to the X server.

4md24m	       Specifies the drawable.

4mx0m
4my24m	       Specify the x and y coordinates, which are rela-
	  tive to the origin of the drawable and define the
	  upper-left corner of the rectangle.

4mwidth0m
4mheight24m    Specify the width and height of the subimage,
	  which define the dimensions of the rectangle.

4mplane_mask0m
	  Specifies the plane mask.

4mformat24m    Specifies the format for the image.  You can pass
	  4mXYPixmap24m or 4mZPixmap24m.
|__

The 4mXGetImage24m function returns a pointer to an 4mXImage24m struc-
ture.  This structure provides you with the contents of the
specified rectangle of the drawable in the format you spec-
ify.  If the format argument is 4mXYPixmap24m, the image contains
only the bit planes you passed to the plane_mask argument.
If the plane_mask argument only requests a subset of the
planes of the display, the depth of the returned image will
be the number of planes requested.  If the format argument
is 4mZPixmap24m, 4mXGetImage24m returns as zero the bits in all planes
not specified in the plane_mask argument.  The function per-
forms no range checking on the values in plane_mask and
ignores extraneous bits.

4mXGetImage24m returns the depth of the image to the depth member
of the 4mXImage24m structure.  The depth of the image is as spec-
ified when the drawable was created, except when getting a
subset of the planes in 4mXYPixmap24m format, when the depth is
given by the number of bits set to 1 in plane_mask.

If the drawable is a pixmap, the given rectangle must be
wholly contained within the pixmap, or a 4mBadMatch24m error
results.  If the drawable is a window, the window must be
viewable, and it must be the case that if there were no
inferiors or overlapping windows, the specified rectangle of



			     1m2650m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


the window would be fully visible on the screen and wholly
contained within the outside edges of the window, or a 4mBad-0m
4mMatch24m error results.  Note that the borders of the window
can be included and read with this request.  If the window
has backing-store, the backing-store contents are returned
for regions of the window that are obscured by noninferior
windows.  If the window does not have backing-store, the
returned contents of such obscured regions are undefined.
The returned contents of visible regions of inferiors of a
different depth than the specified window's depth are also
undefined.  The pointer cursor image is not included in the
returned contents.  If a problem occurs, 4mXGetImage24m returns
NULL.

4mXGetImage24m can generate 4mBadDrawable24m, 4mBadMatch24m, and 4mBadValue0m
errors.


To copy the contents of a rectangle on the display to a
location within a preexisting image structure, use 4mXGet-0m
4mSubImage24m.




































			     1m2660m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
XImage *XGetSubImage(4mdisplay24m, 4md24m, 4mx24m, 4my24m, 4mwidth24m, 4mheight24m, 4mplane_mask24m, 4mformat24m, 4mdest_image24m, 4mdest_x24m,
		     4mdest_y24m)
      Display *4mdisplay24m;
      Drawable 4md24m;
      int 4mx24m, 4my24m;
      unsigned int 4mwidth24m, 4mheight24m;
      unsigned long 4mplane_mask24m;
      int 4mformat24m;
      XImage *4mdest_image24m;
      int 4mdest_x24m, 4mdest_y24m;


4mdisplay24m   Specifies the connection to the X server.

4md24m	       Specifies the drawable.

4mx0m
4my24m	       Specify the x and y coordinates, which are rela-
	  tive to the origin of the drawable and define the
	  upper-left corner of the rectangle.

4mwidth0m
4mheight24m    Specify the width and height of the subimage,
	  which define the dimensions of the rectangle.

4mplane_mask0m
	  Specifies the plane mask.

4mformat24m    Specifies the format for the image.  You can pass
	  4mXYPixmap24m or 4mZPixmap24m.

4mdest_image0m
	  Specifies the destination image.

4mdest_x0m
4mdest_y24m    Specify the x and y coordinates, which are rela-
	  tive to the origin of the destination rectangle,
	  specify its upper-left corner, and determine where
	  the subimage is placed in the destination image.
|__

The 4mXGetSubImage24m function updates dest_image with the speci-
fied subimage in the same manner as 4mXGetImage24m.  If the for-
mat argument is 4mXYPixmap24m, the image contains only the bit
planes you passed to the plane_mask argument.  If the format
argument is 4mZPixmap24m, 4mXGetSubImage24m returns as zero the bits
in all planes not specified in the plane_mask argument.	 The
function performs no range checking on the values in
plane_mask and ignores extraneous bits.	 As a convenience,
4mXGetSubImage24m returns a pointer to the same 4mXImage24m structure
specified by dest_image.





			     1m2670m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


The depth of the destination 4mXImage24m structure must be the
same as that of the drawable.  If the specified subimage
does not fit at the specified location on the destination
image, the right and bottom edges are clipped.	If the draw-
able is a pixmap, the given rectangle must be wholly con-
tained within the pixmap, or a 4mBadMatch24m error results.  If
the drawable is a window, the window must be viewable, and
it must be the case that if there were no inferiors or over-
lapping windows, the specified rectangle of the window would
be fully visible on the screen and wholly contained within
the outside edges of the window, or a 4mBadMatch24m error
results.  If the window has backing-store, then the backing-
store contents are returned for regions of the window that
are obscured by noninferior windows.  If the window does not
have backing-store, the returned contents of such obscured
regions are undefined.	The returned contents of visible
regions of inferiors of a different depth than the specified
window's depth are also undefined.  If a problem occurs,
4mXGetSubImage24m returns NULL.

4mXGetSubImage24m can generate 4mBadDrawable24m, 4mBadGC24m, 4mBadMatch24m, and
4mBadValue24m errors.



































			     1m2680m





1mXlib - C Library			X11, Release 6.7 DRAFT0m




			 1mChapter 90m

	    1mWindow and Session Manager Functions0m



Although it is difficult to categorize functions as exclu-
sively for an application, a window manager, or a session
manager, the functions in this chapter are most often used
by window managers and session managers.  It is not expected
that these functions will be used by most application pro-
grams.	Xlib provides management functions to:

·    Change the parent of a window

·    Control the lifetime of a window

·    Manage installed colormaps

·    Set and retrieve the font search path

·    Grab the server

·    Kill a client

·    Control the screen saver

·    Control host access

1m9.1.	Changing the Parent of a Window0m

To change a window's parent to another window on the same
screen, use 4mXReparentWindow24m.  There is no way to move a win-
dow between screens.





















			     1m2690m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
XReparentWindow(4mdisplay24m, 4mw24m, 4mparent24m, 4mx24m, 4my24m)
      Display *4mdisplay24m;
      Window 4mw24m;
      Window 4mparent24m;
      int 4mx24m, 4my24m;


4mdisplay24m   Specifies the connection to the X server.

4mw24m	       Specifies the window.

4mparent24m    Specifies the parent window.

4mx0m
4my24m	       Specify the x and y coordinates of the position in
	  the new parent window.
|__

If the specified window is mapped, 4mXReparentWindow24m automati-
cally performs an 4mUnmapWindow24m request on it, removes it from
its current position in the hierarchy, and inserts it as the
child of the specified parent.	The window is placed in the
stacking order on top with respect to sibling windows.

After reparenting the specified window, 4mXReparentWindow0m
causes the X server to generate a 4mReparentNotify24m event.  The
override_redirect member returned in this event is set to
the window's corresponding attribute.  Window manager
clients usually should ignore this window if this member is
set to 4mTrue24m.  Finally, if the specified window was origi-
nally mapped, the X server automatically performs a 4mMapWin-0m
4mdow24m request on it.

The X server performs normal exposure processing on formerly
obscured windows.  The X server might not generate 4mExpose0m
events for regions from the initial 4mUnmapWindow24m request that
are immediately obscured by the final 4mMapWindow24m request.  A
4mBadMatch24m error results if:

·    The new parent window is not on the same screen as the
     old parent window.

·    The new parent window is the specified window or an
     inferior of the specified window.

·    The new parent is 4mInputOnly24m, and the window is not.

·    The specified window has a 4mParentRelative24m background,
     and the new parent window is not the same depth as the
     specified window.

4mXReparentWindow24m can generate 4mBadMatch24m and 4mBadWindow24m errors.




			     1m2700m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


1m9.2.	Controlling the Lifetime of a Window0m

The save-set of a client is a list of other clients' windows
that, if they are inferiors of one of the client's windows
at connection close, should not be destroyed and should be
remapped if they are unmapped.	For further information
about close-connection processing, see section 2.6.  To
allow an application's window to survive when a window man-
ager that has reparented a window fails, Xlib provides the
save-set functions that you can use to control the longevity
of subwindows that are normally destroyed when the parent is
destroyed.  For example, a window manager that wants to add
decoration to a window by adding a frame might reparent an
application's window.  When the frame is destroyed, the
application's window should not be destroyed but be returned
to its previous place in the window hierarchy.

The X server automatically removes windows from the save-set
when they are destroyed.


To add or remove a window from the client's save-set, use
4mXChangeSaveSet24m.
__
|
XChangeSaveSet(4mdisplay24m, 4mw24m, 4mchange_mode24m)
      Display *4mdisplay24m;
      Window 4mw24m;
      int 4mchange_mode24m;


4mdisplay24m   Specifies the connection to the X server.

4mw24m	       Specifies the window that you want to add to or
	  delete from the client's save-set.

4mchange_mode0m
	  Specifies the mode.  You can pass 4mSetModeInsert24m or
	  4mSetModeDelete24m.
|__

Depending on the specified mode, 4mXChangeSaveSet24m either
inserts or deletes the specified window from the client's
save-set.  The specified window must have been created by
some other client, or a 4mBadMatch24m error results.

4mXChangeSaveSet24m can generate 4mBadMatch24m, 4mBadValue24m, and 4mBadWin-0m
4mdow24m errors.


To add a window to the client's save-set, use 4mXAddToSaveSet24m.






			     1m2710m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
XAddToSaveSet(4mdisplay24m, 4mw24m)
      Display *4mdisplay24m;
      Window 4mw24m;


4mdisplay24m   Specifies the connection to the X server.

4mw24m	       Specifies the window that you want to add to the
	  client's save-set.
|__

The 4mXAddToSaveSet24m function adds the specified window to the
client's save-set.  The specified window must have been cre-
ated by some other client, or a 4mBadMatch24m error results.

4mXAddToSaveSet24m can generate 4mBadMatch24m and 4mBadWindow24m errors.


To remove a window from the client's save-set, use 4mXRemove-0m
4mFromSaveSet24m.
__
|
XRemoveFromSaveSet(4mdisplay24m, 4mw24m)
      Display *4mdisplay24m;
      Window 4mw24m;


4mdisplay24m   Specifies the connection to the X server.

4mw24m	       Specifies the window that you want to delete from
	  the client's save-set.
|__

The 4mXRemoveFromSaveSet24m function removes the specified window
from the client's save-set.  The specified window must have
been created by some other client, or a 4mBadMatch24m error
results.

4mXRemoveFromSaveSet24m can generate 4mBadMatch24m and 4mBadWindow0m
errors.

1m9.3.	Managing Installed Colormaps0m

The X server maintains a list of installed colormaps.  Win-
dows using these colormaps are guaranteed to display with
correct colors; windows using other colormaps may or may not
display with correct colors.  Xlib provides functions that
you can use to install a colormap, uninstall a colormap, and
obtain a list of installed colormaps.

At any time, there is a subset of the installed maps that is
viewed as an ordered list and is called the required list.
The length of the required list is at most M, where M is the



			     1m2720m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


minimum number of installed colormaps specified for the
screen in the connection setup.	 The required list is main-
tained as follows.  When a colormap is specified to 4mXIn-0m
4mstallColormap24m, it is added to the head of the list; the list
is truncated at the tail, if necessary, to keep its length
to at most M.  When a colormap is specified to 4mXUninstall-0m
4mColormap24m and it is in the required list, it is removed from
the list.  A colormap is not added to the required list when
it is implicitly installed by the X server, and the X server
cannot implicitly uninstall a colormap that is in the
required list.


To install a colormap, use 4mXInstallColormap24m.
__
|
XInstallColormap(4mdisplay24m, 4mcolormap24m)
      Display *4mdisplay24m;
      Colormap 4mcolormap24m;


4mdisplay24m   Specifies the connection to the X server.

4mcolormap24m  Specifies the colormap.
|__

The 4mXInstallColormap24m function installs the specified col-
ormap for its associated screen.  All windows associated
with this colormap immediately display with true colors.
You associated the windows with this colormap when you cre-
ated them by calling 4mXCreateWindow24m, 4mXCreateSimpleWindow24m,
4mXChangeWindowAttributes24m, or 4mXSetWindowColormap24m.

If the specified colormap is not already an installed col-
ormap, the X server generates a 4mColormapNotify24m event on each
window that has that colormap.	In addition, for every other
colormap that is installed as a result of a call to 4mXIn-0m
4mstallColormap24m, the X server generates a 4mColormapNotify24m event
on each window that has that colormap.

4mXInstallColormap24m can generate a 4mBadColor24m error.


To uninstall a colormap, use 4mXUninstallColormap24m.













			     1m2730m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
XUninstallColormap(4mdisplay24m, 4mcolormap24m)
      Display *4mdisplay24m;
      Colormap 4mcolormap24m;


4mdisplay24m   Specifies the connection to the X server.

4mcolormap24m  Specifies the colormap.
|__

The 4mXUninstallColormap24m function removes the specified col-
ormap from the required list for its screen.  As a result,
the specified colormap might be uninstalled, and the X
server might implicitly install or uninstall additional col-
ormaps.	 Which colormaps get installed or uninstalled is
server dependent except that the required list must remain
installed.

If the specified colormap becomes uninstalled, the X server
generates a 4mColormapNotify24m event on each window that has
that colormap.	In addition, for every other colormap that
is installed or uninstalled as a result of a call to 4mXUnin-0m
4mstallColormap24m, the X server generates a 4mColormapNotify24m event
on each window that has that colormap.

4mXUninstallColormap24m can generate a 4mBadColor24m error.


To obtain a list of the currently installed colormaps for a
given screen, use 4mXListInstalledColormaps24m.
__
|
Colormap *XListInstalledColormaps(4mdisplay24m, 4mw24m, 4mnum_return24m)
      Display *4mdisplay24m;
      Window 4mw24m;
      int *4mnum_return24m;


4mdisplay24m   Specifies the connection to the X server.

4mw24m	       Specifies the window that determines the screen.

4mnum_return0m
	  Returns the number of currently installed col-
	  ormaps.
|__

The 4mXListInstalledColormaps24m function returns a list of the
currently installed colormaps for the screen of the speci-
fied window.  The order of the colormaps in the list is not
significant and is no explicit indication of the required
list.  When the allocated list is no longer needed, free it
by using 4mXFree24m.



			     1m2740m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


4mXListInstalledColormaps24m can generate a 4mBadWindow24m error.

1m9.4.	Setting and Retrieving the Font Search Path0m

The set of fonts available from a server depends on a font
search path.  Xlib provides functions to set and retrieve
the search path for a server.


To set the font search path, use 4mXSetFontPath24m.
__
|
XSetFontPath(4mdisplay24m, 4mdirectories24m, 4mndirs24m)
      Display *4mdisplay24m;
      char **4mdirectories24m;
      int 4mndirs24m;


4mdisplay24m   Specifies the connection to the X server.

4mdirectories0m
	  Specifies the directory path used to look for a
	  font.	 Setting the path to the empty list restores
	  the default path defined for the X server.

4mndirs24m     Specifies the number of directories in the path.
|__

The 4mXSetFontPath24m function defines the directory search path
for font lookup.  There is only one search path per X
server, not one per client.  The encoding and interpretation
of the strings are implementation-dependent, but typically
they specify directories or font servers to be searched in
the order listed.  An X server is permitted to cache font
information internally; for example, it might cache an
entire font from a file and not check on subsequent opens of
that font to see if the underlying font file has changed.
However, when the font path is changed, the X server is
guaranteed to flush all cached information about fonts for
which there currently are no explicit resource IDs allo-
cated.	The meaning of an error from this request is imple-
mentation-dependent.

4mXSetFontPath24m can generate a 4mBadValue24m error.


To get the current font search path, use 4mXGetFontPath24m.










			     1m2750m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
char **XGetFontPath(4mdisplay24m, 4mnpaths_return24m)
      Display *4mdisplay24m;
      int *4mnpaths_return24m;



4mdisplay24m   Specifies the connection to the X server.

4mnpaths_return0m
	  Returns the number of strings in the font path
	  array.
|__

The 4mXGetFontPath24m function allocates and returns an array of
strings containing the search path.  The contents of these
strings are implementation-dependent and are not intended to
be interpreted by client applications.	When it is no longer
needed, the data in the font path should be freed by using
4mXFreeFontPath24m.


To free data returned by 4mXGetFontPath24m, use 4mXFreeFontPath24m.
__
|
XFreeFontPath(4mlist24m)
      char **4mlist24m;



4mlist24m      Specifies the array of strings you want to free.
|__

The 4mXFreeFontPath24m function frees the data allocated by 4mXGet-0m
4mFontPath24m.

1m9.5.	Grabbing the Server0m

Xlib provides functions that you can use to grab and ungrab
the server.  These functions can be used to control process-
ing of output on other connections by the window system
server.	 While the server is grabbed, no processing of
requests or close downs on any other connection will occur.
A client closing its connection automatically ungrabs the
server.	 Although grabbing the server is highly discouraged,
it is sometimes necessary.


To grab the server, use 4mXGrabServer24m.








			     1m2760m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
XGrabServer(4mdisplay24m)
      Display *4mdisplay24m;


4mdisplay24m   Specifies the connection to the X server.
|__

The 4mXGrabServer24m function disables processing of requests and
close downs on all other connections than the one this
request arrived on.  You should not grab the X server any
more than is absolutely necessary.


To ungrab the server, use 4mXUngrabServer24m.
__
|
XUngrabServer(4mdisplay24m)
      Display *4mdisplay24m;


4mdisplay24m   Specifies the connection to the X server.
|__

The 4mXUngrabServer24m function restarts processing of requests
and close downs on other connections.  You should avoid
grabbing the X server as much as possible.

1m9.6.	Killing Clients0m

Xlib provides a function to cause the connection to a client
to be closed and its resources to be destroyed.	 To destroy
a client, use 4mXKillClient24m.
__
|
XKillClient(4mdisplay24m, 4mresource24m)
      Display *4mdisplay24m;
      XID 4mresource24m;


4mdisplay24m   Specifies the connection to the X server.

4mresource24m  Specifies any resource associated with the client
	  that you want to destroy or 4mAllTemporary24m.
|__

The 4mXKillClient24m function forces a close down of the client
that created the resource if a valid resource is specified.
If the client has already terminated in either 4mRetainPerma-0m
4mnent24m or 4mRetainTemporary24m mode, all of the client's resources
are destroyed.	If 4mAllTemporary24m is specified, the resources
of all clients that have terminated in 4mRetainTemporary24m are
destroyed (see section 2.5).  This permits implementation of
window manager facilities that aid debugging.  A client can



			     1m2770m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


set its close-down mode to 4mRetainTemporary24m.  If the client
then crashes, its windows would not be destroyed.  The pro-
grammer can then inspect the application's window tree and
use the window manager to destroy the zombie windows.

4mXKillClient24m can generate a 4mBadValue24m error.

1m9.7.	Controlling the Screen Saver0m

Xlib provides functions that you can use to set or reset the
mode of the screen saver, to force or activate the screen
saver, or to obtain the current screen saver values.


To set the screen saver mode, use 4mXSetScreenSaver24m.
__
|
XSetScreenSaver(4mdisplay24m, 4mtimeout24m, 4minterval24m, 4mprefer_blanking24m, 4mallow_exposures24m)
      Display *4mdisplay24m;
      int 4mtimeout24m, 4minterval24m;
      int 4mprefer_blanking24m;
      int 4mallow_exposures24m;


4mdisplay24m   Specifies the connection to the X server.

4mtimeout24m   Specifies the timeout, in seconds, until the
	  screen saver turns on.

4minterval24m  Specifies the interval, in seconds, between screen
	  saver alterations.

4mprefer_blanking0m
	  Specifies how to enable screen blanking.  You can
	  pass 4mDontPreferBlanking24m, 4mPreferBlanking24m, or
	  4mDefaultBlanking24m.

4mallow_exposures0m
	  Specifies the screen save control values.  You can
	  pass 4mDontAllowExposures24m, 4mAllowExposures24m, or
	  4mDefaultExposures24m.
|__

Timeout and interval are specified in seconds.	A timeout of
0 disables the screen saver (but an activated screen saver
is not deactivated), and a timeout of -1 restores the
default.  Other negative values generate a 4mBadValue24m error.
If the timeout value is nonzero, 4mXSetScreenSaver24m enables the
screen saver.  An interval of 0 disables the random-pattern
motion.	 If no input from devices (keyboard, mouse, and so
on) is generated for the specified number of timeout seconds
once the screen saver is enabled, the screen saver is acti-
vated.




			     1m2780m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


For each screen, if blanking is preferred and the hardware
supports video blanking, the screen simply goes blank.	Oth-
erwise, if either exposures are allowed or the screen can be
regenerated without sending 4mExpose24m events to clients, the
screen is tiled with the root window background tile ran-
domly re-origined each interval seconds.  Otherwise, the
screens' state do not change, and the screen saver is not
activated.  The screen saver is deactivated, and all screen
states are restored at the next keyboard or pointer input or
at the next call to 4mXForceScreenSaver24m with mode 4mScreenSaver-0m
4mReset24m.

If the server-dependent screen saver method supports peri-
odic change, the interval argument serves as a hint about
how long the change period should be, and zero hints that no
periodic change should be made.	 Examples of ways to change
the screen include scrambling the colormap periodically,
moving an icon image around the screen periodically, or
tiling the screen with the root window background tile, ran-
domly re-origined periodically.

4mXSetScreenSaver24m can generate a 4mBadValue24m error.


To force the screen saver on or off, use 4mXForceScreenSaver24m.
__
|
XForceScreenSaver(4mdisplay24m, 4mmode24m)
      Display *4mdisplay24m;
      int 4mmode24m;


4mdisplay24m   Specifies the connection to the X server.

4mmode24m      Specifies the mode that is to be applied.  You can
	  pass 4mScreenSaverActive24m or 4mScreenSaverReset24m.
|__

If the specified mode is 4mScreenSaverActive24m and the screen
saver currently is deactivated, 4mXForceScreenSaver24m activates
the screen saver even if the screen saver had been disabled
with a timeout of zero.	 If the specified mode is 4mScreen-0m
4mSaverReset24m and the screen saver currently is enabled,
4mXForceScreenSaver24m deactivates the screen saver if it was
activated, and the activation timer is reset to its initial
state (as if device input had been received).

4mXForceScreenSaver24m can generate a 4mBadValue24m error.


To activate the screen saver, use 4mXActivateScreenSaver24m.






			     1m2790m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
XActivateScreenSaver(4mdisplay24m)
      Display *4mdisplay24m;


4mdisplay24m   Specifies the connection to the X server.
|__


To reset the screen saver, use 4mXResetScreenSaver24m.
__
|
XResetScreenSaver(4mdisplay24m)
      Display *4mdisplay24m;


4mdisplay24m   Specifies the connection to the X server.
|__


To get the current screen saver values, use 4mXGetScreenSaver24m.
__
|
XGetScreenSaver(4mdisplay24m, 4mtimeout_return24m, 4minterval_return24m, 4mprefer_blanking_return24m,
		  4mallow_exposures_return24m)
      Display *4mdisplay24m;
      int *4mtimeout_return24m, *4minterval_return24m;
      int *4mprefer_blanking_return24m;
      int *4mallow_exposures_return24m;


4mdisplay24m   Specifies the connection to the X server.

4mtimeout_return0m
	  Returns the timeout, in seconds, until the screen
	  saver turns on.

4minterval_return0m
	  Returns the interval between screen saver invoca-
	  tions.

4mprefer_blanking_return0m
	  Returns the current screen blanking preference
	  (4mDontPreferBlanking24m, 4mPreferBlanking24m, or 4mDefault-0m
	  4mBlanking24m).

4mallow_exposures_return0m
	  Returns the current screen save control value
	  (4mDontAllowExposures24m, 4mAllowExposures24m, or 4mDefaultEx-0m
	  4mposures24m).
|__






			     1m2800m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


1m9.8.	Controlling Host Access0m

This section discusses how to:

·    Add, get, or remove hosts from the access control list

·    Change, enable, or disable access

X does not provide any protection on a per-window basis.  If
you find out the resource ID of a resource, you can manipu-
late it.  To provide some minimal level of protection, how-
ever, connections are permitted only from machines you
trust.	This is adequate on single-user workstations but
obviously breaks down on timesharing machines.	Although
provisions exist in the X protocol for proper connection
authentication, the lack of a standard authentication server
leaves host-level access control as the only common mecha-
nism.

The initial set of hosts allowed to open connections typi-
cally consists of:

·    The host the window system is running on.

·    On POSIX-conformant systems, each host listed in the
     4m/etc/X?.hosts24m file.  The ? indicates the number of the
     display.  This file should consist of host names sepa-
     rated by newlines.	 DECnet nodes must terminate in ::
     to distinguish them from Internet hosts.

If a host is not in the access control list when the access
control mechanism is enabled and if the host attempts to
establish a connection, the server refuses the connection.
To change the access list, the client must reside on the
same host as the server and/or must have been granted per-
mission in the initial authorization at connection setup.

Servers also can implement other access control policies in
addition to or in place of this host access facility.  For
further information about other access control implementa-
tions, see ``X Window System Protocol.''

1m9.8.1.  Adding, Getting, or Removing Hosts0m

Xlib provides functions that you can use to add, get, or
remove hosts from the access control list.  All the host
access control functions use the 4mXHostAddress24m structure,
which contains:









			     1m2810m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
typedef struct {
     int family;	      /* for example FamilyInternet */
     int length;	      /* length of address, in bytes */
     char *address;	      /* pointer to where to find the address */
} XHostAddress;

|__

The family member specifies which protocol address family to
use (for example, TCP/IP or DECnet) and can be 4mFamilyInter-0m
4mnet24m, 4mFamilyInternet624m, 4mFamilyDECnet24m, or 4mFamilyChaos24m.	 The
length member specifies the length of the address in bytes.
The address member specifies a pointer to the address.

For TCP/IP, the address should be in network byte order.
For IP version 4 addresses, the family should be FamilyIn-
ternet and the length should be 4 bytes.  For IP version 6
addresses, the family should be FamilyInternet6 and the
length should be 16 bytes.

For the DECnet family, the server performs no automatic
swapping on the address bytes.	A Phase IV address is 2
bytes long.  The first byte contains the least significant 8
bits of the node number.  The second byte contains the most
significant 2 bits of the node number in the least signifi-
cant 2 bits of the byte and the area in the most significant
6 bits of the byte.


To add a single host, use 4mXAddHost24m.
__
|
XAddHost(4mdisplay24m, 4mhost24m)
      Display *4mdisplay24m;
      XHostAddress *4mhost24m;


4mdisplay24m   Specifies the connection to the X server.

4mhost24m      Specifies the host that is to be added.
|__

The 4mXAddHost24m function adds the specified host to the access
control list for that display.	The server must be on the
same host as the client issuing the command, or a 4mBadAccess0m
error results.

4mXAddHost24m can generate 4mBadAccess24m and 4mBadValue24m errors.


To add multiple hosts at one time, use 4mXAddHosts24m.





			     1m2820m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
XAddHosts(4mdisplay24m, 4mhosts24m, 4mnum_hosts24m)
      Display *4mdisplay24m;
      XHostAddress *4mhosts24m;
      int 4mnum_hosts24m;


4mdisplay24m   Specifies the connection to the X server.

4mhosts24m     Specifies each host that is to be added.

4mnum_hosts24m Specifies the number of hosts.
|__

The 4mXAddHosts24m function adds each specified host to the
access control list for that display.  The server must be on
the same host as the client issuing the command, or a 4mBadAc-0m
4mcess24m error results.

4mXAddHosts24m can generate 4mBadAccess24m and 4mBadValue24m errors.


To obtain a host list, use 4mXListHosts24m.
__
|
XHostAddress *XListHosts(4mdisplay24m, 4mnhosts_return24m, 4mstate_return24m)
      Display *4mdisplay24m;
      int *4mnhosts_return24m;
      Bool *4mstate_return24m;


4mdisplay24m   Specifies the connection to the X server.

4mnhosts_return0m
	  Returns the number of hosts currently in the
	  access control list.

4mstate_return0m
	  Returns the state of the access control.
|__

The 4mXListHosts24m function returns the current access control
list as well as whether the use of the list at connection
setup was enabled or disabled.	4mXListHosts24m allows a program
to find out what machines can make connections.	 It also
returns a pointer to a list of host structures that were
allocated by the function.  When no longer needed, this mem-
ory should be freed by calling 4mXFree24m.


To remove a single host, use 4mXRemoveHost24m.






			     1m2830m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
XRemoveHost(4mdisplay24m, 4mhost24m)
      Display *4mdisplay24m;
      XHostAddress *4mhost24m;


4mdisplay24m   Specifies the connection to the X server.

4mhost24m      Specifies the host that is to be removed.
|__

The 4mXRemoveHost24m function removes the specified host from the
access control list for that display.  The server must be on
the same host as the client process, or a 4mBadAccess24m error
results.  If you remove your machine from the access list,
you can no longer connect to that server, and this operation
cannot be reversed unless you reset the server.

4mXRemoveHost24m can generate 4mBadAccess24m and 4mBadValue24m errors.


To remove multiple hosts at one time, use 4mXRemoveHosts24m.
__
|
XRemoveHosts(4mdisplay24m, 4mhosts24m, 4mnum_hosts24m)
      Display *4mdisplay24m;
      XHostAddress *4mhosts24m;
      int 4mnum_hosts24m;


4mdisplay24m   Specifies the connection to the X server.

4mhosts24m     Specifies each host that is to be removed.

4mnum_hosts24m Specifies the number of hosts.
|__

The 4mXRemoveHosts24m function removes each specified host from
the access control list for that display.  The X server must
be on the same host as the client process, or a 4mBadAccess0m
error results.	If you remove your machine from the access
list, you can no longer connect to that server, and this
operation cannot be reversed unless you reset the server.

4mXRemoveHosts24m can generate 4mBadAccess24m and 4mBadValue24m errors.

1m9.8.2.  Changing, Enabling, or Disabling Access Control0m

Xlib provides functions that you can use to enable, disable,
or change access control.

For these functions to execute successfully, the client
application must reside on the same host as the X server
and/or have been given permission in the initial



			     1m2840m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


authorization at connection setup.


To change access control, use 4mXSetAccessControl24m.
__
|
XSetAccessControl(4mdisplay24m, 4mmode24m)
      Display *4mdisplay24m;
      int 4mmode24m;


4mdisplay24m   Specifies the connection to the X server.

4mmode24m      Specifies the mode.  You can pass 4mEnableAccess24m or
	  4mDisableAccess24m.
|__

The 4mXSetAccessControl24m function either enables or disables
the use of the access control list at each connection setup.

4mXSetAccessControl24m can generate 4mBadAccess24m and 4mBadValue0m
errors.


To enable access control, use 4mXEnableAccessControl24m.
__
|
XEnableAccessControl(4mdisplay24m)
      Display *4mdisplay24m;


4mdisplay24m   Specifies the connection to the X server.
|__

The 4mXEnableAccessControl24m function enables the use of the
access control list at each connection setup.

4mXEnableAccessControl24m can generate a 4mBadAccess24m error.


To disable access control, use 4mXDisableAccessControl24m.
__
|
XDisableAccessControl(4mdisplay24m)
      Display *4mdisplay24m;


4mdisplay24m   Specifies the connection to the X server.
|__

The 4mXDisableAccessControl24m function disables the use of the
access control list at each connection setup.





			     1m2850m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


4mXDisableAccessControl24m can generate a 4mBadAccess24m error.
























































			     1m2860m





1mXlib - C Library			X11, Release 6.7 DRAFT0m




			 1mChapter 100m

			   1mEvents0m



A client application communicates with the X server through
the connection you establish with the 4mXOpenDisplay24m function.
A client application sends requests to the X server over
this connection.  These requests are made by the Xlib func-
tions that are called in the client application.  Many Xlib
functions cause the X server to generate events, and the
user's typing or moving the pointer can generate events
asynchronously.	 The X server returns events to the client
on the same connection.

This chapter discusses the following topics associated with
events:

·    Event types

·    Event structures

·    Event masks

·    Event processing

Functions for handling events are dealt with in the next
chapter.

1m10.1.	 Event Types0m

An event is data generated asynchronously by the X server as
a result of some device activity or as side effects of a
request sent by an Xlib function.  Device-related events
propagate from the source window to ancestor windows until
some client application has selected that event type or
until the event is explicitly discarded.  The X server gen-
erally sends an event to a client application only if the
client has specifically asked to be informed of that event
type, typically by setting the event-mask attribute of the
window.	 The mask can also be set when you create a window
or by changing the window's event-mask.	 You can also mask
out events that would propagate to ancestor windows by
manipulating the do-not-propagate mask of the window's
attributes.  However, 4mMappingNotify24m events are always sent
to all clients.

An event type describes a specific event generated by the X
server.	 For each event type, a corresponding constant name
is defined in <4mX11/X.h24m>, which is used when referring to an
event type.  The following table lists the event category



			     1m2870m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


and its associated event type or types.	 The processing
associated with these events is discussed in section 10.5.



-------------------------------------------------------------
1mEvent Category	   Event Type0m
-------------------------------------------------------------
Keyboard events		 4mKeyPress24m, 4mKeyRelease0m
Pointer events		 4mButtonPress24m, 4mButtonRelease24m, 4mMotion-0m
			 4mNotify0m
Window crossing events	 4mEnterNotify24m, 4mLeaveNotify0m
Input focus events	 4mFocusIn24m, 4mFocusOut0m
Keymap state notifica-	 4mKeymapNotify0m
tion event
Exposure events		 4mExpose24m, 4mGraphicsExpose24m, 4mNoExpose0m
Structure control	 4mCirculateRequest24m, 4mConfigureRequest24m,
events			 4mMapRequest24m, 4mResizeRequest0m
Window state notifica-	 4mCirculateNotify24m, 4mConfigureNotify24m,
tion events		 4mCreateNotify24m, 4mDestroyNotify24m, 4mGravi-0m
			 4mtyNotify24m, 4mMapNotify24m, 4mMappingNotify24m,
			 4mReparentNotify24m, 4mUnmapNotify24m,
			 4mVisibilityNotify0m
Colormap state notifi-	 4mColormapNotify0m
cation event
Client communication	 4mClientMessage24m, 4mPropertyNotify24m,
events			 4mSelectionClear24m, 4mSelectionNotify24m,
			 4mSelectionRequest0m
-------------------------------------------------------------


1m10.2.	 Event Structures0m

For each event type, a corresponding structure is declared
in <4mX11/Xlib.h24m>.  All the event structures have the follow-
ing common members:

__
|
typedef struct {
     int type;
     unsigned long serial;    /* # of last request processed by server */
     Bool send_event;	      /* true if this came from a SendEvent request */
     Display *display;	      /* Display the event was read from */
     Window window;
} XAnyEvent;

|__

The type member is set to the event type constant name that
uniquely identifies it.	 For example, when the X server
reports a 4mGraphicsExpose24m event to a client application, it
sends an 4mXGraphicsExposeEvent24m structure with the type member
set to 4mGraphicsExpose24m.  The display member is set to a



			     1m2880m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


pointer to the display the event was read on.  The
send_event member is set to 4mTrue24m if the event came from a
4mSendEvent24m protocol request.  The serial member is set from
the serial number reported in the protocol but expanded from
the 16-bit least-significant bits to a full 32-bit value.
The window member is set to the window that is most useful
to toolkit dispatchers.

The X server can send events at any time in the input
stream.	 Xlib stores any events received while waiting for a
reply in an event queue for later use.	Xlib also provides
functions that allow you to check events in the event queue
(see section 11.3).

In addition to the individual structures declared for each
event type, the 4mXEvent24m structure is a union of the individ-
ual structures declared for each event type.  Depending on
the type, you should access members of each event by using
the 4mXEvent24m union.






































			     1m2890m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
typedef union _XEvent {
     int type;		      /* must not be changed */
     XAnyEvent xany;
     XKeyEvent xkey;
     XButtonEvent xbutton;
     XMotionEvent xmotion;
     XCrossingEvent xcrossing;
     XFocusChangeEvent xfocus;
     XExposeEvent xexpose;
     XGraphicsExposeEvent xgraphicsexpose;
     XNoExposeEvent xnoexpose;
     XVisibilityEvent xvisibility;
     XCreateWindowEvent xcreatewindow;
     XDestroyWindowEvent xdestroywindow;
     XUnmapEvent xunmap;
     XMapEvent xmap;
     XMapRequestEvent xmaprequest;
     XReparentEvent xreparent;
     XConfigureEvent xconfigure;
     XGravityEvent xgravity;
     XResizeRequestEvent xresizerequest;
     XConfigureRequestEvent xconfigurerequest;
     XCirculateEvent xcirculate;
     XCirculateRequestEvent xcirculaterequest;
     XPropertyEvent xproperty;
     XSelectionClearEvent xselectionclear;
     XSelectionRequestEvent xselectionrequest;
     XSelectionEvent xselection;
     XColormapEvent xcolormap;
     XClientMessageEvent xclient;
     XMappingEvent xmapping;
     XErrorEvent xerror;
     XKeymapEvent xkeymap;
     long pad[24];
} XEvent;

|__

An 4mXEvent24m structure's first entry always is the type member,
which is set to the event type.	 The second member always is
the serial number of the protocol request that generated the
event.	The third member always is send_event, which is a
4mBool24m that indicates if the event was sent by a different
client.	 The fourth member always is a display, which is the
display that the event was read from.  Except for keymap
events, the fifth member always is a window, which has been
carefully selected to be useful to toolkit dispatchers.	 To
avoid breaking toolkits, the order of these first five
entries is not to change.  Most events also contain a time
member, which is the time at which an event occurred.  In
addition, a pointer to the generic event must be cast before
it is used to access any other information in the structure.




			     1m2900m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


1m10.3.	 Event Masks0m

Clients select event reporting of most events relative to a
window.	 To do this, pass an event mask to an Xlib event-
handling function that takes an event_mask argument.  The
bits of the event mask are defined in <4mX11/X.h24m>.  Each bit
in the event mask maps to an event mask name, which
describes the event or events you want the X server to
return to a client application.

Unless the client has specifically asked for them, most
events are not reported to clients when they are generated.
Unless the client suppresses them by setting graphics-expo-
sures in the GC to 4mFalse24m, 4mGraphicsExpose24m and 4mNoExpose24m are
reported by default as a result of 4mXCopyPlane24m and 4mXCopyArea24m.
4mSelectionClear24m, 4mSelectionRequest24m, 4mSelectionNotify24m, or
4mClientMessage24m cannot be masked.  Selection-related events
are only sent to clients cooperating with selections (see
section 4.5).  When the keyboard or pointer mapping is
changed, 4mMappingNotify24m is always sent to clients.

The following table lists the event mask constants you can
pass to the event_mask argument and the circumstances in
which you would want to specify the event mask:


-----------------------------------------------------------
1mEvent Mask		 Circumstances0m
-----------------------------------------------------------
4mNoEventMask24m	    No events wanted
4mKeyPressMask24m	    Keyboard down events wanted
4mKeyReleaseMask24m	    Keyboard up events wanted
4mButtonPressMask24m	    Pointer button down events wanted
4mButtonReleaseMask24m	    Pointer button up events wanted
4mEnterWindowMask24m	    Pointer window entry events wanted
4mLeaveWindowMask24m	    Pointer window leave events wanted
4mPointerMotionMask24m	    Pointer motion events wanted
4mPointerMotionHint-24m	    Pointer motion hints wanted
4mMask0m
4mButton1MotionMask24m	    Pointer motion while button 1 down
4mButton2MotionMask24m	    Pointer motion while button 2 down
4mButton3MotionMask24m	    Pointer motion while button 3 down
4mButton4MotionMask24m	    Pointer motion while button 4 down
4mButton5MotionMask24m	    Pointer motion while button 5 down
4mButtonMotionMask24m	    Pointer motion while any button
		       down
4mKeymapStateMask24m	    Keyboard state wanted at window
		       entry and focus in
4mExposureMask24m	    Any exposure wanted
4mVisibilityChangeMask24m   Any change in visibility wanted
4mStructureNotifyMask24m    Any change in window structure
		       wanted
4mResizeRedirectMask24m	    Redirect resize of this window




			     1m2910m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


-----------------------------------------------------------
1mEvent Mask		 Circumstances0m
-----------------------------------------------------------
4mSubstructureNotify-24m    Substructure notification wanted
4mMask0m
4mSubstructureRedi-24m	    Redirect structure requests on
4mrectMask24m		    children
4mFocusChangeMask24m	    Any change in input focus wanted
4mPropertyChangeMask24m	    Any change in property wanted
4mColormapChangeMask24m	    Any change in colormap wanted
4mOwnerGrabButtonMask24m    Automatic grabs should activate
		       with owner_events set to 4mTrue0m
-----------------------------------------------------------



1m10.4.	 Event Processing Overview0m

The event reported to a client application during event pro-
cessing depends on which event masks you provide as the
event-mask attribute for a window.  For some event masks,
there is a one-to-one correspondence between the event mask
constant and the event type constant.  For example, if you
pass the event mask 4mButtonPressMask24m, the X server sends back
only 4mButtonPress24m events.  Most events contain a time member,
which is the time at which an event occurred.

In other cases, one event mask constant can map to several
event type constants.  For example, if you pass the event
mask 4mSubstructureNotifyMask24m, the X server can send back 4mCir-0m
4mculateNotify24m, 4mConfigureNotify24m, 4mCreateNotify24m, 4mDestroyNotify24m,
4mGravityNotify24m, 4mMapNotify24m, 4mReparentNotify24m, or 4mUnmapNotify0m
events.

In another case, two event masks can map to one event type.
For example, if you pass either 4mPointerMotionMask24m or 4mButton-0m
4mMotionMask24m, the X server sends back a 4mMotionNotify24m event.

The following table lists the event mask, its associated
event type or types, and the structure name associated with
the event type.	 Some of these structures actually are type-
defs to a generic structure that is shared between two event
types.	Note that N.A. appears in columns for which the
information is not applicable.


------------------------------------------------------------------------------------------
1mEvent Mask		      Event Type	 Structure		  Generic Structure0m
------------------------------------------------------------------------------------------
ButtonMotionMask	    MotionNotify       XPointerMovedEvent	XMotionEvent
Button1MotionMask
Button2MotionMask
Button3MotionMask




			     1m2920m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


------------------------------------------------------------------------------------------
1mEvent Mask		      Event Type	 Structure		  Generic Structure0m
------------------------------------------------------------------------------------------
Button4MotionMask
Button5MotionMask
ButtonPressMask		    ButtonPress	       XButtonPressedEvent	XButtonEvent
ButtonReleaseMask	    ButtonRelease      XButtonReleasedEvent	XButtonEvent
ColormapChangeMask	    ColormapNotify     XColormapEvent
EnterWindowMask		    EnterNotify	       XEnterWindowEvent	XCrossingEvent
LeaveWindowMask		    LeaveNotify	       XLeaveWindowEvent	XCrossingEvent
ExposureMask		    Expose	       XExposeEvent
GCGraphicsExposures in GC   GraphicsExpose     XGraphicsExposeEvent
			    NoExpose	       XNoExposeEvent
FocusChangeMask		    FocusIn	       XFocusInEvent		XFocusChangeEvent
			    FocusOut	       XFocusOutEvent		XFocusChangeEvent
KeymapStateMask		    KeymapNotify       XKeymapEvent
KeyPressMask		    KeyPress	       XKeyPressedEvent		XKeyEvent
KeyReleaseMask		    KeyRelease	       XKeyReleasedEvent	XKeyEvent
OwnerGrabButtonMask	    N.A.	       N.A.
PointerMotionMask	    MotionNotify       XPointerMovedEvent	XMotionEvent
PointerMotionHintMask	    N.A.	       N.A.
PropertyChangeMask	    PropertyNotify     XPropertyEvent
ResizeRedirectMask	    ResizeRequest      XResizeRequestEvent
StructureNotifyMask	    CirculateNotify    XCirculateEvent
			    ConfigureNotify    XConfigureEvent
			    DestroyNotify      XDestroyWindowEvent
			    GravityNotify      XGravityEvent
			    MapNotify	       XMapEvent
			    ReparentNotify     XReparentEvent
			    UnmapNotify	       XUnmapEvent
SubstructureNotifyMask	    CirculateNotify    XCirculateEvent
			    ConfigureNotify    XConfigureEvent
			    CreateNotify       XCreateWindowEvent
			    DestroyNotify      XDestroyWindowEvent
			    GravityNotify      XGravityEvent
			    MapNotify	       XMapEvent
			    ReparentNotify     XReparentEvent
			    UnmapNotify	       XUnmapEvent
SubstructureRedirectMask    CirculateRequest   XCirculateRequestEvent
			    ConfigureRequest   XConfigureRequestEvent
			    MapRequest	       XMapRequestEvent
N.A.			    ClientMessage      XClientMessageEvent
N.A.			    MappingNotify      XMappingEvent
N.A.			    SelectionClear     XSelectionClearEvent
N.A.			    SelectionNotify    XSelectionEvent
N.A.			    SelectionRequest   XSelectionRequestEvent
VisibilityChangeMask	    VisibilityNotify   XVisibilityEvent
------------------------------------------------------------------------------------------


The sections that follow describe the processing that occurs
when you select the different event masks.  The sections are
organized according to these processing categories:




			     1m2930m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


·    Keyboard and pointer events

·    Window crossing events

·    Input focus events

·    Keymap state notification events

·    Exposure events

·    Window state notification events

·    Structure control events

·    Colormap state notification events

·    Client communication events

1m10.5.	 Keyboard and Pointer Events0m

This section discusses:

·    Pointer button events

·    Keyboard and pointer events

1m10.5.1.  Pointer Button Events0m

The following describes the event processing that occurs
when a pointer button press is processed with the pointer in
some window w and when no active pointer grab is in
progress.

The X server searches the ancestors of w from the root down,
looking for a passive grab to activate.	 If no matching pas-
sive grab on the button exists, the X server automatically
starts an active grab for the client receiving the event and
sets the last-pointer-grab time to the current server time.
The effect is essentially equivalent to an 4mXGrabButton24m with
these client passed arguments:

------------------------------------------------------
1mArgument	    Value0m
------------------------------------------------------
4mw24m		       The event window
4mevent_mask24m	       The client's selected pointer
		  events on the event window
4mpointer_mode24m      4mGrabModeAsync0m
4mkeyboard_mode24m     4mGrabModeAsync0m
4mowner_events24m      4mTrue24m, if the client has selected
		  4mOwnerGrabButtonMask24m on the event
		  window, otherwise 4mFalse0m
4mconfine_to24m	       4mNone0m




			     1m2940m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


------------------------------------------------------
1mArgument	    Value0m
------------------------------------------------------
4mcursor24m	       4mNone0m
------------------------------------------------------


The active grab is automatically terminated when the logical
state of the pointer has all buttons released.	Clients can
modify the active grab by calling 4mXUngrabPointer24m and
4mXChangeActivePointerGrab24m.

1m10.5.2.  Keyboard and Pointer Events0m

This section discusses the processing that occurs for the
keyboard events 4mKeyPress24m and 4mKeyRelease24m and the pointer
events 4mButtonPress24m, 4mButtonRelease24m, and 4mMotionNotify24m.  For
information about the keyboard event-handling utilities, see
chapter 11.

The X server reports 4mKeyPress24m or 4mKeyRelease24m events to
clients wanting information about keys that logically change
state.	Note that these events are generated for all keys,
even those mapped to modifier bits.  The X server reports
4mButtonPress24m or 4mButtonRelease24m events to clients wanting
information about buttons that logically change state.

The X server reports 4mMotionNotify24m events to clients wanting
information about when the pointer logically moves.  The X
server generates this event whenever the pointer is moved
and the pointer motion begins and ends in the window.  The
granularity of 4mMotionNotify24m events is not guaranteed, but a
client that selects this event type is guaranteed to receive
at least one event when the pointer moves and then rests.

The generation of the logical changes lags the physical
changes if device event processing is frozen.

To receive 4mKeyPress24m, 4mKeyRelease24m, 4mButtonPress24m, and 4mButtonRe-0m
4mlease24m events, set 4mKeyPressMask24m, 4mKeyReleaseMask24m, 4mButtonPress-0m
4mMask24m, and 4mButtonReleaseMask24m bits in the event-mask attribute
of the window.

To receive 4mMotionNotify24m events, set one or more of the fol-
lowing event masks bits in the event-mask attribute of the
window.

·    4mButton1MotionMask24m - 4mButton5MotionMask0m

     The client application receives 4mMotionNotify24m events
     only when one or more of the specified buttons is
     pressed.





			     1m2950m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


·    4mButtonMotionMask0m

     The client application receives 4mMotionNotify24m events
     only when at least one button is pressed.

·    4mPointerMotionMask0m

     The client application receives 4mMotionNotify24m events
     independent of the state of the pointer buttons.

·    4mPointerMotionHintMask0m

     If 4mPointerMotionHintMask24m is selected in combination
     with one or more of the above masks, the X server is
     free to send only one 4mMotionNotify24m event (with the
     is_hint member  of the 4mXPointerMovedEvent24m structure set
     to 4mNotifyHint24m) to the client for the event window,
     until either the key or button state changes, the
     pointer leaves the event window, or the client calls
     4mXQueryPointer24m or 4mXGetMotionEvents24m.  The server still
     may send 4mMotionNotify24m events without is_hint set to
     4mNotifyHint24m.

The source of the event is the viewable window that the
pointer is in.	The window used by the X server to report
these events depends on the window's position in the window
hierarchy and whether any intervening window prohibits the
generation of these events.  Starting with the source win-
dow, the X server searches up the window hierarchy until it
locates the first window specified by a client as having an
interest in these events.  If one of the intervening windows
has its do-not-propagate-mask set to prohibit generation of
the event type, the events of those types will be sup-
pressed.  Clients can modify the actual window used for
reporting by performing active grabs and, in the case of
keyboard events, by using the focus window.

The structures for these event types contain:



















			     1m2960m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
typedef struct {
     int type;		      /* ButtonPress or ButtonRelease */
     unsigned long serial;    /* # of last request processed by server */
     Bool send_event;	      /* true if this came from a SendEvent request */
     Display *display;	      /* Display the event was read from */
     Window window;	      /* ``event'' window it is reported relative to */
     Window root;	      /* root window that the event occurred on */
     Window subwindow;	      /* child window */
     Time time;		      /* milliseconds */
     int x, y;		      /* pointer x, y coordinates in event window */
     int x_root, y_root;      /* coordinates relative to root */
     unsigned int state;      /* key or button mask */
     unsigned int button;     /* detail */
     Bool same_screen;	      /* same screen flag */
} XButtonEvent;
typedef XButtonEvent XButtonPressedEvent;
typedef XButtonEvent XButtonReleasedEvent;



typedef struct {
     int type;		      /* KeyPress or KeyRelease */
     unsigned long serial;    /* # of last request processed by server */
     Bool send_event;	      /* true if this came from a SendEvent request */
     Display *display;	      /* Display the event was read from */
     Window window;	      /* ``event'' window it is reported relative to */
     Window root;	      /* root window that the event occurred on */
     Window subwindow;	      /* child window */
     Time time;		      /* milliseconds */
     int x, y;		      /* pointer x, y coordinates in event window */
     int x_root, y_root;      /* coordinates relative to root */
     unsigned int state;      /* key or button mask */
     unsigned int keycode;    /* detail */
     Bool same_screen;	      /* same screen flag */
} XKeyEvent;
typedef XKeyEvent XKeyPressedEvent;
typedef XKeyEvent XKeyReleasedEvent;



typedef struct {
     int type;		      /* MotionNotify */
     unsigned long serial;    /* # of last request processed by server */
     Bool send_event;	      /* true if this came from a SendEvent request */
     Display *display;	      /* Display the event was read from */
     Window window;	      /* ``event'' window reported relative to */
     Window root;	      /* root window that the event occurred on */
     Window subwindow;	      /* child window */
     Time time;		      /* milliseconds */
     int x, y;		      /* pointer x, y coordinates in event window */
     int x_root, y_root;      /* coordinates relative to root */
     unsigned int state;      /* key or button mask */
     char is_hint;	      /* detail */



			     1m2970m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


     Bool same_screen;	      /* same screen flag */
} XMotionEvent;
typedef XMotionEvent XPointerMovedEvent;

|__

These structures have the following common members: window,
root, subwindow, time, x, y, x_root, y_root, state, and
same_screen.  The window member is set to the window on
which the event was generated and is referred to as the
event window.  As long as the conditions previously dis-
cussed are met, this is the window used by the X server to
report the event.  The root member is set to the source win-
dow's root window.  The x_root and y_root members are set to
the pointer's coordinates relative to the root window's ori-
gin at the time of the event.

The same_screen member is set to indicate whether the event
window is on the same screen as the root window and can be
either 4mTrue24m or 4mFalse24m.	 If 4mTrue24m, the event and root windows
are on the same screen.	 If 4mFalse24m, the event and root win-
dows are not on the same screen.

If the source window is an inferior of the event window, the
subwindow member of the structure is set to the child of the
event window that is the source window or the child of the
event window that is an ancestor of the source window.	Oth-
erwise, the X server sets the subwindow member to 4mNone24m.  The
time member is set to the time when the event was generated
and is expressed in milliseconds.

If the event window is on the same screen as the root win-
dow, the x and y members are set to the coordinates relative
to the event window's origin.  Otherwise, these members are
set to zero.

The state member is set to indicate the logical state of the
pointer buttons and modifier keys just prior to the event,
which is the bitwise inclusive OR of one or more of the but-
ton or modifier key masks: 4mButton1Mask24m, 4mButton2Mask24m, 4mBut-0m
4mton3Mask24m, 4mButton4Mask24m, 4mButton5Mask24m, 4mShiftMask24m, 4mLockMask24m,
4mControlMask24m, 4mMod1Mask24m, 4mMod2Mask24m, 4mMod3Mask24m, 4mMod4Mask24m, and
4mMod5Mask24m.

Each of these structures also has a member that indicates
the detail.  For the 4mXKeyPressedEvent24m and 4mXKeyReleasedEvent0m
structures, this member is called a keycode.  It is set to a
number that represents a physical key on the keyboard.	The
keycode is an arbitrary representation for any key on the
keyboard (see sections 12.7 and 16.1).

For the 4mXButtonPressedEvent24m and 4mXButtonReleasedEvent24m struc-
tures, this member is called button.  It represents the
pointer button that changed state and can be the 4mButton124m,



			     1m2980m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


4mButton224m, 4mButton324m, 4mButton424m, or 4mButton524m value.  For the
4mXPointerMovedEvent24m structure, this member is called is_hint.
It can be set to 4mNotifyNormal24m or 4mNotifyHint24m.

Some of the symbols mentioned in this section have fixed
values, as follows:

-----------------------------------------------------------
1mSymbol		 Value0m
-----------------------------------------------------------
4mButton1MotionMask24m	    (1L<<8)
4mButton2MotionMask24m	    (1L<<9)
4mButton3MotionMask24m	    (1L<<10)
4mButton4MotionMask24m	    (1L<<11)
4mButton5MotionMask24m	    (1L<<12)
4mButton1Mask24m	    (1<<8)
4mButton2Mask24m	    (1<<9)
4mButton3Mask24m	    (1<<10)
4mButton4Mask24m	    (1<<11)
4mButton5Mask24m	    (1<<12)
4mShiftMask24m		    (1<<0)
4mLockMask24m		    (1<<1)
4mControlMask24m	    (1<<2)
4mMod1Mask24m		    (1<<3)
4mMod2Mask24m		    (1<<4)
4mMod3Mask24m		    (1<<5)
4mMod4Mask24m		    (1<<6)
4mMod5Mask24m		    (1<<7)
4mButton124m		    1
4mButton224m		    2
4mButton324m		    3
4mButton424m		    4
4mButton524m		    5
-----------------------------------------------------------


1m10.6.	 Window Entry/Exit Events0m

This section describes the processing that occurs for the
window crossing events 4mEnterNotify24m and 4mLeaveNotify24m.  If a
pointer motion or a window hierarchy change causes the
pointer to be in a different window than before, the X
server reports 4mEnterNotify24m or 4mLeaveNotify24m events to clients
who have selected for these events.  All 4mEnterNotify24m and
4mLeaveNotify24m events caused by a hierarchy change are gener-
ated after any hierarchy event (4mUnmapNotify24m, 4mMapNotify24m, 4mCon-0m
4mfigureNotify24m, 4mGravityNotify24m, 4mCirculateNotify24m) caused by that
change; however, the X protocol does not constrain the
ordering of 4mEnterNotify24m and 4mLeaveNotify24m events with respect
to 4mFocusOut24m, 4mVisibilityNotify24m, and 4mExpose24m events.

This contrasts with 4mMotionNotify24m events, which are also gen-
erated when the pointer moves but only when the pointer
motion begins and ends in a single window.  An 4mEnterNotify0m



			     1m2990m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


or 4mLeaveNotify24m event also can be generated when some client
application calls 4mXGrabPointer24m and 4mXUngrabPointer24m.

To receive 4mEnterNotify24m or 4mLeaveNotify24m events, set the 4mEnter-0m
4mWindowMask24m or 4mLeaveWindowMask24m bits of the event-mask
attribute of the window.

The structure for these event types contains:

__
|
typedef struct {
     int type;		      /* EnterNotify or LeaveNotify */
     unsigned long serial;    /* # of last request processed by server */
     Bool send_event;	      /* true if this came from a SendEvent request */
     Display *display;	      /* Display the event was read from */
     Window window;	      /* ``event'' window reported relative to */
     Window root;	      /* root window that the event occurred on */
     Window subwindow;	      /* child window */
     Time time;		      /* milliseconds */
     int x, y;		      /* pointer x, y coordinates in event window */
     int x_root, y_root;      /* coordinates relative to root */
     int mode;		      /* NotifyNormal, NotifyGrab, NotifyUngrab */
     int detail;
			      /*
			      * NotifyAncestor, NotifyVirtual, NotifyInferior,
			      * NotifyNonlinear,NotifyNonlinearVirtual
			      */
     Bool same_screen;	      /* same screen flag */
     Bool focus;	      /* boolean focus */
     unsigned int state;      /* key or button mask */
} XCrossingEvent;
typedef XCrossingEvent XEnterWindowEvent;
typedef XCrossingEvent XLeaveWindowEvent;

|__

The window member is set to the window on which the 4mEnter-0m
4mNotify24m or 4mLeaveNotify24m event was generated and is referred to
as the event window.  This is the window used by the X
server to report the event, and is relative to the root win-
dow on which the event occurred.  The root member is set to
the root window of the screen on which the event occurred.

For a 4mLeaveNotify24m event, if a child of the event window con-
tains the initial position of the pointer, the subwindow
component is set to that child.	 Otherwise, the X server
sets the subwindow member to 4mNone24m.	 For an 4mEnterNotify0m
event, if a child of the event window contains the final
pointer position, the subwindow component is set to that
child or 4mNone24m.

The time member is set to the time when the event was gener-
ated and is expressed in milliseconds.	The x and y members



			     1m3000m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


are set to the coordinates of the pointer position in the
event window.  This position is always the pointer's final
position, not its initial position.  If the event window is
on the same screen as the root window, x and y are the
pointer coordinates relative to the event window's origin.
Otherwise, x and y are set to zero.  The x_root and y_root
members are set to the pointer's coordinates relative to the
root window's origin at the time of the event.

The same_screen member is set to indicate whether the event
window is on the same screen as the root window and can be
either 4mTrue24m or 4mFalse24m.	 If 4mTrue24m, the event and root windows
are on the same screen.	 If 4mFalse24m, the event and root win-
dows are not on the same screen.

The focus member is set to indicate whether the event window
is the focus window or an inferior of the focus window.	 The
X server can set this member to either 4mTrue24m or 4mFalse24m.	 If
4mTrue24m, the event window is the focus window or an inferior of
the focus window.  If 4mFalse24m, the event window is not the
focus window or an inferior of the focus window.

The state member is set to indicate the state of the pointer
buttons and modifier keys just prior to the event.  The X
server can set this member to the bitwise inclusive OR of
one or more of the button or modifier key masks: 4mBut-0m
4mton1Mask24m, 4mButton2Mask24m, 4mButton3Mask24m, 4mButton4Mask24m, 4mBut-0m
4mton5Mask24m, 4mShiftMask24m, 4mLockMask24m, 4mControlMask24m, 4mMod1Mask24m,
4mMod2Mask24m, 4mMod3Mask24m, 4mMod4Mask24m, 4mMod5Mask24m.

The mode member is set to indicate whether the events are
normal events, pseudo-motion events when a grab activates,
or pseudo-motion events when a grab deactivates.  The X
server can set this member to 4mNotifyNormal24m, 4mNotifyGrab24m, or
4mNotifyUngrab24m.

The detail member is set to indicate the notify detail and
can be 4mNotifyAncestor24m, 4mNotifyVirtual24m, 4mNotifyInferior24m, 4mNoti-0m
4mfyNonlinear24m, or 4mNotifyNonlinearVirtual24m.

1m10.6.1.  Normal Entry/Exit Events0m

4mEnterNotify24m and 4mLeaveNotify24m events are generated when the
pointer moves from one window to another window.  Normal
events are identified by 4mXEnterWindowEvent24m or 4mXLeaveWindow-0m
4mEvent24m structures whose mode member is set to 4mNotifyNormal24m.

·    When the pointer moves from window A to window B and A
     is an inferior of B, the X server does the following:

     -	  It generates a 4mLeaveNotify24m event on window A, with
	  the detail member of the 4mXLeaveWindowEvent24m struc-
	  ture set to 4mNotifyAncestor24m.




			     1m3010m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


     -	  It generates a 4mLeaveNotify24m event on each window
	  between window A and window B, exclusive, with the
	  detail member of each 4mXLeaveWindowEvent24m structure
	  set to 4mNotifyVirtual24m.

     -	  It generates an 4mEnterNotify24m event on window B,
	  with the detail member of the 4mXEnterWindowEvent0m
	  structure set to 4mNotifyInferior24m.

·    When the pointer moves from window A to window B and B
     is an inferior of A, the X server does the following:

     -	  It generates a 4mLeaveNotify24m event on window A, with
	  the detail member of the 4mXLeaveWindowEvent24m struc-
	  ture set to 4mNotifyInferior24m.

     -	  It generates an 4mEnterNotify24m event on each window
	  between window A and window B, exclusive, with the
	  detail member of each 4mXEnterWindowEvent24m structure
	  set to 4mNotifyVirtual24m.

     -	  It generates an 4mEnterNotify24m event on window B,
	  with the detail member of the 4mXEnterWindowEvent0m
	  structure set to 4mNotifyAncestor24m.

·    When the pointer moves from window A to window B and
     window C is their least common ancestor, the X server
     does the following:

     -	  It generates a 4mLeaveNotify24m event on window A, with
	  the detail member of the 4mXLeaveWindowEvent24m struc-
	  ture set to 4mNotifyNonlinear24m.

     -	  It generates a 4mLeaveNotify24m event on each window
	  between window A and window C, exclusive, with the
	  detail member of each 4mXLeaveWindowEvent24m structure
	  set to 4mNotifyNonlinearVirtual24m.

     -	  It generates an 4mEnterNotify24m event on each window
	  between window C and window B, exclusive, with the
	  detail member of each 4mXEnterWindowEvent24m structure
	  set to 4mNotifyNonlinearVirtual24m.

     -	  It generates an 4mEnterNotify24m event on window B,
	  with the detail member of the 4mXEnterWindowEvent0m
	  structure set to 4mNotifyNonlinear24m.

·    When the pointer moves from window A to window B on
     different screens, the X server does the following:

     -	  It generates a 4mLeaveNotify24m event on window A, with
	  the detail member of the 4mXLeaveWindowEvent24m struc-
	  ture set to 4mNotifyNonlinear24m.




			     1m3020m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


     -	  If window A is not a root window, it generates a
	  4mLeaveNotify24m event on each window above window A up
	  to and including its root, with the detail member
	  of each 4mXLeaveWindowEvent24m structure set to 4mNoti-0m
	  4mfyNonlinearVirtual24m.

     -	  If window B is not a root window, it generates an
	  4mEnterNotify24m event on each window from window B's
	  root down to but not including window B, with the
	  detail member of each 4mXEnterWindowEvent24m structure
	  set to 4mNotifyNonlinearVirtual24m.

     -	  It generates an 4mEnterNotify24m event on window B,
	  with the detail member of the 4mXEnterWindowEvent0m
	  structure set to 4mNotifyNonlinear24m.

1m10.6.2.  Grab and Ungrab Entry/Exit Events0m

Pseudo-motion mode 4mEnterNotify24m and 4mLeaveNotify24m events are
generated when a pointer grab activates or deactivates.
Events in which the pointer grab activates are identified by
4mXEnterWindowEvent24m or 4mXLeaveWindowEvent24m structures whose mode
member is set to 4mNotifyGrab24m.  Events in which the pointer
grab deactivates are identified by 4mXEnterWindowEvent24m or
4mXLeaveWindowEvent24m structures whose mode member is set to
4mNotifyUngrab24m (see 4mXGrabPointer24m).

·    When a pointer grab activates after any initial warp
     into a confine_to window and before generating any
     actual 4mButtonPress24m event that activates the grab, G is
     the grab_window for the grab, and P is the window the
     pointer is in, the X server does the following:

     -	  It generates 4mEnterNotify24m and 4mLeaveNotify24m events
	  (see section 10.6.1) with the mode members of the
	  4mXEnterWindowEvent24m and 4mXLeaveWindowEvent24m structures
	  set to 4mNotifyGrab24m.  These events are generated as
	  if the pointer were to suddenly warp from its cur-
	  rent position in P to some position in G.  How-
	  ever, the pointer does not warp, and the X server
	  uses the pointer position as both the initial and
	  final positions for the events.

·    When a pointer grab deactivates after generating any
     actual 4mButtonRelease24m event that deactivates the grab, G
     is the grab_window for the grab, and P is the window
     the pointer is in, the X server does the following:

     -	  It generates 4mEnterNotify24m and 4mLeaveNotify24m events
	  (see section 10.6.1) with the mode members of the
	  4mXEnterWindowEvent24m and 4mXLeaveWindowEvent24m structures
	  set to 4mNotifyUngrab24m.  These events are generated
	  as if the pointer were to suddenly warp from some
	  position in G to its current position in P.



			     1m3030m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


	  However, the pointer does not warp, and the X
	  server uses the current pointer position as both
	  the initial and final positions for the events.

1m10.7.	 Input Focus Events0m

This section describes the processing that occurs for the
input focus events 4mFocusIn24m and 4mFocusOut24m.  The X server can
report 4mFocusIn24m or 4mFocusOut24m events to clients wanting infor-
mation about when the input focus changes.  The keyboard is
always attached to some window (typically, the root window
or a top-level window), which is called the focus window.
The focus window and the position of the pointer determine
the window that receives keyboard input.  Clients may need
to know when the input focus changes to control highlighting
of areas on the screen.

To receive 4mFocusIn24m or 4mFocusOut24m events, set the 4mFocusChange-0m
4mMask24m bit in the event-mask attribute of the window.

The structure for these event types contains:

__
|
typedef struct {
     int type;		      /* FocusIn or FocusOut */
     unsigned long serial;    /* # of last request processed by server */
     Bool send_event;	      /* true if this came from a SendEvent request */
     Display *display;	      /* Display the event was read from */
     Window window;	      /* window of event */
     int mode;		      /* NotifyNormal, NotifyGrab, NotifyUngrab */
     int detail;
			      /*
			      * NotifyAncestor, NotifyVirtual, NotifyInferior,
			      * NotifyNonlinear,NotifyNonlinearVirtual, NotifyPointer,
			      * NotifyPointerRoot, NotifyDetailNone
			      */
} XFocusChangeEvent;
typedef XFocusChangeEvent XFocusInEvent;
typedef XFocusChangeEvent XFocusOutEvent;

|__

The window member is set to the window on which the 4mFocusIn0m
or 4mFocusOut24m event was generated.  This is the window used by
the X server to report the event.  The mode member is set to
indicate whether the focus events are normal focus events,
focus events while grabbed, focus events when a grab acti-
vates, or focus events when a grab deactivates.	 The X
server can set the mode member to 4mNotifyNormal24m, 4mNotifyWhile-0m
4mGrabbed24m, 4mNotifyGrab24m, or 4mNotifyUngrab24m.

All 4mFocusOut24m events caused by a window unmap are generated
after any 4mUnmapNotify24m event; however, the X protocol does



			     1m3040m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


not constrain the ordering of 4mFocusOut24m events with respect
to generated 4mEnterNotify24m, 4mLeaveNotify24m, 4mVisibilityNotify24m, and
4mExpose24m events.

Depending on the event mode, the detail member is set to
indicate the notify detail and can be 4mNotifyAncestor24m, 4mNoti-0m
4mfyVirtual24m, 4mNotifyInferior24m, 4mNotifyNonlinear24m, 4mNotifyNonlin-0m
4mearVirtual24m, 4mNotifyPointer24m, 4mNotifyPointerRoot24m, or 4mNotifyDe-0m
4mtailNone24m.

1m10.7.1.  Normal Focus Events and Focus Events While Grabbed0m

Normal focus events are identified by 4mXFocusInEvent24m or 4mXFo-0m
4mcusOutEvent24m structures whose mode member is set to 4mNoti-0m
4mfyNormal24m.	Focus events while grabbed are identified by 4mXFo-0m
4mcusInEvent24m or 4mXFocusOutEvent24m structures whose mode member is
set to 4mNotifyWhileGrabbed24m.	 The X server processes normal
focus and focus events while grabbed according to the fol-
lowing:

·    When the focus moves from window A to window B, A is an
     inferior of B, and the pointer is in window P, the X
     server does the following:

     -	  It generates a 4mFocusOut24m event on window A, with
	  the detail member of the 4mXFocusOutEvent24m structure
	  set to 4mNotifyAncestor24m.

     -	  It generates a 4mFocusOut24m event on each window
	  between window A and window B, exclusive, with the
	  detail member of each 4mXFocusOutEvent24m structure set
	  to 4mNotifyVirtual24m.

     -	  It generates a 4mFocusIn24m event on window B, with the
	  detail member of the 4mXFocusOutEvent24m structure set
	  to 4mNotifyInferior24m.

     -	  If window P is an inferior of window B but window
	  P is not window A or an inferior or ancestor of
	  window A, it generates a 4mFocusIn24m event on each
	  window below window B, down to and including win-
	  dow P, with the detail member of each 4mXFocusIn-0m
	  4mEvent24m structure set to 4mNotifyPointer24m.

·    When the focus moves from window A to window B, B is an
     inferior of A, and the pointer is in window P, the X
     server does the following:

     -	  If window P is an inferior of window A but P is
	  not an inferior of window B or an ancestor of B,
	  it generates a 4mFocusOut24m event on each window from
	  window P up to but not including window A, with
	  the detail member of each 4mXFocusOutEvent24m structure
	  set to 4mNotifyPointer24m.



			     1m3050m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


     -	  It generates a 4mFocusOut24m event on window A, with
	  the detail member of the 4mXFocusOutEvent24m structure
	  set to 4mNotifyInferior24m.

     -	  It generates a 4mFocusIn24m event on each window
	  between window A and window B, exclusive, with the
	  detail member of each 4mXFocusInEvent24m structure set
	  to 4mNotifyVirtual24m.

     -	  It generates a 4mFocusIn24m event on window B, with the
	  detail member of the 4mXFocusInEvent24m structure set
	  to 4mNotifyAncestor24m.

·    When the focus moves from window A to window B, window
     C is their least common ancestor, and the pointer is in
     window P, the X server does the following:

     -	  If window P is an inferior of window A, it gener-
	  ates a 4mFocusOut24m event on each window from window P
	  up to but not including window A, with the detail
	  member of the 4mXFocusOutEvent24m structure set to
	  4mNotifyPointer24m.

     -	  It generates a 4mFocusOut24m event on window A, with
	  the detail member of the 4mXFocusOutEvent24m structure
	  set to 4mNotifyNonlinear24m.

     -	  It generates a 4mFocusOut24m event on each window
	  between window A and window C, exclusive, with the
	  detail member of each 4mXFocusOutEvent24m structure set
	  to 4mNotifyNonlinearVirtual24m.

     -	  It generates a 4mFocusIn24m event on each window
	  between C and B, exclusive, with the detail member
	  of each 4mXFocusInEvent24m structure set to 4mNotifyNon-0m
	  4mlinearVirtual24m.

     -	  It generates a 4mFocusIn24m event on window B, with the
	  detail member of the 4mXFocusInEvent24m structure set
	  to 4mNotifyNonlinear24m.

     -	  If window P is an inferior of window B, it gener-
	  ates a 4mFocusIn24m event on each window below window B
	  down to and including window P, with the detail
	  member of the 4mXFocusInEvent24m structure set to 4mNoti-0m
	  4mfyPointer24m.

·    When the focus moves from window A to window B on dif-
     ferent screens and the pointer is in window P, the X
     server does the following:

     -	  If window P is an inferior of window A, it gener-
	  ates a 4mFocusOut24m event on each window from window P
	  up to but not including window A, with the detail



			     1m3060m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


	  member of each 4mXFocusOutEvent24m structure set to
	  4mNotifyPointer24m.

     -	  It generates a 4mFocusOut24m event on window A, with
	  the detail member of the 4mXFocusOutEvent24m structure
	  set to 4mNotifyNonlinear24m.

     -	  If window A is not a root window, it generates a
	  4mFocusOut24m event on each window above window A up to
	  and including its root, with the detail member of
	  each 4mXFocusOutEvent24m structure set to 4mNotifyNonlin-0m
	  4mearVirtual24m.

     -	  If window B is not a root window, it generates a
	  4mFocusIn24m event on each window from window B's root
	  down to but not including window B, with the
	  detail member of each 4mXFocusInEvent24m structure set
	  to 4mNotifyNonlinearVirtual24m.

     -	  It generates a 4mFocusIn24m event on window B, with the
	  detail member of each 4mXFocusInEvent24m structure set
	  to 4mNotifyNonlinear24m.

     -	  If window P is an inferior of window B, it gener-
	  ates a 4mFocusIn24m event on each window below window B
	  down to and including window P, with the detail
	  member of each 4mXFocusInEvent24m structure set to
	  4mNotifyPointer24m.

·    When the focus moves from window A to 4mPointerRoot0m
     (events sent to the window under the pointer) or 4mNone0m
     (discard), and the pointer is in window P, the X server
     does the following:

     -	  If window P is an inferior of window A, it gener-
	  ates a 4mFocusOut24m event on each window from window P
	  up to but not including window A, with the detail
	  member of each 4mXFocusOutEvent24m structure set to
	  4mNotifyPointer24m.

     -	  It generates a 4mFocusOut24m event on window A, with
	  the detail member of the 4mXFocusOutEvent24m structure
	  set to 4mNotifyNonlinear24m.

     -	  If window A is not a root window, it generates a
	  4mFocusOut24m event on each window above window A up to
	  and including its root, with the detail member of
	  each 4mXFocusOutEvent24m structure set to 4mNotifyNonlin-0m
	  4mearVirtual24m.

     -	  It generates a 4mFocusIn24m event on the root window of
	  all screens, with the detail member of each 4mXFo-0m
	  4mcusInEvent24m structure set to 4mNotifyPointerRoot24m (or
	  4mNotifyDetailNone24m).



			     1m3070m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


     -	  If the new focus is 4mPointerRoot24m, it generates a
	  4mFocusIn24m event on each window from window P's root
	  down to and including window P, with the detail
	  member of each 4mXFocusInEvent24m structure set to
	  4mNotifyPointer24m.

·    When the focus moves from 4mPointerRoot24m (events sent to
     the window under the pointer) or 4mNone24m to window A, and
     the pointer is in window P, the X server does the fol-
     lowing:

     -	  If the old focus is 4mPointerRoot24m, it generates a
	  4mFocusOut24m event on each window from window P up to
	  and including window P's root, with the detail
	  member of each 4mXFocusOutEvent24m structure set to
	  4mNotifyPointer24m.

     -	  It generates a 4mFocusOut24m event on all root windows,
	  with the detail member of each 4mXFocusOutEvent0m
	  structure set to 4mNotifyPointerRoot24m (or 4mNotifyDe-0m
	  4mtailNone24m).

     -	  If window A is not a root window, it generates a
	  4mFocusIn24m event on each window from window A's root
	  down to but not including window A, with the
	  detail member of each 4mXFocusInEvent24m structure set
	  to 4mNotifyNonlinearVirtual24m.

     -	  It generates a 4mFocusIn24m event on window A, with the
	  detail member of the 4mXFocusInEvent24m structure set
	  to 4mNotifyNonlinear24m.

     -	  If window P is an inferior of window A, it gener-
	  ates a 4mFocusIn24m event on each window below window A
	  down to and including window P, with the detail
	  member of each 4mXFocusInEvent24m structure set to
	  4mNotifyPointer24m.

·    When the focus moves from 4mPointerRoot24m (events sent to
     the window under the pointer) to 4mNone24m (or vice versa),
     and the pointer is in window P, the X server does the
     following:

     -	  If the old focus is 4mPointerRoot24m, it generates a
	  4mFocusOut24m event on each window from window P up to
	  and including window P's root, with the detail
	  member of each 4mXFocusOutEvent24m structure set to
	  4mNotifyPointer24m.

     -	  It generates a 4mFocusOut24m event on all root windows,
	  with the detail member of each 4mXFocusOutEvent0m
	  structure set to either 4mNotifyPointerRoot24m or 4mNoti-0m
	  4mfyDetailNone24m.




			     1m3080m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


     -	  It generates a 4mFocusIn24m event on all root windows,
	  with the detail member of each 4mXFocusInEvent0m
	  structure set to 4mNotifyDetailNone24m or 4mNotifyPoint-0m
	  4merRoot24m.

     -	  If the new focus is 4mPointerRoot24m, it generates a
	  4mFocusIn24m event on each window from window P's root
	  down to and including window P, with the detail
	  member of each 4mXFocusInEvent24m structure set to
	  4mNotifyPointer24m.

1m10.7.2.  Focus Events Generated by Grabs0m

Focus events in which the keyboard grab activates are iden-
tified by 4mXFocusInEvent24m or 4mXFocusOutEvent24m structures whose
mode member is set to 4mNotifyGrab24m.	Focus events in which the
keyboard grab deactivates are identified by 4mXFocusInEvent24m or
4mXFocusOutEvent24m structures whose mode member is set to 4mNoti-0m
4mfyUngrab24m (see 4mXGrabKeyboard24m).

·    When a keyboard grab activates before generating any
     actual 4mKeyPress24m event that activates the grab, G is the
     grab_window, and F is the current focus, the X server
     does the following:

     -	  It generates 4mFocusIn24m and 4mFocusOut24m events, with the
	  mode members of the 4mXFocusInEvent24m and 4mXFocu-0m
	  4msOutEvent24m structures set to 4mNotifyGrab24m.  These
	  events are generated as if the focus were to
	  change from F to G.

·    When a keyboard grab deactivates after generating any
     actual 4mKeyRelease24m event that deactivates the grab, G is
     the grab_window, and F is the current focus, the X
     server does the following:

     -	  It generates 4mFocusIn24m and 4mFocusOut24m events, with the
	  mode members of the 4mXFocusInEvent24m and 4mXFocu-0m
	  4msOutEvent24m structures set to 4mNotifyUngrab24m.  These
	  events are generated as if the focus were to
	  change from G to F.

1m10.8.	 Key Map State Notification Events0m

The X server can report 4mKeymapNotify24m events to clients that
want information about changes in their keyboard state.

To receive 4mKeymapNotify24m events, set the 4mKeymapStateMask24m bit
in the event-mask attribute of the window.  The X server
generates this event immediately after every 4mEnterNotify24m and
4mFocusIn24m event.

The structure for this event type contains:




			     1m3090m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
/* generated on EnterWindow and FocusIn when KeymapState selected */
typedef struct {
     int type;		      /* KeymapNotify */
     unsigned long serial;    /* # of last request processed by server */
     Bool send_event;	      /* true if this came from a SendEvent request */
     Display *display;	      /* Display the event was read from */
     Window window;
     char key_vector[32];
} XKeymapEvent;

|__

The window member is not used but is present to aid some
toolkits.  The key_vector member is set to the bit vector of
the keyboard.  Each bit set to 1 indicates that the corre-
sponding key is currently pressed.  The vector is repre-
sented as 32 bytes.  Byte N (from 0) contains the bits for
keys 8N to 8N + 7 with the least significant bit in the byte
representing key 8N.

1m10.9.	 Exposure Events0m

The X protocol does not guarantee to preserve the contents
of window regions when the windows are obscured or reconfig-
ured.  Some implementations may preserve the contents of
windows.  Other implementations are free to destroy the con-
tents of windows when exposed.	X expects client applica-
tions to assume the responsibility for restoring the con-
tents of an exposed window region.  (An exposed window
region describes a formerly obscured window whose region
becomes visible.)  Therefore, the X server sends 4mExpose0m
events describing the window and the region of the window
that has been exposed.	A naive client application usually
redraws the entire window.  A more sophisticated client
application redraws only the exposed region.

1m10.9.1.  Expose Events0m

The X server can report 4mExpose24m events to clients wanting
information about when the contents of window regions have
been lost.  The circumstances in which the X server gener-
ates 4mExpose24m events are not as definite as those for other
events.	 However, the X server never generates 4mExpose24m events
on windows whose class you specified as 4mInputOnly24m.	 The X
server can generate 4mExpose24m events when no valid contents are
available for regions of a window and either the regions are
visible, the regions are viewable and the server is (perhaps
newly) maintaining backing store on the window, or the win-
dow is not viewable but the server is (perhaps newly) honor-
ing the window's backing-store attribute of 4mAlways24m or 4mWhen-0m
4mMapped24m.  The regions decompose into an (arbitrary) set of
rectangles, and an 4mExpose24m event is generated for each rec-
tangle.	 For any given window, the X server guarantees to



			     1m3100m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


report contiguously all of the regions exposed by some
action that causes 4mExpose24m events, such as raising a window.

To receive 4mExpose24m events, set the 4mExposureMask24m bit in the
event-mask attribute of the window.

The structure for this event type contains:

__
|
typedef struct {
     int type;		      /* Expose */
     unsigned long serial;    /* # of last request processed by server */
     Bool send_event;	      /* true if this came from a SendEvent request */
     Display *display;	      /* Display the event was read from */
     Window window;
     int x, y;
     int width, height;
     int count;		      /* if nonzero, at least this many more */
} XExposeEvent;

|__

The window member is set to the exposed (damaged) window.
The x and y members are set to the coordinates relative to
the window's origin and indicate the upper-left corner of
the rectangle.	The width and height members are set to the
size (extent) of the rectangle.	 The count member is set to
the number of 4mExpose24m events that are to follow.  If count is
zero, no more 4mExpose24m events follow for this window.  How-
ever, if count is nonzero, at least that number of 4mExpose0m
events (and possibly more) follow for this window.  Simple
applications that do not want to optimize redisplay by dis-
tinguishing between subareas of its window can just ignore
all 4mExpose24m events with nonzero counts and perform full
redisplays on events with zero counts.

1m10.9.2.  GraphicsExpose and NoExpose Events0m

The X server can report 4mGraphicsExpose24m events to clients
wanting information about when a destination region could
not be computed during certain graphics requests: 4mXCopyArea0m
or 4mXCopyPlane24m.  The X server generates this event whenever a
destination region could not be computed because of an
obscured or out-of-bounds source region.  In addition, the X
server guarantees to report contiguously all of the regions
exposed by some graphics request (for example, copying an
area of a drawable to a destination drawable).

The X server generates a 4mNoExpose24m event whenever a graphics
request that might produce a 4mGraphicsExpose24m event does not
produce any.  In other words, the client is really asking
for a 4mGraphicsExpose24m event but instead receives a 4mNoExpose0m
event.



			     1m3110m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


To receive 4mGraphicsExpose24m or 4mNoExpose24m events, you must first
set the graphics-exposure attribute of the graphics context
to 4mTrue24m.  You also can set the graphics-expose attribute
when creating a graphics context using 4mXCreateGC24m or by call-
ing 4mXSetGraphicsExposures24m.

The structures for these event types contain:

__
|
typedef struct {
     int type;		      /* GraphicsExpose */
     unsigned long serial;    /* # of last request processed by server */
     Bool send_event;	      /* true if this came from a SendEvent request */
     Display *display;	      /* Display the event was read from */
     Drawable drawable;
     int x, y;
     int width, height;
     int count;		      /* if nonzero, at least this many more */
     int major_code;	      /* core is CopyArea or CopyPlane */
     int minor_code;	      /* not defined in the core */
} XGraphicsExposeEvent;



typedef struct {
     int type;		      /* NoExpose */
     unsigned long serial;    /* # of last request processed by server */
     Bool send_event;	      /* true if this came from a SendEvent request */
     Display *display;	      /* Display the event was read from */
     Drawable drawable;
     int major_code;	      /* core is CopyArea or CopyPlane */
     int minor_code;	      /* not defined in the core */
} XNoExposeEvent;

|__

Both structures have these common members: drawable,
major_code, and minor_code.  The drawable member is set to
the drawable of the destination region on which the graphics
request was to be performed.  The major_code member is set
to the graphics request initiated by the client and can be
either 4mX_CopyArea24m or 4mX_CopyPlane24m.  If it is 4mX_CopyArea24m, a
call to 4mXCopyArea24m initiated the request.  If it is 4mX_Copy-0m
4mPlane24m, a call to 4mXCopyPlane24m initiated the request.  These
constants are defined in <4mX11/Xproto.h24m>.  The minor_code
member, like the major_code member, indicates which graphics
request was initiated by the client.  However, the
minor_code member is not defined by the core X protocol and
will be zero in these cases, although it may be used by an
extension.

The 4mXGraphicsExposeEvent24m structure has these additional mem-
bers: x, y, width, height, and count.  The x and y members



			     1m3120m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


are set to the coordinates relative to the drawable's origin
and indicate the upper-left corner of the rectangle.  The
width and height members are set to the size (extent) of the
rectangle.  The count member is set to the number of 4mGraph-0m
4micsExpose24m events to follow.  If count is zero, no more
4mGraphicsExpose24m events follow for this window.  However, if
count is nonzero, at least that number of 4mGraphicsExpose0m
events (and possibly more) are to follow for this window.

1m10.10.  Window State Change Events0m

The following sections discuss:

·    4mCirculateNotify24m events

·    4mConfigureNotify24m events

·    4mCreateNotify24m events

·    4mDestroyNotify24m events

·    4mGravityNotify24m events

·    4mMapNotify24m events

·    4mMappingNotify24m events

·    4mReparentNotify24m events

·    4mUnmapNotify24m events

·    4mVisibilityNotify24m events

1m10.10.1.  CirculateNotify Events0m

The X server can report 4mCirculateNotify24m events to clients
wanting information about when a window changes its position
in the stack.  The X server generates this event type when-
ever a window is actually restacked as a result of a client
application calling 4mXCirculateSubwindows24m, 4mXCirculateSubwin-0m
4mdowsUp24m, or 4mXCirculateSubwindowsDown24m.

To receive 4mCirculateNotify24m events, set the 4mStructureNotify-0m
4mMask24m bit in the event-mask attribute of the window or the
4mSubstructureNotifyMask24m bit in the event-mask attribute of
the parent window (in which case, circulating any child gen-
erates an event).

The structure for this event type contains:








			     1m3130m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
typedef struct {
     int type;		      /* CirculateNotify */
     unsigned long serial;    /* # of last request processed by server */
     Bool send_event;	      /* true if this came from a SendEvent request */
     Display *display;	      /* Display the event was read from */
     Window event;
     Window window;
     int place;		      /* PlaceOnTop, PlaceOnBottom */
} XCirculateEvent;

|__

The event member is set either to the restacked window or to
its parent, depending on whether 4mStructureNotify24m or 4mSub-0m
4mstructureNotify24m was selected.  The window member is set to
the window that was restacked.	The place member is set to
the window's position after the restack occurs and is either
4mPlaceOnTop24m or 4mPlaceOnBottom24m.	If it is 4mPlaceOnTop24m, the win-
dow is now on top of all siblings.  If it is 4mPlaceOnBottom24m,
the window is now below all siblings.

1m10.10.2.  ConfigureNotify Events0m

The X server can report 4mConfigureNotify24m events to clients
wanting information about actual changes to a window's
state, such as size, position, border, and stacking order.
The X server generates this event type whenever one of the
following configure window requests made by a client appli-
cation actually completes:

·    A window's size, position, border, and/or stacking
     order is reconfigured by calling 4mXConfigureWindow24m.

·    The window's position in the stacking order is changed
     by calling 4mXLowerWindow24m, 4mXRaiseWindow24m, or 4mXRestackWin-0m
     4mdows24m.

·    A window is moved by calling 4mXMoveWindow24m.

·    A window's size is changed by calling 4mXResizeWindow24m.

·    A window's size and location is changed by calling
     4mXMoveResizeWindow24m.

·    A window is mapped and its position in the stacking
     order is changed by calling 4mXMapRaised24m.

·    A window's border width is changed by calling 4mXSetWin-0m
     4mdowBorderWidth24m.

To receive 4mConfigureNotify24m events, set the 4mStructureNotify-0m
4mMask24m bit in the event-mask attribute of the window or the
4mSubstructureNotifyMask24m bit in the event-mask attribute of



			     1m3140m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


the parent window (in which case, configuring any child gen-
erates an event).

The structure for this event type contains:

__
|
typedef struct {
     int type;		      /* ConfigureNotify */
     unsigned long serial;    /* # of last request processed by server */
     Bool send_event;	      /* true if this came from a SendEvent request */
     Display *display;	      /* Display the event was read from */
     Window event;
     Window window;
     int x, y;
     int width, height;
     int border_width;
     Window above;
     Bool override_redirect;
} XConfigureEvent;

|__

The event member is set either to the reconfigured window or
to its parent, depending on whether 4mStructureNotify24m or 4mSub-0m
4mstructureNotify24m was selected.  The window member is set to
the window whose size, position, border, and/or stacking
order was changed.

The x and y members are set to the coordinates relative to
the parent window's origin and indicate the position of the
upper-left outside corner of the window.  The width and
height members are set to the inside size of the window, not
including the border.  The border_width member is set to the
width of the window's border, in pixels.

The above member is set to the sibling window and is used
for stacking operations.  If the X server sets this member
to 4mNone24m, the window whose state was changed is on the bottom
of the stack with respect to sibling windows.  However, if
this member is set to a sibling window, the window whose
state was changed is placed on top of this sibling window.

The override_redirect member is set to the override-redirect
attribute of the window.  Window manager clients normally
should ignore this window if the override_redirect member is
4mTrue24m.

1m10.10.3.  CreateNotify Events0m

The X server can report 4mCreateNotify24m events to clients want-
ing information about creation of windows.  The X server
generates this event whenever a client application creates a
window by calling 4mXCreateWindow24m or 4mXCreateSimpleWindow24m.



			     1m3150m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


To receive 4mCreateNotify24m events, set the 4mSubstructureNotify-0m
4mMask24m bit in the event-mask attribute of the window.  Creat-
ing any children then generates an event.

The structure for the event type contains:

__
|
typedef struct {
     int type;		      /* CreateNotify */
     unsigned long serial;    /* # of last request processed by server */
     Bool send_event;	      /* true if this came from a SendEvent request */
     Display *display;	      /* Display the event was read from */
     Window parent;	      /* parent of the window */
     Window window;	      /* window id of window created */
     int x, y;		      /* window location */
     int width, height;	      /* size of window */
     int border_width;	      /* border width */
     Bool override_redirect;  /* creation should be overridden */
} XCreateWindowEvent;

|__

The parent member is set to the created window's parent.
The window member specifies the created window.	 The x and y
members are set to the created window's coordinates relative
to the parent window's origin and indicate the position of
the upper-left outside corner of the created window.  The
width and height members are set to the inside size of the
created window (not including the border) and are always
nonzero.  The border_width member is set to the width of the
created window's border, in pixels.  The override_redirect
member is set to the override-redirect attribute of the win-
dow.  Window manager clients normally should ignore this
window if the override_redirect member is 4mTrue24m.

1m10.10.4.  DestroyNotify Events0m

The X server can report 4mDestroyNotify24m events to clients
wanting information about which windows are destroyed.	The
X server generates this event whenever a client application
destroys a window by calling 4mXDestroyWindow24m or 4mXDestroySub-0m
4mwindows24m.

The ordering of the 4mDestroyNotify24m events is such that for
any given window, 4mDestroyNotify24m is generated on all inferi-
ors of the window before being generated on the window
itself.	 The X protocol does not constrain the ordering
among siblings and across subhierarchies.

To receive 4mDestroyNotify24m events, set the 4mStructureNotifyMask0m
bit in the event-mask attribute of the window or the 4mSub-0m
4mstructureNotifyMask24m bit in the event-mask attribute of the
parent window (in which case, destroying any child generates



			     1m3160m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


an event).

The structure for this event type contains:

__
|
typedef struct {
     int type;		      /* DestroyNotify */
     unsigned long serial;    /* # of last request processed by server */
     Bool send_event;	      /* true if this came from a SendEvent request */
     Display *display;	      /* Display the event was read from */
     Window event;
     Window window;
} XDestroyWindowEvent;

|__

The event member is set either to the destroyed window or to
its parent, depending on whether 4mStructureNotify24m or 4mSub-0m
4mstructureNotify24m was selected.  The window member is set to
the window that is destroyed.

1m10.10.5.  GravityNotify Events0m

The X server can report 4mGravityNotify24m events to clients
wanting information about when a window is moved because of
a change in the size of its parent.  The X server generates
this event whenever a client application actually moves a
child window as a result of resizing its parent by calling
4mXConfigureWindow24m, 4mXMoveResizeWindow24m, or 4mXResizeWindow24m.

To receive 4mGravityNotify24m events, set the 4mStructureNotifyMask0m
bit in the event-mask attribute of the window or the 4mSub-0m
4mstructureNotifyMask24m bit in the event-mask attribute of the
parent window (in which case, any child that is moved
because its parent has been resized generates an event).

The structure for this event type contains:

__
|
typedef struct {
     int type;		      /* GravityNotify */
     unsigned long serial;    /* # of last request processed by server */
     Bool send_event;	      /* true if this came from a SendEvent request */
     Display *display;	      /* Display the event was read from */
     Window event;
     Window window;
     int x, y;
} XGravityEvent;

|__

The event member is set either to the window that was moved



			     1m3170m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


or to its parent, depending on whether 4mStructureNotify24m or
4mSubstructureNotify24m was selected.  The window member is set
to the child window that was moved.  The x and y members are
set to the coordinates relative to the new parent window's
origin and indicate the position of the upper-left outside
corner of the window.

1m10.10.6.  MapNotify Events0m

The X server can report 4mMapNotify24m events to clients wanting
information about which windows are mapped.  The X server
generates this event type whenever a client application
changes the window's state from unmapped to mapped by call-
ing 4mXMapWindow24m, 4mXMapRaised24m, 4mXMapSubwindows24m, 4mXReparentWindow24m,
or as a result of save-set processing.

To receive 4mMapNotify24m events, set the 4mStructureNotifyMask24m bit
in the event-mask attribute of the window or the 4mSubstruc-0m
4mtureNotifyMask24m bit in the event-mask attribute of the parent
window (in which case, mapping any child generates an
event).

The structure for this event type contains:

__
|
typedef struct {
     int type;		      /* MapNotify */
     unsigned long serial;    /* # of last request processed by server */
     Bool send_event;	      /* true if this came from a SendEvent request */
     Display *display;	      /* Display the event was read from */
     Window event;
     Window window;
     Bool override_redirect;  /* boolean, is override set... */
} XMapEvent;

|__

The event member is set either to the window that was mapped
or to its parent, depending on whether 4mStructureNotify24m or
4mSubstructureNotify24m was selected.  The window member is set
to the window that was mapped.	The override_redirect member
is set to the override-redirect attribute of the window.
Window manager clients normally should ignore this window if
the override-redirect attribute is 4mTrue24m, because these
events usually are generated from pop-ups, which override
structure control.

1m10.10.7.  MappingNotify Events0m

The X server reports 4mMappingNotify24m events to all clients.
There is no mechanism to express disinterest in this event.
The X server generates this event type whenever a client
application successfully calls:



			     1m3180m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


·    4mXSetModifierMapping24m to indicate which KeyCodes are to
     be used as modifiers

·    4mXChangeKeyboardMapping24m to change the keyboard mapping

·    4mXSetPointerMapping24m to set the pointer mapping

The structure for this event type contains:

__
|
typedef struct {
     int type;		      /* MappingNotify */
     unsigned long serial;    /* # of last request processed by server */
     Bool send_event;	      /* true if this came from a SendEvent request */
     Display *display;	      /* Display the event was read from */
     Window window;	      /* unused */
     int request;	      /* one of MappingModifier, MappingKeyboard,
				 MappingPointer */
     int first_keycode;	      /* first keycode */
     int count;		      /* defines range of change w. first_keycode*/
} XMappingEvent;

|__

The request member is set to indicate the kind of mapping
change that occurred and can be 4mMappingModifier24m, 4mMappingKey-0m
4mboard24m, or 4mMappingPointer24m.  If it is 4mMappingModifier24m, the
modifier mapping was changed.  If it is 4mMappingKeyboard24m, the
keyboard mapping was changed.  If it is 4mMappingPointer24m, the
pointer button mapping was changed.  The first_keycode and
count members are set only if the request member was set to
4mMappingKeyboard24m.  The number in first_keycode represents the
first number in the range of the altered mapping, and count
represents the number of keycodes altered.

To update the client application's knowledge of the key-
board, you should call 4mXRefreshKeyboardMapping24m.

1m10.10.8.  ReparentNotify Events0m

The X server can report 4mReparentNotify24m events to clients
wanting information about changing a window's parent.  The X
server generates this event whenever a client application
calls 4mXReparentWindow24m and the window is actually reparented.

To receive 4mReparentNotify24m events, set the 4mStructureNotify-0m
4mMask24m bit in the event-mask attribute of the window or the
4mSubstructureNotifyMask24m bit in the event-mask attribute of
either the old or the new parent window (in which case,
reparenting any child generates an event).

The structure for this event type contains:




			     1m3190m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
typedef struct {
     int type;		      /* ReparentNotify */
     unsigned long serial;    /* # of last request processed by server */
     Bool send_event;	      /* true if this came from a SendEvent request */
     Display *display;	      /* Display the event was read from */
     Window event;
     Window window;
     Window parent;
     int x, y;
     Bool override_redirect;
} XReparentEvent;

|__

The event member is set either to the reparented window or
to the old or the new parent, depending on whether 4mStruc-0m
4mtureNotify24m or 4mSubstructureNotify24m was selected.  The window
member is set to the window that was reparented.  The parent
member is set to the new parent window.	 The x and y members
are set to the reparented window's coordinates relative to
the new parent window's origin and define the upper-left
outer corner of the reparented window.	The override_redi-
rect member is set to the override-redirect attribute of the
window specified by the window member.	Window manager
clients normally should ignore this window if the over-
ride_redirect member is 4mTrue24m.

1m10.10.9.  UnmapNotify Events0m

The X server can report 4mUnmapNotify24m events to clients want-
ing information about which windows are unmapped.  The X
server generates this event type whenever a client applica-
tion changes the window's state from mapped to unmapped.

To receive 4mUnmapNotify24m events, set the 4mStructureNotifyMask0m
bit in the event-mask attribute of the window or the 4mSub-0m
4mstructureNotifyMask24m bit in the event-mask attribute of the
parent window (in which case, unmapping any child window
generates an event).

The structure for this event type contains:















			     1m3200m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
typedef struct {
     int type;		      /* UnmapNotify */
     unsigned long serial;    /* # of last request processed by server */
     Bool send_event;	      /* true if this came from a SendEvent request */
     Display *display;	      /* Display the event was read from */
     Window event;
     Window window;
     Bool from_configure;
} XUnmapEvent;

|__

The event member is set either to the unmapped window or to
its parent, depending on whether 4mStructureNotify24m or 4mSub-0m
4mstructureNotify24m was selected.  This is the window used by
the X server to report the event.  The window member is set
to the window that was unmapped.  The from_configure member
is set to 4mTrue24m if the event was generated as a result of a
resizing of the window's parent when the window itself had a
win_gravity of 4mUnmapGravity24m.

1m10.10.10.  VisibilityNotify Events0m

The X server can report 4mVisibilityNotify24m events to clients
wanting any change in the visibility of the specified win-
dow.  A region of a window is visible if someone looking at
the screen can actually see it.	 The X server generates this
event whenever the visibility changes state.  However, this
event is never generated for windows whose class is 4mInpu-0m
4mtOnly24m.

All 4mVisibilityNotify24m events caused by a hierarchy change are
generated after any hierarchy event (4mUnmapNotify24m, 4mMapNotify24m,
4mConfigureNotify24m, 4mGravityNotify24m, 4mCirculateNotify24m) caused by
that change.  Any 4mVisibilityNotify24m event on a given window
is generated before any 4mExpose24m events on that window, but it
is not required that all 4mVisibilityNotify24m events on all win-
dows be generated before all 4mExpose24m events on all windows.
The X protocol does not constrain the ordering of 4mVisibili-0m
4mtyNotify24m events with respect to 4mFocusOut24m, 4mEnterNotify24m, and
4mLeaveNotify24m events.

To receive 4mVisibilityNotify24m events, set the 4mVisibility-0m
4mChangeMask24m bit in the event-mask attribute of the window.

The structure for this event type contains:










			     1m3210m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
typedef struct {
     int type;		      /* VisibilityNotify */
     unsigned long serial;    /* # of last request processed by server */
     Bool send_event;	      /* true if this came from a SendEvent request */
     Display *display;	      /* Display the event was read from */
     Window window;
     int state;
} XVisibilityEvent;

|__

The window member is set to the window whose visibility
state changes.	The state member is set to the state of the
window's visibility and can be 4mVisibilityUnobscured24m, 4mVisi-0m
4mbilityPartiallyObscured24m, or 4mVisibilityFullyObscured24m.	The X
server ignores all of a window's subwindows when determining
the visibility state of the window and processes 4mVisibili-0m
4mtyNotify24m events according to the following:

·    When the window changes state from partially obscured,
     fully obscured, or not viewable to viewable and com-
     pletely unobscured, the X server generates the event
     with the state member of the 4mXVisibilityEvent24m structure
     set to 4mVisibilityUnobscured24m.

·    When the window changes state from viewable and com-
     pletely unobscured or not viewable to viewable and par-
     tially obscured, the X server generates the event with
     the state member of the 4mXVisibilityEvent24m structure set
     to 4mVisibilityPartiallyObscured24m.

·    When the window changes state from viewable and com-
     pletely unobscured, viewable and partially obscured, or
     not viewable to viewable and fully obscured, the X
     server generates the event with the state member of the
     4mXVisibilityEvent24m structure set to 4mVisibilityFullyOb-0m
     4mscured24m.

1m10.11.  Structure Control Events0m

This section discusses:

·    4mCirculateRequest24m events

·    4mConfigureRequest24m events

·    4mMapRequest24m events

·    4mResizeRequest24m events







			     1m3220m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


1m10.11.1.  CirculateRequest Events0m

The X server can report 4mCirculateRequest24m events to clients
wanting information about when another client initiates a
circulate window request on a specified window.	 The X
server generates this event type whenever a client initiates
a circulate window request on a window and a subwindow actu-
ally needs to be restacked.  The client initiates a circu-
late window request on the window by calling 4mXCirculateSub-0m
4mwindows24m, 4mXCirculateSubwindowsUp24m, or 4mXCirculateSubwindows-0m
4mDown24m.

To receive 4mCirculateRequest24m events, set the 4mSubstructur-0m
4meRedirectMask24m in the event-mask attribute of the window.
Then, in the future, the circulate window request for the
specified window is not executed, and thus, any subwindow's
position in the stack is not changed.  For example, suppose
a client application calls 4mXCirculateSubwindowsUp24m to raise a
subwindow to the top of the stack.  If you had selected 4mSub-0m
4mstructureRedirectMask24m on the window, the X server reports to
you a 4mCirculateRequest24m event and does not raise the subwin-
dow to the top of the stack.

The structure for this event type contains:

__
|
typedef struct {
     int type;		      /* CirculateRequest */
     unsigned long serial;    /* # of last request processed by server */
     Bool send_event;	      /* true if this came from a SendEvent request */
     Display *display;	      /* Display the event was read from */
     Window parent;
     Window window;
     int place;		      /* PlaceOnTop, PlaceOnBottom */
} XCirculateRequestEvent;

|__

The parent member is set to the parent window.	The window
member is set to the subwindow to be restacked.	 The place
member is set to what the new position in the stacking order
should be and is either 4mPlaceOnTop24m or 4mPlaceOnBottom24m.	If it
is 4mPlaceOnTop24m, the subwindow should be on top of all sib-
lings.	If it is 4mPlaceOnBottom24m, the subwindow should be
below all siblings.

1m10.11.2.  ConfigureRequest Events0m

The X server can report 4mConfigureRequest24m events to clients
wanting information about when a different client initiates
a configure window request on any child of a specified win-
dow.  The configure window request attempts to reconfigure a
window's size, position, border, and stacking order.  The X



			     1m3230m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


server generates this event whenever a different client ini-
tiates a configure window request on a window by calling
4mXConfigureWindow24m, 4mXLowerWindow24m, 4mXRaiseWindow24m, 4mXMapRaised24m,
4mXMoveResizeWindow24m, 4mXMoveWindow24m, 4mXResizeWindow24m, 4mXRestackWin-0m
4mdows24m, or 4mXSetWindowBorderWidth24m.

To receive 4mConfigureRequest24m events, set the 4mSubstructur-0m
4meRedirectMask24m bit in the event-mask attribute of the window.
4mConfigureRequest24m events are generated when a 4mConfigureWindow0m
protocol request is issued on a child window by another
client.	 For example, suppose a client application calls
4mXLowerWindow24m to lower a window.  If you had selected 4mSub-0m
4mstructureRedirectMask24m on the parent window and if the over-
ride-redirect attribute of the window is set to 4mFalse24m, the X
server reports a 4mConfigureRequest24m event to you and does not
lower the specified window.

The structure for this event type contains:

__
|
typedef struct {
     int type;		      /* ConfigureRequest */
     unsigned long serial;    /* # of last request processed by server */
     Bool send_event;	      /* true if this came from a SendEvent request */
     Display *display;	      /* Display the event was read from */
     Window parent;
     Window window;
     int x, y;
     int width, height;
     int border_width;
     Window above;
     int detail;	      /* Above, Below, TopIf, BottomIf, Opposite */
     unsigned long value_mask;
} XConfigureRequestEvent;

|__

The parent member is set to the parent window.	The window
member is set to the window whose size, position, border
width, and/or stacking order is to be reconfigured.  The
value_mask member indicates which components were specified
in the 4mConfigureWindow24m protocol request.  The corresponding
values are reported as given in the request.  The remaining
values are filled in from the current geometry of the win-
dow, except in the case of above (sibling) and detail
(stack-mode), which are reported as 4mNone24m and 4mAbove24m, respec-
tively, if they are not given in the request.

1m10.11.3.  MapRequest Events0m

The X server can report 4mMapRequest24m events to clients wanting
information about a different client's desire to map win-
dows.  A window is considered mapped when a map window



			     1m3240m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


request completes.  The X server generates this event when-
ever a different client initiates a map window request on an
unmapped window whose override_redirect member is set to
4mFalse24m.  Clients initiate map window requests by calling
4mXMapWindow24m, 4mXMapRaised24m, or 4mXMapSubwindows24m.

To receive 4mMapRequest24m events, set the 4mSubstructureRedirect-0m
4mMask24m bit in the event-mask attribute of the window.  This
means another client's attempts to map a child window by
calling one of the map window request functions is inter-
cepted, and you are sent a 4mMapRequest24m instead.  For example,
suppose a client application calls 4mXMapWindow24m to map a win-
dow.  If you (usually a window manager) had selected 4mSub-0m
4mstructureRedirectMask24m on the parent window and if the over-
ride-redirect attribute of the window is set to 4mFalse24m, the X
server reports a 4mMapRequest24m event to you and does not map
the specified window.  Thus, this event gives your window
manager client the ability to control the placement of sub-
windows.

The structure for this event type contains:

__
|
typedef struct {
     int type;		      /* MapRequest */
     unsigned long serial;    /* # of last request processed by server */
     Bool send_event;	      /* true if this came from a SendEvent request */
     Display *display;	      /* Display the event was read from */
     Window parent;
     Window window;
} XMapRequestEvent;

|__

The parent member is set to the parent window.	The window
member is set to the window to be mapped.

1m10.11.4.  ResizeRequest Events0m

The X server can report 4mResizeRequest24m events to clients
wanting information about another client's attempts to
change the size of a window.  The X server generates this
event whenever some other client attempts to change the size
of the specified window by calling 4mXConfigureWindow24m, 4mXRe-0m
4msizeWindow24m, or 4mXMoveResizeWindow24m.

To receive 4mResizeRequest24m events, set the 4mResizeRedirect24m bit
in the event-mask attribute of the window.  Any attempts to
change the size by other clients are then redirected.

The structure for this event type contains:





			     1m3250m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
typedef struct {
     int type;		      /* ResizeRequest */
     unsigned long serial;    /* # of last request processed by server */
     Bool send_event;	      /* true if this came from a SendEvent request */
     Display *display;	      /* Display the event was read from */
     Window window;
     int width, height;
} XResizeRequestEvent;

|__

The window member is set to the window whose size another
client attempted to change.  The width and height members
are set to the inside size of the window, excluding the bor-
der.

1m10.12.  Colormap State Change Events0m

The X server can report 4mColormapNotify24m events to clients
wanting information about when the colormap changes and when
a colormap is installed or uninstalled.	 The X server gener-
ates this event type whenever a client application:

·    Changes the colormap member of the 4mXSetWindowAttributes0m
     structure by calling 4mXChangeWindowAttributes24m, 4mXFreeCol-0m
     4mormap24m, or 4mXSetWindowColormap0m

·    Installs or uninstalls the colormap by calling 4mXIn-0m
     4mstallColormap24m or 4mXUninstallColormap0m

To receive 4mColormapNotify24m events, set the 4mColormapChangeMask0m
bit in the event-mask attribute of the window.

The structure for this event type contains:

__
|
typedef struct {
     int type;		      /* ColormapNotify */
     unsigned long serial;    /* # of last request processed by server */
     Bool send_event;	      /* true if this came from a SendEvent request */
     Display *display;	      /* Display the event was read from */
     Window window;
     Colormap colormap;	      /* colormap or None */
     Bool new;
     int state;		      /* ColormapInstalled, ColormapUninstalled */
} XColormapEvent;

|__

The window member is set to the window whose associated col-
ormap is changed, installed, or uninstalled.  For a colormap
that is changed, installed, or uninstalled, the colormap



			     1m3260m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


member is set to the colormap associated with the window.
For a colormap that is changed by a call to 4mXFreeColormap24m,
the colormap member is set to 4mNone24m.  The new member is set
to indicate whether the colormap for the specified window
was changed or installed or uninstalled and can be 4mTrue24m or
4mFalse24m.  If it is 4mTrue24m, the colormap was changed.  If it is
4mFalse24m, the colormap was installed or uninstalled.	The state
member is always set to indicate whether the colormap is
installed or uninstalled and can be 4mColormapInstalled24m or
4mColormapUninstalled24m.

1m10.13.  Client Communication Events0m

This section discusses:

·    4mClientMessage24m events

·    4mPropertyNotify24m events

·    4mSelectionClear24m events

·    4mSelectionNotify24m events

·    4mSelectionRequest24m events

1m10.13.1.  ClientMessage Events0m

The X server generates 4mClientMessage24m events only when a
client calls the function 4mXSendEvent24m.

The structure for this event type contains:

__
|
typedef struct {
     int type;		      /* ClientMessage */
     unsigned long serial;    /* # of last request processed by server */
     Bool send_event;	      /* true if this came from a SendEvent request */
     Display *display;	      /* Display the event was read from */
     Window window;
     Atom message_type;
     int format;
     union {
	  char b[20];
	  short s[10];
	  long l[5];
	     } data;
} XClientMessageEvent;

|__

The message_type member is set to an atom that indicates how
the data should be interpreted by the receiving client.	 The
format member is set to 8, 16, or 32 and specifies whether



			     1m3270m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


the data should be viewed as a list of bytes, shorts, or
longs.	The data member is a union that contains the members
b, s, and l.  The b, s, and l members represent data of
twenty 8-bit values, ten 16-bit values, and five 32-bit val-
ues.  Particular message types might not make use of all
these values.  The X server places no interpretation on the
values in the window, message_type, or data members.

1m10.13.2.  PropertyNotify Events0m

The X server can report 4mPropertyNotify24m events to clients
wanting information about property changes for a specified
window.

To receive 4mPropertyNotify24m events, set the 4mPropertyChangeMask0m
bit in the event-mask attribute of the window.

The structure for this event type contains:

__
|
typedef struct {
     int type;		      /* PropertyNotify */
     unsigned long serial;    /* # of last request processed by server */
     Bool send_event;	      /* true if this came from a SendEvent request */
     Display *display;	      /* Display the event was read from */
     Window window;
     Atom atom;
     Time time;
     int state;		      /* PropertyNewValue or PropertyDelete */
} XPropertyEvent;

|__

The window member is set to the window whose associated
property was changed.  The atom member is set to the prop-
erty's atom and indicates which property was changed or
desired.  The time member is set to the server time when the
property was changed.  The state member is set to indicate
whether the property was changed to a new value or deleted
and can be 4mPropertyNewValue24m or 4mPropertyDelete24m.  The state
member is set to 4mPropertyNewValue24m when a property of the
window is changed using 4mXChangeProperty24m or 4mXRotateWindow-0m
4mProperties24m (even when adding zero-length data using 4mXChange-0m
4mProperty24m) and when replacing all or part of a property with
identical data using 4mXChangeProperty24m or 4mXRotateWindowProper-0m
4mties24m.  The state member is set to 4mPropertyDelete24m when a
property of the window is deleted using 4mXDeleteProperty24m or,
if the delete argument is 4mTrue24m, 4mXGetWindowProperty24m.

1m10.13.3.  SelectionClear Events0m

The X server reports 4mSelectionClear24m events to the client
losing ownership of a selection.  The X server generates



			     1m3280m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


this event type when another client asserts ownership of the
selection by calling 4mXSetSelectionOwner24m.

The structure for this event type contains:

__
|
typedef struct {
     int type;		      /* SelectionClear */
     unsigned long serial;    /* # of last request processed by server */
     Bool send_event;	      /* true if this came from a SendEvent request */
     Display *display;	      /* Display the event was read from */
     Window window;
     Atom selection;
     Time time;
} XSelectionClearEvent;

|__

The selection member is set to the selection atom.  The time
member is set to the last change time recorded for the
selection.  The window member is the window that was speci-
fied by the current owner (the owner losing the selection)
in its 4mXSetSelectionOwner24m call.

1m10.13.4.  SelectionRequest Events0m

The X server reports 4mSelectionRequest24m events to the owner of
a selection.  The X server generates this event whenever a
client requests a selection conversion by calling 4mXConvertS-0m
4melection24m for the owned selection.

The structure for this event type contains:

__
|
typedef struct {
     int type;		      /* SelectionRequest */
     unsigned long serial;    /* # of last request processed by server */
     Bool send_event;	      /* true if this came from a SendEvent request */
     Display *display;	      /* Display the event was read from */
     Window owner;
     Window requestor;
     Atom selection;
     Atom target;
     Atom property;
     Time time;
} XSelectionRequestEvent;

|__

The owner member is set to the window that was specified by
the current owner in its 4mXSetSelectionOwner24m call.	The
requestor member is set to the window requesting the



			     1m3290m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


selection.  The selection member is set to the atom that
names the selection.  For example, PRIMARY is used to indi-
cate the primary selection.  The target member is set to the
atom that indicates the type the selection is desired in.
The property member can be a property name or 4mNone24m.  The
time member is set to the timestamp or 4mCurrentTime24m value
from the 4mConvertSelection24m request.

The owner should convert the selection based on the speci-
fied target type and send a 4mSelectionNotify24m event back to
the requestor.	A complete specification for using selec-
tions is given in the X Consortium standard 4mInter-Client0m
4mCommunication24m 4mConventions24m 4mManual24m.

1m10.13.5.  SelectionNotify Events0m

This event is generated by the X server in response to a
4mConvertSelection24m protocol request when there is no owner for
the selection.	When there is an owner, it should be gener-
ated by the owner of the selection by using 4mXSendEvent24m.  The
owner of a selection should send this event to a requestor
when a selection has been converted and stored as a property
or when a selection conversion could not be performed (which
is indicated by setting the property member to 4mNone24m).

If 4mNone24m is specified as the property in the 4mConvertSelection0m
protocol request, the owner should choose a property name,
store the result as that property on the requestor window,
and then send a 4mSelectionNotify24m giving that actual property
name.

The structure for this event type contains:

__
|
typedef struct {
     int type;		      /* SelectionNotify */
     unsigned long serial;    /* # of last request processed by server */
     Bool send_event;	      /* true if this came from a SendEvent request */
     Display *display;	      /* Display the event was read from */
     Window requestor;
     Atom selection;
     Atom target;
     Atom property;	      /* atom or None */
     Time time;
} XSelectionEvent;

|__

The requestor member is set to the window associated with
the requestor of the selection.	 The selection member is set
to the atom that indicates the selection.  For example, PRI-
MARY is used for the primary selection.	 The target member
is set to the atom that indicates the converted type.  For



			     1m3300m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


example, PIXMAP is used for a pixmap.  The property member
is set to the atom that indicates which property the result
was stored on.	If the conversion failed, the property mem-
ber is set to 4mNone24m.  The time member is set to the time the
conversion took place and can be a timestamp or 4mCurrentTime24m.




















































			     1m3310m





1mXlib - C Library			X11, Release 6.7 DRAFT0m




			 1mChapter 110m

		  1mEvent Handling Functions0m



This chapter discusses the Xlib functions you can use to:

·    Select events

·    Handle the output buffer and the event queue

·    Select events from the event queue

·    Send and get events

·    Handle protocol errors

			      Note

	  Some toolkits use their own event-handling
	  functions and do not allow you to interchange
	  these event-handling functions with those in
	  Xlib.	 For further information, see the docu-
	  mentation supplied with the toolkit.


Most applications simply are event loops: they wait for an
event, decide what to do with it, execute some amount of
code that results in changes to the display, and then wait
for the next event.

1m11.1.	 Selecting Events0m

There are two ways to select the events you want reported to
your client application.  One way is to set the event_mask
member of the 4mXSetWindowAttributes24m structure when you call
4mXCreateWindow24m and 4mXChangeWindowAttributes24m.  Another way is
to use 4mXSelectInput24m.
















			     1m3320m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
XSelectInput(4mdisplay24m, 4mw24m, 4mevent_mask24m)
      Display *4mdisplay24m;
      Window 4mw24m;
      long 4mevent_mask24m;


4mdisplay24m   Specifies the connection to the X server.

4mw24m	       Specifies the window whose events you are inter-
	  ested in.

4mevent_mask0m
	  Specifies the event mask.
|__

The 4mXSelectInput24m function requests that the X server report
the events associated with the specified event mask.  Ini-
tially, X will not report any of these events.	Events are
reported relative to a window.	If a window is not inter-
ested in a device event, it usually propagates to the clos-
est ancestor that is interested, unless the do_not_propagate
mask prohibits it.

Setting the event-mask attribute of a window overrides any
previous call for the same window but not for other clients.
Multiple clients can select for the same events on the same
window with the following restrictions:

·    Multiple clients can select events on the same window
     because their event masks are disjoint.  When the X
     server generates an event, it reports it to all inter-
     ested clients.

·    Only one client at a time can select 4mCirculateRequest24m,
     4mConfigureRequest24m, or 4mMapRequest24m events, which are asso-
     ciated with the event mask 4mSubstructureRedirectMask24m.

·    Only one client at a time can select a 4mResizeRequest0m
     event, which is associated with the event mask 4mResiz-0m
     4meRedirectMask24m.

·    Only one client at a time can select a 4mButtonPress0m
     event, which is associated with the event mask 4mButton-0m
     4mPressMask24m.

The server reports the event to all interested clients.

4mXSelectInput24m can generate a 4mBadWindow24m error.

1m11.2.	 Handling the Output Buffer0m

The output buffer is an area used by Xlib to store requests.
The functions described in this section flush the output



			     1m3330m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


buffer if the function would block or not return an event.
That is, all requests residing in the output buffer that
have not yet been sent are transmitted to the X server.
These functions differ in the additional tasks they might
perform.


To flush the output buffer, use 4mXFlush24m.
__
|
XFlush(4mdisplay24m)
      Display *4mdisplay24m;


4mdisplay24m   Specifies the connection to the X server.
|__

The 4mXFlush24m function flushes the output buffer.  Most client
applications need not use this function because the output
buffer is automatically flushed as needed by calls to 4mXPend-0m
4ming24m, 4mXNextEvent24m, and 4mXWindowEvent24m.  Events generated by the
server may be enqueued into the library's event queue.


To flush the output buffer and then wait until all requests
have been processed, use 4mXSync24m.
__
|
XSync(4mdisplay24m, 4mdiscard24m)
      Display *4mdisplay24m;
      Bool 4mdiscard24m;


4mdisplay24m   Specifies the connection to the X server.

4mdiscard24m   Specifies a Boolean value that indicates whether
	  4mXSync24m discards all events on the event queue.
|__

The 4mXSync24m function flushes the output buffer and then waits
until all requests have been received and processed by the X
server.	 Any errors generated must be handled by the error
handler.  For each protocol error received by Xlib, 4mXSync0m
calls the client application's error handling routine (see
section 11.8.2).  Any events generated by the server are
enqueued into the library's event queue.

Finally, if you passed 4mFalse24m, 4mXSync24m does not discard the
events in the queue.  If you passed 4mTrue24m, 4mXSync24m discards all
events in the queue, including those events that were on the
queue before 4mXSync24m was called.  Client applications seldom
need to call 4mXSync24m.





			     1m3340m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


1m11.3.	 Event Queue Management0m

Xlib maintains an event queue.	However, the operating sys-
tem also may be buffering data in its network connection
that is not yet read into the event queue.


To check the number of events in the event queue, use
4mXEventsQueued24m.
__
|
int XEventsQueued(4mdisplay24m, 4mmode24m)
     Display *4mdisplay24m;
     int 4mmode24m;


4mdisplay24m   Specifies the connection to the X server.

4mmode24m      Specifies the mode.  You can pass 4mQueuedAlready24m,
	  4mQueuedAfterFlush24m, or 4mQueuedAfterReading24m.
|__

If mode is 4mQueuedAlready24m, 4mXEventsQueued24m returns the number
of events already in the event queue (and never performs a
system call).  If mode is 4mQueuedAfterFlush24m, 4mXEventsQueued0m
returns the number of events already in the queue if the
number is nonzero.  If there are no events in the queue,
4mXEventsQueued24m flushes the output buffer, attempts to read
more events out of the application's connection, and returns
the number read.  If mode is 4mQueuedAfterReading24m,
4mXEventsQueued24m returns the number of events already in the
queue if the number is nonzero.	 If there are no events in
the queue, 4mXEventsQueued24m attempts to read more events out of
the application's connection without flushing the output
buffer and returns the number read.

4mXEventsQueued24m always returns immediately without I/O if
there are events already in the queue.	4mXEventsQueued24m with
mode 4mQueuedAfterFlush24m is identical in behavior to 4mXPending24m.
4mXEventsQueued24m with mode 4mQueuedAlready24m is identical to the
4mXQLength24m function.


To return the number of events that are pending, use 4mXPend-0m
4ming24m.












			     1m3350m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
int XPending(4mdisplay24m)
      Display *4mdisplay24m;


4mdisplay24m   Specifies the connection to the X server.
|__

The 4mXPending24m function returns the number of events that have
been received from the X server but have not been removed
from the event queue.  4mXPending24m is identical to
4mXEventsQueued24m with the mode 4mQueuedAfterFlush24m specified.

1m11.4.	 Manipulating the Event Queue0m

Xlib provides functions that let you manipulate the event
queue.	This section discusses how to:

·    Obtain events, in order, and remove them from the queue

·    Peek at events in the queue without removing them

·    Obtain events that match the event mask or the arbi-
     trary predicate procedures that you provide

1m11.4.1.  Returning the Next Event0m

To get the next event and remove it from the queue, use
4mXNextEvent24m.
__
|
XNextEvent(4mdisplay24m, 4mevent_return24m)
      Display *4mdisplay24m;
      XEvent *4mevent_return24m;


4mdisplay24m   Specifies the connection to the X server.

4mevent_return0m
	  Returns the next event in the queue.
|__

The 4mXNextEvent24m function copies the first event from the
event queue into the specified 4mXEvent24m structure and then
removes it from the queue.  If the event queue is empty,
4mXNextEvent24m flushes the output buffer and blocks until an
event is received.


To peek at the event queue, use 4mXPeekEvent24m.







			     1m3360m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
XPeekEvent(4mdisplay24m, 4mevent_return24m)
      Display *4mdisplay24m;
      XEvent *4mevent_return24m;


4mdisplay24m   Specifies the connection to the X server.

4mevent_return0m
	  Returns a copy of the matched event's associated
	  structure.
|__

The 4mXPeekEvent24m function returns the first event from the
event queue, but it does not remove the event from the
queue.	If the queue is empty, 4mXPeekEvent24m flushes the output
buffer and blocks until an event is received.  It then
copies the event into the client-supplied 4mXEvent24m structure
without removing it from the event queue.

1m11.4.2.  Selecting Events Using a Predicate Procedure0m

Each of the functions discussed in this section requires you
to pass a predicate procedure that determines if an event
matches what you want.	Your predicate procedure must decide
if the event is useful without calling any Xlib functions.
If the predicate directly or indirectly causes the state of
the event queue to change, the result is not defined.  If
Xlib has been initialized for threads, the predicate is
called with the display locked and the result of a call by
the predicate to any Xlib function that locks the display is
not defined unless the caller has first called 4mXLockDisplay24m.

The predicate procedure and its associated arguments are:
__
|
Bool (*4mpredicate24m)(4mdisplay24m, 4mevent24m, 4marg24m)
     Display *4mdisplay24m;
     XEvent *4mevent24m;
     XPointer 4marg24m;


4mdisplay24m   Specifies the connection to the X server.

4mevent24m     Specifies the 4mXEvent24m structure.

4marg24m       Specifies the argument passed in from the
	  4mXIfEvent24m, 4mXCheckIfEvent24m, or 4mXPeekIfEvent24m function.
|__

The predicate procedure is called once for each event in the
queue until it finds a match.  After finding a match, the
predicate procedure must return 4mTrue24m.  If it did not find a
match, it must return 4mFalse24m.



			     1m3370m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


To check the event queue for a matching event and, if found,
remove the event from the queue, use 4mXIfEvent24m.
__
|
XIfEvent(4mdisplay24m, 4mevent_return24m, 4mpredicate24m, 4marg24m)
      Display *4mdisplay24m;
      XEvent *4mevent_return24m;
      Bool (*4mpredicate24m)();
      XPointer 4marg24m;


4mdisplay24m   Specifies the connection to the X server.

4mevent_return0m
	  Returns the matched event's associated structure.

4mpredicate24m Specifies the procedure that is to be called to
	  determine if the next event in the queue matches
	  what you want.

4marg24m       Specifies the user-supplied argument that will be
	  passed to the predicate procedure.
|__

The 4mXIfEvent24m function completes only when the specified
predicate procedure returns 4mTrue24m for an event, which indi-
cates an event in the queue matches.  4mXIfEvent24m flushes the
output buffer if it blocks waiting for additional events.
4mXIfEvent24m removes the matching event from the queue and
copies the structure into the client-supplied 4mXEvent24m struc-
ture.


To check the event queue for a matching event without block-
ing, use 4mXCheckIfEvent24m.






















			     1m3380m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
Bool XCheckIfEvent(4mdisplay24m, 4mevent_return24m, 4mpredicate24m, 4marg24m)
      Display *4mdisplay24m;
      XEvent *4mevent_return24m;
      Bool (*4mpredicate24m)();
      XPointer 4marg24m;


4mdisplay24m   Specifies the connection to the X server.

4mevent_return0m
	  Returns a copy of the matched event's associated
	  structure.

4mpredicate24m Specifies the procedure that is to be called to
	  determine if the next event in the queue matches
	  what you want.

4marg24m       Specifies the user-supplied argument that will be
	  passed to the predicate procedure.
|__

When the predicate procedure finds a match, 4mXCheckIfEvent0m
copies the matched event into the client-supplied 4mXEvent0m
structure and returns 4mTrue24m.  (This event is removed from the
queue.)	 If the predicate procedure finds no match, 4mXCheck-0m
4mIfEvent24m returns 4mFalse24m, and the output buffer will have been
flushed.  All earlier events stored in the queue are not
discarded.


To check the event queue for a matching event without remov-
ing the event from the queue, use 4mXPeekIfEvent24m.
























			     1m3390m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
XPeekIfEvent(4mdisplay24m, 4mevent_return24m, 4mpredicate24m, 4marg24m)
      Display *4mdisplay24m;
      XEvent *4mevent_return24m;
      Bool (*4mpredicate24m)();
      XPointer 4marg24m;


4mdisplay24m   Specifies the connection to the X server.

4mevent_return0m
	  Returns a copy of the matched event's associated
	  structure.

4mpredicate24m Specifies the procedure that is to be called to
	  determine if the next event in the queue matches
	  what you want.

4marg24m       Specifies the user-supplied argument that will be
	  passed to the predicate procedure.
|__

The 4mXPeekIfEvent24m function returns only when the specified
predicate procedure returns 4mTrue24m for an event.  After the
predicate procedure finds a match, 4mXPeekIfEvent24m copies the
matched event into the client-supplied 4mXEvent24m structure
without removing the event from the queue.  4mXPeekIfEvent0m
flushes the output buffer if it blocks waiting for addi-
tional events.

1m11.4.3.  Selecting Events Using a Window or Event Mask0m

The functions discussed in this section let you select
events by window or event types, allowing you to process
events out of order.


To remove the next event that matches both a window and an
event mask, use 4mXWindowEvent24m.


















			     1m3400m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
XWindowEvent(4mdisplay24m, 4mw24m, 4mevent_mask24m, 4mevent_return24m)
      Display *4mdisplay24m;
      Window 4mw24m;
      long 4mevent_mask24m;
      XEvent *4mevent_return24m;


4mdisplay24m   Specifies the connection to the X server.

4mw24m	       Specifies the window whose events you are inter-
	  ested in.

4mevent_mask0m
	  Specifies the event mask.

4mevent_return0m
	  Returns the matched event's associated structure.
|__

The 4mXWindowEvent24m function searches the event queue for an
event that matches both the specified window and event mask.
When it finds a match, 4mXWindowEvent24m removes that event from
the queue and copies it into the specified 4mXEvent24m structure.
The other events stored in the queue are not discarded.	 If
a matching event is not in the queue, 4mXWindowEvent24m flushes
the output buffer and blocks until one is received.


To remove the next event that matches both a window and an
event mask (if any), use 4mXCheckWindowEvent24m.  This function
is similar to 4mXWindowEvent24m except that it never blocks and
it returns a 4mBool24m indicating if the event was returned.
























			     1m3410m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
Bool XCheckWindowEvent(4mdisplay24m, 4mw24m, 4mevent_mask24m, 4mevent_return24m)
      Display *4mdisplay24m;
      Window 4mw24m;
      long 4mevent_mask24m;
      XEvent *4mevent_return24m;


4mdisplay24m   Specifies the connection to the X server.

4mw24m	       Specifies the window whose events you are inter-
	  ested in.

4mevent_mask0m
	  Specifies the event mask.

4mevent_return0m
	  Returns the matched event's associated structure.
|__

The 4mXCheckWindowEvent24m function searches the event queue and
then the events available on the server connection for the
first event that matches the specified window and event
mask.  If it finds a match, 4mXCheckWindowEvent24m removes that
event, copies it into the specified 4mXEvent24m structure, and
returns 4mTrue24m.  The other events stored in the queue are not
discarded.  If the event you requested is not available,
4mXCheckWindowEvent24m returns 4mFalse24m, and the output buffer will
have been flushed.


To remove the next event that matches an event mask, use
4mXMaskEvent24m.
__
|
XMaskEvent(4mdisplay24m, 4mevent_mask24m, 4mevent_return24m)
      Display *4mdisplay24m;
      long 4mevent_mask24m;
      XEvent *4mevent_return24m;


4mdisplay24m   Specifies the connection to the X server.

4mevent_mask0m
	  Specifies the event mask.

4mevent_return0m
	  Returns the matched event's associated structure.
|__

The 4mXMaskEvent24m function searches the event queue for the
events associated with the specified mask.  When it finds a
match, 4mXMaskEvent24m removes that event and copies it into the
specified 4mXEvent24m structure.  The other events stored in the



			     1m3420m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


queue are not discarded.  If the event you requested is not
in the queue, 4mXMaskEvent24m flushes the output buffer and
blocks until one is received.


To return and remove the next event that matches an event
mask (if any), use 4mXCheckMaskEvent24m.  This function is simi-
lar to 4mXMaskEvent24m except that it never blocks and it returns
a 4mBool24m indicating if the event was returned.
__
|
Bool XCheckMaskEvent(4mdisplay24m, 4mevent_mask24m, 4mevent_return24m)
      Display *4mdisplay24m;
      long 4mevent_mask24m;
      XEvent *4mevent_return24m;


4mdisplay24m   Specifies the connection to the X server.

4mevent_mask0m
	  Specifies the event mask.

4mevent_return0m
	  Returns the matched event's associated structure.
|__

The 4mXCheckMaskEvent24m function searches the event queue and
then any events available on the server connection for the
first event that matches the specified mask.  If it finds a
match, 4mXCheckMaskEvent24m removes that event, copies it into
the specified 4mXEvent24m structure, and returns 4mTrue24m.  The other
events stored in the queue are not discarded.  If the event
you requested is not available, 4mXCheckMaskEvent24m returns
4mFalse24m, and the output buffer will have been flushed.


To return and remove the next event in the queue that
matches an event type, use 4mXCheckTypedEvent24m.



















			     1m3430m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
Bool XCheckTypedEvent(4mdisplay24m, 4mevent_type24m, 4mevent_return24m)
      Display *4mdisplay24m;
      int 4mevent_type24m;
      XEvent *4mevent_return24m;


4mdisplay24m   Specifies the connection to the X server.

4mevent_type0m
	  Specifies the event type to be compared.


4mevent_return0m
	  Returns the matched event's associated structure.
|__

The 4mXCheckTypedEvent24m function searches the event queue and
then any events available on the server connection for the
first event that matches the specified type.  If it finds a
match, 4mXCheckTypedEvent24m removes that event, copies it into
the specified 4mXEvent24m structure, and returns 4mTrue24m.  The other
events in the queue are not discarded.	If the event is not
available, 4mXCheckTypedEvent24m returns 4mFalse24m, and the output
buffer will have been flushed.


To return and remove the next event in the queue that
matches an event type and a window, use 4mXCheckTypedWindow-0m
4mEvent24m.
__
|
Bool XCheckTypedWindowEvent(4mdisplay24m, 4mw24m, 4mevent_type24m, 4mevent_return24m)
      Display *4mdisplay24m;
      Window 4mw24m;
      int 4mevent_type24m;
      XEvent *4mevent_return24m;


4mdisplay24m   Specifies the connection to the X server.

4mw24m	       Specifies the window.

4mevent_type0m
	  Specifies the event type to be compared.


4mevent_return0m
	  Returns the matched event's associated structure.
|__

The 4mXCheckTypedWindowEvent24m function searches the event queue
and then any events available on the server connection for
the first event that matches the specified type and window.



			     1m3440m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


If it finds a match, 4mXCheckTypedWindowEvent24m removes the
event from the queue, copies it into the specified 4mXEvent0m
structure, and returns 4mTrue24m.  The other events in the queue
are not discarded.  If the event is not available, 4mXCheck-0m
4mTypedWindowEvent24m returns 4mFalse24m, and the output buffer will
have been flushed.

1m11.5.	 Putting an Event Back into the Queue0m

To push an event back into the event queue, use 4mXPutBack-0m
4mEvent24m.
__
|
XPutBackEvent(4mdisplay24m, 4mevent24m)
      Display *4mdisplay24m;
      XEvent *4mevent24m;


4mdisplay24m   Specifies the connection to the X server.

4mevent24m     Specifies the event.
|__

The 4mXPutBackEvent24m function pushes an event back onto the
head of the display's event queue by copying the event into
the queue.  This can be useful if you read an event and then
decide that you would rather deal with it later.  There is
no limit to the number of times in succession that you can
call 4mXPutBackEvent24m.

1m11.6.	 Sending Events to Other Applications0m

To send an event to a specified window, use 4mXSendEvent24m.
This function is often used in selection processing.  For
example, the owner of a selection should use 4mXSendEvent24m to
send a 4mSelectionNotify24m event to a requestor when a selection
has been converted and stored as a property.




















			     1m3450m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
Status XSendEvent(4mdisplay24m, 4mw24m, 4mpropagate24m, 4mevent_mask24m, 4mevent_send24m)
      Display *4mdisplay24m;
      Window 4mw24m;
      Bool 4mpropagate24m;
      long 4mevent_mask24m;
      XEvent *4mevent_send24m;


4mdisplay24m   Specifies the connection to the X server.

4mw24m	       Specifies the window the event is to be sent to,
	  or 4mPointerWindow24m, or 4mInputFocus24m.

4mpropagate24m Specifies a Boolean value.

4mevent_mask0m
	  Specifies the event mask.

4mevent_send0m
	  Specifies the event that is to be sent.
|__

The 4mXSendEvent24m function identifies the destination window,
determines which clients should receive the specified
events, and ignores any active grabs.  This function
requires you to pass an event mask.  For a discussion of the
valid event mask names, see section 10.3.  This function
uses the w argument to identify the destination window as
follows:

·    If w is 4mPointerWindow24m, the destination window is the
     window that contains the pointer.

·    If w is 4mInputFocus24m and if the focus window contains the
     pointer, the destination window is the window that con-
     tains the pointer; otherwise, the destination window is
     the focus window.

To determine which clients should receive the specified
events, 4mXSendEvent24m uses the propagate argument as follows:

·    If event_mask is the empty set, the event is sent to
     the client that created the destination window.  If
     that client no longer exists, no event is sent.

·    If propagate is 4mFalse24m, the event is sent to every
     client selecting on destination any of the event types
     in the event_mask argument.

·    If propagate is 4mTrue24m and no clients have selected on
     destination any of the event types in event-mask, the
     destination is replaced with the closest ancestor of
     destination for which some client has selected a type



			     1m3460m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


     in event-mask and for which no intervening window has
     that type in its do-not-propagate-mask.  If no such
     window exists or if the window is an ancestor of the
     focus window and 4mInputFocus24m was originally specified as
     the destination, the event is not sent to any clients.
     Otherwise, the event is reported to every client
     selecting on the final destination any of the types
     specified in event_mask.

The event in the 4mXEvent24m structure must be one of the core
events or one of the events defined by an extension (or a
4mBadValue24m error results) so that the X server can correctly
byte-swap the contents as necessary.  The contents of the
event are otherwise unaltered and unchecked by the X server
except to force send_event to 4mTrue24m in the forwarded event
and to set the serial number in the event correctly; there-
fore these fields and the display field are ignored by
4mXSendEvent24m.

4mXSendEvent24m returns zero if the conversion to wire protocol
format failed and returns nonzero otherwise.

4mXSendEvent24m can generate 4mBadValue24m and 4mBadWindow24m errors.

1m11.7.	 Getting Pointer Motion History0m

Some X server implementations will maintain a more complete
history of pointer motion than is reported by event notifi-
cation.	 The pointer position at each pointer hardware
interrupt may be stored in a buffer for later retrieval.
This buffer is called the motion history buffer.  For exam-
ple, a few applications, such as paint programs, want to
have a precise history of where the pointer traveled.  How-
ever, this historical information is highly excessive for
most applications.


To determine the approximate maximum number of elements in
the motion buffer, use 4mXDisplayMotionBufferSize24m.
__
|
unsigned long XDisplayMotionBufferSize(4mdisplay24m)
	Display *4mdisplay24m;


4mdisplay24m   Specifies the connection to the X server.
|__

The server may retain the recent history of the pointer
motion and do so to a finer granularity than is reported by
4mMotionNotify24m events.  The 4mXGetMotionEvents24m function makes
this history available.





			     1m3470m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


To get the motion history for a specified window and time,
use 4mXGetMotionEvents24m.
__
|
XTimeCoord *XGetMotionEvents(4mdisplay24m, 4mw24m, 4mstart24m, 4mstop24m, 4mnevents_return24m)
      Display *4mdisplay24m;
      Window 4mw24m;
      Time 4mstart24m, 4mstop24m;
      int *4mnevents_return24m;


4mdisplay24m   Specifies the connection to the X server.

4mw24m	       Specifies the window.

4mstart0m
4mstop24m      Specify the time interval in which the events are
	  returned from the motion history buffer.  You can
	  pass a timestamp or 4mCurrentTime24m.

4mnevents_return0m
	  Returns the number of events from the motion his-
	  tory buffer.
|__

The 4mXGetMotionEvents24m function returns all events in the
motion history buffer that fall between the specified start
and stop times, inclusive, and that have coordinates that
lie within the specified window (including its borders) at
its present placement.	If the server does not support
motion history, if the start time is later than the stop
time, or if the start time is in the future, no events are
returned; 4mXGetMotionEvents24m returns NULL.  If the stop time
is in the future, it is equivalent to specifying 4mCurrent-0m
4mTime24m.  The return type for this function is a structure
defined as follows:

__
|
typedef struct {
     Time time;
     short x, y;
} XTimeCoord;

|__

The time member is set to the time, in milliseconds.  The x
and y members are set to the coordinates of the pointer and
are reported relative to the origin of the specified window.
To free the data returned from this call, use 4mXFree24m.

4mXGetMotionEvents24m can generate a 4mBadWindow24m error.





			     1m3480m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


1m11.8.	 Handling Protocol Errors0m

Xlib provides functions that you can use to enable or dis-
able synchronization and to use the default error handlers.

1m11.8.1.  Enabling or Disabling Synchronization0m

When debugging X applications, it often is very convenient
to require Xlib to behave synchronously so that errors are
reported as they occur.	 The following function lets you
disable or enable synchronous behavior.	 Note that graphics
may occur 30 or more times more slowly when synchronization
is enabled.  On POSIX-conformant systems, there is also a
global variable 4m_Xdebug24m that, if set to nonzero before
starting a program under a debugger, will force synchronous
library behavior.

After completing their work, all Xlib functions that gener-
ate protocol requests call what is known as an after func-
tion.  4mXSetAfterFunction24m sets which function is to be
called.
__
|
int (*XSetAfterFunction(4mdisplay24m, 4mprocedure24m))()
      Display *4mdisplay24m;
      int (*4mprocedure24m)();


4mdisplay24m   Specifies the connection to the X server.

4mprocedure24m Specifies the procedure to be called.
|__

The specified procedure is called with only a display
pointer.  4mXSetAfterFunction24m returns the previous after func-
tion.

To enable or disable synchronization, use 4mXSynchronize24m.
__
|
int (*XSynchronize(4mdisplay24m, 4monoff24m))()
      Display *4mdisplay24m;
      Bool 4monoff24m;


4mdisplay24m   Specifies the connection to the X server.

4monoff24m     Specifies a Boolean value that indicates whether
	  to enable or disable synchronization.
|__

The 4mXSynchronize24m function returns the previous after func-
tion.  If onoff is 4mTrue24m, 4mXSynchronize24m turns on synchronous
behavior.  If onoff is 4mFalse24m, 4mXSynchronize24m turns off



			     1m3490m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


synchronous behavior.

1m11.8.2.  Using the Default Error Handlers0m

There are two default error handlers in Xlib: one to handle
typically fatal conditions (for example, the connection to a
display server dying because a machine crashed) and one to
handle protocol errors from the X server.  These error han-
dlers can be changed to user-supplied routines if you prefer
your own error handling and can be changed as often as you
like.  If either function is passed a NULL pointer, it will
reinvoke the default handler.  The action of the default
handlers is to print an explanatory message and exit.


To set the error handler, use 4mXSetErrorHandler24m.
__
|
int (*XSetErrorHandler(4mhandler24m))()
      int (*4mhandler24m)(Display *, XErrorEvent *)


4mhandler24m   Specifies the program's supplied error handler.
|__

Xlib generally calls the program's supplied error handler
whenever an error is received.	It is not called on 4mBadName0m
errors from 4mOpenFont24m, 4mLookupColor24m, or 4mAllocNamedColor24m proto-
col requests or on 4mBadFont24m errors from a 4mQueryFont24m protocol
request.  These errors generally are reflected back to the
program through the procedural interface.  Because this con-
dition is not assumed to be fatal, it is acceptable for your
error handler to return; the returned value is ignored.
However, the error handler should not call any functions
(directly or indirectly) on the display that will generate
protocol requests or that will look for input events.  The
previous error handler is returned.

The 4mXErrorEvent24m structure contains:


typedef struct {
     int type;
     Display *display;	 /* Display the event was read from */
     unsigned long serial;/* serial number of failed request */
     unsigned char error_code;/* error code of failed request */
     unsigned char request_code;/* Major op-code of failed request */
     unsigned char minor_code;/* Minor op-code of failed request */
     XID resourceid;	 /* resource id */
} XErrorEvent;


The serial member is the number of requests, starting from
one, sent over the network connection since it was opened.



			     1m3500m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


It is the number that was the value of 4mNextRequest24m immedi-
ately before the failing call was made.	 The request_code
member is a protocol request of the procedure that failed,
as defined in <4mX11/Xproto.h24m>.  The following error codes can
be returned by the functions described in this chapter:

-------------------------------------------------------------
1mError Code			    Description0m
-------------------------------------------------------------
4mBadAccess24m		 A client attempts to grab a key/button
		    combination already grabbed by another
		    client.
		    A client attempts to free a colormap
		    entry that it had not already allocated
		    or to free an entry in a colormap that
		    was created with all entries writable.
		    A client attempts to store into a read-
		    only or unallocated colormap entry.
		    A client attempts to modify the access
		    control list from other than the local
		    (or otherwise authorized) host.
		    A client attempts to select an event
		    type that another client has already
		    selected.
4mBadAlloc24m		 The server fails to allocate the
		    requested resource.	 Note that the
		    explicit listing of 4mBadAlloc24m errors in
		    requests only covers allocation errors
		    at a very coarse level and is not
		    intended to (nor can it in practice hope
		    to) cover all cases of a server running
		    out of allocation space in the middle of
		    service.  The semantics when a server
		    runs out of allocation space are left
		    unspecified, but a server may generate a
		    4mBadAlloc24m error on any request for this
		    reason, and clients should be prepared
		    to receive such errors and handle or
		    discard them.
4mBadAtom24m		 A value for an atom argument does not
		    name a defined atom.
4mBadColor24m		 A value for a colormap argument does not
		    name a defined colormap.
4mBadCursor24m		 A value for a cursor argument does not
		    name a defined cursor.
4mBadDrawable24m	 A value for a drawable argument does not
		    name a defined window or pixmap.
4mBadFont24m		 A value for a font argument does not
		    name a defined font (or, in some cases,
		    4mGContext24m).
4mBadGC24m		 A value for a 4mGContext24m argument does not
		    name a defined 4mGContext24m.





			     1m3510m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


-------------------------------------------------------------
1mError Code			    Description0m
-------------------------------------------------------------
4mBadIDChoice24m	 The value chosen for a resource identi-
		    fier either is not included in the range
		    assigned to the client or is already in
		    use.  Under normal circumstances, this
		    cannot occur and should be considered a
		    server or Xlib error.
4mBadImplementation24m	 The server does not implement some
		    aspect of the request.  A server that
		    generates this error for a core request
		    is deficient.  As such, this error is
		    not listed for any of the requests, but
		    clients should be prepared to receive
		    such errors and handle or discard them.
4mBadLength24m		 The length of a request is shorter or
		    longer than that required to contain the
		    arguments.	This is an internal Xlib or
		    server error.
		    The length of a request exceeds the max-
		    imum length accepted by the server.
4mBadMatch24m		 In a graphics request, the root and
		    depth of the graphics context do not
		    match those of the drawable.
		    An 4mInputOnly24m window is used as a draw-
		    able.
		    Some argument or pair of arguments has
		    the correct type and range, but it fails
		    to match in some other way required by
		    the request.
		    An 4mInputOnly24m window lacks this
		    attribute.
4mBadName24m		 A font or color of the specified name
		    does not exist.
4mBadPixmap24m		 A value for a pixmap argument does not
		    name a defined pixmap.
4mBadRequest24m		 The major or minor opcode does not spec-
		    ify a valid request.  This usually is an
		    Xlib or server error.
4mBadValue24m		 Some numeric value falls outside of the
		    range of values accepted by the request.
		    Unless a specific range is specified for
		    an argument, the full range defined by
		    the argument's type is accepted.  Any
		    argument defined as a set of alterna-
		    tives typically can generate this error
		    (due to the encoding).
4mBadWindow24m		 A value for a window argument does not
		    name a defined window.
-------------------------------------------------------------






			     1m3520m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


			    Note

     The 4mBadAtom24m, 4mBadColor24m, 4mBadCursor24m, 4mBadDrawable24m,
     4mBadFont24m, 4mBadGC24m, 4mBadPixmap24m, and 4mBadWindow24m errors
     are also used when the argument type is extended
     by a set of fixed alternatives.



To obtain textual descriptions of the specified error code,
use 4mXGetErrorText24m.
__
|
XGetErrorText(4mdisplay24m, 4mcode24m, 4mbuffer_return24m, 4mlength24m)
      Display *4mdisplay24m;
      int 4mcode24m;
      char *4mbuffer_return24m;
      int 4mlength24m;


4mdisplay24m   Specifies the connection to the X server.

4mcode24m      Specifies the error code for which you want to
	  obtain a description.

4mbuffer_return0m
	  Returns the error description.

4mlength24m    Specifies the size of the buffer.
|__

The 4mXGetErrorText24m function copies a null-terminated string
describing the specified error code into the specified
buffer.	 The returned text is in the encoding of the current
locale.	 It is recommended that you use this function to
obtain an error description because extensions to Xlib may
define their own error codes and error strings.


To obtain error messages from the error database, use
4mXGetErrorDatabaseText24m.
















			     1m3530m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
XGetErrorDatabaseText(4mdisplay24m, 4mname24m, 4mmessage24m, 4mdefault_string24m, 4mbuffer_return24m, 4mlength24m)
      Display *4mdisplay24m;
      char *4mname24m, *4mmessage24m;
      char *4mdefault_string24m;
      char *4mbuffer_return24m;
      int 4mlength24m;


4mdisplay24m   Specifies the connection to the X server.

4mname24m      Specifies the name of the application.

4mmessage24m   Specifies the type of the error message.

4mdefault_string0m
	  Specifies the default error message if none is
	  found in the database.

4mbuffer_return0m
	  Returns the error description.

4mlength24m    Specifies the size of the buffer.
|__

The 4mXGetErrorDatabaseText24m function returns a null-terminated
message (or the default message) from the error message
database.  Xlib uses this function internally to look up its
error messages.	 The text in the default_string argument is
assumed to be in the encoding of the current locale, and the
text stored in the buffer_return argument is in the encoding
of the current locale.

The name argument should generally be the name of your
application.  The message argument should indicate which
type of error message you want.	 If the name and message are
not in the Host Portable Character Encoding, the result is
implementation-dependent.  Xlib uses three predefined
``application names'' to report errors.	 In these names,
uppercase and lowercase matter.

XProtoError
	  The protocol error number is used as a string for
	  the message argument.

XlibMessage
	  These are the message strings that are used inter-
	  nally by the library.

XRequest  For a core protocol request, the major request
	  protocol number is used for the message argument.
	  For an extension request, the extension name (as
	  given by 4mInitExtension24m) followed by a period (.)
	  and the minor request protocol number is used for



			     1m3540m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


	  the message argument.	 If no string is found in
	  the error database, the default_string is returned
	  to the buffer argument.


To report an error to the user when the requested display
does not exist, use 4mXDisplayName24m.
__
|
char *XDisplayName(4mstring24m)
      char *4mstring24m;


4mstring24m    Specifies the character string.
|__

The 4mXDisplayName24m function returns the name of the display
that 4mXOpenDisplay24m would attempt to use.  If a NULL string is
specified, 4mXDisplayName24m looks in the environment for the
display and returns the display name that 4mXOpenDisplay24m would
attempt to use.	 This makes it easier to report to the user
precisely which display the program attempted to open when
the initial connection attempt failed.


To handle fatal I/O errors, use 4mXSetIOErrorHandler24m.
__
|
int (*XSetIOErrorHandler(4mhandler24m))()
      int (*4mhandler24m)(Display *);


4mhandler24m   Specifies the program's supplied error handler.
|__

The 4mXSetIOErrorHandler24m sets the fatal I/O error handler.
Xlib calls the program's supplied error handler if any sort
of system call error occurs (for example, the connection to
the server was lost).  This is assumed to be a fatal condi-
tion, and the called routine should not return.	 If the I/O
error handler does return, the client process exits.

Note that the previous error handler is returned.














			     1m3550m





1mXlib - C Library			X11, Release 6.7 DRAFT0m




			 1mChapter 120m

		   1mInput Device Functions0m



You can use the Xlib input device functions to:

·    Grab the pointer and individual buttons on the pointer

·    Grab the keyboard and individual keys on the keyboard

·    Resume event processing

·    Move the pointer

·    Set the input focus

·    Manipulate the keyboard and pointer settings

·    Manipulate the keyboard encoding

1m12.1.	 Pointer Grabbing0m

Xlib provides functions that you can use to control input
from the pointer, which usually is a mouse.  Usually, as
soon as keyboard and mouse events occur, the X server deliv-
ers them to the appropriate client, which is determined by
the window and input focus.  The X server provides suffi-
cient control over event delivery to allow window managers
to support mouse ahead and various other styles of user
interface.  Many of these user interfaces depend on synchro-
nous delivery of events.  The delivery of  pointer and key-
board events can be controlled independently.

When mouse buttons or keyboard keys are grabbed, events will
be sent to the grabbing client rather than the normal client
who would have received the event.  If the keyboard or
pointer is in asynchronous mode, further mouse and keyboard
events will continue to be processed.  If the keyboard or
pointer is in synchronous mode, no further events are pro-
cessed until the grabbing client allows them (see 4mXAllow-0m
4mEvents24m).  The keyboard or pointer is considered frozen dur-
ing this interval.  The event that triggered the grab can
also be replayed.

Note that the logical state of a device (as seen by client
applications) may lag the physical state if device event
processing is frozen.

There are two kinds of grabs: active and passive.  An active
grab occurs when a single client grabs the keyboard and/or



			     1m3560m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


pointer explicitly (see 4mXGrabPointer24m and 4mXGrabKeyboard24m).  A
passive grab occurs when clients grab a particular keyboard
key or pointer button in a window, and the grab will acti-
vate when the key or button is actually pressed.  Passive
grabs are convenient for implementing reliable pop-up menus.
For example, you can guarantee that the pop-up is mapped
before the up pointer button event occurs by grabbing a but-
ton requesting synchronous behavior.  The down event will
trigger the grab and freeze further processing of pointer
events until you have the chance to map the pop-up window.
You can then allow further event processing.  The up event
will then be correctly processed relative to the pop-up win-
dow.

For many operations, there are functions that take a time
argument.  The X server includes a timestamp in various
events.	 One special time, called 4mCurrentTime24m, represents
the current server time.  The X server maintains the time
when the input focus was last changed, when the keyboard was
last grabbed, when the pointer was last grabbed, or when a
selection was last changed.  Your application may be slow
reacting to an event.  You often need some way to specify
that your request should not occur if another application
has in the meanwhile taken control of the keyboard, pointer,
or selection.  By providing the timestamp from the event in
the request, you can arrange that the operation not take
effect if someone else has performed an operation in the
meanwhile.

A timestamp is a time value, expressed in milliseconds.	 It
typically is the time since the last server reset.  Time-
stamp values wrap around (after about 49.7 days).  The
server, given its current time is represented by timestamp
T, always interprets timestamps from clients by treating
half of the timestamp space as being later in time than T.
One timestamp value, named 4mCurrentTime24m, is never generated
by the server.	This value is reserved for use in requests
to represent the current server time.

For many functions in this section, you pass pointer event
mask bits.  The valid pointer event mask bits are: 4mButton-0m
4mPressMask24m, 4mButtonReleaseMask24m, 4mEnterWindowMask24m, 4mLeaveWindow-0m
4mMask24m, 4mPointerMotionMask24m, 4mPointerMotionHintMask24m, 4mBut-0m
4mton1MotionMask24m, 4mButton2MotionMask24m, 4mButton3MotionMask24m, 4mBut-0m
4mton4MotionMask24m, 4mButton5MotionMask24m, 4mButtonMotionMask24m, and
4mKeyMapStateMask24m.  For other functions in this section, you
pass keymask bits.  The valid keymask bits are: 4mShiftMask24m,
4mLockMask24m, 4mControlMask24m, 4mMod1Mask24m, 4mMod2Mask24m, 4mMod3Mask24m,
4mMod4Mask24m, and 4mMod5Mask24m.


To grab the pointer, use 4mXGrabPointer24m.





			     1m3570m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
int XGrabPointer(4mdisplay24m, 4mgrab_window24m, 4mowner_events24m, 4mevent_mask24m, 4mpointer_mode24m,
	       4mkeyboard_mode24m, 4mconfine_to24m, 4mcursor24m, 4mtime24m)
      Display *4mdisplay24m;
      Window 4mgrab_window24m;
      Bool 4mowner_events24m;
      unsigned int 4mevent_mask24m;
      int 4mpointer_mode24m, 4mkeyboard_mode24m;
      Window 4mconfine_to24m;
      Cursor 4mcursor24m;
      Time 4mtime24m;


4mdisplay24m   Specifies the connection to the X server.

4mgrab_window0m
	  Specifies the grab window.

4mowner_events0m
	  Specifies a Boolean value that indicates whether
	  the pointer events are to be reported as usual or
	  reported with respect to the grab window if
	  selected by the event mask.

4mevent_mask0m
	  Specifies which pointer events are reported to the
	  client.  The mask is the bitwise inclusive OR of
	  the valid pointer event mask bits.

4mpointer_mode0m
	  Specifies further processing of pointer events.
	  You can pass 4mGrabModeSync24m or 4mGrabModeAsync24m.

4mkeyboard_mode0m
	  Specifies further processing of keyboard events.
	  You can pass 4mGrabModeSync24m or 4mGrabModeAsync24m.

4mconfine_to0m
	  Specifies the window to confine the pointer in or
	  4mNone24m.

4mcursor24m    Specifies the cursor that is to be displayed dur-
	  ing the grab or 4mNone24m.

4mtime24m      Specifies the time.  You can pass either a time-
	  stamp or 4mCurrentTime24m.
|__

The 4mXGrabPointer24m function actively grabs control of the
pointer and returns 4mGrabSuccess24m if the grab was successful.
Further pointer events are reported only to the grabbing
client.	 4mXGrabPointer24m overrides any active pointer grab by
this client.  If owner_events is 4mFalse24m, all generated
pointer events are reported with respect to grab_window and



			     1m3580m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


are reported only if selected by event_mask.  If
owner_events is 4mTrue24m and if a generated pointer event would
normally be reported to this client, it is reported as
usual.	Otherwise, the event is reported with respect to the
grab_window and is reported only if selected by event_mask.
For either value of owner_events, unreported events are dis-
carded.

If the pointer_mode is 4mGrabModeAsync24m, pointer event process-
ing continues as usual.	 If the pointer is currently frozen
by this client, the processing of events for the pointer is
resumed.  If the pointer_mode is 4mGrabModeSync24m, the state of
the pointer, as seen by client applications, appears to
freeze, and the X server generates no further pointer events
until the grabbing client calls 4mXAllowEvents24m or until the
pointer grab is released.  Actual pointer changes are not
lost while the pointer is frozen; they are simply queued in
the server for later processing.

If the keyboard_mode is 4mGrabModeAsync24m, keyboard event pro-
cessing is unaffected by activation of the grab.  If the
keyboard_mode is 4mGrabModeSync24m, the state of the keyboard, as
seen by client applications, appears to freeze, and the X
server generates no further keyboard events until the grab-
bing client calls 4mXAllowEvents24m or until the pointer grab is
released.  Actual keyboard changes are not lost while the
pointer is frozen; they are simply queued in the server for
later processing.

If a cursor is specified, it is displayed regardless of what
window the pointer is in.  If 4mNone24m is specified, the normal
cursor for that window is displayed when the pointer is in
grab_window or one of its subwindows; otherwise, the cursor
for grab_window is displayed.

If a confine_to window is specified, the pointer is
restricted to stay contained in that window.  The confine_to
window need have no relationship to the grab_window.  If the
pointer is not initially in the confine_to window, it is
warped automatically to the closest edge just before the
grab activates and enter/leave events are generated as
usual.	If the confine_to window is subsequently reconfig-
ured, the pointer is warped automatically, as necessary, to
keep it contained in the window.

The time argument allows you to avoid certain circumstances
that come up if applications take a long time to respond or
if there are long network delays.  Consider a situation
where you have two applications, both of which normally grab
the pointer when clicked on.  If both applications specify
the timestamp from the event, the second application may
wake up faster and successfully grab the pointer before the
first application.  The first application then will get an
indication that the other application grabbed the pointer



			     1m3590m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


before its request was processed.

4mXGrabPointer24m generates 4mEnterNotify24m and 4mLeaveNotify24m events.

Either if grab_window or confine_to window is not viewable
or if the confine_to window lies completely outside the
boundaries of the root window, 4mXGrabPointer24m fails and
returns 4mGrabNotViewable24m.  If the pointer is actively grabbed
by some other client, it fails and returns 4mAlreadyGrabbed24m.
If the pointer is frozen by an active grab of another
client, it fails and returns 4mGrabFrozen24m.  If the specified
time is earlier than the last-pointer-grab time or later
than the current X server time, it fails and returns 4mGrabIn-0m
4mvalidTime24m.	 Otherwise, the last-pointer-grab time is set to
the specified time (4mCurrentTime24m is replaced by the current X
server time).

4mXGrabPointer24m can generate 4mBadCursor24m, 4mBadValue24m, and 4mBadWindow0m
errors.


To ungrab the pointer, use 4mXUngrabPointer24m.
__
|
XUngrabPointer(4mdisplay24m, 4mtime24m)
      Display *4mdisplay24m;
      Time 4mtime24m;


4mdisplay24m   Specifies the connection to the X server.

4mtime24m      Specifies the time.  You can pass either a time-
	  stamp or 4mCurrentTime24m.
|__

The 4mXUngrabPointer24m function releases the pointer and any
queued events if this client has actively grabbed the
pointer from 4mXGrabPointer24m, 4mXGrabButton24m, or from a normal
button press.  4mXUngrabPointer24m does not release the pointer
if the specified time is earlier than the last-pointer-grab
time or is later than the current X server time.  It also
generates 4mEnterNotify24m and 4mLeaveNotify24m events.	 The X server
performs an 4mUngrabPointer24m request automatically if the event
window or confine_to window for an active pointer grab
becomes not viewable or if window reconfiguration causes the
confine_to window to lie completely outside the boundaries
of the root window.


To change an active pointer grab, use 4mXChangeActivePointer-0m
4mGrab24m.






			     1m3600m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
XChangeActivePointerGrab(4mdisplay24m, 4mevent_mask24m, 4mcursor24m, 4mtime24m)
      Display *4mdisplay24m;
      unsigned int 4mevent_mask24m;
      Cursor 4mcursor24m;
      Time 4mtime24m;


4mdisplay24m   Specifies the connection to the X server.

4mevent_mask0m
	  Specifies which pointer events are reported to the
	  client.  The mask is the bitwise inclusive OR of
	  the valid pointer event mask bits.

4mcursor24m    Specifies the cursor that is to be displayed or
	  4mNone24m.

4mtime24m      Specifies the time.  You can pass either a time-
	  stamp or 4mCurrentTime24m.
|__

The 4mXChangeActivePointerGrab24m function changes the specified
dynamic parameters if the pointer is actively grabbed by the
client and if the specified time is no earlier than the
last-pointer-grab time and no later than the current X
server time.  This function has no effect on the passive
parameters of an 4mXGrabButton24m.  The interpretation of
event_mask and cursor is the same as described in 4mXGrab-0m
4mPointer24m.

4mXChangeActivePointerGrab24m can generate 4mBadCursor24m and 4mBadValue0m
errors.


To grab a pointer button, use 4mXGrabButton24m.





















			     1m3610m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
XGrabButton(4mdisplay24m, 4mbutton24m, 4mmodifiers24m, 4mgrab_window24m, 4mowner_events24m, 4mevent_mask24m,
		4mpointer_mode24m, 4mkeyboard_mode24m, 4mconfine_to24m, 4mcursor24m)
      Display *4mdisplay24m;
      unsigned int 4mbutton24m;
      unsigned int 4mmodifiers24m;
      Window 4mgrab_window24m;
      Bool 4mowner_events24m;
      unsigned int 4mevent_mask24m;
      int 4mpointer_mode24m, 4mkeyboard_mode24m;
      Window 4mconfine_to24m;
      Cursor 4mcursor24m;


4mdisplay24m   Specifies the connection to the X server.

4mbutton24m    Specifies the pointer button that is to be grabbed
	  or 4mAnyButton24m.

4mmodifiers24m Specifies the set of keymasks or 4mAnyModifier24m.  The
	  mask is the bitwise inclusive OR of the valid key-
	  mask bits.

4mgrab_window0m
	  Specifies the grab window.

4mowner_events0m
	  Specifies a Boolean value that indicates whether
	  the pointer events are to be reported as usual or
	  reported with respect to the grab window if
	  selected by the event mask.

4mevent_mask0m
	  Specifies which pointer events are reported to the
	  client.  The mask is the bitwise inclusive OR of
	  the valid pointer event mask bits.

4mpointer_mode0m
	  Specifies further processing of pointer events.
	  You can pass 4mGrabModeSync24m or 4mGrabModeAsync24m.

4mkeyboard_mode0m
	  Specifies further processing of keyboard events.
	  You can pass 4mGrabModeSync24m or 4mGrabModeAsync24m.

4mconfine_to0m
	  Specifies the window to confine the pointer in or
	  4mNone24m.

4mcursor24m    Specifies the cursor that is to be displayed or
	  4mNone24m.
|__

The 4mXGrabButton24m function establishes a passive grab.  In the



			     1m3620m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


future, the pointer is actively grabbed (as for 4mXGrab-0m
4mPointer24m), the last-pointer-grab time is set to the time at
which the button was pressed (as transmitted in the 4mButton-0m
4mPress24m event), and the 4mButtonPress24m event is reported if all
of the following conditions are true:

·    The pointer is not grabbed, and the specified button is
     logically pressed when the specified modifier keys are
     logically down, and no other buttons or modifier keys
     are logically down.

·    The grab_window contains the pointer.

·    The confine_to window (if any) is viewable.

·    A passive grab on the same button/key combination does
     not exist on any ancestor of grab_window.

The interpretation of the remaining arguments is as for
4mXGrabPointer24m.  The active grab is terminated automatically
when the logical state of the pointer has all buttons
released (independent of the state of the logical modifier
keys).

Note that the logical state of a device (as seen by client
applications) may lag the physical state if device event
processing is frozen.

This request overrides all previous grabs by the same client
on the same button/key combinations on the same window.	 A
modifiers of 4mAnyModifier24m is equivalent to issuing the grab
request for all possible modifier combinations (including
the combination of no modifiers).  It is not required that
all modifiers specified have currently assigned KeyCodes.  A
button of 4mAnyButton24m is equivalent to issuing the request for
all possible buttons.  Otherwise, it is not required that
the specified button currently be assigned to a physical
button.

If some other client has already issued an 4mXGrabButton24m with
the same button/key combination on the same window, a 4mBadAc-0m
4mcess24m error results.  When using 4mAnyModifier24m or 4mAnyButton24m,
the request fails completely, and a 4mBadAccess24m error results
(no grabs are established) if there is a conflicting grab
for any combination.  4mXGrabButton24m has no effect on an active
grab.

4mXGrabButton24m can generate 4mBadCursor24m, 4mBadValue24m, and 4mBadWindow0m
errors.


To ungrab a pointer button, use 4mXUngrabButton24m.





			     1m3630m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
XUngrabButton(4mdisplay24m, 4mbutton24m, 4mmodifiers24m, 4mgrab_window24m)
      Display *4mdisplay24m;
      unsigned int 4mbutton24m;
      unsigned int 4mmodifiers24m;
      Window 4mgrab_window24m;


4mdisplay24m   Specifies the connection to the X server.

4mbutton24m    Specifies the pointer button that is to be
	  released or 4mAnyButton24m.

4mmodifiers24m Specifies the set of keymasks or 4mAnyModifier24m.  The
	  mask is the bitwise inclusive OR of the valid key-
	  mask bits.

4mgrab_window0m
	  Specifies the grab window.
|__

The 4mXUngrabButton24m function releases the passive button/key
combination on the specified window if it was grabbed by
this client.  A modifiers of 4mAnyModifier24m is equivalent to
issuing the ungrab request for all possible modifier combi-
nations, including the combination of no modifiers.  A but-
ton of 4mAnyButton24m is equivalent to issuing the request for
all possible buttons.  4mXUngrabButton24m has no effect on an
active grab.

4mXUngrabButton24m can generate 4mBadValue24m and 4mBadWindow24m errors.

1m12.2.	 Keyboard Grabbing0m

Xlib provides functions that you can use to grab or ungrab
the keyboard as well as allow events.

For many functions in this section, you pass keymask bits.
The valid keymask bits are: 4mShiftMask24m, 4mLockMask24m, 4mControl-0m
4mMask24m, 4mMod1Mask24m, 4mMod2Mask24m, 4mMod3Mask24m, 4mMod4Mask24m, and 4mMod5Mask24m.


To grab the keyboard, use 4mXGrabKeyboard24m.














			     1m3640m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
int XGrabKeyboard(4mdisplay24m, 4mgrab_window24m, 4mowner_events24m, 4mpointer_mode24m, 4mkeyboard_mode24m, 4mtime24m)
      Display *4mdisplay24m;
      Window 4mgrab_window24m;
      Bool 4mowner_events24m;
      int 4mpointer_mode24m, 4mkeyboard_mode24m;
      Time 4mtime24m;


4mdisplay24m   Specifies the connection to the X server.

4mgrab_window0m
	  Specifies the grab window.

4mowner_events0m
	  Specifies a Boolean value that indicates whether
	  the keyboard events are to be reported as usual.

4mpointer_mode0m
	  Specifies further processing of pointer events.
	  You can pass 4mGrabModeSync24m or 4mGrabModeAsync24m.

4mkeyboard_mode0m
	  Specifies further processing of keyboard events.
	  You can pass 4mGrabModeSync24m or 4mGrabModeAsync24m.

4mtime24m      Specifies the time.  You can pass either a time-
	  stamp or 4mCurrentTime24m.
|__

The 4mXGrabKeyboard24m function actively grabs control of the
keyboard and generates 4mFocusIn24m and 4mFocusOut24m events.  Further
key events are reported only to the grabbing client.
4mXGrabKeyboard24m overrides any active keyboard grab by this
client.	 If owner_events is 4mFalse24m, all generated key events
are reported with respect to grab_window.  If owner_events
is 4mTrue24m and if a generated key event would normally be
reported to this client, it is reported normally; otherwise,
the event is reported with respect to the grab_window.	Both
4mKeyPress24m and 4mKeyRelease24m events are always reported, indepen-
dent of any event selection made by the client.

If the keyboard_mode argument is 4mGrabModeAsync24m, keyboard
event processing continues as usual.  If the keyboard is
currently frozen by this client, then processing of keyboard
events is resumed.  If the keyboard_mode  argument is 4mGrab-0m
4mModeSync24m, the state of the keyboard (as seen by client
applications) appears to freeze, and the X server generates
no further keyboard events until the grabbing client issues
a releasing 4mXAllowEvents24m call or until the keyboard grab is
released.  Actual keyboard changes are not lost while the
keyboard is frozen; they are simply queued in the server for
later processing.




			     1m3650m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


If pointer_mode is 4mGrabModeAsync24m, pointer event processing
is unaffected by activation of the grab.  If pointer_mode is
4mGrabModeSync24m, the state of the pointer (as seen by client
applications) appears to freeze, and the X server generates
no further pointer events until the grabbing client issues a
releasing 4mXAllowEvents24m call or until the keyboard grab is
released.  Actual pointer changes are not lost while the
pointer is frozen; they are simply queued in the server for
later processing.

If the keyboard is actively grabbed by some other client,
4mXGrabKeyboard24m fails and returns 4mAlreadyGrabbed24m.  If
grab_window is not viewable, it fails and returns 4mGrab-0m
4mNotViewable24m.  If the keyboard is frozen by an active grab of
another client, it fails and returns 4mGrabFrozen24m.  If the
specified time is earlier than the last-keyboard-grab time
or later than the current X server time, it fails and
returns 4mGrabInvalidTime24m.  Otherwise, the last-keyboard-grab
time is set to the specified time (4mCurrentTime24m is replaced
by the current X server time).

4mXGrabKeyboard24m can generate 4mBadValue24m and 4mBadWindow24m errors.


To ungrab the keyboard, use 4mXUngrabKeyboard24m.
__
|
XUngrabKeyboard(4mdisplay24m, 4mtime24m)
      Display *4mdisplay24m;
      Time 4mtime24m;


4mdisplay24m   Specifies the connection to the X server.

4mtime24m      Specifies the time.  You can pass either a time-
	  stamp or 4mCurrentTime24m.
|__

The 4mXUngrabKeyboard24m function releases the keyboard and any
queued events if this client has it actively grabbed from
either 4mXGrabKeyboard24m or 4mXGrabKey24m.  4mXUngrabKeyboard24m does not
release the keyboard and any queued events if the specified
time is earlier than the last-keyboard-grab time or is later
than the current X server time.	 It also generates 4mFocusIn0m
and 4mFocusOut24m events.  The X server automatically performs an
4mUngrabKeyboard24m request if the event window for an active
keyboard grab becomes not viewable.


To passively grab a single key of the keyboard, use
4mXGrabKey24m.






			     1m3660m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
XGrabKey(4mdisplay24m, 4mkeycode24m, 4mmodifiers24m, 4mgrab_window24m, 4mowner_events24m, 4mpointer_mode24m,
	     4mkeyboard_mode24m)
      Display *4mdisplay24m;
      int 4mkeycode24m;
      unsigned int 4mmodifiers24m;
      Window 4mgrab_window24m;
      Bool 4mowner_events24m;
      int 4mpointer_mode24m, 4mkeyboard_mode24m;


4mdisplay24m   Specifies the connection to the X server.

4mkeycode24m   Specifies the KeyCode or 4mAnyKey24m.

4mmodifiers24m Specifies the set of keymasks or 4mAnyModifier24m.  The
	  mask is the bitwise inclusive OR of the valid key-
	  mask bits.

4mgrab_window0m
	  Specifies the grab window.

4mowner_events0m
	  Specifies a Boolean value that indicates whether
	  the keyboard events are to be reported as usual.

4mpointer_mode0m
	  Specifies further processing of pointer events.
	  You can pass 4mGrabModeSync24m or 4mGrabModeAsync24m.

4mkeyboard_mode0m
	  Specifies further processing of keyboard events.
	  You can pass 4mGrabModeSync24m or 4mGrabModeAsync24m.
|__

The 4mXGrabKey24m function establishes a passive grab on the key-
board.	In the future, the keyboard is actively grabbed (as
for 4mXGrabKeyboard24m), the last-keyboard-grab time is set to
the time at which the key was pressed (as transmitted in the
4mKeyPress24m event), and the 4mKeyPress24m event is reported if all
of the following conditions are true:

·    The keyboard is not grabbed and the specified key
     (which can itself be a modifier key) is logically
     pressed when the specified modifier keys are logically
     down, and no other modifier keys are logically down.

·    Either the grab_window is an ancestor of (or is) the
     focus window, or the grab_window is a descendant of the
     focus window and contains the pointer.

·    A passive grab on the same key combination does not
     exist on any ancestor of grab_window.




			     1m3670m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


The interpretation of the remaining arguments is as for
4mXGrabKeyboard24m.  The active grab is terminated automatically
when the logical state of the keyboard has the specified key
released (independent of the logical state of the modifier
keys).

Note that the logical state of a device (as seen by client
applications) may lag the physical state if device event
processing is frozen.

A modifiers argument of 4mAnyModifier24m is equivalent to issuing
the request for all possible modifier combinations (includ-
ing the combination of no modifiers).  It is not required
that all modifiers specified have currently assigned Key-
Codes.	A keycode argument of 4mAnyKey24m is equivalent to issu-
ing the request for all possible KeyCodes.  Otherwise, the
specified keycode must be in the range specified by min_key-
code and max_keycode in the connection setup, or a 4mBadValue0m
error results.

If some other client has issued a 4mXGrabKey24m with the same key
combination on the same window, a 4mBadAccess24m error results.
When using 4mAnyModifier24m or 4mAnyKey24m, the request fails com-
pletely, and a 4mBadAccess24m error results (no grabs are estab-
lished) if there is a conflicting grab for any combination.

4mXGrabKey24m can generate 4mBadAccess24m, 4mBadValue24m, and 4mBadWindow0m
errors.


To ungrab a key, use 4mXUngrabKey24m.
__
|
XUngrabKey(4mdisplay24m, 4mkeycode24m, 4mmodifiers24m, 4mgrab_window24m)
      Display *4mdisplay24m;
      int 4mkeycode24m;
      unsigned int 4mmodifiers24m;
      Window 4mgrab_window24m;


4mdisplay24m   Specifies the connection to the X server.

4mkeycode24m   Specifies the KeyCode or 4mAnyKey24m.

4mmodifiers24m Specifies the set of keymasks or 4mAnyModifier24m.  The
	  mask is the bitwise inclusive OR of the valid key-
	  mask bits.

4mgrab_window0m
	  Specifies the grab window.
|__

The 4mXUngrabKey24m function releases the key combination on the
specified window if it was grabbed by this client.  It has



			     1m3680m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


no effect on an active grab.  A modifiers of 4mAnyModifier24m is
equivalent to issuing the request for all possible modifier
combinations (including the combination of no modifiers).  A
keycode argument of 4mAnyKey24m is equivalent to issuing the
request for all possible key codes.

4mXUngrabKey24m can generate 4mBadValue24m and 4mBadWindow24m errors.

1m12.3.	 Resuming Event Processing0m

The previous sections discussed grab mechanisms with which
processing of events by the server can be temporarily sus-
pended.	 This section describes the mechanism for resuming
event processing.


To allow further events to be processed when the device has
been frozen, use 4mXAllowEvents24m.
__
|
XAllowEvents(4mdisplay24m, 4mevent_mode24m, 4mtime24m)
      Display *4mdisplay24m;
      int 4mevent_mode24m;
      Time 4mtime24m;


4mdisplay24m   Specifies the connection to the X server.

4mevent_mode0m
	  Specifies the event mode.  You can pass 4mAsync-0m
	  4mPointer24m, 4mSyncPointer24m, 4mAsyncKeyboard24m, 4mSyncKeyboard24m,
	  4mReplayPointer24m, 4mReplayKeyboard24m, 4mAsyncBoth24m, or
	  4mSyncBoth24m.

4mtime24m      Specifies the time.  You can pass either a time-
	  stamp or 4mCurrentTime24m.
|__

The 4mXAllowEvents24m function releases some queued events if the
client has caused a device to freeze.  It has no effect if
the specified time is earlier than the last-grab time of the
most recent active grab for the client or if the specified
time is later than the current X server time.  Depending on
the event_mode argument, the following occurs:

4mAsyncPointer24m   If the pointer is frozen by the client,
	       pointer event processing continues as usual.
	       If the pointer is frozen twice by the client
	       on behalf of two separate grabs, 4mAsyncPointer0m
	       thaws for both.	4mAsyncPointer24m has no effect
	       if the pointer is not frozen by the client,
	       but the pointer need not be grabbed by the
	       client.




			     1m3690m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


4mSyncPointer24m    If the pointer is frozen and actively grabbed
	       by the client, pointer event processing con-
	       tinues as usual until the next 4mButtonPress24m or
	       4mButtonRelease24m event is reported to the
	       client.	At this time, the pointer again
	       appears to freeze.  However, if the reported
	       event causes the pointer grab to be released,
	       the pointer does not freeze.  4mSyncPointer24m has
	       no effect if the pointer is not frozen by the
	       client or if the pointer is not grabbed by
	       the client.
4mReplay-24m	    If the pointer is actively grabbed by the
4mPointer24m	    client and is frozen as the result of an
	       event having been sent to the client (either
	       from the activation of an 4mXGrabButton24m or from
	       a previous 4mXAllowEvents24m with mode 4mSyncPointer0m
	       but not from an 4mXGrabPointer24m), the pointer
	       grab is released and that event is completely
	       reprocessed.  This time, however, the func-
	       tion ignores any passive grabs at or above
	       (toward the root of) the grab_window of the
	       grab just released.  The request has no
	       effect if the pointer is not grabbed by the
	       client or if the pointer is not frozen as the
	       result of an event.
4mAsyncKey-24m	    If the keyboard is frozen by the client, key-
4mboard24m	    board event processing continues as usual.
	       If the keyboard is frozen twice by the client
	       on behalf of two separate grabs, 4mAsyncKey-0m
	       4mboard24m thaws for both.  4mAsyncKeyboard24m has no
	       effect if the keyboard is not frozen by the
	       client, but the keyboard need not be grabbed
	       by the client.
4mSyncKeyboard24m   If the keyboard is frozen and actively
	       grabbed by the client, keyboard event pro-
	       cessing continues as usual until the next
	       4mKeyPress24m or 4mKeyRelease24m event is reported to
	       the client.  At this time, the keyboard again
	       appears to freeze.  However, if the reported
	       event causes the keyboard grab to be
	       released, the keyboard does not freeze.
	       4mSyncKeyboard24m has no effect if the keyboard is
	       not frozen by the client or if the keyboard
	       is not grabbed by the client.













			     1m3700m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


4mReplayKey-24m	    If the keyboard is actively grabbed by the
4mboard24m	    client and is frozen as the result of an
	       event having been sent to the client (either
	       from the activation of an 4mXGrabKey24m or from a
	       previous 4mXAllowEvents24m with mode 4mSyncKeyboard0m
	       but not from an 4mXGrabKeyboard24m), the keyboard
	       grab is released and that event is completely
	       reprocessed.  This time, however, the func-
	       tion ignores any passive grabs at or above
	       (toward the root of) the grab_window of the
	       grab just released.  The request has no
	       effect if the keyboard is not grabbed by the
	       client or if the keyboard is not frozen as
	       the result of an event.
4mSyncBoth24m	    If both pointer and keyboard are frozen by
	       the client, event processing for both devices
	       continues as usual until the next 4mButton-0m
	       4mPress24m, 4mButtonRelease24m, 4mKeyPress24m, or 4mKeyRelease0m
	       event is reported to the client for a grabbed
	       device (button event for the pointer, key
	       event for the keyboard), at which time the
	       devices again appear to freeze.	However, if
	       the reported event causes the grab to be
	       released, then the devices do not freeze (but
	       if the other device is still grabbed, then a
	       subsequent event for it will still cause both
	       devices to freeze).  4mSyncBoth24m has no effect
	       unless both pointer and keyboard are frozen
	       by the client.  If the pointer or keyboard is
	       frozen twice by the client on behalf of two
	       separate grabs, 4mSyncBoth24m thaws for both (but
	       a subsequent freeze for 4mSyncBoth24m will only
	       freeze each device once).
4mAsyncBoth24m	    If the pointer and the keyboard are frozen by
	       the client, event processing for both devices
	       continues as usual.  If a device is frozen
	       twice by the client on behalf of two separate
	       grabs, 4mAsyncBoth24m thaws for both.  4mAsyncBoth0m
	       has no effect unless both pointer and key-
	       board are frozen by the client.


4mAsyncPointer24m, 4mSyncPointer24m, and 4mReplayPointer24m have no effect
on the processing of keyboard events.  4mAsyncKeyboard24m, 4mSyncK-0m
4meyboard24m, and 4mReplayKeyboard24m have no effect on the processing
of pointer events.  It is possible for both a pointer grab
and a keyboard grab (by the same or different clients) to be
active simultaneously.	If a device is frozen on behalf of
either grab, no event processing is performed for the
device.	 It is possible for a single device to be frozen
because of both grabs.	In this case, the freeze must be
released on behalf of both grabs before events can again be
processed.  If a device is frozen twice by a single client,
then a single 4mAllowEvents24m releases both.



			     1m3710m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


4mXAllowEvents24m can generate a 4mBadValue24m error.

1m12.4.	 Moving the Pointer0m

Although movement of the pointer normally should be left to
the control of the end user, sometimes it is necessary to
move the pointer to a new position under program control.


To move the pointer to an arbitrary point in a window, use
4mXWarpPointer24m.
__
|
XWarpPointer(4mdisplay24m, 4msrc_w24m, 4mdest_w24m, 4msrc_x24m, 4msrc_y24m, 4msrc_width24m, 4msrc_height24m, 4mdest_x24m,
		4mdest_y24m)
	Display *4mdisplay24m;
	Window 4msrc_w24m, 4mdest_w24m;
	int 4msrc_x24m, 4msrc_y24m;
	unsigned int 4msrc_width24m, 4msrc_height24m;
	int 4mdest_x24m, 4mdest_y24m;


4mdisplay24m   Specifies the connection to the X server.

4msrc_w24m     Specifies the source window or 4mNone24m.

4mdest_w24m    Specifies the destination window or 4mNone24m.

4msrc_x0m
4msrc_y0m
4msrc_width0m
4msrc_height0m
	  Specify a rectangle in the source window.

4mdest_x0m
4mdest_y24m    Specify the x and y coordinates within the desti-
	  nation window.
|__

If dest_w is 4mNone24m, 4mXWarpPointer24m moves the pointer by the
offsets (dest_x, dest_y) relative to the current position of
the pointer.  If dest_w is a window, 4mXWarpPointer24m moves the
pointer to the offsets (dest_x, dest_y) relative to the ori-
gin of dest_w.	However, if src_w is a window, the move only
takes place if the window src_w contains the pointer and if
the specified rectangle of src_w contains the pointer.

The src_x and src_y coordinates are relative to the origin
of src_w.  If src_height is zero, it is replaced with the
current height of src_w minus src_y.  If src_width is zero,
it is replaced with the current width of src_w minus src_x.

There is seldom any reason for calling this function.  The
pointer should normally be left to the user.  If you do use



			     1m3720m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


this function, however, it generates events just as if the
user had instantaneously moved the pointer from one position
to another.  Note that you cannot use 4mXWarpPointer24m to move
the pointer outside the confine_to window of an active
pointer grab.  An attempt to do so will only move the
pointer as far as the closest edge of the confine_to window.

4mXWarpPointer24m can generate a 4mBadWindow24m error.

1m12.5.	 Controlling Input Focus0m

Xlib provides functions that you can use to set and get the
input focus.  The input focus is a shared resource, and
cooperation among clients is required for correct interac-
tion.  See the 4mInter-Client24m 4mCommunication24m 4mConventions24m 4mManual0m
for input focus policy.


To set the input focus, use 4mXSetInputFocus24m.
__
|
XSetInputFocus(4mdisplay24m, 4mfocus24m, 4mrevert_to24m, 4mtime24m)
      Display *4mdisplay24m;
      Window 4mfocus24m;
      int 4mrevert_to24m;
      Time 4mtime24m;


4mdisplay24m   Specifies the connection to the X server.

4mfocus24m     Specifies the window, 4mPointerRoot24m, or 4mNone24m.

4mrevert_to24m Specifies where the input focus reverts to if the
	  window becomes not viewable.	You can pass 4mRevert-0m
	  4mToParent24m, 4mRevertToPointerRoot24m, or 4mRevertToNone24m.

4mtime24m      Specifies the time.  You can pass either a time-
	  stamp or 4mCurrentTime24m.
|__

The 4mXSetInputFocus24m function changes the input focus and the
last-focus-change time.	 It has no effect if the specified
time is earlier than the current last-focus-change time or
is later than the current X server time.  Otherwise, the
last-focus-change time is set to the specified time (4mCur-0m
4mrentTime24m is replaced by the current X server time).  4mXSet-0m
4mInputFocus24m causes the X server to generate 4mFocusIn24m and 4mFocu-0m
4msOut24m events.

Depending on the focus argument, the following occurs:

·    If focus is 4mNone24m, all keyboard events are discarded
     until a new focus window is set, and the revert_to
     argument is ignored.



			     1m3730m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


·    If focus is a window, it becomes the keyboard's focus
     window.  If a generated keyboard event would normally
     be reported to this window or one of its inferiors, the
     event is reported as usual.  Otherwise, the event is
     reported relative to the focus window.

·    If focus is 4mPointerRoot24m, the focus window is dynami-
     cally taken to be the root window of whatever screen
     the pointer is on at each keyboard event.	In this
     case, the revert_to argument is ignored.

The specified focus window must be viewable at the time
4mXSetInputFocus24m is called, or a 4mBadMatch24m error results.  If
the focus window later becomes not viewable, the X server
evaluates the revert_to argument to determine the new focus
window as follows:

·    If revert_to is 4mRevertToParent24m, the focus reverts to
     the parent (or the closest viewable ancestor), and the
     new revert_to value is taken to be 4mRevertToNone24m.

·    If revert_to is 4mRevertToPointerRoot24m or 4mRevertToNone24m,
     the focus reverts to 4mPointerRoot24m or 4mNone24m, respectively.
     When the focus reverts, the X server generates 4mFocusIn0m
     and 4mFocusOut24m events, but the last-focus-change time is
     not affected.

4mXSetInputFocus24m can generate 4mBadMatch24m, 4mBadValue24m, and 4mBadWin-0m
4mdow24m errors.


To obtain the current input focus, use 4mXGetInputFocus24m.
__
|
XGetInputFocus(4mdisplay24m, 4mfocus_return24m, 4mrevert_to_return24m)
      Display *4mdisplay24m;
      Window *4mfocus_return24m;
      int *4mrevert_to_return24m;


4mdisplay24m   Specifies the connection to the X server.

4mfocus_return0m
	  Returns the focus window, 4mPointerRoot24m, or 4mNone24m.

4mrevert_to_return0m
	  Returns the current focus state (4mRevertToParent24m,
	  4mRevertToPointerRoot24m, or 4mRevertToNone24m).
|__

The 4mXGetInputFocus24m function returns the focus window and the
current focus state.





			     1m3740m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


1m12.6.	 Manipulating the Keyboard and Pointer Settings0m

Xlib provides functions that you can use to change the key-
board control, obtain a list of the auto-repeat keys, turn
keyboard auto-repeat on or off, ring the bell, set or obtain
the pointer button or keyboard mapping, and obtain a bit
vector for the keyboard.

This section discusses the user-preference options of bell,
key click, pointer behavior, and so on.	 The default values
for many of these options are server dependent.	 Not all
implementations will actually be able to control all of
these parameters.

The 4mXChangeKeyboardControl24m function changes control of a
keyboard and operates on a 4mXKeyboardControl24m structure:
__
|
/* Mask bits for ChangeKeyboardControl */

#define	  4mKBKeyClickPercent24m	   (1L<<0)
#define	  4mKBBellPercent24m		   (1L<<1)
#define	  4mKBBellPitch24m		   (1L<<2)
#define	  4mKBBellDuration24m		   (1L<<3)
#define	  4mKBLed24m			   (1L<<4)
#define	  4mKBLedMode24m		   (1L<<5)
#define	  4mKBKey24m			   (1L<<6)
#define	  4mKBAutoRepeatMode24m		   (1L<<7)


/* Values */

typedef struct {
     int key_click_percent;
     int bell_percent;
     int bell_pitch;
     int bell_duration;
     int led;
     int led_mode;	 /* LedModeOn, LedModeOff */
     int key;
     int auto_repeat_mode;/* AutoRepeatModeOff, AutoRepeatModeOn,
			    AutoRepeatModeDefault */
} XKeyboardControl;

|__

The key_click_percent member sets the volume for key clicks
between 0 (off) and 100 (loud) inclusive, if possible.	A
setting of -1 restores the default.  Other negative values
generate a 4mBadValue24m error.

The bell_percent sets the base volume for the bell between 0
(off) and 100 (loud) inclusive, if possible.  A setting of
-1 restores the default.  Other negative values generate a



			     1m3750m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


4mBadValue24m error.  The bell_pitch member sets the pitch (spec-
ified in Hz) of the bell, if possible.	A setting of -1
restores the default.  Other negative values generate a 4mBad-0m
4mValue24m error.  The bell_duration member sets the duration of
the bell specified in milliseconds, if possible.  A setting
of -1 restores the default.  Other negative values generate
a 4mBadValue24m error.

If both the led_mode and led members are specified, the
state of that LED is changed, if possible.  The led_mode
member can be set to 4mLedModeOn24m or 4mLedModeOff24m.	 If only
led_mode is specified, the state of all LEDs are changed, if
possible.  At most 32 LEDs numbered from one are supported.
No standard interpretation of LEDs is defined.	If led is
specified without led_mode, a 4mBadMatch24m error results.

If both the auto_repeat_mode and key members are specified,
the auto_repeat_mode of that key is changed (according to
4mAutoRepeatModeOn24m, 4mAutoRepeatModeOff24m, or 4mAutoRepeatModeDe-0m
4mfault24m), if possible.  If only auto_repeat_mode is specified,
the global auto_repeat_mode for the entire keyboard is
changed, if possible, and does not affect the per-key set-
tings.	If a key is specified without an auto_repeat_mode, a
4mBadMatch24m error results.  Each key has an individual mode of
whether or not it should auto-repeat and a default setting
for the mode.  In addition, there is a global mode of
whether auto-repeat should be enabled or not and a default
setting for that mode.	When global mode is 4mAutoRepeatMod-0m
4meOn24m, keys should obey their individual auto-repeat modes.
When global mode is 4mAutoRepeatModeOff24m, no keys should auto-
repeat.	 An auto-repeating key generates alternating 4mKey-0m
4mPress24m and 4mKeyRelease24m events.	When a key is used as a modi-
fier, it is desirable for the key not to auto-repeat,
regardless of its auto-repeat setting.

A bell generator connected with the console but not directly
on a keyboard is treated as if it were part of the keyboard.
The order in which controls are verified and altered is
server-dependent.  If an error is generated, a subset of the
controls may have been altered.

















			     1m3760m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
XChangeKeyboardControl(4mdisplay24m, 4mvalue_mask24m, 4mvalues24m)
      Display *4mdisplay24m;
      unsigned long 4mvalue_mask24m;
      XKeyboardControl *4mvalues24m;


4mdisplay24m   Specifies the connection to the X server.

4mvalue_mask0m
	  Specifies which controls to change.  This mask is
	  the bitwise inclusive OR of the valid control mask
	  bits.

4mvalues24m    Specifies one value for each bit set to 1 in the
	  mask.
|__

The 4mXChangeKeyboardControl24m function controls the keyboard
characteristics defined by the 4mXKeyboardControl24m structure.
The value_mask argument specifies which values are to be
changed.

4mXChangeKeyboardControl24m can generate 4mBadMatch24m and 4mBadValue0m
errors.


To obtain the current control values for the keyboard, use
4mXGetKeyboardControl24m.
__
|
XGetKeyboardControl(4mdisplay24m, 4mvalues_return24m)
      Display *4mdisplay24m;
      XKeyboardState *4mvalues_return24m;


4mdisplay24m   Specifies the connection to the X server.

4mvalues_return0m
	  Returns the current keyboard controls in the spec-
	  ified 4mXKeyboardState24m structure.
|__

The 4mXGetKeyboardControl24m function returns the current control
values for the keyboard to the 4mXKeyboardState24m structure.












			     1m3770m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
typedef struct {
     int key_click_percent;
     int bell_percent;
     unsigned int bell_pitch, bell_duration;
     unsigned long led_mask;
     int global_auto_repeat;
     char auto_repeats[32];
} XKeyboardState;

|__

For the LEDs, the least significant bit of led_mask corre-
sponds to LED one, and each bit set to 1 in led_mask indi-
cates an LED that is lit.  The global_auto_repeat member can
be set to 4mAutoRepeatModeOn24m or 4mAutoRepeatModeOff24m.  The
auto_repeats member is a bit vector.  Each bit set to 1
indicates that auto-repeat is enabled for the corresponding
key.  The vector is represented as 32 bytes.  Byte N (from
0) contains the bits for keys 8N to 8N + 7 with the least
significant bit in the byte representing key 8N.


To turn on keyboard auto-repeat, use 4mXAutoRepeatOn24m.
__
|
XAutoRepeatOn(4mdisplay24m)
      Display *4mdisplay24m;


4mdisplay24m   Specifies the connection to the X server.
|__

The 4mXAutoRepeatOn24m function turns on auto-repeat for the key-
board on the specified display.


To turn off keyboard auto-repeat, use 4mXAutoRepeatOff24m.
__
|
XAutoRepeatOff(4mdisplay24m)
      Display *4mdisplay24m;


4mdisplay24m   Specifies the connection to the X server.
|__

The 4mXAutoRepeatOff24m function turns off auto-repeat for the
keyboard on the specified display.


To ring the bell, use 4mXBell24m.





			     1m3780m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
XBell(4mdisplay24m, 4mpercent24m)
      Display *4mdisplay24m;
      int 4mpercent24m;


4mdisplay24m   Specifies the connection to the X server.

4mpercent24m   Specifies the volume for the bell, which can range
	  from -100 to 100 inclusive.
|__

The 4mXBell24m function rings the bell on the keyboard on the
specified display, if possible.	 The specified volume is
relative to the base volume for the keyboard.  If the value
for the percent argument is not in the range -100 to 100
inclusive, a 4mBadValue24m error results.  The volume at which
the bell rings when the percent argument is nonnegative is:

     base - [(base * percent) / 100] + percent

The volume at which the bell rings when the percent argument
is negative is:

     base + [(base * percent) / 100]

To change the base volume of the bell, use 4mXChangeKeyboard-0m
4mControl24m.

4mXBell24m can generate a 4mBadValue24m error.


To obtain a bit vector that describes the state of the key-
board, use 4mXQueryKeymap24m.
__
|
XQueryKeymap(4mdisplay24m, 4mkeys_return24m)
      Display *4mdisplay24m;
      char 4mkeys_return24m[32];


4mdisplay24m   Specifies the connection to the X server.

4mkeys_return0m
	  Returns an array of bytes that identifies which
	  keys are pressed down.  Each bit represents one
	  key of the keyboard.
|__

The 4mXQueryKeymap24m function returns a bit vector for the logi-
cal state of the keyboard, where each bit set to 1 indicates
that the corresponding key is currently pressed down.  The
vector is represented as 32 bytes.  Byte N (from 0) contains
the bits for keys 8N to 8N + 7 with the least significant



			     1m3790m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


bit in the byte representing key 8N.

Note that the logical state of a device (as seen by client
applications) may lag the physical state if device event
processing is frozen.


To set the mapping of the pointer buttons, use 4mXSetPoint-0m
4merMapping24m.
__
|
int XSetPointerMapping(4mdisplay24m, 4mmap24m, 4mnmap24m)
      Display *4mdisplay24m;
      unsigned char 4mmap24m[];
      int 4mnmap24m;


4mdisplay24m   Specifies the connection to the X server.

4mmap24m       Specifies the mapping list.

4mnmap24m      Specifies the number of items in the mapping list.
|__

The 4mXSetPointerMapping24m function sets the mapping of the
pointer.  If it succeeds, the X server generates a 4mMapping-0m
4mNotify24m event, and 4mXSetPointerMapping24m returns 4mMappingSuccess24m.
Element map[i] defines the logical button number for the
physical button i+1.  The length of the list must be the
same as 4mXGetPointerMapping24m would return, or a 4mBadValue24m error
results.  A zero element disables a button, and elements are
not restricted in value by the number of physical buttons.
However, no two elements can have the same nonzero value, or
a 4mBadValue24m error results.	If any of the buttons to be
altered are logically in the down state, 4mXSetPointerMapping0m
returns 4mMappingBusy24m, and the mapping is not changed.

4mXSetPointerMapping24m can generate a 4mBadValue24m error.


To get the pointer mapping, use 4mXGetPointerMapping24m.
















			     1m3800m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
int XGetPointerMapping(4mdisplay24m, 4mmap_return24m, 4mnmap24m)
      Display *4mdisplay24m;
      unsigned char 4mmap_return24m[];
      int 4mnmap24m;


4mdisplay24m   Specifies the connection to the X server.

4mmap_return0m
	  Returns the mapping list.

4mnmap24m      Specifies the number of items in the mapping list.
|__

The 4mXGetPointerMapping24m function returns the current mapping
of the pointer.	 Pointer buttons are numbered starting from
one.  4mXGetPointerMapping24m returns the number of physical but-
tons actually on the pointer.  The nominal mapping for a
pointer is map[i]=i+1.	The nmap argument specifies the
length of the array where the pointer mapping is returned,
and only the first nmap elements are returned in map_return.


To control the pointer's interactive feel, use 4mXChangePoint-0m
4merControl24m.































			     1m3810m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
XChangePointerControl(4mdisplay24m, 4mdo_accel24m, 4mdo_threshold24m, 4maccel_numerator24m,
			4maccel_denominator24m, 4mthreshold24m)
      Display *4mdisplay24m;
      Bool 4mdo_accel24m, 4mdo_threshold24m;
      int 4maccel_numerator24m, 4maccel_denominator24m;
      int 4mthreshold24m;


4mdisplay24m   Specifies the connection to the X server.

4mdo_accel24m  Specifies a Boolean value that controls whether
	  the values for the accel_numerator or accel_denom-
	  inator are used.

4mdo_threshold0m
	  Specifies a Boolean value that controls whether
	  the value for the threshold is used.

4maccel_numerator0m
	  Specifies the numerator for the acceleration mul-
	  tiplier.

4maccel_denominator0m
	  Specifies the denominator for the acceleration
	  multiplier.

4mthreshold24m Specifies the acceleration threshold.
|__

The 4mXChangePointerControl24m function defines how the pointing
device moves.  The acceleration, expressed as a fraction, is
a multiplier for movement.  For example, specifying 3/1
means the pointer moves three times as fast as normal.	The
fraction may be rounded arbitrarily by the X server.  Accel-
eration only takes effect if the pointer moves more than
threshold pixels at once and only applies to the amount
beyond the value in the threshold argument.  Setting a value
to -1 restores the default.  The values of the do_accel and
do_threshold arguments must be 4mTrue24m for the pointer values
to be set, or the parameters are unchanged.  Negative values
(other than -1) generate a 4mBadValue24m error, as does a zero
value for the accel_denominator argument.

4mXChangePointerControl24m can generate a 4mBadValue24m error.


To get the current pointer parameters, use 4mXGetPointerCon-0m
4mtrol24m.








			     1m3820m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
XGetPointerControl(4mdisplay24m, 4maccel_numerator_return24m, 4maccel_denominator_return24m,
		       4mthreshold_return24m)
      Display *4mdisplay24m;
      int *4maccel_numerator_return24m, *4maccel_denominator_return24m;
      int *4mthreshold_return24m;


4mdisplay24m   Specifies the connection to the X server.

4maccel_numerator_return0m
	  Returns the numerator for the acceleration multi-
	  plier.

4maccel_denominator_return0m
	  Returns the denominator for the acceleration mul-
	  tiplier.

4mthreshold_return0m
	  Returns the acceleration threshold.
|__

The 4mXGetPointerControl24m function returns the pointer's cur-
rent acceleration multiplier and acceleration threshold.

1m12.7.	 Manipulating the Keyboard Encoding0m

A KeyCode represents a physical (or logical) key.  KeyCodes
lie in the inclusive range [8,255].  A KeyCode value carries
no intrinsic information, although server implementors may
attempt to encode geometry (for example, matrix) information
in some fashion so that it can be interpreted in a server-
dependent fashion.  The mapping between keys and KeyCodes
cannot be changed.

A KeySym is an encoding of a symbol on the cap of a key.
The set of defined KeySyms includes the ISO Latin character
sets (1-4), Katakana, Arabic, Cyrillic, Greek, Technical,
Special, Publishing, APL, Hebrew, Thai, Korean and a miscel-
lany of keys found on keyboards (Return, Help, Tab, and so
on).  To the extent possible, these sets are derived from
international standards.  In areas where no standards exist,
some of these sets are derived from Digital Equipment Corpo-
ration standards.  The list of defined symbols can be found
in <4mX11/keysymdef.h24m>.  Unfortunately, some C preprocessors
have limits on the number of defined symbols.  If you must
use KeySyms not in the Latin 1-4, Greek, and miscellaneous
classes, you may have to define a symbol for those sets.
Most applications usually only include <4mX11/keysym.h24m>, which
defines symbols for ISO Latin 1-4, Greek, and miscellaneous.

A list of KeySyms is associated with each KeyCode.  The list
is intended to convey the set of symbols on the correspond-
ing key.  If the list (ignoring trailing 4mNoSymbol24m entries)



			     1m3830m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


is a single KeySym ``4mK24m'', then the list is treated as if it
were the list ``4mK24m NoSymbol 4mK24m NoSymbol''.  If the list
(ignoring trailing 4mNoSymbol24m entries) is a pair of KeySyms
``4mK124m 4mK224m'', then the list is treated as if it were the list
``4mK124m 4mK224m 4mK124m 4mK224m''.  If the list (ignoring trailing 4mNoSymbol0m
entries) is a triple of KeySyms ``4mK124m 4mK224m 4mK324m'', then the list
is treated as if it were the list ``4mK124m 4mK224m 4mK324m NoSymbol''.
When an explicit ``void'' element is desired in the list,
the value 4mVoidSymbol24m can be used.

The first four elements of the list are split into two
groups of KeySyms.  Group 1 contains the first and second
KeySyms; Group 2 contains the third and fourth KeySyms.
Within each group, if the second element of the group is
4mNoSymbol24m, then the group should be treated as if the second
element were the same as the first element, except when the
first element is an alphabetic KeySym ``4mK24m'' for which both
lowercase and uppercase forms are defined.  In that case,
the group should be treated as if the first element were the
lowercase form of ``4mK24m'' and the second element were the
uppercase form of ``4mK24m''.

The standard rules for obtaining a KeySym from a 4mKeyPress0m
event make use of only the Group 1 and Group 2 KeySyms; no
interpretation of other KeySyms in the list is given.  Which
group to use is determined by the modifier state.  Switching
between groups is controlled by the KeySym named MODE
SWITCH, by attaching that KeySym to some KeyCode and attach-
ing that KeyCode to any one of the modifiers 4mMod124m through
4mMod524m.  This modifier is called the 4mgroup24m 4mmodifier24m.  For any
KeyCode, Group 1 is used when the group modifier is off, and
Group 2 is used when the group modifier is on.

The 4mLock24m modifier is interpreted as CapsLock when the KeySym
named XK_Caps_Lock is attached to some KeyCode and that Key-
Code is attached to the 4mLock24m modifier.  The 4mLock24m modifier is
interpreted as ShiftLock when the KeySym named XK_Shift_Lock
is attached to some KeyCode and that KeyCode is attached to
the 4mLock24m modifier.	 If the 4mLock24m modifier could be inter-
preted as both CapsLock and ShiftLock, the CapsLock inter-
pretation is used.

The operation of keypad keys is controlled by the KeySym
named XK_Num_Lock, by attaching that KeySym to some KeyCode
and attaching that KeyCode to any one of the modifiers 4mMod10m
through 4mMod524m.  This modifier is called the 4mnumlock24m 4mmodifier24m.
The standard KeySyms with the prefix ``XK_KP_'' in their
name are called keypad KeySyms; these are KeySyms with
numeric value in the hexadecimal range 0xFF80 to 0xFFBD
inclusive.  In addition, vendor-specific KeySyms in the
hexadecimal range 0x11000000 to 0x1100FFFF are also keypad
KeySyms.





			     1m3840m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


Within a group, the choice of KeySym is determined by apply-
ing the first rule that is satisfied from the following
list:

·    The numlock modifier is on and the second KeySym is a
     keypad KeySym.  In this case, if the 4mShift24m modifier is
     on, or if the 4mLock24m modifier is on and is interpreted as
     ShiftLock, then the first KeySym is used, otherwise the
     second KeySym is used.

·    The 4mShift24m and 4mLock24m modifiers are both off.  In this
     case, the first KeySym is used.

·    The 4mShift24m modifier is off, and the 4mLock24m modifier is on
     and is interpreted as CapsLock.  In this case, the
     first KeySym is used, but if that KeySym is lowercase
     alphabetic, then the corresponding uppercase KeySym is
     used instead.

·    The 4mShift24m modifier is on, and the 4mLock24m modifier is on
     and is interpreted as CapsLock.  In this case, the sec-
     ond KeySym is used, but if that KeySym is lowercase
     alphabetic, then the corresponding uppercase KeySym is
     used instead.

·    The 4mShift24m modifier is on, or the 4mLock24m modifier is on
     and is interpreted as ShiftLock, or both.	In this
     case, the second KeySym is used.

No spatial geometry of the symbols on the key is defined by
their order in the KeySym list, although a geometry might be
defined on a server-specific basis.  The X server does not
use the mapping between KeyCodes and KeySyms.  Rather, it
merely stores it for reading and writing by clients.


To obtain the legal KeyCodes for a display, use 4mXDisplayKey-0m
4mcodes24m.



















			     1m3850m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
XDisplayKeycodes(4mdisplay24m, 4mmin_keycodes_return24m, 4mmax_keycodes_return24m)
	Display *4mdisplay24m;
	int *4mmin_keycodes_return24m, *4mmax_keycodes_return24m;


4mdisplay24m   Specifies the connection to the X server.

4mmin_keycodes_return0m
	  Returns the minimum number of KeyCodes.

4mmax_keycodes_return0m
	  Returns the maximum number of KeyCodes.
|__

The 4mXDisplayKeycodes24m function returns the min-keycodes and
max-keycodes supported by the specified display.  The mini-
mum number of KeyCodes returned is never less than 8, and
the maximum number of KeyCodes returned is never greater
than 255.  Not all KeyCodes in this range are required to
have corresponding keys.


To obtain the symbols for the specified KeyCodes, use
4mXGetKeyboardMapping24m.
__
|
KeySym *XGetKeyboardMapping(4mdisplay24m, 4mfirst_keycode24m, 4mkeycode_count24m,
			    4mkeysyms_per_keycode_return24m)
      Display *4mdisplay24m;
      KeyCode 4mfirst_keycode24m;
      int 4mkeycode_count24m;
      int *4mkeysyms_per_keycode_return24m;


4mdisplay24m   Specifies the connection to the X server.

4mfirst_keycode0m
	  Specifies the first KeyCode that is to be
	  returned.

4mkeycode_count0m
	  Specifies the number of KeyCodes that are to be
	  returned.

4mkeysyms_per_keycode_return0m
	  Returns the number of KeySyms per KeyCode.
|__

The 4mXGetKeyboardMapping24m function returns the symbols for the
specified number of KeyCodes starting with first_keycode.
The value specified in first_keycode must be greater than or
equal to min_keycode as returned by 4mXDisplayKeycodes24m, or a
4mBadValue24m error results.  In addition, the following



			     1m3860m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


expression must be less than or equal to max_keycode as
returned by 4mXDisplayKeycodes24m:


     first_keycode + keycode_count - 1


If this is not the case, a 4mBadValue24m error results.	 The num-
ber of elements in the KeySyms list is:


     keycode_count * keysyms_per_keycode_return


KeySym number N, counting from zero, for KeyCode K has the
following index in the list, counting from zero:

     (K - first_code) * keysyms_per_code_return + N


The X server arbitrarily chooses the keysyms_per_key-
code_return value to be large enough to report all requested
symbols.  A special KeySym value of 4mNoSymbol24m is used to fill
in unused elements for individual KeyCodes.  To free the
storage returned by 4mXGetKeyboardMapping24m, use 4mXFree24m.

4mXGetKeyboardMapping24m can generate a 4mBadValue24m error.


To change the keyboard mapping, use 4mXChangeKeyboardMapping24m.



























			     1m3870m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
XChangeKeyboardMapping(4mdisplay24m, 4mfirst_keycode24m, 4mkeysyms_per_keycode24m, 4mkeysyms24m, 4mnum_codes24m)
      Display *4mdisplay24m;
      int 4mfirst_keycode24m;
      int 4mkeysyms_per_keycode24m;
      KeySym *4mkeysyms24m;
      int 4mnum_codes24m;


4mdisplay24m   Specifies the connection to the X server.

4mfirst_keycode0m
	  Specifies the first KeyCode that is to be changed.

4mkeysyms_per_keycode0m
	  Specifies the number of KeySyms per KeyCode.

4mkeysyms24m   Specifies an array of KeySyms.

4mnum_codes24m Specifies the number of KeyCodes that are to be
	  changed.
|__

The 4mXChangeKeyboardMapping24m function defines the symbols for
the specified number of KeyCodes starting with first_key-
code.  The symbols for KeyCodes outside this range remain
unchanged.  The number of elements in keysyms must be:


     num_codes * keysyms_per_keycode


The specified first_keycode must be greater than or equal to
min_keycode returned by 4mXDisplayKeycodes24m, or a 4mBadValue0m
error results.	In addition, the following expression must
be less than or equal to max_keycode as returned by 4mXDis-0m
4mplayKeycodes24m, or a 4mBadValue24m error results:


     first_keycode + num_codes - 1


KeySym number N, counting from zero, for KeyCode K has the
following index in keysyms, counting from zero:


     (K - first_keycode) * keysyms_per_keycode + N


The specified keysyms_per_keycode can be chosen arbitrarily
by the client to be large enough to hold all desired sym-
bols.  A special KeySym value of 4mNoSymbol24m should be used to
fill in unused elements for individual KeyCodes.  It is
legal for 4mNoSymbol24m to appear in nontrailing positions of the



			     1m3880m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


effective list for a KeyCode.  4mXChangeKeyboardMapping24m gener-
ates a 4mMappingNotify24m event.

There is no requirement that the X server interpret this
mapping.  It is merely stored for reading and writing by
clients.

4mXChangeKeyboardMapping24m can generate 4mBadAlloc24m and 4mBadValue0m
errors.

The next six functions make use of the 4mXModifierKeymap24m data
structure, which contains:

__
|
typedef struct {
     int max_keypermod;	 /* This server's max number of keys per modifier */
     KeyCode *modifiermap;/* An 8 by max_keypermod array of the modifiers */
} XModifierKeymap;

|__

To create an 4mXModifierKeymap24m structure, use 4mXNewModifiermap24m.
__
|
XModifierKeymap *XNewModifiermap(4mmax_keys_per_mod24m)
	int 4mmax_keys_per_mod24m;


4mmax_keys_per_mod0m
	  Specifies the number of KeyCode entries preallo-
	  cated to the modifiers in the map.
|__

The 4mXNewModifiermap24m function returns a pointer to 4mXModi-0m
4mfierKeymap24m structure for later use.


To add a new entry to an 4mXModifierKeymap24m structure, use 4mXIn-0m
4msertModifiermapEntry24m.

















			     1m3890m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
XModifierKeymap *XInsertModifiermapEntry(4mmodmap24m, 4mkeycode_entry24m, 4mmodifier24m)
     XModifierKeymap *4mmodmap24m;
     KeyCode 4mkeycode_entry24m;
     int 4mmodifier24m;


4mmodmap24m    Specifies the 4mXModifierKeymap24m structure.

4mkeycode_entry0m
	  Specifies the KeyCode.

4mmodifier24m  Specifies the modifier.
|__

The 4mXInsertModifiermapEntry24m function adds the specified Key-
Code to the set that controls the specified modifier and
returns the resulting 4mXModifierKeymap24m structure (expanded as
needed).


To delete an entry from an 4mXModifierKeymap24m structure, use
4mXDeleteModifiermapEntry24m.
__
|
XModifierKeymap *XDeleteModifiermapEntry(4mmodmap24m, 4mkeycode_entry24m, 4mmodifier24m)
     XModifierKeymap *4mmodmap24m;
     KeyCode 4mkeycode_entry24m;
     int 4mmodifier24m;


4mmodmap24m    Specifies the 4mXModifierKeymap24m structure.

4mkeycode_entry0m
	  Specifies the KeyCode.

4mmodifier24m  Specifies the modifier.
|__

The 4mXDeleteModifiermapEntry24m function deletes the specified
KeyCode from the set that controls the specified modifier
and returns a pointer to the resulting 4mXModifierKeymap0m
structure.


To destroy an 4mXModifierKeymap24m structure, use 4mXFreeModi-0m
4mfiermap24m.










			     1m3900m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
XFreeModifiermap(4mmodmap24m)
	XModifierKeymap *4mmodmap24m;


4mmodmap24m    Specifies the 4mXModifierKeymap24m structure.
|__

The 4mXFreeModifiermap24m function frees the specified 4mXModi-0m
4mfierKeymap24m structure.


To set the KeyCodes to be used as modifiers, use 4mXSetModi-0m
4mfierMapping24m.
__
|
int XSetModifierMapping(4mdisplay24m, 4mmodmap24m)
	Display *4mdisplay24m;
	XModifierKeymap *4mmodmap24m;


4mdisplay24m   Specifies the connection to the X server.

4mmodmap24m    Specifies the 4mXModifierKeymap24m structure.
|__

The 4mXSetModifierMapping24m function specifies the KeyCodes of
the keys (if any) that are to be used as modifiers.  If it
succeeds, the X server generates a 4mMappingNotify24m event, and
4mXSetModifierMapping24m returns 4mMappingSuccess24m.  X permits at
most 8 modifier keys.  If more than 8 are specified in the
4mXModifierKeymap24m structure, a 4mBadLength24m error results.

The modifiermap member of the 4mXModifierKeymap24m structure con-
tains 8 sets of max_keypermod KeyCodes, one for each modi-
fier in the order 4mShift24m, 4mLock24m, 4mControl24m, 4mMod124m, 4mMod224m, 4mMod324m,
4mMod424m, and 4mMod524m.  Only nonzero KeyCodes have meaning in each
set, and zero KeyCodes are ignored.  In addition, all of the
nonzero KeyCodes must be in the range specified by min_key-
code and max_keycode in the 4mDisplay24m structure, or a 4mBadValue0m
error results.

An X server can impose restrictions on how modifiers can be
changed, for example, if certain keys do not generate up
transitions in hardware, if auto-repeat cannot be disabled
on certain keys, or if multiple modifier keys are not sup-
ported.	 If some such restriction is violated, the status
reply is 4mMappingFailed24m, and none of the modifiers are
changed.  If the new KeyCodes specified for a modifier dif-
fer from those currently defined and any (current or new)
keys for that modifier are in the logically down state,
4mXSetModifierMapping24m returns 4mMappingBusy24m, and none of the
modifiers is changed.




			     1m3910m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


4mXSetModifierMapping24m can generate 4mBadAlloc24m and 4mBadValue0m
errors.


To obtain the KeyCodes used as modifiers, use 4mXGetModi-0m
4mfierMapping24m.
__
|
XModifierKeymap *XGetModifierMapping(4mdisplay24m)
      Display *4mdisplay24m;



4mdisplay24m   Specifies the connection to the X server.
|__

The 4mXGetModifierMapping24m function returns a pointer to a
newly created 4mXModifierKeymap24m structure that contains the
keys being used as modifiers.  The structure should be freed
after use by calling 4mXFreeModifiermap24m.  If only zero values
appear in the set for any modifier, that modifier is dis-
abled.



































			     1m3920m





1mXlib - C Library			X11, Release 6.7 DRAFT0m




			 1mChapter 130m

	1mLocales and Internationalized Text Functions0m



An internationalized application is one that is adaptable to
the requirements of different native languages, local cus-
toms, and character string encodings.  The process of adapt-
ing the operation to a particular native language, local
custom, or string encoding is called 4mlocalization24m.	 A goal
of internationalization is to permit localization without
program source modifications or recompilation.

As one of the localization mechanisms, Xlib provides an X
Input Method (4mXIM24m) functional interface for international-
ized text input and an X Output Method (4mXOM24m) functional
interface for internationalized text output.

Internationalization in X is based on the concept of a
4mlocale24m.  A locale defines the localized behavior of a pro-
gram at run time.  Locales affect Xlib in its:

·    Encoding and processing of input method text

·    Encoding of resource files and values

·    Encoding and imaging of text strings

·    Encoding and decoding for inter-client text communica-
     tion

Characters from various languages are represented in a com-
puter using an encoding.  Different languages have different
encodings, and there are even different encodings for the
same characters in the same language.

This chapter defines support for localized text imaging and
text input and describes the locale mechanism that controls
all locale-dependent Xlib functions.  Sets of functions are
provided for multibyte (char *) text as well as wide charac-
ter (wchar_t) text in the form supported by the host C lan-
guage environment.  The multibyte and wide character func-
tions are equivalent except for the form of the text argu-
ment.

The Xlib internationalization functions are not meant to
provide support for multilingual applications (mixing multi-
ple languages within a single piece of text), but they make
it possible to implement applications that work in limited
fashion with more than one language in independent contexts.




			     1m3930m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


The remainder of this chapter discusses:

·    X locale management

·    Locale and modifier dependencies

·    Variable argument lists

·    Output methods

·    Input methods

·    String constants

1m13.1.	 X Locale Management0m

X supports one or more of the locales defined by the host
environment.  On implementations that conform to the ANSI C
library, the locale announcement method is 4msetlocale24m.  This
function configures the locale operation of both the host C
library and Xlib.  The operation of Xlib is governed by the
LC_CTYPE category; this is called the 4mcurrent24m 4mlocale24m.	 An
implementation is permitted to provide implementation-depen-
dent mechanisms for announcing the locale in addition to
4msetlocale24m.

On implementations that do not conform to the ANSI C
library, the locale announcement method is Xlib implementa-
tion-dependent.

The mechanism by which the semantic operation of Xlib is
defined for a specific locale is implementation-dependent.


X is not required to support all the locales supported by
the host.  To determine if the current locale is supported
by X, use 4mXSupportsLocale24m.
__
|
Bool XSupportsLocale()

|__

The 4mXSupportsLocale24m function returns 4mTrue24m if Xlib functions
are capable of operating under the current locale.  If it
returns 4mFalse24m, Xlib locale-dependent functions for which the
4mXLocaleNotSupported24m return status is defined will return
4mXLocaleNotSupported24m.  Other Xlib locale-dependent routines
will operate in the ``C'' locale.

The client is responsible for selecting its locale and X
modifiers.  Clients should provide a means for the user to
override the clients' locale selection at client invocation.
Most single-display X clients operate in a single locale for



			     1m3940m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


both X and the host processing environment.  They will con-
figure the locale by calling three functions: the host
locale configuration function, 4mXSupportsLocale24m, and 4mXSetLo-0m
4mcaleModifiers24m.

The semantics of certain categories of X internationaliza-
tion capabilities can be configured by setting modifiers.
Modifiers are named by implementation-dependent and locale-
specific strings.  The only standard use for this capability
at present is selecting one of several styles of keyboard
input method.


To configure Xlib locale modifiers for the current locale,
use 4mXSetLocaleModifiers24m.
__
|
char *XSetLocaleModifiers(4mmodifier_list24m)
      char *4mmodifier_list24m;


4mmodifier_list0m
	  Specifies the modifiers.
|__

The 4mXSetLocaleModifiers24m function sets the X modifiers for
the current locale setting.  The modifier_list argument is a
null-terminated string of the form ``{@4mcategory24m=4mvalue24m}'',
that is, having zero or more concatenated ``@4mcate-0m
4mgory24m=4mvalue24m'' entries, where 4mcategory24m is a category name and
4mvalue24m is the (possibly empty) setting for that category.
The values are encoded in the current locale.  Category
names are restricted to the POSIX Portable Filename Charac-
ter Set.

The local host X locale modifiers announcer (on POSIX-com-
pliant systems, the XMODIFIERS environment variable) is
appended to the modifier_list to provide default values on
the local host.	 If a given category appears more than once
in the list, the first setting in the list is used.  If a
given category is not included in the full modifier list,
the category is set to an implementation-dependent default
for the current locale.	 An empty value for a category
explicitly specifies the implementation-dependent default.

If the function is successful, it returns a pointer to a
string.	 The contents of the string are such that a subse-
quent call with that string (in the same locale) will
restore the modifiers to the same settings.  If modi-
fier_list is a NULL pointer, 4mXSetLocaleModifiers24m also
returns a pointer to such a string, and the current locale
modifiers are not changed.





			     1m3950m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


If invalid values are given for one or more modifier cate-
gories supported by the locale, a NULL pointer is returned,
and none of the current modifiers are changed.

At program startup, the modifiers that are in effect are
unspecified until the first successful call to set them.
Whenever the locale is changed, the modifiers that are in
effect become unspecified until the next successful call to
set them.  Clients should always call 4mXSetLocaleModifiers0m
with a non-NULL modifier_list after setting the locale
before they call any locale-dependent Xlib routine.

The only standard modifier category currently defined is
``im'', which identifies the desired input method.  The val-
ues for input method are not standardized.  A single locale
may use multiple input methods, switching input method under
user control.  The modifier may specify the initial input
method in effect or an ordered list of input methods.  Mul-
tiple input methods may be specified in a single im value
string in an implementation-dependent manner.

The returned modifiers string is owned by Xlib and should
not be modified or freed by the client.	 It may be freed by
Xlib after the current locale or modifiers are changed.
Until freed, it will not be modified by Xlib.

The recommended procedure for clients initializing their
locale and modifiers is to obtain locale and modifier
announcers separately from one of the following prioritized
sources:

·    A command line option

·    A resource

·    The empty string ("")

The first of these that is defined should be used.  Note
that when a locale command line option or locale resource is
defined, the effect should be to set all categories to the
specified locale, overriding any category-specific settings
in the local host environment.

1m13.2.	 Locale and Modifier Dependencies0m

The internationalized Xlib functions operate in the current
locale configured by the host environment and X locale modi-
fiers set by 4mXSetLocaleModifiers24m or in the locale and modi-
fiers configured at the time some object supplied to the
function was created.  For each locale-dependent function,
the following table describes the locale (and modifiers)
dependency:





			     1m3960m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


--------------------------------------------------------------------------
1mLocale from	 Affects the Function		In0m
--------------------------------------------------------------------------
	       Locale Query/Configuration:
4msetlocale24m	    4mXSupportsLocale24m		Locale queried
	       4mXSetLocaleModifiers24m		   Locale modified

	       Resources:
4msetlocale24m	    4mXrmGetFileDatabase24m		Locale of 4mXrmDatabase0m
	       4mXrmGetStringDatabase0m
4mXrmDatabase24m    4mXrmPutFileDatabase24m		Locale of 4mXrmDatabase0m
	       4mXrmLocaleOfDatabase0m

	       Setting Standard Properties:
4msetlocale24m	    4mXmbSetWMProperties24m		Encoding of sup-
					      plied/returned
					      text (some WM_ property
					      text in environment locale)
	       4mXutf8SetWMProperties0m
4msetlocale24m	    4mXmbTextPropertyToTextList24m	Encoding of sup-
					      plied/returned text
	       4mXwcTextPropertyToTextList0m
	       4mXutf8TextPropertyToTextList0m
	       4mXmbTextListToTextProperty0m
	       4mXwcTextListToTextProperty0m
	       4mXutf8TextListToTextProperty0m

	       Text Input:
4msetlocale24m	    4mXOpenIM24m			XIM input method selection
	       4mXRegisterIMInstantiateCall-24m	   XIM selection
	       4mback0m
	       4mXUnregisterIMInstantiate-24m	   XIM selection
	       4mCallback0m
4mXIM24m	    4mXCreateIC24m			XIC input method configura-
					      tion
	       4mXLocaleOfIM24m, and so on	   Queried locale
4mXIC24m	    4mXmbLookupString24m		Keyboard layout
	       4mXwcLookupString24m		   Encoding of returned text
	       4mXutf8LookupString0m

	       Text Drawing:
4msetlocale24m	    4mXOpenOM24m			XOM output method selection
	       4mXCreateFontSet24m		   Charsets of fonts in
					      4mXFontSet0m
4mXOM24m	    4mXCreateOC24m			XOC output method configu-
					      ration
	       4mXLocaleOfOM24m, and so on	   Queried locale
4mXFontSet24m	    4mXmbDrawText24m,			Locale of supplied text
	       4mXwcDrawText24m, and so on	   Locale of supplied text
	       4mXutf8DrawText24m, and so on	   Locale-dependent metrics
	       4mXExtentsOfFontSet24m, and so on   Locale-dependent metrics
	       4mXmbTextExtents24m,
	       4mXwcTextExtents24m,




			     1m3970m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


--------------------------------------------------------------------------
1mLocale from	 Affects the Function		In0m
--------------------------------------------------------------------------
	       4mXutf8TextExtents24m, and so on

	       Xlib Errors:
4msetlocale24m	    4mXGetErrorDatabaseText24m		Locale of error message
	       4mXGetErrorText0m
--------------------------------------------------------------------------


Clients may assume that a locale-encoded text string
returned by an X function can be passed to a C library rou-
tine, or vice versa, if the locale is the same at the two
calls.

All text strings processed by internationalized Xlib func-
tions are assumed to begin in the initial state of the
encoding of the locale, if the encoding is state-dependent.

All Xlib functions behave as if they do not change the cur-
rent locale or X modifier setting.  (This means that if they
do change locale or call 4mXSetLocaleModifiers24m with a non-NULL
argument, they must save and restore the current state on
entry and exit.)  Also, Xlib functions on implementations
that conform to the ANSI C library do not alter the global
state associated with the ANSI C functions 4mmblen24m, 4mmbtowc24m,
4mwctomb24m, and 4mstrtok24m.

1m13.3.	 Variable Argument Lists0m

Various functions in this chapter have arguments that con-
form to the ANSI C variable argument list calling conven-
tion.  Each function denoted with an argument of the form
``...'' takes a variable-length list of name and value
pairs, where each name is a string and each value is of type
4mXPointer24m.	A name argument that is NULL identifies the end
of the list.

A variable-length argument list may contain a nested list.
If the name 4mXNVaNestedList24m is specified in place of an argu-
ment name, then the following value is interpreted as an
4mXVaNestedList24m value that specifies a list of values logi-
cally inserted into the original list at the point of decla-
ration.	 A NULL identifies the end of a nested list.


To allocate a nested variable argument list dynamically, use
4mXVaCreateNestedList24m.








			     1m3980m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
typedef void * XVaNestedList;

XVaNestedList XVaCreateNestedList(4mdummy24m, ...)
      int 4mdummy24m;


4mdummy24m     Specifies an unused argument (required by ANSI C).

...	  Specifies the variable length argument list.
|__

The 4mXVaCreateNestedList24m function allocates memory and copies
its arguments into a single list pointer, which may be used
as a value for arguments requiring a list value.  Any
entries are copied as specified.  Data passed by reference
is not copied; the caller must ensure data remains valid for
the lifetime of the nested list.  The list should be freed
using 4mXFree24m when it is no longer needed.

1m13.4.	 Output Methods0m

This section provides discussions of the following X Output
Method (XOM) topics:

·    Output method overview

·    Output method functions

·    Output method values

·    Output context functions

·    Output context values

·    Creating and freeing a font set

·    Obtaining font set metrics

·    Drawing text using font sets

1m13.4.1.  Output Method Overview0m

Locale-dependent text may include one or more text compo-
nents, each of which may require different fonts and charac-
ter set encodings.  In some languages, each component might
have a different drawing direction, and some components
might contain context-dependent characters that change shape
based on relationships with neighboring characters.

When drawing such locale-dependent text, some locale-spe-
cific knowledge is required; for example, what fonts are
required to draw the text, how the text can be separated
into components, and which fonts are selected to draw each



			     1m3990m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


component.  Further, when bidirectional text must be drawn,
the internal representation order of the text must be
changed into the visual representation order to be drawn.

An X Output Method provides a functional interface so that
clients do not have to deal directly with such locale-depen-
dent details.  Output methods provide the following capabil-
ities:

·    Creating a set of fonts required to draw locale-depen-
     dent text.

·    Drawing locale-dependent text with a font set without
     the caller needing to be aware of locale dependencies.

·    Obtaining the escapement and extents in pixels of
     locale-dependent text.

·    Determining if bidirectional or context-dependent draw-
     ing is required in a specific locale with a specific
     font set.

Two different abstractions are used in the representation of
the output method for clients.

The abstraction used to communicate with an output method is
an opaque data structure represented by the 4mXOM24m data type.
The abstraction for representing the state of a particular
output thread is called an 4moutput24m 4mcontext24m.  The Xlib repre-
sentation of an output context is an 4mXOC24m, which is compati-
ble with 4mXFontSet24m in terms of its functional interface, but
is a broader, more generalized abstraction.

1m13.4.2.  Output Method Functions0m

To open an output method, use 4mXOpenOM24m.





















			     1m4000m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
XOM XOpenOM(4mdisplay24m, 4mdb24m, 4mres_name24m, 4mres_class24m)
      Display *4mdisplay24m;
      XrmDatabase 4mdb24m;
      char *4mres_name24m;
      char *4mres_class24m;


4mdisplay24m   Specifies the connection to the X server.

4mdb24m	       Specifies a pointer to the resource database.

4mres_name24m  Specifies the full resource name of the applica-
	  tion.

4mres_class24m Specifies the full class name of the application.
|__

The 4mXOpenOM24m function opens an output method matching the
current locale and modifiers specification.  The current
locale and modifiers are bound to the output method when
4mXOpenOM24m is called.	 The locale associated with an output
method cannot be changed.

The specific output method to which this call will be routed
is identified on the basis of the current locale and modi-
fiers.	4mXOpenOM24m will identify a default output method corre-
sponding to the current locale.	 That default can be modi-
fied using 4mXSetLocaleModifiers24m to set the output method mod-
ifier.

The db argument is the resource database to be used by the
output method for looking up resources that are private to
the output method.  It is not intended that this database be
used to look up values that can be set as OC values in an
output context.	 If db is NULL, no database is passed to the
output method.

The res_name and res_class arguments specify the resource
name and class of the application.  They are intended to be
used as prefixes by the output method when looking up
resources that are common to all output contexts that may be
created for this output method.	 The characters used for
resource names and classes must be in the X Portable Charac-
ter Set.  The resources looked up are not fully specified if
res_name or res_class is NULL.

The res_name and res_class arguments are not assumed to
exist beyond the call to 4mXOpenOM24m.	The specified resource
database is assumed to exist for the lifetime of the output
method.

4mXOpenOM24m returns NULL if no output method could be opened.




			     1m4010m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


To close an output method, use 4mXCloseOM24m.
__
|
Status XCloseOM(4mom24m)
      XOM 4mom24m;


4mom24m	       Specifies the output method.
|__

The 4mXCloseOM24m function closes the specified output method.


To set output method attributes, use 4mXSetOMValues24m.
__
|
char * XSetOMValues(4mom24m, ...)
      XOM 4mom24m;


4mom24m	       Specifies the output method.

...	  Specifies the variable-length argument list to set
	  XOM values.
|__

The 4mXSetOMValues24m function presents a variable argument list
programming interface for setting properties or features of
the specified output method.  This function returns NULL if
it succeeds; otherwise, it returns the name of the first
argument that could not be set.	 Xlib does not attempt to
set arguments from the supplied list that follow the failed
argument; all arguments in the list preceding the failed
argument have been set correctly.

No standard arguments are currently defined by Xlib.


To query an output method, use 4mXGetOMValues24m.
__
|
char * XGetOMValues(4mom24m, ...)
      XOM 4mom24m;


4mom24m	       Specifies the output method.

...	  Specifies the variable-length argument list to get
	  XOM values.
|__

The 4mXGetOMValues24m function presents a variable argument list
programming interface for querying properties or features of
the specified output method.  This function returns NULL if



			     1m4020m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


it succeeds; otherwise, it returns the name of the first
argument that could not be obtained.

To obtain the display associated with an output method, use
4mXDisplayOfOM24m.
__
|
Display * XDisplayOfOM(4mom24m)
     XOM 4mom24m;


4mom24m	       Specifies the output method.
|__

The 4mXDisplayOfOM24m function returns the display associated
with the specified output method.


To get the locale associated with an output method, use 4mXLo-0m
4mcaleOfOM24m.
__
|
char * XLocaleOfOM(4mom24m)
      XOM 4mom24m;


4mom24m	       Specifies the output method.
|__

The 4mXLocaleOfOM24m returns the locale associated with the spec-
ified output method.

1m13.4.3.  X Output Method Values0m

The following table describes how XOM values are interpreted
by an output method.  The first column lists the XOM values.
The second column indicates how each of the XOM values are
treated by a particular output style.


The following key applies to this table.

-------------------------------------------------------------
1mKey	       Explanation0m
-------------------------------------------------------------
G	     This value may be read using 4mXGetOMValues24m.
-------------------------------------------------------------










			     1m4030m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


-----------------------------
1mXOM Value		   Key0m
-----------------------------
4mXNRequiredCharSet24m	       G
4mXNQueryOrientation24m	       G
4mXNDirectionalDepen-24m       G
4mdentDrawing0m
4mXNContextualDrawing24m       G
-----------------------------



1m13.4.3.1.  Required Char Set0m

The 4mXNRequiredCharSet24m argument returns the list of charsets
that are required for loading the fonts needed for the
locale.	 The value of the argument is a pointer to a struc-
ture of type 4mXOMCharSetList24m.

The 4mXOMCharSetList24m structure is defined as follows:
__
|

typedef struct {
     int charset_count;
     char **charset_list;
} XOMCharSetList;

|__

The charset_list member is a list of one or more null-termi-
nated charset names, and the charset_count member is the
number of charset names.

The required charset list is owned by Xlib and should not be
modified or freed by the client.  It will be freed by a call
to 4mXCloseOM24m with the associated 4mXOM24m.	Until freed, its con-
tents will not be modified by Xlib.


1m13.4.3.2.  Query Orientation0m

The 4mXNQueryOrientation24m argument returns the global orienta-
tion of text when drawn.  Other than 4mXOMOrientation_LTR_TTB24m,
the set of orientations supported is locale-dependent.	The
value of the argument is a pointer to a structure of type
4mXOMOrientation24m.  Clients are responsible for freeing the
4mXOMOrientation24m structure by using 4mXFree24m; this also frees the
contents of the structure.








			     1m4040m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
typedef struct {
     int num_orientation;
     XOrientation *orientation;/* Input Text description */
} XOMOrientation;

typedef enum {
     XOMOrientation_LTR_TTB,
     XOMOrientation_RTL_TTB,
     XOMOrientation_TTB_LTR,
     XOMOrientation_TTB_RTL,
     XOMOrientation_Context
} XOrientation;

|__

The possible value for XOrientation may be:

·    4mXOMOrientation_LTR_TTB24m left-to-right, top-to-bottom
     global orientation

·    4mXOMOrientation_RTL_TTB24m right-to-left, top-to-bottom
     global orientation

·    4mXOMOrientation_TTB_LTR24m top-to-bottom, left-to-right
     global orientation

·    4mXOMOrientation_TTB_RTL24m top-to-bottom, right-to-left
     global orientation

·    4mXOMOrientation_Context24m contextual global orientation


1m13.4.3.3.  Directional Dependent Drawing0m

The 4mXNDirectionalDependentDrawing24m argument indicates whether
the text rendering functions implement implicit handling of
directional text.  If this value is 4mTrue24m, the output method
has knowledge of directional dependencies and reorders text
as necessary when rendering text.  If this value is 4mFalse24m,
the output method does not implement any directional text
handling, and all character directions are assumed to be
left-to-right.

Regardless of the rendering order of characters, the origins
of all characters are on the primary draw direction side of
the drawing origin.

This OM value presents functionality identical to the 4mXDi-0m
4mrectionalDependentDrawing24m function.







			     1m4050m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


1m13.4.3.4.  Context Dependent Drawing0m

The 4mXNContextualDrawing24m argument indicates whether the text
rendering functions implement implicit context-dependent
drawing.  If this value is 4mTrue24m, the output method has
knowledge of context dependencies and performs character
shape editing, combining glyphs to present a single charac-
ter as necessary.  The actual shape editing is dependent on
the locale implementation and the font set used.

This OM value presents functionality identical to the 4mXCon-0m
4mtextualDrawing24m function.

1m13.4.4.  Output Context Functions0m

An output context is an abstraction that contains both the
data required by an output method and the information
required to display that data.	There can be multiple output
contexts for one output method.	 The programming interfaces
for creating, reading, or modifying an output context use a
variable argument list.	 The name elements of the argument
lists are referred to as XOC values.  It is intended that
output methods be controlled by these XOC values.  As new
XOC values are created, they should be registered with the X
Consortium.  An 4mXOC24m can be used anywhere an 4mXFontSet24m can be
used, and vice versa; 4mXFontSet24m is retained for compatibility
with previous releases.	 The concepts of output methods and
output contexts include broader, more generalized abstrac-
tion than font set, supporting complex and more intelligent
text display, and dealing not only with multiple fonts but
also with context dependencies.	 However, 4mXFontSet24m is widely
used in several interfaces, so 4mXOC24m is defined as an upward
compatible type of 4mXFontSet24m.


To create an output context, use 4mXCreateOC24m.
__
|
XOC XCreateOC(4mom24m, ...)
      XOM 4mom24m;


4mom24m	       Specifies the output method.

...	  Specifies the variable-length argument list to set
	  XOC values.
|__

The 4mXCreateOC24m function creates an output context within the
specified output method.

The base font names argument is mandatory at creation time,
and the output context will not be created unless it is pro-
vided.	All other output context values can be set later.



			     1m4060m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


4mXCreateOC24m returns NULL if no output context could be cre-
ated.  NULL can be returned for any of the following rea-
sons:

·    A required argument was not set.

·    A read-only argument was set.

·    An argument name is not recognized.

·    The output method encountered an output method imple-
     mentation-dependent error.

4mXCreateOC24m can generate a 4mBadAtom24m error.


To destroy an output context, use 4mXDestroyOC24m.
__
|
void XDestroyOC(4moc24m)
      XOC 4moc24m;


4moc24m	       Specifies the output context.
|__

The 4mXDestroyOC24m function destroys the specified output con-
text.


To get the output method associated with an output context,
use 4mXOMOfOC24m.
__
|
XOM XOMOfOC(4moc24m)
      XOC 4moc24m;


4moc24m	       Specifies the output context.
|__

The 4mXOMOfOC24m function returns the output method associated
with the specified output context.


Xlib provides two functions for setting and reading output
context values, respectively, 4mXSetOCValues24m and 4mXGetOCValues24m.
Both functions have a variable-length argument list.  In
that argument list, any XOC value's name must be denoted
with a character string using the X Portable Character Set.


To set XOC values, use 4mXSetOCValues24m.




			     1m4070m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
char * XSetOCValues(4moc24m, ...)
      XOC 4moc24m;


4moc24m	       Specifies the output context.

...	  Specifies the variable-length argument list to set
	  XOC values.
|__

The 4mXSetOCValues24m function returns NULL if no error occurred;
otherwise, it returns the name of the first argument that
could not be set.  An argument might not be set for any of
the following reasons:

·    The argument is read-only.

·    The argument name is not recognized.

·    An implementation-dependent error occurs.

Each value to be set must be an appropriate datum, matching
the data type imposed by the semantics of the argument.

4mXSetOCValues24m can generate a 4mBadAtom24m error.


To obtain XOC values, use 4mXGetOCValues24m.
__
|
char * XGetOCValues(4moc24m, ...)
      XOC 4moc24m;


4moc24m	       Specifies the output context.

...	  Specifies the variable-length argument list to get
	  XOC values.
|__

The 4mXGetOCValues24m function returns NULL if no error occurred;
otherwise, it returns the name of the first argument that
could not be obtained.	An argument might not be obtained
for any of the following reasons:

·    The argument name is not recognized.

·    An implementation-dependent error occurs.

Each argument value following a name must point to a loca-
tion where the value is to be stored.





			     1m4080m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


1m13.4.5.  Output Context Values0m

The following table describes how XOC values are interpreted
by an output method.  The first column lists the XOC values.
The second column indicates the alternative interfaces that
function identically and are provided for compatibility with
previous releases.  The third column indicates how each of
the XOC values is treated.

The following keys apply to this table.

-------------------------------------------------------------
1mKey	       Explanation0m
-------------------------------------------------------------
C	     This value must be set with 4mXCreateOC24m.
D	     This value may be set using 4mXCreateOC24m.  If it
	     is not set,
	     a default is provided.
G	     This value may be read using 4mXGetOCValues24m.
S	     This value must be set using 4mXSetOCValues24m.
-------------------------------------------------------------



-----------------------------------------------
1mXOC Value	   Alternative Interface    Key0m
-----------------------------------------------
BaseFontName	    4mXCreateFontSet24m	       C-G
MissingCharSet	    4mXCreateFontSet24m		G
DefaultString	    4mXCreateFontSet24m		G
Orientation		   -		 D-S-G
ResourceName		   -		  S-G
ResourceClass		   -		  S-G
FontInfo	    4mXFontsOfFontSet24m	G
OMAutomatic		   -		   G
-----------------------------------------------



1m13.4.5.1.  Base Font Name0m

The 4mXNBaseFontName24m argument is a list of base font names
that Xlib uses to load the fonts needed for the locale.	 The
base font names are a comma-separated list.  The string is
null-terminated and is assumed to be in the Host Portable
Character Encoding; otherwise, the result is implementation-
dependent.  White space immediately on either side of a sep-
arating comma is ignored.

Use of XLFD font names permits Xlib to obtain the fonts
needed for a variety of locales from a single locale-inde-
pendent base font name.	 The single base font name should
name a family of fonts whose members are encoded in the var-
ious charsets needed by the locales of interest.



			     1m4090m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


An XLFD base font name can explicitly name a charset needed
for the locale.	 This allows the user to specify an exact
font for use with a charset required by a locale, fully con-
trolling the font selection.

If a base font name is not an XLFD name, Xlib will attempt
to obtain an XLFD name from the font properties for the
font.  If Xlib is successful, the 4mXGetOCValues24m function will
return this XLFD name instead of the client-supplied name.

This argument must be set at creation time and cannot be
changed.  If no fonts exist for any of the required
charsets, or if the locale definition in Xlib requires that
a font exist for a particular charset and a font is not
found for that charset, 4mXCreateOC24m returns NULL.

When querying for the 4mXNBaseFontName24m XOC value, 4mXGetOCValues0m
returns a null-terminated string identifying the base font
names that Xlib used to load the fonts needed for the
locale.	 This string is owned by Xlib and should not be mod-
ified or freed by the client.  The string will be freed by a
call to 4mXDestroyOC24m with the associated 4mXOC24m.  Until freed,
the string contents will not be modified by Xlib.

1m13.4.5.2.  Missing CharSet0m

The 4mXNMissingCharSet24m argument returns the list of required
charsets that are missing from the font set.  The value of
the argument is a pointer to a structure of type 4mXOM-0m
4mCharSetList24m.

If fonts exist for all of the charsets required by the cur-
rent locale, charset_list is set to NULL and charset_count
is set to zero.	 If no fonts exist for one or more of the
required charsets, charset_list is set to a list of one or
more null-terminated charset names for which no fonts exist,
and charset_count is set to the number of missing charsets.
The charsets are from the list of the required charsets for
the encoding of the locale and do not include any charsets
to which Xlib may be able to remap a required charset.

The missing charset list is owned by Xlib and should not be
modified or freed by the client.  It will be freed by a call
to 4mXDestroyOC24m with the associated 4mXOC24m.  Until freed, its
contents will not be modified by Xlib.

1m13.4.5.3.  Default String0m

When a drawing or measuring function is called with an 4mXOC0m
that has missing charsets, some characters in the locale
will not be drawable.  The 4mXNDefaultString24m argument returns
a pointer to a string that represents the glyphs that are
drawn with this 4mXOC24m when the charsets of the available fonts
do not include all glyphs required to draw a character.	 The



			     1m4100m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


string does not necessarily consist of valid characters in
the current locale and is not necessarily drawn with the
fonts loaded for the font set, but the client can draw or
measure the default glyphs by including this string in a
string being drawn or measured with the 4mXOC24m.

If the 4mXNDefaultString24m argument returned the empty string
(""), no glyphs are drawn and the escapement is zero.  The
returned string is null-terminated.  It is owned by Xlib and
should not be modified or freed by the client.	It will be
freed by a call to 4mXDestroyOC24m with the associated 4mXOC24m.
Until freed, its contents will not be modified by Xlib.

1m13.4.5.4.  Orientation0m

The 4mXNOrientation24m argument specifies the current orientation
of text when drawn.  The value of this argument is one of
the values returned by the 4mXGetOMValues24m function with the
4mXNQueryOrientation24m argument specified in the 4mXOrientation0m
list.  The value of the argument is of type 4mXOrientation24m.
When 4mXNOrientation24m is queried, the value specifies the cur-
rent orientation.  When 4mXNOrientation24m is set, a value is
used to set the current orientation.

When 4mXOMOrientation_Context24m is set, the text orientation of
the text is determined according to an implementation-
defined method (for example, ISO 6429 control sequences),
and the initial text orientation for locale-dependent Xlib
functions is assumed to be 4mXOMOrientation_LTR_TTB24m.

The 4mXNOrientation24m value does not change the prime drawing
direction for Xlib drawing functions.

1m13.4.5.5.  Resource Name and Class0m

The 4mXNResourceName24m and 4mXNResourceClass24m arguments are strings
that specify the full name and class used by the client to
obtain resources for the display of the output context.
These values should be used as prefixes for name and class
when looking up resources that may vary according to the
output context.	 If these values are not set, the resources
will not be fully specified.

It is not intended that values that can be set as XOM values
be set as resources.

When querying for the 4mXNResourceName24m or 4mXNResourceClass24m XOC
value, 4mXGetOCValues24m returns a null-terminated string.  This
string is owned by Xlib and should not be modified or freed
by the client.	The string will be freed by a call to 4mXDe-0m
4mstroyOC24m with the associated 4mXOC24m or when the associated value
is changed via 4mXSetOCValues24m.  Until freed, the string con-
tents will not be modified by Xlib.




			     1m4110m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


1m13.4.5.6.  Font Info0m

The 4mXNFontInfo24m argument specifies a list of one or more
4mXFontStruct24m structures and font names for the fonts used for
drawing by the given output context.  The value of the argu-
ment is a pointer to a structure of type 4mXOMFontInfo24m.

__
|
typedef struct {
     int num_font;
     XFontStruct **font_struct_list;
     char **font_name_list;
} XOMFontInfo;

|__

A list of pointers to the 4mXFontStruct24m structures is returned
to font_struct_list.  A list of pointers to null-terminated,
fully-specified font name strings in the locale of the out-
put context is returned to font_name_list.  The
font_name_list order corresponds to the font_struct_list
order.	The number of 4mXFontStruct24m structures and font names
is returned to num_font.

Because it is not guaranteed that a given character will be
imaged using a single font glyph, there is no provision for
mapping a character or default string to the font proper-
ties, font ID, or direction hint for the font for the char-
acter.	The client may access the 4mXFontStruct24m list to obtain
these values for all the fonts currently in use.

Xlib does not guarantee that fonts are loaded from the
server at the creation of an 4mXOC24m.	Xlib may choose to cache
font data, loading it only as needed to draw text or compute
text dimensions.  Therefore, existence of the per_char met-
rics in the 4mXFontStruct24m structures in the 4mXFontStructSet24m is
undefined.  Also, note that all properties in the
4mXFontStruct24m structures are in the STRING encoding.

The client must not free the 4mXOMFontInfo24m struct itself; it
will be freed when the 4mXOC24m is closed.

1m13.4.5.7.  OM Automatic0m

The 4mXNOMAutomatic24m argument returns whether the associated
output context was created by 4mXCreateFontSet24m or not.
Because the 4mXFreeFontSet24m function not only destroys the out-
put context but also closes the implicit output method asso-
ciated with it, 4mXFreeFontSet24m should be used with any output
context created by 4mXCreateFontSet24m.	 However, it is possible
that a client does not know how the output context was cre-
ated.  Before a client destroys the output context, it can
query whether 4mXNOMAutomatic24m is set to determine whether



			     1m4120m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


4mXFreeFontSet24m or 4mXDestroyOC24m should be used to destroy the
output context.

1m13.4.6.  Creating and Freeing a Font Set0m

Xlib international text drawing is done using a set of one
or more fonts, as needed for the locale of the text.  Fonts
are loaded according to a list of base font names supplied
by the client and the charsets required by the locale.	The
4mXFontSet24m is an opaque type representing the state of a par-
ticular output thread and is equivalent to the type 4mXOC24m.


The 4mXCreateFontSet24m function is a convenience function for
creating an output context using only default values.  The
returned 4mXFontSet24m has an implicitly created 4mXOM24m.  This 4mXOM0m
has an OM value 4mXNOMAutomatic24m automatically set to 4mTrue24m so
that the output context self indicates whether it was cre-
ated by 4mXCreateOC24m or 4mXCreateFontSet24m.
__
|
XFontSet XCreateFontSet(4mdisplay24m, 4mbase_font_name_list24m, 4mmissing_charset_list_return24m,
	       4mmissing_charset_count_return24m, 4mdef_string_return24m)
      Display *4mdisplay24m;
      char *4mbase_font_name_list24m;
      char ***4mmissing_charset_list_return24m;
      int *4mmissing_charset_count_return24m;
      char **4mdef_string_return24m;


4mdisplay24m   Specifies the connection to the X server.

4mbase_font_name_list0m
	  Specifies the base font names.

4mmissing_charset_list_return0m
	  Returns the missing charsets.

4mmissing_charset_count_return0m
	  Returns the number of missing charsets.

4mdef_string_return0m
	  Returns the string drawn for missing charsets.
|__

The 4mXCreateFontSet24m function creates a font set for the spec-
ified display.	The font set is bound to the current locale
when 4mXCreateFontSet24m is called.  The font set may be used in
subsequent calls to obtain font and character information
and to image text in the locale of the font set.

The base_font_name_list argument is a list of base font
names that Xlib uses to load the fonts needed for the
locale.	 The base font names are a comma-separated list.



			     1m4130m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


The string is null-terminated and is assumed to be in the
Host Portable Character Encoding; otherwise, the result is
implementation-dependent.  White space immediately on either
side of a separating comma is ignored.

Use of XLFD font names permits Xlib to obtain the fonts
needed for a variety of locales from a single locale-inde-
pendent base font name.	 The single base font name should
name a family of fonts whose members are encoded in the var-
ious charsets needed by the locales of interest.

An XLFD base font name can explicitly name a charset needed
for the locale.	 This allows the user to specify an exact
font for use with a charset required by a locale, fully con-
trolling the font selection.

If a base font name is not an XLFD name, Xlib will attempt
to obtain an XLFD name from the font properties for the
font.  If this action is successful in obtaining an XLFD
name, the 4mXBaseFontNameListOfFontSet24m function will return
this XLFD name instead of the client-supplied name.

Xlib uses the following algorithm to select the fonts that
will be used to display text with the 4mXFontSet24m.

For each font charset required by the locale, the base font
name list is searched for the first appearance of one of the
following cases that names a set of fonts that exist at the
server:

·    The first XLFD-conforming base font name that specifies
     the required charset or a superset of the required
     charset in its 4mCharSetRegistry24m and 4mCharSetEncoding0m
     fields.  The implementation may use a base font name
     whose specified charset is a superset of the required
     charset, for example, an ISO8859-1 font for an ASCII
     charset.

·    The first set of one or more XLFD-conforming base font
     names that specify one or more charsets that can be
     remapped to support the required charset.	The Xlib
     implementation may recognize various mappings from a
     required charset to one or more other charsets and use
     the fonts for those charsets.  For example, JIS Roman
     is ASCII with tilde and backslash replaced by yen and
     overbar; Xlib may load an ISO8859-1 font to support
     this character set if a JIS Roman font is not avail-
     able.

·    The first XLFD-conforming font name or the first non-
     XLFD font name for which an XLFD font name can be
     obtained, combined with the required charset (replacing
     the 4mCharSetRegistry24m and 4mCharSetEncoding24m fields in the
     XLFD font name).  As in case 1, the implementation may



			     1m4140m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


     use a charset that is a superset of the required
     charset.

·    The first font name that can be mapped in some imple-
     mentation-dependent manner to one or more fonts that
     support imaging text in the charset.

For example, assume that a locale required the charsets:


ISO8859-1
JISX0208.1983
JISX0201.1976
GB2312-1980.0


The user could supply a base_font_name_list that explicitly
specifies the charsets, ensuring that specific fonts are
used if they exist.  For example:


"-JIS-Fixed-Medium-R-Normal--26-180-100-100-C-240-JISX0208.1983-0,\
-JIS-Fixed-Medium-R-Normal--26-180-100-100-C-120-JISX0201.1976-0,\
-GB-Fixed-Medium-R-Normal--26-180-100-100-C-240-GB2312-1980.0,\
-Adobe-Courier-Bold-R-Normal--25-180-75-75-M-150-ISO8859-1"


Alternatively, the user could supply a base_font_name_list
that omits the charsets, letting Xlib select font charsets
required for the locale.  For example:


"-JIS-Fixed-Medium-R-Normal--26-180-100-100-C-240,\
-JIS-Fixed-Medium-R-Normal--26-180-100-100-C-120,\
-GB-Fixed-Medium-R-Normal--26-180-100-100-C-240,\
-Adobe-Courier-Bold-R-Normal--25-180-100-100-M-150"


Alternatively, the user could simply supply a single base
font name that allows Xlib to select from all available
fonts that meet certain minimum XLFD property requirements.
For example:


"-*-*-*-R-Normal--*-180-100-100-*-*"


If 4mXCreateFontSet24m is unable to create the font set, either
because there is insufficient memory or because the current
locale is not supported, 4mXCreateFontSet24m returns NULL, miss-
ing_charset_list_return is set to NULL, and miss-
ing_charset_count_return is set to zero.  If fonts exist for
all of the charsets required by the current locale, 4mXCreate-0m
4mFontSet24m returns a valid 4mXFontSet24m,



			     1m4150m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


missing_charset_list_return is set to NULL, and miss-
ing_charset_count_return is set to zero.

If no font exists for one or more of the required charsets,
4mXCreateFontSet24m sets missing_charset_list_return to a list of
one or more null-terminated charset names for which no font
exists and sets missing_charset_count_return to the number
of missing fonts.  The charsets are from the list of the
required charsets for the encoding of the locale and do not
include any charsets to which Xlib may be able to remap a
required charset.

If no font exists for any of the required charsets or if the
locale definition in Xlib requires that a font exist for a
particular charset and a font is not found for that charset,
4mXCreateFontSet24m returns NULL.  Otherwise, 4mXCreateFontSet0m
returns a valid 4mXFontSet24m to font_set.

When an Xmb/wc/utf8 drawing or measuring function is called
with an 4mXFontSet24m that has missing charsets, some characters
in the locale will not be drawable.  If def_string_return is
non-NULL, 4mXCreateFontSet24m returns a pointer to a string that
represents the glyphs that are drawn with this 4mXFontSet24m when
the charsets of the available fonts do not include all font
glyphs required to draw a codepoint.  The string does not
necessarily consist of valid characters in the current
locale and is not necessarily drawn with the fonts loaded
for the font set, but the client can draw and measure the
default glyphs by including this string in a string being
drawn or measured with the 4mXFontSet24m.

If the string returned to def_string_return is the empty
string (""), no glyphs are drawn, and the escapement is
zero.  The returned string is null-terminated.	It is owned
by Xlib and should not be modified or freed by the client.
It will be freed by a call to 4mXFreeFontSet24m with the associ-
ated 4mXFontSet24m.  Until freed, its contents will not be modi-
fied by Xlib.

The client is responsible for constructing an error message
from the missing charset and default string information and
may choose to continue operation in the case that some fonts
did not exist.

The returned 4mXFontSet24m and missing charset list should be
freed with 4mXFreeFontSet24m and 4mXFreeStringList24m, respectively.
The client-supplied base_font_name_list may be freed by the
client after calling 4mXCreateFontSet24m.


To obtain a list of 4mXFontStruct24m structures and full font
names given an 4mXFontSet24m, use 4mXFontsOfFontSet24m.





			     1m4160m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
int XFontsOfFontSet(4mfont_set24m, 4mfont_struct_list_return24m, 4mfont_name_list_return24m)
       XFontSet 4mfont_set24m;
       XFontStruct ***4mfont_struct_list_return24m;
       char ***4mfont_name_list_return24m;


4mfont_set24m  Specifies the font set.

4mfont_struct_list_return0m
	  Returns the list of font structs.

4mfont_name_list_return0m
	  Returns the list of font names.
|__

The 4mXFontsOfFontSet24m function returns a list of one or more
4mXFontStructs24m and font names for the fonts used by the
Xmb/wc/utf8 layer for the given font set.  A list of point-
ers to the 4mXFontStruct24m structures is returned to
font_struct_list_return.  A list of pointers to null-termi-
nated, fully specified font name strings in the locale of
the font set is returned to font_name_list_return.  The
font_name_list order corresponds to the font_struct_list
order.	The number of 4mXFontStruct24m structures and font names
is returned as the value of the function.

Because it is not guaranteed that a given character will be
imaged using a single font glyph, there is no provision for
mapping a character or default string to the font proper-
ties, font ID, or direction hint for the font for the char-
acter.	The client may access the 4mXFontStruct24m list to obtain
these values for all the fonts currently in use.

Xlib does not guarantee that fonts are loaded from the
server at the creation of an 4mXFontSet24m.  Xlib may choose to
cache font data, loading it only as needed to draw text or
compute text dimensions.  Therefore, existence of the
per_char metrics in the 4mXFontStruct24m structures in the
4mXFontStructSet24m is undefined.  Also, note that all properties
in the 4mXFontStruct24m structures are in the STRING encoding.

The 4mXFontStruct24m and font name lists are owned by Xlib and
should not be modified or freed by the client.	They will be
freed by a call to 4mXFreeFontSet24m with the associated
4mXFontSet24m.	Until freed, their contents will not be modified
by Xlib.


To obtain the base font name list and the selected font name
list given an 4mXFontSet24m, use 4mXBaseFontNameListOfFontSet24m.






			     1m4170m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
char *XBaseFontNameListOfFontSet(4mfont_set24m)
      XFontSet 4mfont_set24m;


4mfont_set24m  Specifies the font set.
|__

The 4mXBaseFontNameListOfFontSet24m function returns the original
base font name list supplied by the client when the 4mXFontSet0m
was created.  A null-terminated string containing a list of
comma-separated font names is returned as the value of the
function.  White space may appear immediately on either side
of separating commas.

If 4mXCreateFontSet24m obtained an XLFD name from the font prop-
erties for the font specified by a non-XLFD base name, the
4mXBaseFontNameListOfFontSet24m function will return the XLFD
name instead of the non-XLFD base name.

The base font name list is owned by Xlib and should not be
modified or freed by the client.  It will be freed by a call
to 4mXFreeFontSet24m with the associated 4mXFontSet24m.	 Until freed,
its contents will not be modified by Xlib.


To obtain the locale name given an 4mXFontSet24m, use 4mXLocaleOf-0m
4mFontSet24m.
__
|
char *XLocaleOfFontSet(4mfont_set24m)
      XFontSet 4mfont_set24m;


4mfont_set24m  Specifies the font set.
|__

The 4mXLocaleOfFontSet24m function returns the name of the locale
bound to the specified 4mXFontSet24m, as a null-terminated
string.

The returned locale name string is owned by Xlib and should
not be modified or freed by the client.	 It may be freed by
a call to 4mXFreeFontSet24m with the associated 4mXFontSet24m.	Until
freed, it will not be modified by Xlib.


The 4mXFreeFontSet24m function is a convenience function for
freeing an output context.  4mXFreeFontSet24m also frees its
associated 4mXOM24m if the output context was created by 4mXCreate-0m
4mFontSet24m.






			     1m4180m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
void XFreeFontSet(4mdisplay24m, 4mfont_set24m)
      Display *4mdisplay24m;
      XFontSet 4mfont_set24m;


4mdisplay24m   Specifies the connection to the X server.

4mfont_set24m  Specifies the font set.
|__

The 4mXFreeFontSet24m function frees the specified font set.  The
associated base font name list, font name list, 4mXFontStruct0m
list, and 4mXFontSetExtents24m, if any, are freed.

1m13.4.7.  Obtaining Font Set Metrics0m

Metrics for the internationalized text drawing functions are
defined in terms of a primary draw direction, which is the
default direction in which the character origin advances for
each succeeding character in the string.  The Xlib interface
is currently defined to support only a left-to-right primary
draw direction.	 The drawing origin is the position passed
to the drawing function when the text is drawn.	 The base-
line is a line drawn through the drawing origin parallel to
the primary draw direction.  Character ink is the pixels
painted in the foreground color and does not include inter-
line or intercharacter spacing or image text background pix-
els.

The drawing functions are allowed to implement implicit text
directionality control, reversing the order in which charac-
ters are rendered along the primary draw direction in
response to locale-specific lexical analysis of the string.

Regardless of the character rendering order, the origins of
all characters are on the primary draw direction side of the
drawing origin.	 The screen location of a particular charac-
ter image may be determined with 4mXmbTextPerCharExtents24m, 4mXwc-0m
4mTextPerCharExtents24m or 4mXutf8TextPerCharExtents24m.

The drawing functions are allowed to implement context-
dependent rendering, where the glyphs drawn for a string are
not simply a concatenation of the glyphs that represent each
individual character.  A string of two characters drawn with
4mXmbDrawString24m may render differently than if the two charac-
ters were drawn with separate calls to 4mXmbDrawString24m.  If
the client appends or inserts a character in a previously
drawn string, the client may need to redraw some adjacent
characters to obtain proper rendering.


To find out about direction-dependent rendering, use 4mXDirec-0m
4mtionalDependentDrawing24m.



			     1m4190m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
Bool XDirectionalDependentDrawing(4mfont_set24m)
      XFontSet 4mfont_set24m;


4mfont_set24m  Specifies the font set.
|__

The 4mXDirectionalDependentDrawing24m function returns 4mTrue24m if
the drawing functions implement implicit text directional-
ity; otherwise, it returns 4mFalse24m.


To find out about context-dependent rendering, use 4mXContex-0m
4mtualDrawing24m.
__
|
Bool XContextualDrawing(4mfont_set24m)
      XFontSet 4mfont_set24m;


4mfont_set24m  Specifies the font set.
|__

The 4mXContextualDrawing24m function returns 4mTrue24m if text drawn
with the font set might include context-dependent drawing;
otherwise, it returns 4mFalse24m.


To find out about context-dependent or direction-dependent
rendering, use 4mXContextDependentDrawing24m.
__
|
Bool XContextDependentDrawing(4mfont_set24m)
      XFontSet 4mfont_set24m;


4mfont_set24m  Specifies the font set.
|__

The 4mXContextDependentDrawing24m function returns 4mTrue24m if the
drawing functions implement implicit text directionality or
if text drawn with the font_set might include context-depen-
dent drawing; otherwise, it returns 4mFalse24m.

The drawing functions do not interpret newline, tab, or
other control characters.  The behavior when nonprinting
characters other than space are drawn is implementation-
dependent.  It is the client's responsibility to interpret
control characters in a text stream.

The maximum character extents for the fonts that are used by
the text drawing layers can be accessed by the 4mXFontSetEx-0m
4mtents24m structure:



			     1m4200m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


typedef struct {
     XRectangle max_ink_extent;/* over all drawable characters */
     XRectangle max_logical_extent;/* over all drawable characters */
} XFontSetExtents;


The 4mXRectangle24m structures used to return font set metrics
are the usual Xlib screen-oriented rectangles with x, y giv-
ing the upper left corner, and width and height always posi-
tive.

The max_ink_extent member gives the maximum extent, over all
drawable characters, of the rectangles that bound the char-
acter glyph image drawn in the foreground color, relative to
a constant origin.  See 4mXmbTextExtents24m, 4mXwcTextExtents24m and
4mXutf8TextExtents24m for detailed semantics.

The max_logical_extent member gives the maximum extent, over
all drawable characters, of the rectangles that specify min-
imum spacing to other graphical features, relative to a con-
stant origin.  Other graphical features drawn by the client,
for example, a border surrounding the text, should not
intersect this rectangle.  The max_logical_extent member
should be used to compute minimum interline spacing and the
minimum area that must be allowed in a text field to draw a
given number of arbitrary characters.

Due to context-dependent rendering, appending a given char-
acter to a string may change the string's extent by an
amount other than that character's individual extent.

The rectangles for a given character in a string can be
obtained from 4mXmbPerCharExtents24m, 4mXwcPerCharExtents24m or
4mXutf8PerCharExtents24m.


To obtain the maximum extents structure given an 4mXFontSet24m,
use 4mXExtentsOfFontSet24m.
__
|
XFontSetExtents *XExtentsOfFontSet(4mfont_set24m)
       XFontSet 4mfont_set24m;


4mfont_set24m  Specifies the font set.
|__

The 4mXExtentsOfFontSet24m function returns an 4mXFontSetExtents0m
structure for the fonts used by the Xmb/wc/utf8 layer for
the given font set.

The 4mXFontSetExtents24m structure is owned by Xlib and should
not be modified or freed by the client.	 It will be freed by
a call to 4mXFreeFontSet24m with the associated 4mXFontSet24m.	Until



			     1m4210m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


freed, its contents will not be modified by Xlib.


To obtain the escapement in pixels of the specified text as
a value, use 4mXmbTextEscapement24m, 4mXwcTextEscapement24m or
4mXutf8TextEscapement24m.
__
|
int XmbTextEscapement(4mfont_set24m, 4mstring24m, 4mnum_bytes24m)
      XFontSet 4mfont_set24m;
      char *4mstring24m;
      int 4mnum_bytes24m;


int XwcTextEscapement(4mfont_set24m, 4mstring24m, 4mnum_wchars24m)
      XFontSet 4mfont_set24m;
      wchar_t *4mstring24m;
      int 4mnum_wchars24m;


int Xutf8TextEscapement(4mfont_set24m, 4mstring24m, 4mnum_bytes24m)
      XFontSet 4mfont_set24m;
      char *4mstring24m;
      int 4mnum_bytes24m;


4mfont_set24m  Specifies the font set.

4mstring24m    Specifies the character string.

4mnum_bytes24m Specifies the number of bytes in the string argu-
	  ment.

4mnum_wchars0m
	  Specifies the number of characters in the string
	  argument.
|__

The 4mXmbTextEscapement24m, 4mXwcTextEscapement24m and 4mXutf8Tex-0m
4mtEscapement24m functions return the escapement in pixels of the
specified string as a value, using the fonts loaded for the
specified font set.  The escapement is the distance in pix-
els in the primary draw direction from the drawing origin to
the origin of the next character to be drawn, assuming that
the rendering of the next character is not dependent on the
supplied string.

Regardless of the character rendering order, the escapement
is always positive.

The function 4mXutf8TextEscapement24m is an XFree86 extension
introduced in XFree86 4.0.2. Its presence is indicated by
the macro 4mX_HAVE_UTF8_STRING24m.




			     1m4220m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


To obtain the overall_ink_return and overall_logical_return
arguments, the overall bounding box of the string's image,
and a logical bounding box, use 4mXmbTextExtents24m, 4mXwcTextEx-0m
4mtents24m or 4mXutf8TextExtents24m.
__
|
int XmbTextExtents(4mfont_set24m, 4mstring24m, 4mnum_bytes24m, 4moverall_ink_return24m, 4moverall_logical_return24m)
      XFontSet 4mfont_set24m;
      char *4mstring24m;
      int 4mnum_bytes24m;
      XRectangle *4moverall_ink_return24m;
      XRectangle *4moverall_logical_return24m;


int XwcTextExtents(4mfont_set24m, 4mstring24m, 4mnum_wchars24m,
4moverall_ink_return24m, 4moverall_logical_return24m)
      XFontSet 4mfont_set24m;
      wchar_t *4mstring24m;
      int 4mnum_wchars24m;
      XRectangle *4moverall_ink_return24m;
      XRectangle *4moverall_logical_return24m;


int Xutf8TextExtents(4mfont_set24m, 4mstring24m, 4mnum_bytes24m, 4moverall_ink_return24m, 4moverall_logical_return24m)
      XFontSet 4mfont_set24m;
      char *4mstring24m;
      int 4mnum_bytes24m;
      XRectangle *4moverall_ink_return24m;
      XRectangle *4moverall_logical_return24m;


4mfont_set24m  Specifies the font set.

4mstring24m    Specifies the character string.

4mnum_bytes24m Specifies the number of bytes in the string argu-
	  ment.

4mnum_wchars0m
	  Specifies the number of characters in the string
	  argument.

4moverall_ink_return0m
	  Returns the overall ink dimensions.

4moverall_logical_return0m
	  Returns the overall logical dimensions.
|__

The 4mXmbTextExtents24m, 4mXwcTextExtents24m and 4mXutf8TextExtents0m
functions set the components of the specified over-
all_ink_return and overall_logical_return arguments to the
overall bounding box of the string's image and a logical
bounding box for spacing purposes, respectively.  They



			     1m4230m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


return the value returned by 4mXmbTextEscapement24m, 4mXwcTex-0m
4mtEscapement24m or 4mXutf8TextEscapement24m.  These metrics are rela-
tive to the drawing origin of the string, using the fonts
loaded for the specified font set.

If the overall_ink_return argument is non-NULL, it is set to
the bounding box of the string's character ink.	 The over-
all_ink_return for a nondescending, horizontally drawn Latin
character is conventionally entirely above the baseline;
that is, overall_ink_return.height <= -overall_ink_return.y.
The overall_ink_return for a nonkerned character is entirely
at, and to the right of, the origin; that is, over-
all_ink_return.x >= 0.	A character consisting of a single
pixel at the origin would set overall_ink_return fields y =
0, x = 0, width = 1, and height = 1.

If the overall_logical_return argument is non-NULL, it is
set to the bounding box that provides minimum spacing to
other graphical features for the string.  Other graphical
features, for example, a border surrounding the text, should
not intersect this rectangle.

When the 4mXFontSet24m has missing charsets, metrics for each
unavailable character are taken from the default string
returned by 4mXCreateFontSet24m so that the metrics represent the
text as it will actually be drawn.  The behavior for an
invalid codepoint is undefined.

To determine the effective drawing origin for a character in
a drawn string, the client should call 4mXmbTextPerCharExtents0m
on the entire string, then on the character, and subtract
the x values of the returned rectangles for the character.
This is useful to redraw portions of a line of text or to
justify words, but for context-dependent rendering, the
client should not assume that it can redraw the character by
itself and get the same rendering.

The function 4mXutf8TextExtents24m is an XFree86 extension intro-
duced in XFree86 4.0.2. Its presence is indicated by the
macro 4mX_HAVE_UTF8_STRING24m.


To obtain per-character information for a text string, use
4mXmbTextPerCharExtents24m, 4mXwcTextPerCharExtents24m or
4mXutf8TextPerCharExtents24m.












			     1m4240m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
Status XmbTextPerCharExtents(4mfont_set24m, 4mstring24m, 4mnum_bytes24m, 4mink_array_return24m,
	   4mlogical_array_return24m, 4marray_size24m, 4mnum_chars_return24m, 4moverall_ink_return24m, 4moverall_logical_return24m)
      XFontSet 4mfont_set24m;
      char *4mstring24m;
      int 4mnum_bytes24m;
      XRectangle *4mink_array_return24m;
      XRectangle *4mlogical_array_return24m;
      int 4marray_size24m;
      int *4mnum_chars_return24m;
      XRectangle *4moverall_ink_return24m;
      XRectangle *4moverall_logical_return24m;


Status XwcTextPerCharExtents(4mfont_set24m, 4mstring24m, 4mnum_wchars24m, 4mink_array_return24m,
	  4mlogical_array_return24m, 4marray_size24m, 4mnum_chars_return24m, 4moverall_ink_return24m, 4moverall_ink_return24m)
      XFontSet 4mfont_set24m;
      wchar_t *4mstring24m;
      int 4mnum_wchars24m;
      XRectangle *4mink_array_return24m;
      XRectangle *4mlogical_array_return24m;
      int 4marray_size24m;
      int *4mnum_chars_return24m;
      XRectangle *4moverall_ink_return24m;
      XRectangle *4moverall_logical_return24m;


Status Xutf8TextPerCharExtents(4mfont_set24m, 4mstring24m, 4mnum_bytes24m, 4mink_array_return24m,
	   4mlogical_array_return24m, 4marray_size24m, 4mnum_chars_return24m, 4moverall_ink_return24m, 4moverall_logical_return24m)
      XFontSet 4mfont_set24m;
      char *4mstring24m;
      int 4mnum_bytes24m;
      XRectangle *4mink_array_return24m;
      XRectangle *4mlogical_array_return24m;
      int 4marray_size24m;
      int *4mnum_chars_return24m;
      XRectangle *4moverall_ink_return24m;
      XRectangle *4moverall_logical_return24m;


4mfont_set24m  Specifies the font set.

4mstring24m    Specifies the character string.

4mnum_bytes24m Specifies the number of bytes in the string argu-
	  ment.

4mnum_wchars0m
	  Specifies the number of characters in the string
	  argument.

4mink_array_return0m
	  Returns the ink dimensions for each character.




			     1m4250m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


4mlogical_array_return0m
	  Returns the logical dimensions for each character.

4marray_size0m
	  Specifies the size of ink_array_return and logi-
	  cal_array_return.  The caller must pass in arrays
	  of this size.

4mnum_chars_return0m
	  Returns the number of characters in the string
	  argument.

4moverall_ink_return0m
	  Returns the overall ink extents of the entire
	  string.

4moverall_logical_return0m
	  Returns the overall logical extents of the entire
	  string.
|__

The 4mXmbTextPerCharExtents24m, 4mXwcTextPerCharExtents24m and
4mXutf8TextPerCharExtents24m functions return the text dimensions
of each character of the specified text, using the fonts
loaded for the specified font set.  Each successive element
of ink_array_return and logical_array_return is set to the
successive character's drawn metrics, relative to the draw-
ing origin of the string and one rectangle for each charac-
ter in the supplied text string.  The number of elements of
ink_array_return and logical_array_return that have been set
is returned to num_chars_return.

Each element of ink_array_return is set to the bounding box
of the corresponding character's drawn foreground color.
Each element of logical_array_return is set to the bounding
box that provides minimum spacing to other graphical fea-
tures for the corresponding character.	Other graphical fea-
tures should not intersect any of the logical_array_return
rectangles.

Note that an 4mXRectangle24m represents the effective drawing
dimensions of the character, regardless of the number of
font glyphs that are used to draw the character or the
direction in which the character is drawn.  If multiple
characters map to a single character glyph, the dimensions
of all the 4mXRectangles24m of those characters are the same.

When the 4mXFontSet24m has missing charsets, metrics for each
unavailable character are taken from the default string
returned by 4mXCreateFontSet24m so that the metrics represent the
text as it will actually be drawn.  The behavior for an
invalid codepoint is undefined.





			     1m4260m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


If the array_size is too small for the number of characters
in the supplied text, the functions return zero and
num_chars_return is set to the number of rectangles
required.  Otherwise, the functions return a nonzero value.

If the overall_ink_return or overall_logical_return argument
is non-NULL, 4mXmbTextPerCharExtents24m, 4mXwcTextPerCharExtents0m
and 4mXutf8TextPerCharExtents24m return the maximum extent of the
string's metrics to overall_ink_return or overall_logi-
cal_return, as returned by 4mXmbTextExtents24m, 4mXwcTextExtents24m or
4mXutf8TextExtents24m.

The function 4mXutf8TextPerCharExtents24m is an XFree86 extension
introduced in XFree86 4.0.2. Its presence is indicated by
the macro 4mX_HAVE_UTF8_STRING24m.

1m13.4.8.  Drawing Text Using Font Sets0m

The functions defined in this section draw text at a speci-
fied location in a drawable.  They are similar to the func-
tions 4mXDrawText24m, 4mXDrawString24m, and 4mXDrawImageString24m except
that they work with font sets instead of single fonts and
interpret the text based on the locale of the font set (for
functions whose name starts with Xmb or Xwc) or as UTF-8
encoded text (for functions whose name starts with Xutf8),
instead of treating the bytes of the string as direct font
indexes.  See section 8.6 for details of the use of Graphics
Contexts (GCs) and possible protocol errors.  If a 4mBadFont0m
error is generated, characters prior to the offending char-
acter may have been drawn.

The text is drawn using the fonts loaded for the specified
font set; the font in the GC is ignored and may be modified
by the functions.  No validation that all fonts conform to
some width rule is performed.

The text functions 4mXmbDrawText24m, 4mXwcDrawText24m and 4mXutf8Draw-0m
4mText24m use the following structures:



















			     1m4270m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
typedef struct {
     char *chars;	 /* pointer to string */
     int nchars;	 /* number of bytes */
     int delta;		 /* pixel delta between strings */
     XFontSet font_set;	 /* fonts, None means don't change */
} XmbTextItem;



typedef struct {
     wchar_t *chars;	 /* pointer to wide char string */
     int nchars;	 /* number of wide characters */
     int delta;		 /* pixel delta between strings */
     XFontSet font_set;	 /* fonts, None means don't change */
} XwcTextItem;

|__


To draw text using multiple font sets in a given drawable,
use 4mXmbDrawText24m, 4mXwcDrawText24m or 4mXutf8DrawText24m.



































			     1m4280m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
void XmbDrawText(4mdisplay24m, 4md24m, 4mgc24m, 4mx24m, 4my24m, 4mitems24m, 4mnitems24m)
      Display *4mdisplay24m;
      Drawable 4md24m;
      GC 4mgc24m;
      int 4mx24m, 4my24m;
      XmbTextItem *4mitems24m;
      int 4mnitems24m;


void XwcDrawText(4mdisplay24m, 4md24m, 4mgc24m, 4mx24m, 4my24m, 4mitems24m, 4mnitems24m)
      Display *4mdisplay24m;
      Drawable 4md24m;
      GC 4mgc24m;
      int 4mx24m, 4my24m;
      XwcTextItem *4mitems24m;
      int 4mnitems24m;


void Xutf8DrawText(4mdisplay24m, 4md24m, 4mgc24m, 4mx24m, 4my24m, 4mitems24m, 4mnitems24m)
      Display *4mdisplay24m;
      Drawable 4md24m;
      GC 4mgc24m;
      int 4mx24m, 4my24m;
      XmbTextItem *4mitems24m;
      int 4mnitems24m;


4mdisplay24m   Specifies the connection to the X server.

4md24m	       Specifies the drawable.

4mgc24m	       Specifies the GC.

4mx0m
4my24m	       Specify the x and y coordinates.

4mitems24m     Specifies an array of text items.

4mnitems24m    Specifies the number of text items in the array.
|__

The 4mXmbDrawText24m, 4mXwcDrawText24m and 4mXutf8DrawText24m functions
allow complex spacing and font set shifts between text
strings.  Each text item is processed in turn, with the ori-
gin of a text element advanced in the primary draw direction
by the escapement of the previous text item.  A text item
delta specifies an additional escapement of the text item
drawing origin in the primary draw direction.  A font_set
member other than 4mNone24m in an item causes the font set to be
used for this and subsequent text items in the text_items
list.  Leading text items with a font_set member set to 4mNone0m
will not be drawn.




			     1m4290m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


4mXmbDrawText24m, 4mXwcDrawText24m and 4mXutf8DrawText24m do not perform
any context-dependent rendering between text segments.
Clients may compute the drawing metrics by passing each text
segment to 4mXmbTextExtents24m, 4mXwcTextExtents24m, 4mXutf8TextExtents0m
or 4mXmbTextPerCharExtents24m, 4mXwcTextPerCharExtents24m.
4mXutf8TextPerCharExtents24m.  When the 4mXFontSet24m has missing
charsets, each unavailable character is drawn with the
default string returned by 4mXCreateFontSet24m.	 The behavior for
an invalid codepoint is undefined.

The function 4mXutf8DrawText24m is an XFree86 extension intro-
duced in XFree86 4.0.2. Its presence is indicated by the
macro 4mX_HAVE_UTF8_STRING24m.


To draw text using a single font set in a given drawable,
use 4mXmbDrawString24m, 4mXwcDrawString24m or 4mXutf8DrawString24m.








































			     1m4300m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
void XmbDrawString(4mdisplay24m, 4md24m, 4mfont_set24m, 4mgc24m, 4mx24m, 4my24m, 4mstring24m, 4mnum_bytes24m)
      Display *4mdisplay24m;
      Drawable 4md24m;
      XFontSet 4mfont_set24m;
      GC 4mgc24m;
      int 4mx24m, 4my24m;
      char *4mstring24m;
      int 4mnum_bytes24m;


void XwcDrawString(4mdisplay24m, 4md24m, 4mfont_set24m, 4mgc24m, 4mx24m, 4my24m, 4mstring24m, 4mnum_wchars24m)
      Display *4mdisplay24m;
      Drawable 4md24m;
      XFontSet 4mfont_set24m;
      GC 4mgc24m;
      int 4mx24m, 4my24m;
      wchar_t *4mstring24m;
      int 4mnum_wchars24m;


void Xutf8DrawString(4mdisplay24m, 4md24m, 4mfont_set24m, 4mgc24m, 4mx24m, 4my24m, 4mstring24m, 4mnum_bytes24m)
      Display *4mdisplay24m;
      Drawable 4md24m;
      XFontSet 4mfont_set24m;
      GC 4mgc24m;
      int 4mx24m, 4my24m;
      char *4mstring24m;
      int 4mnum_bytes24m;


4mdisplay24m   Specifies the connection to the X server.

4md24m	       Specifies the drawable.

4mfont_set24m  Specifies the font set.

4mgc24m	       Specifies the GC.

4mx0m
4my24m	       Specify the x and y coordinates.

4mstring24m    Specifies the character string.

4mnum_bytes24m Specifies the number of bytes in the string argu-
	  ment.

4mnum_wchars0m
	  Specifies the number of characters in the string
	  argument.
|__

The 4mXmbDrawString24m, 4mXwcDrawString24m and 4mXutf8DrawString24m func-
tions draw the specified text with the foreground pixel.



			     1m4310m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


When the 4mXFontSet24m has missing charsets, each unavailable
character is drawn with the default string returned by 4mXCre-0m
4mateFontSet24m.  The behavior for an invalid codepoint is unde-
fined.

The function 4mXutf8DrawString24m is an XFree86 extension intro-
duced in XFree86 4.0.2. Its presence is indicated by the
macro 4mX_HAVE_UTF8_STRING24m.


To draw image text using a single font set in a given draw-
able, use 4mXmbDrawImageString24m, 4mXwcDrawImageString24m or
4mXutf8DrawImageString24m.












































			     1m4320m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
void XmbDrawImageString(4mdisplay24m, 4md24m, 4mfont_set24m, 4mgc24m, 4mx24m, 4my24m, 4mstring24m, 4mnum_bytes24m)
      Display *4mdisplay24m;
      Drawable 4md24m;
      XFontSet 4mfont_set24m;
      GC 4mgc24m;
      int 4mx24m, 4my24m;
      char *4mstring24m;
      int 4mnum_bytes24m;


void XwcDrawImageString(4mdisplay24m, 4md24m, 4mfont_set24m, 4mgc24m, 4mx24m, 4my24m, 4mstring24m, 4mnum_wchars24m)
      Display *4mdisplay24m;
      Drawable 4md24m;
      XFontSet 4mfont_set24m;
      GC 4mgc24m;
      int 4mx24m, 4my24m;
      wchar_t *4mstring24m;
      int 4mnum_wchars24m;


void Xutf8DrawImageString(4mdisplay24m, 4md24m, 4mfont_set24m, 4mgc24m, 4mx24m, 4my24m, 4mstring24m, 4mnum_bytes24m)
      Display *4mdisplay24m;
      Drawable 4md24m;
      XFontSet 4mfont_set24m;
      GC 4mgc24m;
      int 4mx24m, 4my24m;
      char *4mstring24m;
      int 4mnum_bytes24m;


4mdisplay24m   Specifies the connection to the X server.

4md24m	       Specifies the drawable.

4mfont_set24m  Specifies the font set.

4mgc24m	       Specifies the GC.

4mx0m
4my24m	       Specify the x and y coordinates.

4mstring24m    Specifies the character string.

4mnum_bytes24m Specifies the number of bytes in the string argu-
	  ment.

4mnum_wchars0m
	  Specifies the number of characters in the string
	  argument.
|__

The 4mXmbDrawImageString24m, 4mXwcDrawImageString24m and 4mXutf8DrawIm-0m
4mageString24m functions fill a destination rectangle with the



			     1m4330m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


background pixel defined in the GC and then paint the text
with the foreground pixel.  The filled rectangle is the rec-
tangle returned to overall_logical_return by 4mXmbTextExtents24m,
4mXwcTextExtents24m or 4mXutf8TextExtents24m for the same text and
4mXFontSet24m.

When the 4mXFontSet24m has missing charsets, each unavailable
character is drawn with the default string returned by 4mXCre-0m
4mateFontSet24m.  The behavior for an invalid codepoint is unde-
fined.

The function 4mXutf8TextExtents24m is an XFree86 extension intro-
duced in XFree86 4.0.2. Its presence is indicated by the
macro 4mX_HAVE_UTF8_STRING24m.

1m13.5.	 Input Methods0m

This section provides discussions of the following X Input
Method (XIM) topics:

·    Input method overview

·    Input method management

·    Input method functions

·    Input method values

·    Input context functions

·    Input context values

·    Input method callback semantics

·    Event filtering

·    Getting keyboard input

·    Input method conventions

1m13.5.1.  Input Method Overview0m

This section provides definitions for terms and concepts
used for internationalized text input and a brief overview
of the intended use of the mechanisms provided by Xlib.

A large number of languages in the world use alphabets con-
sisting of a small set of symbols (letters) to form words.
To enter text into a computer in an alphabetic language, a
user usually has a keyboard on which there exist key symbols
corresponding to the alphabet.	Sometimes, a few characters
of an alphabetic language are missing on the keyboard.	Many
computer users who speak a Latin-alphabet-based language
only have an English-based keyboard.  They need to hit a



			     1m4340m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


combination of keystrokes to enter a character that does not
exist directly on the keyboard.	 A number of algorithms have
been developed for entering such characters.  These are
known as European input methods, compose input methods, or
dead-key input methods.

Japanese is an example of a language with a phonetic symbol
set, where each symbol represents a specific sound.  There
are two phonetic symbol sets in Japanese:  Katakana and
Hiragana.  In general, Katakana is used for words that are
of foreign origin, and Hiragana is used for writing native
Japanese words.	 Collectively, the two systems are called
Kana.  Each set consists of 48 characters.

Korean also has a phonetic symbol set, called Hangul.  Each
of the 24 basic phonetic symbols (14 consonants and 10 vow-
els) represents a specific sound.  A syllable is composed of
two or three parts: the initial consonants, the vowels, and
the optional last consonants.  With Hangul, syllables can be
treated as the basic units on which text processing is done.
For example, a delete operation may work on a phonetic sym-
bol or a syllable.  Korean code sets include several thou-
sands of these syllables.  A user types the phonetic symbols
that make up the syllables of the words to be entered.	The
display may change as each phonetic symbol is entered.	For
example, when the second phonetic symbol of a syllable is
entered, the first phonetic symbol may change its shape and
size.  Likewise, when the third phonetic symbol is entered,
the first two phonetic symbols may change their shape and
size.

Not all languages rely solely on alphabetic or phonetic sys-
tems.  Some languages, including Japanese and Korean, employ
an ideographic writing system.	In an ideographic system,
rather than taking a small set of symbols and combining them
in different ways to create words, each word consists of one
unique symbol (or, occasionally, several symbols).  The num-
ber of symbols can be very large: approximately 50,000 have
been identified in Hanzi, the Chinese ideographic system.

Two major aspects of ideographic systems impact their use
with computers.	 First, the standard computer character sets
in Japan, China, and Korea include roughly 8,000 characters,
while sets in Taiwan have between 15,000 and 30,000 charac-
ters.  This makes it necessary to use more than one byte to
represent a character.	Second, it obviously is impractical
to have a keyboard that includes all of a given language's
ideographic symbols.  Therefore, a mechanism is required for
entering characters so that a keyboard with a reasonable
number of keys can be used.  Those input methods are usually
based on phonetics, but there also exist methods based on
the graphical properties of characters.





			     1m4350m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


In Japan, both Kana and the ideographic system Kanji are
used.  In Korea, Hangul and sometimes the ideographic system
Hanja are used.	 Now consider entering ideographs in Japan,
Korea, China, and Taiwan.

In Japan, either Kana or English characters are typed and
then a region is selected (sometimes automatically) for con-
version to Kanji.  Several Kanji characters may have the
same phonetic representation.  If that is the case with the
string entered, a menu of characters is presented and the
user must choose the appropriate one.  If no choice is nec-
essary or a preference has been established, the input
method does the substitution directly.	When Latin charac-
ters are converted to Kana or Kanji, it is called a romaji
conversion.

In Korea, it is usually acceptable to keep Korean text in
Hangul form, but some people may choose to write Hanja-orig-
inated words in Hanja rather than in Hangul.  To change
Hangul to Hanja, the user selects a region for conversion
and then follows the same basic method as that described for
Japanese.

Probably because there are well-accepted phonetic writing
systems for Japanese and Korean, computer input methods in
these countries for entering ideographs are fairly standard.
Keyboard keys have both English characters and phonetic sym-
bols engraved on them, and the user can switch between the
two sets.

The situation is different for Chinese.	 While there is a
phonetic system called Pinyin promoted by authorities, there
is no consensus for entering Chinese text.  Some vendors use
a phonetic decomposition (Pinyin or another), others use
ideographic decomposition of Chinese words, with various
implementations and keyboard layouts.  There are about 16
known methods, none of which is a clear standard.

Also, there are actually two ideographic sets used: Tradi-
tional Chinese (the original written Chinese) and Simplified
Chinese.  Several years ago, the People's Republic of China
launched a campaign to simplify some ideographic characters
and eliminate redundancies altogether.	Under the plan,
characters would be streamlined every five years.  Charac-
ters have been revised several times now, resulting in the
smaller, simpler set that makes up Simplified Chinese.

1m13.5.1.1.  Input Method Architecture0m

As shown in the previous section, there are many different
input methods in use today, each varying with language, cul-
ture, and history.  A common feature of many input methods
is that the user may type multiple keystrokes to compose a
single character (or set of characters).  The process of



			     1m4360m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


composing characters from keystrokes is called 4mpreediting24m.
It may require complex algorithms and large dictionaries
involving substantial computer resources.

Input methods may require one or more areas in which to show
the feedback of the actual keystrokes, to propose disam-
biguation to the user, to list dictionaries, and so on.	 The
input method areas of concern are as follows:

·    The 4mstatus24m area is a logical extension of the LEDs that
     exist on the physical keyboard.  It is a window that is
     intended to present the internal state of the input
     method that is critical to the user.  The status area
     may consist of text data and bitmaps or some combina-
     tion.

·    The 4mpreedit24m area displays the intermediate text for
     those languages that are composing prior to the client
     handling the data.

·    The 4mauxiliary24m area is used for pop-up menus and cus-
     tomizing dialogs that may be required for an input
     method.  There may be multiple auxiliary areas for an
     input method.  Auxiliary areas are managed by the input
     method independent of the client.	Auxiliary areas are
     assumed to be separate dialogs, which are maintained by
     the input method.

There are various user interaction styles used for preedit-
ing.  The ones supported by Xlib are as follows:

·    For 4mon-the-spot24m input methods, preediting data will be
     displayed directly in the application window.  Applica-
     tion data is moved to allow preedit data to appear at
     the point of insertion.

·    4mOver-the-spot24m preediting means that the data is dis-
     played in a preedit window that is placed over the
     point of insertion.

·    4mOff-the-spot24m preediting means that the preedit window
     is inside the application window but not at the point
     of insertion.  Often, this type of window is placed at
     the bottom of the application window.

·    4mRoot-window24m preediting refers to input methods that use
     a preedit window that is the child of 4mRootWindow24m.

It would require a lot of computing resources if portable
applications had to include input methods for all the lan-
guages in the world.  To avoid this, a goal of the Xlib
design is to allow an application to communicate with an
input method placed in a separate process.  Such a process
is called an 4minput24m 4mserver24m.  The server to which the



			     1m4370m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


application should connect is dependent on the environment
when the application is started up, that is, the user lan-
guage and the actual encoding to be used for it.  The input
method connection is said to be 4mlocale-dependent24m.	It is
also user-dependent.  For a given language, the user can
choose, to some extent, the user interface style of input
method (if choice is possible among several).

Using an input server implies communication overhead, but
applications can be migrated without relinking.	 Input meth-
ods can be implemented either as a stub communicating to an
input server or as a local library.

An input method may be based on a 4mfront-end24m or a 4mback-end0m
architecture.  In a front-end architecture, there are two
separate connections to the X server: keystrokes go directly
from the X server to the input method on one connection and
other events to the regular client connection.	The input
method is then acting as a filter and sends composed strings
to the client.	A front-end architecture requires synchro-
nization between the two connections to avoid lost key
events or locking issues.

In a back-end architecture, a single X server connection is
used.  A dispatching mechanism must decide on this channel
to delegate appropriate keystrokes to the input method.	 For
instance, it may retain a Help keystroke for its own pur-
pose.  In the case where the input method is a separate
process (that is, a server), there must be a special commu-
nication protocol between the back-end client and the input
server.

A front-end architecture introduces synchronization issues
and a filtering mechanism for noncharacter keystrokes (Func-
tion keys, Help, and so on).  A back-end architecture some-
times implies more communication overhead and more process
switching.  If all three processes (X server, input server,
client) are running on a single workstation, there are two
process switches for each keystroke in a back-end architec-
ture, but there is only one in a front-end architecture.

The abstraction used by a client to communicate with an
input method is an opaque data structure represented by the
4mXIM24m data type.  This data structure is returned by the
4mXOpenIM24m function, which opens an input method on a given
display.  Subsequent operations on this data structure
encapsulate all communication between client and input
method.	 There is no need for an X client to use any net-
working library or natural language package to use an input
method.

A single input server may be used for one or more languages,
supporting one or more encoding schemes.  But the strings
returned from an input method will always be encoded in the



			     1m4380m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


(single) locale associated with the 4mXIM24m object.

1m13.5.1.2.  Input Contexts0m

Xlib provides the ability to manage a multi-threaded state
for text input.	 A client may be using multiple windows,
each window with multiple text entry areas, and the user
possibly switching among them at any time.  The abstraction
for representing the state of a particular input thread is
called an 4minput24m 4mcontext24m.  The Xlib representation of an
input context is an 4mXIC24m.

An input context is the abstraction retaining the state,
properties, and semantics of communication between a client
and an input method.  An input context is a combination of
an input method, a locale specifying the encoding of the
character strings to be returned, a client window, internal
state information, and various layout or appearance charac-
teristics.  The input context concept somewhat matches for
input the graphics context abstraction defined for graphics
output.

One input context belongs to exactly one input method.	Dif-
ferent input contexts may be associated with the same input
method, possibly with the same client window.  An 4mXIC24m is
created with the 4mXCreateIC24m function, providing an 4mXIM24m argu-
ment and affiliating the input context to the input method
for its lifetime.  When an input method is closed with 4mXClo-0m
4mseIM24m, all of its affiliated input contexts should not be
used any more (and should preferably be destroyed before
closing the input method).

Considering the example of a client window with multiple
text entry areas, the application programmer could, for
example, choose to implement as follows:

·    As many input contexts are created as text entry areas,
     and the client will get the input accumulated on each
     context each time it looks up in that context.

·    A single context is created for a top-level window in
     the application.  If such a window contains several
     text entry areas, each time the user moves to another
     text entry area, the client has to indicate changes in
     the context.

A range of choices can be made by application designers to
use either a single or multiple input contexts, according to
the needs of their application.

1m13.5.1.3.  Getting Keyboard Input0m

To obtain characters from an input method, a client must
call the function 4mXmbLookupString24m, 4mXwcLookupString24m or



			     1m4390m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


4mXutf8LookupString24m with an input context created from that
input method.  Both a locale and display are bound to an
input method when it is opened, and an input context inher-
its this locale and display.  Any strings returned by
4mXmbLookupString24m or 4mXwcLookupString24m will be encoded in that
locale. Strings returned by 4mXutf8LookupString24m are encoded in
UTF-8.

1m13.5.1.4.  Focus Management0m

For each text entry area in which the 4mXmbLookupString24m,
4mXwcLookupString24m or 4mXutf8LookupString24m functions are used,
there will be an associated input context.

When the application focus moves to a text entry area, the
application must set the input context focus to the input
context associated with that area.  The input context focus
is set by calling 4mXSetICFocus24m with the appropriate input
context.

Also, when the application focus moves out of a text entry
area, the application should unset the focus for the associ-
ated input context by calling 4mXUnsetICFocus24m.  As an opti-
mization, if 4mXSetICFocus24m is called successively on two dif-
ferent input contexts, setting the focus on the second will
automatically unset the focus on the first.

To set and unset the input context focus correctly, it is
necessary to track application-level focus changes.  Such
focus changes do not necessarily correspond to X server
focus changes.

If a single input context is being used to do input for mul-
tiple text entry areas, it will also be necessary to set the
focus window of the input context whenever the focus window
changes (see section 13.5.6.3).

1m13.5.1.5.  Geometry Management0m

In most input method architectures (on-the-spot being the
notable exception), the input method will perform the dis-
play of its own data.  To provide better visual locality, it
is often desirable to have the input method areas embedded
within a client.  To do this, the client may need to allo-
cate space for an input method.	 Xlib provides support that
allows the size and position of input method areas to be
provided by a client.  The input method areas that are sup-
ported for geometry management are the status area and the
preedit area.

The fundamental concept on which geometry management for
input method windows is based is the proper division of
responsibilities between the client (or toolkit) and the
input method.  The division of responsibilities is as



			     1m4400m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


follows:

·    The client is responsible for the geometry of the input
     method window.

·    The input method is responsible for the contents of the
     input method window.

An input method is able to suggest a size to the client, but
it cannot suggest a placement.	Also the input method can
only suggest a size.  It does not determine the size, and it
must accept the size it is given.

Before a client provides geometry management for an input
method, it must determine if geometry management is needed.
The input method indicates the need for geometry management
by setting 4mXIMPreeditArea24m or 4mXIMStatusArea24m in its 4mXIMStyles0m
value returned by 4mXGetIMValues24m.  When a client has decided
that it will provide geometry management for an input
method, it indicates that decision by setting the 4mXNInput-0m
4mStyle24m value in the 4mXIC24m.

After a client has established with the input method that it
will do geometry management, the client must negotiate the
geometry with the input method.	 The geometry is negotiated
by the following steps:

·    The client suggests an area to the input method by set-
     ting the 4mXNAreaNeeded24m value for that area.  If the
     client has no constraints for the input method, it
     either will not suggest an area or will set the width
     and height to zero.  Otherwise, it will set one of the
     values.

·    The client will get the XIC value 4mXNAreaNeeded24m.  The
     input method will return its suggested size in this
     value.  The input method should pay attention to any
     constraints suggested by the client.

·    The client sets the XIC value 4mXNArea24m to inform the
     input method of the geometry of its window.  The client
     should try to honor the geometry requested by the input
     method.  The input method must accept this geometry.

Clients doing geometry management must be aware that setting
other XIC values may affect the geometry desired by an input
method.	 For example, 4mXNFontSet24m and 4mXNLineSpacing24m may change
the geometry desired by the input method.

The table of XIC values (see section 13.5.6) indicates the
values that can cause the desired geometry to change when
they are set.  It is the responsibility of the client to
renegotiate the geometry of the input method window when it
is needed.



			     1m4410m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


In addition, a geometry management callback is provided by
which an input method can initiate a geometry change.

1m13.5.1.6.  Event Filtering0m

A filtering mechanism is provided to allow input methods to
capture X events transparently to clients.  It is expected
that toolkits (or clients) using 4mXmbLookupString24m, 4mXwcLookup-0m
4mString24m or 4mXutf8LookupString24m will call this filter at some
point in the event processing mechanism to make sure that
events needed by an input method can be filtered by that
input method.

If there were no filter, a client could receive and discard
events that are necessary for the proper functioning of an
input method.  The following provides a few examples of such
events:

·    Expose events on preedit window in local mode.

·    Events may be used by an input method to communicate
     with an input server.  Such input server protocol-
     related events have to be intercepted if one does not
     want to disturb client code.

·    Key events can be sent to a filter before they are
     bound to translations such as those the X Toolkit
     Intrinsics library provides.

Clients are expected to get the XIC value 4mXNFilterEvents24m and
augment the event mask for the client window with that event
mask.  This mask may be zero.

1m13.5.1.7.  Callbacks0m

When an on-the-spot input method is implemented, only the
client can insert or delete preedit data in place and possi-
bly scroll existing text.  This means that the echo of the
keystrokes has to be achieved by the client itself, tightly
coupled with the input method logic.

When the user enters a keystroke, the client calls
4mXmbLookupString24m, 4mXwcLookupString24m or 4mXutf8LookupString24m.  At
this point, in the on-the-spot case, the echo of the key-
stroke in the preedit has not yet been done.  Before return-
ing to the client logic that handles the input characters,
the look-up function must call the echoing logic to insert
the new keystroke.  If the keystrokes entered so far make up
a character, the keystrokes entered need to be deleted, and
the composed character will be returned.  Hence, what hap-
pens is that, while being called by client code, the input
method logic has to call back to the client before it
returns.  The client code, that is, a callback procedure, is
called from the input method logic.



			     1m4420m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


There are a number of cases where the input method logic has
to call back the client.  Each of those cases is associated
with a well-defined callback action.  It is possible for the
client to specify, for each input context, what callback is
to be called for each action.

There are also callbacks provided for feedback of status
information and a callback to initiate a geometry request
for an input method.

1m13.5.1.8.  Visible Position Feedback Masks0m

In the on-the-spot input style, there is a problem when
attempting to draw preedit strings that are longer than the
available space.  Once the display area is exceeded, it is
not clear how best to display the preedit string.  The visi-
ble position feedback masks of 4mXIMText24m help resolve this
problem by allowing the input method to specify hints that
indicate the essential portions of the preedit string.	For
example, such hints can help developers implement scrolling
of a long preedit string within a short preedit display
area.

1m13.5.1.9.  Preedit String Management0m

As highlighted before, the input method architecture pro-
vides preediting, which supports a type of preprocessor
input composition.  In this case, composition consists of
interpreting a sequence of key events and returning a com-
mitted string via 4mXmbLookupString24m, 4mXwcLookupString24m or
4mXutf8LookupString24m.	 This provides the basics for input meth-
ods.

In addition to preediting based on key events, a general
framework is provided to give a client that desires it more
advanced preediting based on the text within the client.
This framework is called 4mstring24m 4mconversion24m and is provided
using XIC values.  The fundamental concept of string conver-
sion is to allow the input method to manipulate the client's
text independent of any user preediting operation.

The need for string conversion is based on language needs
and input method capabilities.	The following are some exam-
ples of string conversion:

·    Transliteration conversion provides language-specific
     conversions within the input method.  In the case of
     Korean input, users wish to convert a Hangul string
     into a Hanja string while in preediting, after preedit-
     ing, or in other situations (for example, on a selected
     string).  The conversion is triggered when the user
     presses a Hangul-to-Hanja key sequence (which may be
     input method specific).  Sometimes the user may want to
     invoke the conversion after finishing preediting or on



			     1m4430m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


     a user-selected string.  Thus, the string to be con-
     verted is in an application buffer, not in the preedit
     area of the input method.	The string conversion ser-
     vices allow the client to request this transliteration
     conversion from the input method.	There are many other
     transliteration conversions defined for various lan-
     guages, for example, Kana-to-Kanji conversion in
     Japanese.

     The key to remember is that transliteration conversions
     are triggered at the request of the user and returned
     to the client immediately without affecting the preedit
     area of the input method.

·    Reconversion of a previously committed string or a
     selected string is supported by many input methods as a
     convenience to the user.  For example, a user tends to
     mistype the commit key while preediting.  In that case,
     some input methods provide a special key sequence to
     request a ``reconvert'' operation on the committed
     string, similiar to the undo facility provided by most
     text editors.  Another example is where the user is
     proofreading a document that has some misconversions
     from preediting and wants to correct the misconverted
     text.  Such reconversion is again triggered by the user
     invoking some special action, but reconversions should
     not affect the state of the preedit area.

·    Context-sensitive conversion is required for some lan-
     guages and input methods that need to retrieve text
     that surrounds the current spot location (cursor posi-
     tion) of the client's buffer.  Such text is needed when
     the preediting operation depends on some surrounding
     characters (usually preceding the spot location).	For
     example, in Thai language input, certain character
     sequences may be invalid and the input method may want
     to check whether characters constitute a valid word.
     Input methods that do such context-dependent checking
     need to retrieve the characters surrounding the current
     cursor position to obtain complete words.

     Unlike other conversions, this conversion is not
     explicitly requested by the user.	Input methods that
     provide such context-sensitive conversion continuously
     need to request context from the client, and any change
     in the context of the spot location may affect such
     conversions.  The client's context would be needed if
     the user moves the cursor and starts editing again.

     For this reason, an input method supporting this type
     of conversion should take notice of when the client
     calls 4mXmbResetIC24m, 4mXwcResetIC24m or 4mXutf8ResetIC24m, which is
     usually an indication of a context change.




			     1m4440m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


Context-sensitive conversions just need a copy of the
client's text, while other conversions replace the client's
text with new text to achieve the reconversion or translit-
eration.   Yet in all cases the result of a conversion,
either immediately or via preediting, is returned by the
4mXmbLookupString24m, 4mXwcLookupString24m and 4mXutf8LookupString24m func-
tions.

String conversion support is dependent on the availability
of the 4mXNStringConversion24m or 4mXNStringConversionCallback24m XIC
values.	 Because the input method may not support string
conversions, clients have to query the availability of
string conversion operations by checking the supported XIC
values list by calling 4mXGetIMValues24m with the 4mXNQueryICVal-0m
4muesList24m IM value.

The difference between these two values is whether the con-
version is invoked by the client or the input method.  The
4mXNStringConversion24m XIC value is used by clients to request a
string conversion from the input method.  The client is
responsible for determining which events are used to trigger
the string conversion and whether the string to be converted
should be copied or deleted.  The type of conversion is
determined by the input method; the client can only pass the
string to be converted.	 The client is guaranteed that no
4mXNStringConversionCallback24m will be issued when this value is
set; thus, the client need only set one of these values.

The 4mXNStringConversionCallback24m XIC value is used by the
client to notify the input method that it will accept
requests from the input method for string conversion.  If
this value is set, it is the input method's responsibility
to determine which events are used to trigger the string
conversion.  When such events occur, the input method issues
a call to the client-supplied procedure to retrieve the
string to be converted.	 The client's callback procedure is
notified whether to copy or delete the string and is pro-
vided with hints as to the amount of text needed.  The 4mXIM-0m
4mStringConversionCallbackStruct24m specifies which text should
be passed back to the input method.

Finally, the input method may call the client's 4mXNStringCon-0m
4mversionCallback24m procedure multiple times if the string
returned from the callback is not sufficient to perform a
successful conversion.	 The arguments to the client's pro-
cedure allow the input method to define a position (in char-
acter units) relative to the client's cursor position and
the size of the text needed.  By varying the position and
size of the desired text in subsequent callbacks, the input
method can retrieve additional text.







			     1m4450m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


1m13.5.2.  Input Method Management0m

The interface to input methods might appear to be simply
creating an input method (4mXOpenIM24m) and freeing an input
method (4mXCloseIM24m).	 However, input methods may require com-
plex communication with input method servers (IM servers),
for example:

·    If the X server, IM server, and X clients are started
     asynchronously, some clients may attempt to connect to
     the IM server before it is fully operational, and fail.
     Therefore, some mechanism is needed to allow clients to
     detect when an IM server has started.

It is up to clients to decide what should be done when an IM
server is not available (for example, wait, or use some
other IM server).


·    Some input methods may allow the underlying IM server
     to be switched.  Such customization may be desired
     without restarting the entire client.

To support management of input methods in these cases, the
following functions are provided:

4mXRegisterIMInstantiate-24m	This function allows clients to
4mCallback24m			register a callback procedure to
			   be called when Xlib detects that
			   an IM server is up and available.
4mXOpenIM24m			A client calls this function as a
			   result of the callback procedure
			   being called.
4mXSetIMValue24m, 4mXSetICValue24m   These functions use the XIM and
			   XIC values, 4mXNDestroyCallback24m, to
			   allow a client to register a
			   callback procedure to be called
			   when Xlib detects that an IM
			   server that was associated with
			   an opened input method is no
			   longer available.
			   In addition, this function can be
			   used to switch IM servers for
			   those input methods that support
			   such functionality.	The IM value
			   for switching IM servers is
			   implementation-dependent; see the
			   description below about switching
			   IM servers.
4mXUnregisterIMInstanti-24m	This function removes a callback
4mateCallback24m		procedure registered by the
			   client.





			     1m4460m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


Input methods that support switching of IM servers may
exhibit some side-effects:

·    The input method will ensure that any new IM server
     supports any of the input styles being used by input
     contexts already associated with the input method.
     However, the list of supported input styles may be dif-
     ferent.


·    Geometry management requests on previously created
     input contexts may be initiated by the new IM server.


1m13.5.2.1.  Hot Keys0m

Some clients need to guarantee which keys can be used to
escape from the input method, regardless of the input method
state; for example, the client-specific Help key or the keys
to move the input focus.  The HotKey mechanism allows
clients to specify a set of keys for this purpose.  However,
the input method might not allow clients to specify hot
keys.  Therefore, clients have to query support of hot keys
by checking the supported XIC values list by calling 4mXGetIM-0m
4mValues24m with the 4mXNQueryICValuesList24m IM value.	 When the hot
keys specified conflict with the key bindings of the input
method, hot keys take precedence over the key bindings of
the input method.


1m13.5.2.2.  Preedit State Operation0m

An input method may have several internal states, depending
on its implementation and the locale.  However, one state
that is independent of locale and implementation is whether
the input method is currently performing a preediting opera-
tion.  Xlib provides the ability for an application to man-
age the preedit state programmatically.	 Two methods are
provided for retrieving the preedit state of an input con-
text.  One method is to query the state by calling 4mXGetIC-0m
4mValues24m with the 4mXNPreeditState24m XIC value.  Another method is
to receive notification whenever the preedit state is
changed.  To receive such notification, an application needs
to register a callback by calling 4mXSetICValues24m with the
4mXNPreeditStateNotifyCallback24m XIC value.  In order to change
the preedit state programmatically, an application needs to
call 4mXSetICValues24m with 4mXNPreeditState.0m

Availability of the preedit state is input method dependent.
The input method may not provide the ability to set the
state or to retrieve the state programmatically.  Therefore,
clients have to query availability of preedit state opera-
tions by checking the supported XIC values list by calling
4mXGetIMValues24m with the 4mXNQueryICValuesList24m IM value.



			     1m4470m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


1m13.5.3.  Input Method Functions0m

To open a connection, use 4mXOpenIM24m.
__
|
XIM XOpenIM(4mdisplay24m, 4mdb24m, 4mres_name24m, 4mres_class24m)
      Display *4mdisplay24m;
      XrmDatabase 4mdb24m;
      char *4mres_name24m;
      char *4mres_class24m;


4mdisplay24m   Specifies the connection to the X server.

4mdb24m	       Specifies a pointer to the resource database.

4mres_name24m  Specifies the full resource name of the applica-
	  tion.

4mres_class24m Specifies the full class name of the application.
|__

The 4mXOpenIM24m function opens an input method, matching the
current locale and modifiers specification.  Current locale
and modifiers are bound to the input method at opening time.
The locale associated with an input method cannot be changed
dynamically.  This implies that the strings returned by
4mXmbLookupString24m or 4mXwcLookupString24m, for any input context
affiliated with a given input method, will be encoded in the
locale current at the time the input method is opened.

The specific input method to which this call will be routed
is identified on the basis of the current locale.  4mXOpenIM0m
will identify a default input method corresponding to the
current locale.	 That default can be modified using 4mXSetLo-0m
4mcaleModifiers24m for the input method modifier.

The db argument is the resource database to be used by the
input method for looking up resources that are private to
the input method.  It is not intended that this database be
used to look up values that can be set as IC values in an
input context.	If db is NULL, no database is passed to the
input method.

The res_name and res_class arguments specify the resource
name and class of the application.  They are intended to be
used as prefixes by the input method when looking up
resources that are common to all input contexts that may be
created for this input method.	The characters used for
resource names and classes must be in the X Portable Charac-
ter Set.  The resources looked up are not fully specified if
res_name or res_class is NULL.





			     1m4480m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


The res_name and res_class arguments are not assumed to
exist beyond the call to 4mXOpenIM24m.	The specified resource
database is assumed to exist for the lifetime of the input
method.

4mXOpenIM24m returns NULL if no input method could be opened.


To close a connection, use 4mXCloseIM24m.
__
|
Status XCloseIM(4mim24m)
      XIM 4mim24m;


4mim24m	       Specifies the input method.
|__

The 4mXCloseIM24m function closes the specified input method.


To set input method attributes, use 4mXSetIMValues24m.
__
|
char * XSetIMValues(4mim24m, ...)
      XIM 4mim24m;


4mim24m	       Specifies the input method.

...	  Specifies the variable-length argument list to set
	  XIM values.
|__

The 4mXSetIMValues24m function presents a variable argument list
programming interface for setting attributes of the speci-
fied input method.  It returns NULL if it succeeds; other-
wise, it returns the name of the first argument that could
not be set.  Xlib does not attempt to set arguments from the
supplied list that follow the failed argument; all arguments
in the list preceding the failed argument have been set cor-
rectly.


To query an input method, use 4mXGetIMValues24m.












			     1m4490m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
char * XGetIMValues(4mim24m, ...)
      XIM 4mim24m;


4mim24m	       Specifies the input method.

...	  Specifies the variable length argument list to get
	  XIM values.
|__

The 4mXGetIMValues24m function presents a variable argument list
programming interface for querying properties or features of
the specified input method.  This function returns NULL if
it succeeds; otherwise, it returns the name of the first
argument that could not be obtained.

Each XIM value argument (following a name) must point to a
location where the XIM value is to be stored.  That is, if
the XIM value is of type T, the argument must be of type T*.
If T itself is a pointer type, then 4mXGetIMValues24m allocates
memory to store the actual data, and the client is responsi-
ble for freeing this data by calling 4mXFree24m with the returned
pointer.


To obtain the display associated with an input method, use
4mXDisplayOfIM24m.
__
|
Display * XDisplayOfIM(4mim24m)
     XIM 4mim24m;


4mim24m	       Specifies the input method.
|__

The 4mXDisplayOfIM24m function returns the display associated
with the specified input method.


To get the locale associated with an input method, use 4mXLo-0m
4mcaleOfIM24m.
__
|
char * XLocaleOfIM(4mim24m)
      XIM 4mim24m;


4mim24m	       Specifies the input method.
|__

The 4mXLocaleOfIM24m function returns the locale associated with
the specified input method.



			     1m4500m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


To register an input method instantiate callback, use 4mXReg-0m
4misterIMInstantiateCallback24m.
__
|
Bool XRegisterIMInstantiateCallback(4mdisplay24m, 4mdb24m, 4mres_name24m, 4mres_class24m, 4mcallback24m, 4mclient_data24m)
      Display *4mdisplay24m;
      XrmDatabase 4mdb24m;
      char *4mres_name24m;
      char *4mres_class24m;
      XIMProc  4mcallback24m;
      XPointer *4mclient_data24m;


4mdisplay24m   Specifies the connection to the X server.

4mdb24m	       Specifies a pointer to the resource database.

4mres_name24m  Specifies the full resource name of the applica-
	  tion.

4mres_class24m Specifies the full class name of the application.

4mcallback24m  Specifies a pointer to the input method instanti-
	  ate callback.

4mclient_data0m
	  Specifies the additional client data.
|__

The 4mXRegisterIMInstantiateCallback24m function registers a
callback to be invoked whenever a new input method becomes
available for the specified display that matches the current
locale and modifiers.

The function returns 4mTrue0m
 if it succeeds; otherwise, it returns 4mFalse24m.

The generic prototype is as follows:



















			     1m4510m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
void IMInstantiateCallback(4mdisplay24m, 4mclient_data24m, 4mcall_data24m)
      Display *4mdisplay24m;
      XPointer 4mclient_data24m;
      XPointer 4mcall_data24m;


4mdisplay24m   Specifies the connection to the X server.

4mclient_data0m
	  Specifies the additional client data.

4mcall_data24m Not used for this callback and always passed as
	  NULL.
|__

To unregister an input method instantiation callback, use
4mXUnregisterIMInstantiateCallback24m.
__
|
Bool XUnregisterIMInstantiateCallback(4mdisplay24m, 4mdb24m, 4mres_name24m, 4mres_class24m, 4mcallback24m, 4mclient_data24m)
      Display *4mdisplay24m;
      XrmDatabase 4mdb24m;
      char *4mres_name24m;
      char *4mres_class24m;
      XIMProc  4mcallback24m;
      XPointer *4mclient_data24m;


4mdisplay24m   Specifies the connection to the X server.

4mdb24m	       Specifies a pointer to the resource database.

4mres_name24m  Specifies the full resource name of the applica-
	  tion.

4mres_class24m Specifies the full class name of the application.

4mcallback24m  Specifies a pointer to the input method instanti-
	  ate callback.

4mclient_data0m
	  Specifies the additional client data.
|__

The 4mXUnregisterIMInstantiateCallback24m function removes an
input method instantiation callback previously registered.
The function returns 4mTrue24m if it succeeds; otherwise, it
returns 4mFalse24m.

1m13.5.4.  Input Method Values0m

The following table describes how XIM values are interpreted
by an input method.  The first column lists the XIM values.



			     1m4520m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


The second column indicates how each of the XIM values are
treated by that input style.


The following keys apply to this table.

-------------------------------------------------------------
1mKey	       Explanation0m
-------------------------------------------------------------
D	     This value may be set using 4mXSetIMValues24m.  If
	     it is not set,
	     a default is provided.
S	     This value may be set using 4mXSetIMValues24m.
G	     This value may be read using 4mXGetIMValues24m.
-------------------------------------------------------------



-------------------------------
1mXIM Value		    Key0m
-------------------------------
4mXNQueryInputStyle24m		G
4mXNResourceName24m	      D-S-G
4mXNResourceClass24m	      D-S-G
4mXNDestroyCallback24m	      D-S-G
4mXNQueryIMValuesList24m	G
4mXNQueryICValuesList24m	G
4mXNVisiblePosition24m		G
4mXNR6PreeditCallbackBe-24m   D-S-G
4mhavior0m
-------------------------------


4mXNR6PreeditCallbackBehavior24m is obsolete and its use is not
recommended (see section 13.5.4.6).


1m13.5.4.1.  Query Input Style0m

A client should always query the input method to determine
which input styles are supported.  The client should then
find an input style it is capable of supporting.

If the client cannot find an input style that it can sup-
port, it should negotiate with the user the continuation of
the program (exit, choose another input method, and so on).

The argument value must be a pointer to a location where the
returned value will be stored.	The returned value is a
pointer to a structure of type 4mXIMStyles24m.	Clients are
responsible for freeing the 4mXIMStyles24m structure.  To do so,
use 4mXFree24m.





			     1m4530m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


The 4mXIMStyles24m structure is defined as follows:

__
|
typedef unsigned long XIMStyle;


#define	  4mXIMPreeditArea24m	      0x0001L
#define	  4mXIMPreeditCallbacks24m    0x0002L
#define	  4mXIMPreeditPosition24m     0x0004L
#define	  4mXIMPreeditNothing24m      0x0008L
#define	  4mXIMPreeditNone24m	      0x0010L

#define	  4mXIMStatusArea24m	      0x0100L
#define	  4mXIMStatusCallbacks24m     0x0200L
#define	  4mXIMStatusNothing24m	      0x0400L
#define	  4mXIMStatusNone24m	      0x0800L


typedef struct {
     unsigned short count_styles;
     XIMStyle * supported_styles;
} XIMStyles;

|__

An 4mXIMStyles24m structure contains the number of input styles
supported in its count_styles field.  This is also the size
of the supported_styles array.

The supported styles is a list of bitmask combinations,
which indicate the combination of styles for each of the
areas supported.  These areas are described later.  Each
element in the list should select one of the bitmask values
for each area.	The list describes the complete set of com-
binations supported.  Only these combinations are supported
by the input method.

The preedit category defines what type of support is pro-
vided by the input method for preedit information.

4mXIMPreeditArea24m    If chosen, the input method would require
		  the client to provide some area values for
		  it to do its preediting.  Refer to XIC
		  values 4mXNArea24m and 4mXNAreaNeeded24m.
4mXIMPreeditPosi-24m   If chosen, the input method would require
4mtion24m	       the client to provide positional values.
		  Refer to XIC values 4mXNSpotLocation24m and
		  4mXNFocusWindow24m.








			     1m4540m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


4mXIMPreeditCall-24m   If chosen, the input method would require
4mbacks24m	       the client to define the set of preedit
		  callbacks.  Refer to XIC values 4mXNPreedit-0m
		  4mStartCallback24m, 4mXNPreeditDoneCallback24m,
		  4mXNPreeditDrawCallback24m, and 4mXNPreeditCaret-0m
		  4mCallback24m.
4mXIMPreeditNoth-24m   If chosen, the input method can function
4ming24m	       without any preedit values.
4mXIMPreeditNone24m    The input method does not provide any
		  preedit feedback.  Any preedit value is
		  ignored.  This style is mutually exclusive
		  with the other preedit styles.


The status category defines what type of support is provided
by the input method for status information.

4mXIMStatusArea24m     The input method requires the client to
		  provide some area values for it to do its
		  status feedback.  See 4mXNArea24m and 4mXNArea-0m
		  4mNeeded24m.
4mXIMStatusCall-24m    The input method requires the client to
4mbacks24m	       define the set of status callbacks, 4mXNSta-0m
		  4mtusStartCallback24m, 4mXNStatusDoneCallback24m,
		  and 4mXNStatusDrawCallback24m.
4mXIMStatusNoth-24m    The input method can function without any
4ming24m	       status values.
4mXIMStatusNone24m     The input method does not provide any sta-
		  tus feedback.	 If chosen, any status value
		  is ignored.  This style is mutually exclu-
		  sive with the other status styles.


1m13.5.4.2.  Resource Name and Class0m

The 4mXNResourceName24m and 4mXNResourceClass24m arguments are strings
that specify the full name and class used by the input
method.	 These values should be used as prefixes for the
name and class when looking up resources that may vary
according to the input method.	If these values are not set,
the resources will not be fully specified.

It is not intended that values that can be set as XIM values
be set as resources.


1m13.5.4.3.  Destroy Callback0m

The 4mXNDestroyCallback24m argument is a pointer to a structure
of type 4mXIMCallback24m.  4mXNDestroyCallback24m is triggered when an
input method stops its service for any reason.	After the
callback is invoked, the input method is closed and the
associated input context(s) are destroyed by Xlib.  There-
fore, the client should not call 4mXCloseIM24m or 4mXDestroyIC24m.



			     1m4550m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


The generic prototype of this callback function is as fol-
lows:
__
|
void DestroyCallback(4mim24m, 4mclient_data24m, 4mcall_data24m)
      XIM 4mim24m;
      XPointer 4mclient_data24m;
      XPointer 4mcall_data24m;


4mim24m	       Specifies the input method.

4mclient_data0m
	  Specifies the additional client data.

4mcall_data24m Not used for this callback and always passed as
	  NULL.
|__

A DestroyCallback is always called with a NULL call_data
argument.


1m13.5.4.4.  Query IM/IC Values List0m

4mXNQueryIMValuesList24m and 4mXNQueryICValuesList24m are used to
query about XIM and XIC values supported by the input
method.

The argument value must be a pointer to a location where the
returned value will be stored.	The returned value is a
pointer to a structure of type 4mXIMValuesList24m.  Clients are
responsible for freeing the 4mXIMValuesList24m structure.  To do
so, use 4mXFree24m.

The 4mXIMValuesList24m structure is defined as follows:
__
|
typedef struct {
     unsigned short count_values;
     char **supported_values;
} XIMValuesList;

|__


1m13.5.4.5.  Visible Position0m

The 4mXNVisiblePosition24m argument indicates whether the visible
position masks of 4mXIMFeedback24m in 4mXIMText24m are available.

The argument value must be a pointer to a location where the
returned value will be stored.	The returned value is of
type 4mBool24m.	 If the returned value is 4mTrue24m, the input method



			     1m4560m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


uses the visible position masks of 4mXIMFeedback24m in 4mXIMText24m;
otherwise, the input method does not use the masks.

Because this XIM value is optional, a client should call
4mXGetIMValues24m with argument 4mXNQueryIMValues24m before using this
argument.  If the 4mXNVisiblePosition24m does not exist in the IM
values list returned from 4mXNQueryIMValues24m, the visible posi-
tion masks of 4mXIMFeedback24m in 4mXIMText24m are not used to indi-
cate the visible position.


1m13.5.4.6.  Preedit Callback Behavior0m

The 4mXNR6PreeditCallbackBehavior24m argument originally included
in the X11R6 specification has been deprecated.-

The 4mXNR6PreeditCallbackBehavior24m argument indicates whether
the behavior of preedit callbacks regarding 4mXIMPreeditDraw-0m
4mCallbackStruct24m values follows Release 5 or Release 6 seman-
tics.

The value is of type 4mBool24m.	 When querying for 4mXNR6Preedit-0m
4mCallbackBehavior24m, if the returned value is 4mTrue24m, the input
method uses the Release 6 behavior; otherwise, it uses the
Release 5 behavior.  The default value is 4mFalse24m.  In order
to use Release 6 semantics, the value of 4mXNR6PreeditCall-0m
4mbackBehavior24m must be set to 4mTrue24m.

Because this XIM value is optional, a client should call
4mXGetIMValues24m with argument 4mXNQueryIMValues24m before using this
argument.  If the 4mXNR6PreeditCallbackBehavior24m does not exist
in the IM values list returned from 4mXNQueryIMValues24m, the
PreeditCallback behavior is Release 5 semantics.


1m13.5.5.  Input Context Functions0m

An input context is an abstraction that is used to contain
both the data required (if any) by an input method and the
information required to display that data.  There may be
multiple input contexts for one input method.  The program-
ming interfaces for creating, reading, or modifying an input
context use a variable argument list.  The name elements of
the argument lists are referred to as XIC values.  It is
intended that input methods be controlled by these XIC
-----------
  - During formulation of the X11R6 specification,
the behavior of the R6 PreeditDrawCallbacks was
going to differ significantly from that of the R5
callbacks.  Late changes to the specification con-
verged the R5 and R6 behaviors, eliminating the
need for 4mXNR6PreeditCallbackBehavior24m.  Unfortu-
nately, this argument was not removed from the R6
specification before it was published.



			     1m4570m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


values.	 As new XIC values are created, they should be reg-
istered with the X Consortium.


To create an input context, use 4mXCreateIC24m.
__
|
XIC XCreateIC(4mim24m, ...)
      XIM 4mim24m;


4mim24m	       Specifies the input method.

...	  Specifies the variable length argument list to set
	  XIC values.
|__

The 4mXCreateIC24m function creates a context within the speci-
fied input method.

Some of the arguments are mandatory at creation time, and
the input context will not be created if those arguments are
not provided.  The mandatory arguments are the input style
and the set of text callbacks (if the input style selected
requires callbacks).  All other input context values can be
set later.

4mXCreateIC24m returns a NULL value if no input context could be
created.  A NULL value could be returned for any of the fol-
lowing reasons:

·    A required argument was not set.

·    A read-only argument was set (for example, 4mXNFil-0m
     4mterEvents24m).

·    The argument name is not recognized.

·    The input method encountered an input method implemen-
     tation-dependent error.

4mXCreateIC24m can generate 4mBadAtom24m, 4mBadColor24m, 4mBadPixmap24m, and
4mBadWindow24m errors.


To destroy an input context, use 4mXDestroyIC24m.











			     1m4580m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
void XDestroyIC(4mic24m)
      XIC 4mic24m;


4mic24m	       Specifies the input context.
|__

4mXDestroyIC24m destroys the specified input context.


To communicate to and synchronize with input method for any
changes in keyboard focus from the client side, use 4mXSetIC-0m
4mFocus24m and 4mXUnsetICFocus24m.
__
|
void XSetICFocus(4mic24m)
      XIC 4mic24m;


4mic24m	       Specifies the input context.
|__

The 4mXSetICFocus24m function allows a client to notify an input
method that the focus window attached to the specified input
context has received keyboard focus.  The input method
should take action to provide appropriate feedback.  Com-
plete feedback specification is a matter of user interface
policy.

Calling 4mXSetICFocus24m does not affect the focus window value.


__
|
void XUnsetICFocus(4mic24m)
      XIC 4mic24m;


4mic24m	       Specifies the input context.
|__

The 4mXUnsetICFocus24m function allows a client to notify an
input method that the specified input context has lost the
keyboard focus and that no more input is expected on the
focus window attached to that input context.  The input
method should take action to provide appropriate feedback.
Complete feedback specification is a matter of user inter-
face policy.

Calling 4mXUnsetICFocus24m does not affect the focus window
value; the client may still receive events from the input
method that are directed to the focus window.




			     1m4590m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


To reset the state of an input context to its initial state,
use 4mXmbResetIC24m, 4mXwcResetIC24m or 4mXutf8ResetIC24m.
__
|
char * XmbResetIC(4mic24m)
      XIC 4mic24m;


wchar_t * XwcResetIC(4mic24m)
      XIC 4mic24m;


char * Xutf8ResetIC(4mic24m)
      XIC 4mic24m;


4mic24m	       Specifies the input context.
|__

When 4mXNResetState24m is set to 4mXIMInitialState24m, 4mXmbResetIC24m,
4mXwcResetIC24m and 4mXutf8ResetIC24m reset an input context to its
initial state; when 4mXNResetState24m is set to 4mXIMPreserveState24m,
the current input context state is preserved.  In both
cases, any input pending on that context is deleted.  The
input method is required to clear the preedit area, if any,
and update the status accordingly.  Calling 4mXmbResetIC24m,
4mXwcResetIC24m or 4mXutf8ResetIC24m does not change the focus.

The return value of 4mXmbResetIC24m is its current preedit string
as a multibyte string.	The return value of 4mXwcResetIC24m is
its current preedit string as a wide character string.	The
return value of 4mXutf8ResetIC24m is its current preedit string
as an UTF-8 string.  If there is any preedit text drawn or
visible to the user, then these procedures must return a
non-NULL string.  If there is no visible preedit text, then
it is input method implementation-dependent whether these
procedures return a non-NULL string or NULL.

The client should free the returned string by calling 4mXFree24m.

The function 4mXutf8ResetIC24m is an XFree86 extension introduced
in XFree86 4.0.2. Its presence is indicated by the macro
4mX_HAVE_UTF8_STRING24m.


To get the input method associated with an input context,
use 4mXIMOfIC24m.










			     1m4600m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
XIM XIMOfIC(4mic24m)
      XIC 4mic24m;


4mic24m	       Specifies the input context.
|__

The 4mXIMOfIC24m function returns the input method associated
with the specified input context.


Xlib provides two functions for setting and reading XIC val-
ues, respectively, 4mXSetICValues24m and 4mXGetICValues24m.  Both
functions have a variable-length argument list.	 In that
argument list, any XIC value's name must be denoted with a
character string using the X Portable Character Set.


To set XIC values, use 4mXSetICValues24m.
__
|
char * XSetICValues(4mic24m, ...)
      XIC 4mic24m;


4mic24m	       Specifies the input context.

...	  Specifies the variable length argument list to set
	  XIC values.
|__

The 4mXSetICValues24m function returns NULL if no error occurred;
otherwise, it returns the name of the first argument that
could not be set.  An argument might not be set for any of
the following reasons:

·    The argument is read-only (for example, 4mXNFil-0m
     4mterEvents24m).

·    The argument name is not recognized.

·    An implementation-dependent error occurs.

Each value to be set must be an appropriate datum, matching
the data type imposed by the semantics of the argument.

4mXSetICValues24m can generate 4mBadAtom24m, 4mBadColor24m, 4mBadCursor24m, 4mBad-0m
4mPixmap24m, and 4mBadWindow24m errors.


To obtain XIC values, use 4mXGetICValues24m.





			     1m4610m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
char * XGetICValues(4mic24m, ...)
      XIC 4mic24m;


4mic24m	       Specifies the input context.

...	  Specifies the variable length argument list to get
	  XIC values.
|__

The 4mXGetICValues24m function returns NULL if no error occurred;
otherwise, it returns the name of the first argument that
could not be obtained.	An argument could not be obtained
for any of the following reasons:

·    The argument name is not recognized.

·    The input method encountered an implementation-depen-
     dent error.

Each IC attribute value argument (following a name) must
point to a location where the IC value is to be stored.
That is, if the IC value is of type T, the argument must be
of type T*.  If T itself is a pointer type, then 4mXGetICVal-0m
4mues24m allocates memory to store the actual data, and the
client is responsible for freeing this data by calling 4mXFree0m
with the returned pointer.  The exception to this rule is
for an IC value of type 4mXVaNestedList24m (for preedit and sta-
tus attributes).  In this case,	 the argument must also be
of type 4mXVaNestedList24m.  Then, the rule of changing type T to
T* and freeing the allocated data applies to each element of
the nested list.

1m13.5.6.  Input Context Values0m

The following tables describe how XIC values are interpreted
by an input method depending on the input style chosen by
the user.

The first column lists the XIC values.	The second column
indicates which values are involved in affecting, negotiat-
ing, and setting the geometry of the input method windows.
The subentries under the third column indicate the different
input styles that are supported.  Each of these columns
indicates how each of the XIC values are treated by that
input style.

The following keys apply to these tables.








			     1m4620m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


-------------------------------------------------------------
1mKey	       Explanation0m
-------------------------------------------------------------
C	     This value must be set with 4mXCreateIC24m.
D	     This value may be set using 4mXCreateIC24m.  If it
	     is not set, a default is provided.
G	     This value may be read using 4mXGetICValues24m.
GN	     This value may cause geometry negotiation when
	     its value is set by means of 4mXCreateIC24m or 4mXSet-0m
	     4mICValues24m.
GR	     This value will be the response of the input
	     method when any GN value is changed.
GS	     This value will cause the geometry of the input
	     method window to be set.
O	     This value must be set once and only once.	 It
	     need not be set at create time.
S	     This value may be set with 4mXSetICValues24m.
Ignored	     This value is ignored by the input method for
	     the given input style.
-------------------------------------------------------------



-----------------------------------------------------------------------------------------------
								1mInput Style0m
1mXIC Value			   Geometry    Preedit	  Preedit    Preedit   Preedit	 Preedit0m
				1mManagement   Callback	  Position    Area     Nothing	  None0m
-----------------------------------------------------------------------------------------------
Input Style				       C-G	  C-G	     C-G       C-G	 C-G
Client Window				       O-G	  O-G	     O-G       O-G     Ignored
Focus Window			    GN	      D-S-G	 D-S-G	    D-S-G     D-S-G    Ignored
Resource Name				     Ignored	 D-S-G	    D-S-G     D-S-G    Ignored
Resource Class				     Ignored	 D-S-G	    D-S-G     D-S-G    Ignored
Geometry Callback			     Ignored	Ignored	    D-S-G    Ignored   Ignored
Filter Events					G	   G	      G		G      Ignored
Destroy Callback			      D-S-G	 D-S-G	    D-S-G     D-S-G	D-S-G
String Conversion Callback		       S-G	  S-G	     S-G       S-G	 S-G
String Conversion			      D-S-G	 D-S-G	    D-S-G     D-S-G	D-S-G
Reset State				      D-S-G	 D-S-G	    D-S-G     D-S-G    Ignored
HotKey					       S-G	  S-G	     S-G       S-G     Ignored
HotKeyState				      D-S-G	 D-S-G	    D-S-G     D-S-G    Ignored
1mPreedit0m
Area				    GS	     Ignored	 D-S-G	    D-S-G    Ignored   Ignored
Area Needed			  GN-GR	     Ignored	Ignored	     S-G     Ignored   Ignored
Spot Location				     Ignored	 D-S-G	   Ignored   Ignored   Ignored
Colormap				     Ignored	 D-S-G	    D-S-G     D-S-G    Ignored
Foreground				     Ignored	 D-S-G	    D-S-G     D-S-G    Ignored
Background				     Ignored	 D-S-G	    D-S-G     D-S-G    Ignored
Background Pixmap			     Ignored	 D-S-G	    D-S-G     D-S-G    Ignored
Font Set			    GN	     Ignored	 D-S-G	    D-S-G     D-S-G    Ignored
Line Spacing			    GN	     Ignored	 D-S-G	    D-S-G     D-S-G    Ignored
Cursor					     Ignored	 D-S-G	    D-S-G     D-S-G    Ignored
Preedit State				      D-S-G	 D-S-G	    D-S-G     D-S-G    Ignored




			     1m4630m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


-----------------------------------------------------------------------------------------------
								1mInput Style0m
1mXIC Value			   Geometry    Preedit	  Preedit    Preedit   Preedit	 Preedit0m
				1mManagement   Callback	  Position    Area     Nothing	  None0m
-----------------------------------------------------------------------------------------------
Preedit State Notify Callback		       S-G	  S-G	     S-G       S-G     Ignored
Preedit Callbacks			      C-S-G	Ignored	   Ignored   Ignored   Ignored
-----------------------------------------------------------------------------------------------



------------------------------------------------------------------------
					      1mInput Style0m
1mXIC Value	       Geometry	    Status    Status	Status	  Status0m
		    1mManagement   Callback    Area	Nothing	   None0m
------------------------------------------------------------------------
Input Style			   C-G	      C-G	C-G	  C-G
Client Window			   O-G	      O-G	O-G	Ignored
Focus Window		GN	  D-S-G	     D-S-G     D-S-G	Ignored
Resource Name			 Ignored     D-S-G     D-S-G	Ignored
Resource Class			 Ignored     D-S-G     D-S-G	Ignored
Geometry Callback		 Ignored     D-S-G    Ignored	Ignored
Filter Events			    G	       G	 G	   G
1mStatus0m
Area			GS	 Ignored     D-S-G    Ignored	Ignored
Area Needed	      GN-GR	 Ignored      S-G     Ignored	Ignored
Colormap			 Ignored     D-S-G     D-S-G	Ignored
Foreground			 Ignored     D-S-G     D-S-G	Ignored
Background			 Ignored     D-S-G     D-S-G	Ignored
Background Pixmap		 Ignored     D-S-G     D-S-G	Ignored
Font Set		GN	 Ignored     D-S-G     D-S-G	Ignored
Line Spacing		GN	 Ignored     D-S-G     D-S-G	Ignored
Cursor				 Ignored     D-S-G     D-S-G	Ignored
Status Callbacks		  C-S-G	    Ignored   Ignored	Ignored
------------------------------------------------------------------------


1m13.5.6.1.  Input Style0m

The 4mXNInputStyle24m argument specifies the input style to be
used.  The value of this argument must be one of the values
returned by the 4mXGetIMValues24m function with the 4mXNQueryInput-0m
4mStyle24m argument specified in the supported_styles list.

Note that this argument must be set at creation time and
cannot be changed.

1m13.5.6.2.  Client Window0m

The 4mXNClientWindow24m argument specifies to the input method
the client window in which the input method can display data
or create subwindows.  Geometry values for input method
areas are given with respect to the client window.  Dynamic
change of client window is not supported.  This argument may



			     1m4640m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


be set only once and should be set before any input is done
using this input context.  If it is not set, the input
method may not operate correctly.

If an attempt is made to set this value a second time with
4mXSetICValues24m, the string 4mXNClientWindow24m will be returned by
4mXSetICValues24m, and the client window will not be changed.

If the client window is not a valid window ID on the display
attached to the input method, a 4mBadWindow24m error can be gen-
erated when this value is used by the input method.

1m13.5.6.3.  Focus Window0m

The 4mXNFocusWindow24m argument specifies the focus window.  The
primary purpose of the 4mXNFocusWindow24m is to identify the win-
dow that will receive the key event when input is composed.
In addition, the input method may possibly affect the focus
window as follows:

·    Select events on it

·    Send events to it

·    Modify its properties

·    Grab the keyboard within that window

The associated value must be of type 4mWindow24m.  If the focus
window is not a valid window ID on the display attached to
the input method, a 4mBadWindow24m error can be generated when
this value is used by the input method.

When this XIC value is left unspecified, the input method
will use the client window as the default focus window.

1m13.5.6.4.  Resource Name and Class0m

The 4mXNResourceName24m and 4mXNResourceClass24m arguments are strings
that specify the full name and class used by the client to
obtain resources for the client window.	 These values should
be used as prefixes for name and class when looking up
resources that may vary according to the input context.	 If
these values are not set, the resources will not be fully
specified.

It is not intended that values that can be set as XIC values
be set as resources.

1m13.5.6.5.  Geometry Callback0m

The 4mXNGeometryCallback24m argument is a structure of type 4mXIM-0m
4mCallback24m (see section 13.5.6.13.12).




			     1m4650m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


The 4mXNGeometryCallback24m argument specifies the geometry call-
back that a client can set.  This callback is not required
for correct operation of either an input method or a client.
It can be set for a client whose user interface policy per-
mits an input method to request the dynamic change of that
input method's window.	An input method that does dynamic
change will need to filter any events that it uses to initi-
ate the change.

1m13.5.6.6.  Filter Events0m

The 4mXNFilterEvents24m argument returns the event mask that an
input method needs to have selected for.  The client is
expected to augment its own event mask for the client window
with this one.

This argument is read-only, is set by the input method at
create time, and is never changed.

The type of this argument is 4munsigned24m 4mlong24m.  Setting this
value will cause an error.

1m13.5.6.7.  Destroy Callback0m

The 4mXNDestroyCallback24m argument is a pointer to a structure
of type 4mXIMCallback24m (see section 13.5.6.13.12).  This call-
back is triggered when the input method stops its service
for any reason; for example, when a connection to an IM
server is broken.  After the destroy callback is called, the
input context is destroyed and the input method is closed.
Therefore, the client should not call 4mXDestroyIC24m and 4mXClo-0m
4mseIM24m.


1m13.5.6.8.  String Conversion Callback0m

The 4mXNStringConversionCallback24m argument is a structure of
type 4mXIMCallback24m (see section 13.5.6.13.12).

The 4mXNStringConversionCallback24m argument specifies a string
conversion callback.  This callback is not required for cor-
rect operation of either the input method or the client.  It
can be set by a client to support string conversions that
may be requested by the input method.  An input method that
does string conversions will filter any events that it uses
to initiate the conversion.

Because this XIC value is optional, a client should call
4mXGetIMValues24m with argument 4mXNQueryICValuesList24m before using
this argument.







			     1m4660m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


1m13.5.6.9.  String Conversion0m

The 4mXNStringConversion24m argument is a structure of type 4mXIM-0m
4mStringConversionText24m.

The 4mXNStringConversion24m argument specifies the string to be
converted by an input method.  This argument is not required
for correct operation of either the input method or the
client.

String conversion facilitates the manipulation of text inde-
pendent of preediting.	It is essential for some input meth-
ods and clients to manipulate text by performing context-
sensitive conversion, reconversion, or transliteration con-
version on it.

Because this XIC value is optional, a client should call
4mXGetIMValues24m with argument 4mXNQueryICValuesList24m before using
this argument.

The 4mXIMStringConversionText24m structure is defined as follows:

__
|

typedef struct _XIMStringConversionText {
     unsigned short length;
     XIMStringConversionFeedback *feedback;
     Bool encoding_is_wchar;
     union {
	  char *mbs;
	  wchar_t *wcs;
     } string;
} XIMStringConversionText;

typedef unsigned long XIMStringConversionFeedback;

|__

The feedback member is reserved for future use.	 The text to
be converted is defined by the string and length members.
The length is indicated in characters.	To prevent the
library from freeing memory pointed to by an uninitialized
pointer, the client should set the feedback element to NULL.


1m13.5.6.10.  Reset State0m

The 4mXNResetState24m argument specifies the state the input con-
text will return to after calling 4mXmbResetIC24m, 4mXwcResetIC24m or
4mXutf8ResetIC24m.

The XIC state may be set to its initial state, as specified
by the 4mXNPreeditState24m value when 4mXCreateIC24m was called, or it



			     1m4670m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


may be set to preserve the current state.

The valid masks for 4mXIMResetState24m are as follows:

__
|

typedef unsigned long XIMResetState;


#define	  4mXIMInitialState24m	      (1L)
#define	  4mXIMPreserveState24m	      (1L<<1)

|__

If 4mXIMInitialState24m is set, then 4mXmbResetIC24m, 4mXwcResetIC24m and
4mXutf8ResetIC24m will return to the initial 4mXNPreeditState24m state
of the XIC.

If 4mXIMPreserveState24m is set, then 4mXmbResetIC24m, 4mXwcResetIC24m and
4mXutf8ResetIC24m will preserve the current state of the XIC.

If 4mXNResetState24m is left unspecified, the default is 4mXIMIni-0m
4mtialState24m.

4mXIMResetState24m values other than those specified above will
default to 4mXIMInitialState24m.

Because this XIC value is optional, a client should call
4mXGetIMValues24m with argument 4mXNQueryICValuesList24m before using
this argument.


1m13.5.6.11.  Hot Keys0m

The 4mXNHotKey24m argument specifies the hot key list to the XIC.
The hot key list is a pointer to the structure of type
4mXIMHotKeyTriggers24m, which specifies the key events that must
be received without any interruption of the input method.
For the hot key list set with this argument to be utilized,
the client must also set 4mXNHotKeyState24m to 4mXIMHotKeyStateON24m.

Because this XIC value is optional, a client should call
4mXGetIMValues24m with argument 4mXNQueryICValuesList24m before using
this functionality.

The value of the argument is a pointer to a structure of
type 4mXIMHotKeyTriggers24m.

If an event for a key in the hot key list is found, then the
process will receive the event and it will be processed
inside the client.





			     1m4680m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
typedef struct {
     KeySym keysym;
     unsigned int modifier;
     unsigned int modifier_mask;
} XIMHotKeyTrigger;

typedef struct {
     int num_hot_key;
     XIMHotKeyTrigger *key;
} XIMHotKeyTriggers;

|__


The combination of modifier and modifier_mask are used to
represent one of three states for each modifier: either the
modifier must be on, or the modifier must be off, or the
modifier is a ``don't care'' - it may be on or off.  When a
modifier_mask bit is set to 0, the state of the associated
modifier is ignored when evaluating whether the key is hot
or not.

-----------------------------------------------------------
1mModifier Bit	 Mask Bit     Meaning0m
-----------------------------------------------------------
0	       1	    The modifier must be off.
1	       1	    The modifier must be on.
n/a	       0	    Do not care if the modifier is
			    on or off.
-----------------------------------------------------------


1m13.5.6.12.  Hot Key State0m

The 4mXNHotKeyState24m argument specifies the hot key state of
the input method.  This is usually used to switch the input
method between hot key operation and normal input process-
ing.

The value of the argument is a pointer to a structure of
type XIMHotKeyState .

__
|
typedef unsigned long XIMHotKeyState;


#define	  4mXIMHotKeyStateON24m			(0x0001L)
#define	  4mXIMHotKeyStateOFF24m		(0x0002L)

|__





			     1m4690m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


If not specified, the default is 4mXIMHotKeyStateOFF24m.


1m13.5.6.13.  Preedit and Status Attributes0m

The 4mXNPreeditAttributes24m and 4mXNStatusAttributes24m arguments
specify to an input method the attributes to be used for the
preedit and status areas, if any.  Those attributes are
passed to 4mXSetICValues24m or 4mXGetICValues24m as a nested variable-
length list.  The names to be used in these lists are
described in the following sections.

1m13.5.6.13.1.	Area0m

The value of the 4mXNArea24m argument must be a pointer to a
structure of type 4mXRectangle.24m The interpretation of the
4mXNArea24m argument is dependent on the input method style that
has been set.

If the input method style is 4mXIMPreeditPosition24m, 4mXNArea0m
specifies the clipping region within which preediting will
take place.  If the focus window has been set, the coordi-
nates are assumed to be relative to the focus window.  Oth-
erwise, the coordinates are assumed to be relative to the
client window.	If neither has been set, the results are
undefined.

If 4mXNArea24m is not specified, is set to NULL, or is invalid,
the input method will default the clipping region to the
geometry of the 4mXNFocusWindow24m.  If the area specified is
NULL or invalid, the results are undefined.

If the input style is 4mXIMPreeditArea24m or 4mXIMStatusArea24m,
4mXNArea24m specifies the geometry provided by the client to the
input method.  The input method may use this area to display
its data, either preedit or status depending on the area
designated.  The input method may create a window as a child
of the client window with dimensions that fit the 4mXNArea24m.
The coordinates are relative to the client window.  If the
client window has not been set yet, the input method should
save these values and apply them when the client window is
set.  If 4mXNArea24m is not specified, is set to NULL, or is
invalid, the results are undefined.

1m13.5.6.13.2.	Area Needed0m

When set, the 4mXNAreaNeeded24m argument specifies the geometry
suggested by the client for this area (preedit or status).
The value associated with the argument must be a pointer to
a structure of type 4mXRectangle24m.  Note that the x, y values
are not used and that nonzero values for width or height are
the constraints that the client wishes the input method to
respect.




			     1m4700m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


When read, the 4mXNAreaNeeded24m argument specifies the preferred
geometry desired by the input method for the area.

This argument is only valid if the input style is 4mXIMPreed-0m
4mitArea24m or 4mXIMStatusArea24m.  It is used for geometry negotia-
tion between the client and the input method and has no
other effect on the input method (see section 13.5.1.5).

1m13.5.6.13.3.	Spot Location0m

The 4mXNSpotLocation24m argument specifies to the input method
the coordinates of the spot to be used by an input method
executing with 4mXNInputStyle24m set to 4mXIMPreeditPosition24m.  When
specified to any input method other than 4mXIMPreeditPosition24m,
this XIC value is ignored.

The x coordinate specifies the position where the next char-
acter would be inserted.  The y coordinate is the position
of the baseline used by the current text line in the focus
window.	 The x and y coordinates are relative to the focus
window, if it has been set; otherwise, they are relative to
the client window.  If neither the focus window nor the
client window has been set, the results are undefined.

The value of the argument is a pointer to a structure of
type 4mXPoint24m.

1m13.5.6.13.4.	Colormap0m

Two different arguments can be used to indicate what col-
ormap the input method should use to allocate colors, a col-
ormap ID, or a standard colormap name.

The 4mXNColormap24m argument is used to specify a colormap ID.
The argument value is of type 4mColormap24m.  An invalid argument
may generate a 4mBadColor24m error when it is used by the input
method.

The 4mXNStdColormap24m argument is used to indicate the name of
the standard colormap in which the input method should allo-
cate colors.  The argument value is an 4mAtom24m that should be a
valid atom for calling 4mXGetRGBColormaps24m.  An invalid argu-
ment may generate a 4mBadAtom24m error when it is used by the
input method.

If the colormap is left unspecified, the client window col-
ormap becomes the default.

1m13.5.6.13.5.	Foreground and Background0m

The 4mXNForeground24m and 4mXNBackground24m arguments specify the
foreground and background pixel, respectively.	The argument
value is of type 4munsigned24m 4mlong24m.  It must be a valid pixel in
the input method colormap.



			     1m4710m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


If these values are left unspecified, the default is deter-
mined by the input method.

1m13.5.6.13.6.	Background Pixmap0m

The 4mXNBackgroundPixmap24m argument specifies a background
pixmap to be used as the background of the window.  The
value must be of type 4mPixmap24m.  An invalid argument may gen-
erate a 4mBadPixmap24m error when it is used by the input method.

If this value is left unspecified, the default is determined
by the input method.

1m13.5.6.13.7.	Font Set0m

The 4mXNFontSet24m argument specifies to the input method what
font set is to be used.	 The argument value is of type
4mXFontSet24m.

If this value is left unspecified, the default is determined
by the input method.

1m13.5.6.13.8.	Line Spacing0m

The 4mXNLineSpace24m argument specifies to the input method what
line spacing is to be used in the preedit window if more
than one line is to be used.  This argument is of type 4mint24m.

If this value is left unspecified, the default is determined
by the input method.

1m13.5.6.13.9.	Cursor0m

The 4mXNCursor24m argument specifies to the input method what
cursor is to be used in the specified window.  This argument
is of type 4mCursor24m.

An invalid argument may generate a 4mBadCursor24m error when it
is used by the input method.  If this value is left unspeci-
fied, the default is determined by the input method.

1m13.5.6.13.10.	 Preedit State0m

The 4mXNPreeditState24m argument specifies the state of input
preediting for the input method.  Input preediting can be on
or off.

The valid mask names for 4mXNPreeditState24m are as follows:









			     1m4720m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|

typedef unsigned long XIMPreeditState;


#define	  4mXIMPreeditUnknown24m      0L
#define	  4mXIMPreeditEnable24m	      1L
#define	  4mXIMPreeditDisable24m      (1L<<1)

|__

If a value of 4mXIMPreeditEnable24m is set, then input preediting
is turned on by the input method.

If a value of 4mXIMPreeditDisable24m is set, then input preedit-
ing is turned off by the input method.

If 4mXNPreeditState24m is left unspecified, then the state will
be implementation-dependent.

When 4mXNResetState24m is set to 4mXIMInitialState24m, the 4mXNPreedit-0m
4mState24m value specified at the creation time will be reflected
as the initial state for 4mXmbResetIC24m, 4mXwcResetIC24m and
4mXutf8ResetIC24m.

Because this XIC value is optional, a client should call
4mXGetIMValues24m with argument 4mXNQueryICValuesList24m before using
this argument.

1m13.5.6.13.11.	 Preedit State Notify Callback0m

The preedit state notify callback is triggered by the input
method when the preediting state has changed.  The value of
the 4mXNPreeditStateNotifyCallback24m argument is a pointer to a
structure of type 4mXIMCallback24m.  The generic prototype is as
follows:
__
|
void PreeditStateNotifyCallback(4mic24m, 4mclient_data24m, 4mcall_data24m)
      XIC 4mic24m;
      XPointer 4mclient_data24m;
      XIMPreeditStateNotifyCallbackStruct *4mcall_data24m;


4mic24m	       Specifies the input context.

4mclient_data0m
	  Specifies the additional client data.

4mcall_data24m Specifies the current preedit state.
|__

The 4mXIMPreeditStateNotifyCallbackStruct24m structure is defined
as follows:



			     1m4730m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
typedef struct _XIMPreeditStateNotifyCallbackStruct {
     XIMPreeditState state;
} XIMPreeditStateNotifyCallbackStruct;

|__


Because this XIC value is optional, a client should call
4mXGetIMValues24m with argument 4mXNQueryICValuesList24m before using
this argument.

1m13.5.6.13.12.	 Preedit and Status Callbacks0m

A client that wants to support the input style 4mXIMPreedit-0m
4mCallbacks24m must provide a set of preedit callbacks to the
input method.  The set of preedit callbacks is as follows:

4mXNPreeditStart-24m	 This is called when the input method
4mCallback24m		 starts preedit.
4mXNPreedit-24m		 This is called when the input method
4mDoneCallback24m	 stops preedit.
4mXNPreeditDraw-24m	 This is called when a number of preedit
4mCallback24m		 keystrokes should be echoed.
4mXNPreeditCaret-24m	 This is called to move the text inser-
4mCallback24m		 tion point within the preedit string.


A client that wants to support the input style 4mXIMStatus-0m
4mCallbacks24m must provide a set of status callbacks to the
input method.  The set of status callbacks is as follows:

4mXNStatusStart-24m	 This is called when the input method
4mCallback24m		 initializes the status area.
4mXNStatusDoneCall-24m	 This is called when the input method no
4mback24m		 longer needs the status area.
4mXNStatusDrawCall-24m	 This is called when updating of the sta-
4mback24m		 tus area is required.


The value of any status or preedit argument is a pointer to
a structure of type 4mXIMCallback24m.















			     1m4740m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|

typedef void (*XIMProc)();

typedef struct {
     XPointer client_data;
     XIMProc callback;
} XIMCallback;

|__

Each callback has some particular semantics and will carry
the data that expresses the environment necessary to the
client into a specific data structure.	This paragraph only
describes the arguments to be used to set the callback.

Setting any of these values while doing preedit may cause
unexpected results.

1m13.5.7.  Input Method Callback Semantics0m

XIM callbacks are procedures defined by clients or text
drawing packages that are to be called from the input method
when selected events occur.  Most clients will use a text
editing package or a toolkit and, hence, will not need to
define such callbacks.	This section defines the callback
semantics, when they are triggered, and what their arguments
are.  This information is mostly useful for X toolkit imple-
mentors.

Callbacks are mostly provided so that clients (or text edit-
ing packages) can implement on-the-spot preediting in their
own window.  In that case, the input method needs to commu-
nicate and synchronize with the client.	 The input method
needs to communicate changes in the preedit window when it
is under control of the client.	 Those callbacks allow the
client to initialize the preedit area, display a new preedit
string, move the text insertion point during preedit, termi-
nate preedit, or update the status area.

All callback procedures follow the generic prototype:
















			     1m4750m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
void CallbackPrototype(4mic24m, 4mclient_data24m, 4mcall_data24m)
      XIC 4mic24m;
      XPointer 4mclient_data24m;
      SomeType 4mcall_data24m;


4mic24m	       Specifies the input context.

4mclient_data0m
	  Specifies the additional client data.

4mcall_data24m Specifies data specific to the callback.
|__

The call_data argument is a structure that expresses the
arguments needed to achieve the semantics; that is, it is a
specific data structure appropriate to the callback.  In
cases where no data is needed in the callback, this
call_data argument is NULL.  The client_data argument is a
closure that has been initially specified by the client when
specifying the callback and passed back.  It may serve, for
example, to inherit application context in the callback.

The following paragraphs describe the programming semantics
and specific data structure associated with the different
reasons.

1m13.5.7.1.  Geometry Callback0m

The geometry callback is triggered by the input method to
indicate that it wants the client to negotiate geometry.
The generic prototype is as follows:
__
|
void GeometryCallback(4mic24m, 4mclient_data24m, 4mcall_data24m)
      XIC 4mic24m;
      XPointer 4mclient_data24m;
      XPointer 4mcall_data24m;


4mic24m	       Specifies the input context.

4mclient_data0m
	  Specifies the additional client data.

4mcall_data24m Not used for this callback and always passed as
	  NULL.
|__

The callback is called with a NULL call_data argument.






			     1m4760m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


1m13.5.7.2.  Destroy Callback0m

The destroy callback is triggered by the input method when
it stops service for any reason.  After the callback is
invoked, the input context will be freed by Xlib.  The
generic prototype is as follows:
__
|
void DestroyCallback(4mic24m, 4mclient_data24m, 4mcall_data24m)
      XIC 4mic24m;
      XPointer 4mclient_data24m;
      XPointer 4mcall_data24m;


4mic24m	       Specifies the input context.

4mclient_data0m
	  Specifies the additional client data.

4mcall_data24m Not used for this callback and always passed as
	  NULL.
|__

The callback is called with a NULL call_data argument.

1m13.5.7.3.  String Conversion Callback0m

The string conversion callback is triggered by the input
method to request the client to return the string to be con-
verted.	 The returned string may be either a multibyte or
wide character string, with an encoding matching the locale
bound to the input context.  The callback prototype is as
follows:
__
|
void StringConversionCallback(4mic24m, 4mclient_data24m, 4mcall_data24m)
      XIC 4mic24m;
      XPointer 4mclient_data24m;
      XIMStringConversionCallbackStruct *4mcall_data24m;


4mic24m	       Specifies the input method.

4mclient_data0m
	  Specifies the additional client data.

4mcall_data24m Specifies the amount of the string to be con-
	  verted.
|__

The callback is passed an 4mXIMStringConversionCallbackStruct0m
structure in the call_data argument.  The text member is an
4mXIMStringConversionText24m structure (see section 13.5.6.9) to
be filled in by the client and describes the text to be sent



			     1m4770m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


to the input method.  The data pointed to by the string and
feedback elements of the 4mXIMStringConversionText24m structure
will be freed using 4mXFree24m by the input method after the
callback returns.  So the client should not point to inter-
nal buffers that are critical to the client.  Similarly,
because the feedback element is currently reserved for
future use, the client should set feedback to NULL to pre-
vent the library from freeing memory at some random location
due to an uninitialized pointer.

The 4mXIMStringConversionCallbackStruct24m structure is defined
as follows:

__
|

typedef struct _XIMStringConversionCallbackStruct {
     XIMStringConversionPosition position;
     XIMCaretDirection direction;
     short factor;
     XIMStringConversionOperation operation;
     XIMStringConversionText *text;
} XIMStringConversionCallbackStruct;

typedef short XIMStringConversionPosition;

typedef unsigned short XIMStringConversionOperation;




#define	  4mXIMStringConversionSubstitu-24m	(0x0001)
	  4mtion0m
#define	  4mXIMStringConversionRetrieval24m	(0x0002)

|__

4mXIMStringConversionPosition24m specifies the starting position
of the string to be returned in the 4mXIMStringConversionText0m
structure.  The value identifies a position, in units of
characters, relative to the client's cursor position in the
client's buffer.

The ending position of the text buffer is determined by the
direction and factor members.  Specifically, it is the char-
acter position relative to the starting point as defined by
the 4mXIMCaretDirection24m.  The factor member of 4mXIMStringCon-0m
4mversionCallbackStruct24m specifies the number of 4mXIMCaretDirec-0m
4mtion24m positions to be applied.  For example, if the direction
specifies 4mXIMLineEnd24m and factor is 1, then all characters
from the starting position to the end of the current display
line are returned.  If the direction specifies 4mXIMForward-0m
4mChar24m or 4mXIMBackwardChar24m, then the factor specifies a rela-
tive position, indicated in characters, from the starting



			     1m4780m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


position.

4mXIMStringConversionOperation24m specifies whether the string to
be converted should be deleted (substitution) or copied
(retrieval) from the client's buffer.  When the 4mXIMString-0m
4mConversionOperation24m is 4mXIMStringConversionSubstitution24m, the
client must delete the string to be converted from its own
buffer.	 When the 4mXIMStringConversionOperation24m is 4mXIMString-0m
4mConversionRetrieval24m, the client must not delete the string
to be converted from its buffer.  The substitute operation
is typically used for reconversion and transliteration con-
version, while the retrieval operation is typically used for
context-sensitive conversion.

1m13.5.7.4.  Preedit State Callbacks0m

When the input method turns preediting on or off, a 4mPreedit-0m
4mStartCallback24m or 4mPreeditDoneCallback24m callback is triggered
to let the toolkit do the setup or the cleanup for the
preedit region.
__
|
int PreeditStartCallback(4mic24m, 4mclient_data24m, 4mcall_data24m)
      XIC 4mic24m;
      XPointer 4mclient_data24m;
      XPointer 4mcall_data24m;


4mic24m	       Specifies the input context.

4mclient_data0m
	  Specifies the additional client data.

4mcall_data24m Not used for this callback and always passed as
	  NULL.
|__

When preedit starts on the specified input context, the
callback is called with a NULL call_data argument.  4mPreedit-0m
4mStartCallback24m will return the maximum size of the preedit
string.	 A positive number indicates the maximum number of
bytes allowed in the preedit string, and a value of -1 indi-
cates there is no limit.














			     1m4790m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
void PreeditDoneCallback(4mic24m, 4mclient_data24m, 4mcall_data24m)
      XIC 4mic24m;
      XPointer 4mclient_data24m;
      XPointer 4mcall_data24m;


4mic24m	       Specifies the input context.

4mclient_data0m
	  Specifies the additional client data.

4mcall_data24m Not used for this callback and always passed as
	  NULL.
|__

When preedit stops on the specified input context, the call-
back is called with a NULL call_data argument.	The client
can release the data allocated by 4mPreeditStartCallback24m.

4mPreeditStartCallback24m should initialize appropriate data
needed for displaying preedit information and for handling
further 4mPreeditDrawCallback24m calls.	 Once 4mPreeditStartCall-0m
4mback24m is called, it will not be called again before 4mPreedit-0m
4mDoneCallback24m has been called.

1m13.5.7.5.  Preedit Draw Callback0m

This callback is triggered to draw and insert, delete or
replace, preedit text in the preedit region.  The preedit
text may include unconverted input text such as Japanese
Kana, converted text such as Japanese Kanji characters, or
characters of both kinds.  That string is either a multibyte
or wide character string, whose encoding matches the locale
bound to the input context.  The callback prototype is as
follows:
__
|
void PreeditDrawCallback(4mic24m, 4mclient_data24m, 4mcall_data24m)
      XIC 4mic24m;
      XPointer 4mclient_data24m;
      XIMPreeditDrawCallbackStruct *4mcall_data24m;


4mic24m	       Specifies the input context.

4mclient_data0m
	  Specifies the additional client data.

4mcall_data24m Specifies the preedit drawing information.
|__

The callback is passed an 4mXIMPreeditDrawCallbackStruct0m
structure in the call_data argument.  The text member of



			     1m4800m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


this structure contains the text to be drawn.  After the
string has been drawn, the caret should be moved to the
specified location.

The 4mXIMPreeditDrawCallbackStruct24m structure is defined as
follows:

__
|
typedef struct _XIMPreeditDrawCallbackStruct {
     int caret;		 /* Cursor offset within preedit string */
     int chg_first;	 /* Starting change position */
     int chg_length;	 /* Length of the change in character count */
     XIMText *text;
} XIMPreeditDrawCallbackStruct;

|__

The client must keep updating a buffer of the preedit text
and the callback arguments referring to indexes in that
buffer.	 The call_data fields have specific meanings accord-
ing to the operation, as follows:

·    To indicate text deletion, the call_data member speci-
     fies a NULL text field.  The text to be deleted is then
     the current text in the buffer from position chg_first
     (starting at zero) on a character length of chg_length.

·    When text is non-NULL, it indicates insertion or
     replacement of text in the buffer.

     The chg_length member identifies the number of charac-
     ters in the current preedit buffer that are affected by
     this call.	 A positive chg_length indicates that
     chg_length number of characters, starting at chg_first,
     must be deleted or must be replaced by text, whose
     length is specified in the 4mXIMText24m structure.

     A chg_length value of zero indicates that text must be
     inserted right at the position specified by chg_first.
     A value of zero for chg_first specifies the first char-
     acter in the buffer.

     chg_length and chg_first combine to identify the modi-
     fication required to the preedit buffer; beginning at
     chg_first, replace chg_length number of characters with
     the text in the supplied 4mXIMText24m structure. For exam-
     ple, suppose the preedit buffer contains the string
     "ABCDE".








			     1m4810m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


	  Text:	     A B C D E
		    ^ ^ ^ ^ ^ ^
	  CharPos:  0 1 2 3 4 5


     The CharPos in the diagram shows the location of the
     character position relative to the character.

     If the value of chg_first is 1 and the value of
     chg_length is 3, this says to replace 3 characters
     beginning at character position 1 with the string in
     the 4mXIMText24m structure.  Hence, BCD would be replaced by
     the value in the structure.

     Though chg_length and chg_first are both signed inte-
     gers they will never have a negative value.

·    The caret member identifies the character position
     before which the cursor should be placed - after modi-
     fication to the preedit buffer has been completed.	 For
     example, if caret is zero, the cursor is at the begin-
     ning of the buffer.  If the caret is one, the cursor is
     between the first and second character.

__
|
     typedef struct _XIMText {
	  unsigned short length;
	  XIMFeedback * feedback;
	  Bool encoding_is_wchar;
	  union {
	       char * multi_byte;
	       wchar_t * wide_char;
	  } string;
     } XIMText;

|__

The text string passed is actually a structure specifying as
follows:

·    The length member is the text length in characters.

·    The encoding_is_wchar member is a value that indicates
     if the text string is encoded in wide character or
     multibyte format.	The text string may be passed either
     as multibyte or as wide character; the input method
     controls in which form data is passed.  The client's
     callback routine must be able to handle data passed in
     either form.

·    The string member is the text string.





			     1m4820m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


·    The feedback member indicates rendering type for each
     character in the string member.  If string is NULL
     (indicating that only highlighting of the existing
     preedit buffer should be updated), feedback points to
     length highlight elements that should be applied to the
     existing preedit buffer, beginning at chg_first.

The feedback member expresses the types of rendering feed-
back the callback should apply when drawing text.  Rendering
of the text to be drawn is specified either in generic ways
(for example, primary, secondary) or in specific ways
(reverse, underline).  When generic indications are given,
the client is free to choose the rendering style.  It is
necessary, however, that primary and secondary be mapped to
two distinct rendering styles.

If an input method wants to control display of the preedit
string, an input method can indicate the visibility hints
using feedbacks in a specific way.  The 4mXIMVisibleToForward24m,
4mXIMVisibleToBackward24m, and 4mXIMVisibleCenter24m masks are exclu-
sively used for these visibility hints.	 The 4mXIMVisibleTo-0m
4mForward24m mask indicates that the preedit text is preferably
displayed in the primary draw direction from the caret posi-
tion in the preedit area forward.  The 4mXIMVisibleToBackward0m
mask indicates that the preedit text is preferably displayed
from the caret position in the preedit area backward, rela-
tive to the primary draw direction.  The 4mXIMVisibleCenter0m
mask indicates that the preedit text is preferably displayed
with the caret position in the preedit area centered.

The insertion point of the preedit string could exist out-
side of the visible area when visibility hints are used.
Only one of the masks is valid for the entire preedit
string, and only one character can hold one of these feed-
backs for a given input context at one time.  This feedback
may be OR'ed together with another highlight (such as 4mXIMRe-0m
4mverse24m).  Only the most recently set feedback is valid, and
any previous feedback is automatically canceled.  This is a
hint to the client, and the client is free to choose how to
display the preedit string.

The feedback member also specifies how rendering of the text
argument should be performed.  If the feedback is NULL, the
callback should apply the same feedback as is used for the
surrounding characters in the preedit buffer; if chg_first
is at a highlight boundary, the client can choose which of
the two highlights to use.  If feedback is not NULL, feed-
back specifies an array defining the rendering for each
character of the string, and the length of the array is thus
length.

If an input method wants to indicate that it is only updat-
ing the feedback of the preedit text without changing the
content of it, the 4mXIMText24m structure will contain a NULL



			     1m4830m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


value for the string field, the number of characters
affected (relative to chg_first) will be in the length
field, and the feedback field will point to an array of 4mXIM-0m
4mFeedback24m.

Each element in the feedback array is a bitmask represented
by a value of type 4mXIMFeedback24m.  The valid mask names are as
follows:

__
|

typedef unsigned long XIMFeedback;


#define	  4mXIMReverse24m	      1L
#define	  4mXIMUnderline24m	      (1L<<1)
#define	  4mXIMHighlight24m	      (1L<<2)
#define	  4mXIMPrimary24m	      (1L<<5)-
#define	  4mXIMSecondary24m	      (1L<<6)-
#define	  4mXIMTertiary24m	      (1L<<7)-
#define	  4mXIMVisibleToForward24m    (1L<<8)
#define	  4mXIMVisibleToBackward24m   (1L<<9)
#define	  4mXIMVisibleCenter24m	      (1L<<10)

|__


Characters drawn with the 4mXIMReverse24m highlight should be
drawn by swapping the foreground and background colors used
to draw normal, unhighlighted characters.  Characters drawn
with the 4mXIMUnderline24m highlight should be underlined.  Char-
acters drawn with the 4mXIMHighlight24m, 4mXIMPrimary24m, 4mXIMSec-0m
4mondary24m, and 4mXIMTertiary24m highlights should be drawn in some
unique manner that must be different from 4mXIMReverse24m and
4mXIMUnderline24m.

1m13.5.7.6.  Preedit Caret Callback0m

An input method may have its own navigation keys to allow
the user to move the text insertion point in the preedit
area (for example, to move backward or forward).  Conse-
quently, input method needs to indicate to the client that
it should move the text insertion point.  It then calls the
PreeditCaretCallback.
-----------
  - The values for 4mXIMPrimary24m, 4mXIMSecondary24m, and
4mXIMTertiary24m were incorrectly defined in the R5
specification.	The X Consortium's X11R5 implemen-
tation correctly implemented the values for these
highlights.  The value of these highlights has
been corrected in this specification to agree with
the values in the Consortium's X11R5 and X11R6
implementations.



			     1m4840m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
void PreeditCaretCallback(4mic24m, 4mclient_data24m, 4mcall_data24m)
      XIC 4mic24m;
      XPointer 4mclient_data24m;
      XIMPreeditCaretCallbackStruct *4mcall_data24m;


4mic24m	       Specifies the input context.

4mclient_data0m
	  Specifies the additional client data.

4mcall_data24m Specifies the preedit caret information.
|__

The input method will trigger PreeditCaretCallback to move
the text insertion point during preedit.  The call_data
argument contains a pointer to an 4mXIMPreeditCaretCallback-0m
4mStruct24m structure, which indicates where the caret should be
moved.	The callback must move the insertion point to its
new location and return, in field position, the new offset
value from the initial position.

The 4mXIMPreeditCaretCallbackStruct24m structure is defined as
follows:

__
|
typedef struct _XIMPreeditCaretCallbackStruct {
     int position;	 /* Caret offset within preedit string */
     XIMCaretDirection direction;/* Caret moves direction */
     XIMCaretStyle style;/* Feedback of the caret */
} XIMPreeditCaretCallbackStruct;

|__

The 4mXIMCaretStyle24m structure is defined as follows:

__
|
typedef enum {
     XIMIsInvisible,	 /* Disable caret feedback */
     XIMIsPrimary,	 /* UI defined caret feedback */
     XIMIsSecondary,	 /* UI defined caret feedback */
} XIMCaretStyle;

|__

The 4mXIMCaretDirection24m structure is defined as follows:








			     1m4850m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
typedef enum {
     XIMForwardChar, XIMBackwardChar,
     XIMForwardWord, XIMBackwardWord,
     XIMCaretUp, XIMCaretDown,
     XIMNextLine, XIMPreviousLine,
     XIMLineStart, XIMLineEnd,
     XIMAbsolutePosition,
     XIMDontChange,
 } XIMCaretDirection;

|__

These values are defined as follows:

4mXIMForwardChar24m    Move the caret forward one character posi-
		  tion.
4mXIMBackwardChar24m   Move the caret backward one character
		  position.
4mXIMForwardWord24m    Move the caret forward one word.
4mXIMBackwardWord24m   Move the caret backward one word.
4mXIMCaretUp24m	       Move the caret up one line keeping the
		  current horizontal offset.
4mXIMCaretDown24m      Move the caret down one line keeping the
		  current horizontal offset.
4mXIMPreviousLine24m   Move the caret to the beginning of the
		  previous line.
4mXIMNextLine24m       Move the caret to the beginning of the
		  next line.
4mXIMLineStart24m      Move the caret to the beginning of the
		  current display line that contains the
		  caret.
4mXIMLineEnd24m	       Move the caret to the end of the current
		  display line that contains the caret.
4mXIMAbsolutePo-24m    The callback must move to the location
4msition24m	       specified by the position field of the
		  callback data, indicated in characters,
		  starting from the beginning of the preedit
		  text.	 Hence, a value of zero means move
		  back to the beginning of the preedit text.
4mXIMDontChange24m     The caret position does not change.


1m13.5.7.7.  Status Callbacks0m

An input method may communicate changes in the status of an
input context (for example, created, destroyed, or focus
changes) with three status callbacks:  StatusStartCallback,
StatusDoneCallback, and StatusDrawCallback.


When the input context is created or gains focus, the input
method calls the StatusStartCallback callback.




			     1m4860m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
void StatusStartCallback(4mic24m, 4mclient_data24m, 4mcall_data24m)
      XIC 4mic24m;
      XPointer 4mclient_data24m;
      XPointer 4mcall_data24m;


4mic24m	       Specifies the input context.

4mclient_data0m
	  Specifies the additional client data.

4mcall_data24m Not used for this callback and always passed as
	  NULL.
|__

The callback should initialize appropriate data for display-
ing status and for responding to StatusDrawCallback calls.
Once StatusStartCallback is called, it will not be called
again before StatusDoneCallback has been called.


When an input context is destroyed or when it loses focus,
the input method calls StatusDoneCallback.
__
|
void StatusDoneCallback(4mic24m, 4mclient_data24m, 4mcall_data24m)
      XIC 4mic24m;
      XPointer 4mclient_data24m;
      XPointer 4mcall_data24m;


4mic24m	       Specifies the input context.

4mclient_data0m
	  Specifies the additional client data.

4mcall_data24m Not used for this callback and always passed as
	  NULL.
|__

The callback may release any data allocated on 4mStatusStart24m.


When an input context status has to be updated, the input
method calls StatusDrawCallback.











			     1m4870m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
void StatusDrawCallback(4mic24m, 4mclient_data24m, 4mcall_data24m)
      XIC 4mic24m;
      XPointer 4mclient_data24m;
      XIMStatusDrawCallbackStruct *4mcall_data24m;


4mic24m	       Specifies the input context.

4mclient_data0m
	  Specifies the additional client data.

4mcall_data24m Specifies the status drawing information.
|__

The callback should update the status area by either drawing
a string or imaging a bitmap in the status area.

The 4mXIMStatusDataType24m and 4mXIMStatusDrawCallbackStruct24m struc-
tures are defined as follows:

__
|
typedef enum {
     XIMTextType,
     XIMBitmapType,
} XIMStatusDataType;

typedef struct _XIMStatusDrawCallbackStruct {
     XIMStatusDataType type;
     union {
	  XIMText *text;
	  Pixmap  bitmap;
     } data;
} XIMStatusDrawCallbackStruct;

|__


The feedback styles 4mXIMVisibleToForward24m, 4mXIMVisibleToBack-0m
4mward24m, and 4mXIMVisibleToCenter24m are not relevant and will not
appear in the 4mXIMFeedback24m element of the 4mXIMText24m structure.


1m13.5.8.  Event Filtering0m

Xlib provides the ability for an input method to register a
filter internal to Xlib.  This filter is called by a client
(or toolkit) by calling 4mXFilterEvent24m after calling 4mXNex-0m
4mtEvent24m.  Any client that uses the 4mXIM24m interface should call
4mXFilterEvent24m to allow input methods to process their events
without knowledge of the client's dispatching mechanism.  A
client's user interface policy may determine the priority of
event filters with respect to other event-handling



			     1m4880m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


mechanisms (for example, modal grabs).

Clients may not know how many filters there are, if any, and
what they do.  They may only know if an event has been fil-
tered on return of 4mXFilterEvent24m.  Clients should discard
filtered events.


To filter an event, use 4mXFilterEvent24m.
__
|
Bool XFilterEvent(4mevent24m, 4mw24m)
      XEvent *4mevent24m;
      Window 4mw24m;


4mevent24m     Specifies the event to filter.

4mw24m	       Specifies the window for which the filter is to be
	  applied.
|__

If the window argument is 4mNone24m, 4mXFilterEvent24m applies the
filter to the window specified in the 4mXEvent24m structure.  The
window argument is provided so that layers above Xlib that
do event redirection can indicate to which window an event
has been redirected.

If 4mXFilterEvent24m returns 4mTrue24m, then some input method has
filtered the event, and the client should discard the event.
If 4mXFilterEvent24m returns 4mFalse24m, then the client should con-
tinue processing the event.

If a grab has occurred in the client and 4mXFilterEvent0m
returns 4mTrue24m, the client should ungrab the keyboard.

1m13.5.9.  Getting Keyboard Input0m

To get composed input from an input method, use 4mXmbLookup-0m
4mString24m, 4mXwcLookupString24m or 4mXutf8LookupString24m.

















			     1m4890m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
int XmbLookupString(4mic24m, 4mevent24m, 4mbuffer_return24m, 4mbytes_buffer24m, 4mkeysym_return24m, 4mstatus_return24m)
      XIC 4mic24m;
      XKeyPressedEvent *4mevent24m;
      char *4mbuffer_return24m;
      int 4mbytes_buffer24m;
      KeySym *4mkeysym_return24m;
      Status *4mstatus_return24m;


int XwcLookupString(4mic24m, 4mevent24m, 4mbuffer_return24m, 4mbytes_buffer24m, 4mkeysym_return24m, 4mstatus_return24m)
      XIC 4mic24m;
      XKeyPressedEvent *4mevent24m;
      wchar_t *4mbuffer_return24m;
      int 4mwchars_buffer24m;
      KeySym *4mkeysym_return24m;
      Status *4mstatus_return24m;


int Xutf8LookupString(4mic24m, 4mevent24m, 4mbuffer_return24m, 4mbytes_buffer24m, 4mkeysym_return24m, 4mstatus_return24m)
      XIC 4mic24m;
      XKeyPressedEvent *4mevent24m;
      char *4mbuffer_return24m;
      int 4mbytes_buffer24m;
      KeySym *4mkeysym_return24m;
      Status *4mstatus_return24m;


4mic24m	       Specifies the input context.

4mevent24m     Specifies the key event to be used.

4mbuffer_return0m
	  Returns a multibyte string or wide character
	  string (if any) from the input method.

4mbytes_buffer0m
4mwchars_buffer0m
	  Specifies space available in the return buffer.

4mkeysym_return0m
	  Returns the KeySym computed from the event if this
	  argument is not NULL.

4mstatus_return0m
	  Returns a value indicating what kind of data is
	  returned.
|__

The 4mXmbLookupString24m, 4mXwcLookupString24m and 4mXutf8LookupString0m
functions return the string from the input method specified
in the buffer_return argument.	If no string is returned,
the buffer_return argument is unchanged.




			     1m4900m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


The KeySym into which the KeyCode from the event was mapped
is returned in the keysym_return argument if it is non-NULL
and the status_return argument indicates that a KeySym was
returned.  If both a string and a KeySym are returned, the
KeySym value does not necessarily correspond to the string
returned.

4mXmbLookupString24m and 4mXutf8LookupString24m return the length of
the string in bytes, and 4mXwcLookupString24m returns the length
of the string in characters.  Both 4mXmbLookupString24m and
4mXwcLookupString24m return text in the encoding of the locale
bound to the input method of the specified input context,
and 4mXutf8LookupString24m returns text in UTF-8 encoding.

Each string returned by 4mXmbLookupString24m and 4mXwcLookupString0m
begins in the initial state of the encoding of the locale
(if the encoding of the locale is state-dependent).

			    Note

     To ensure proper input processing, it is essential
     that the client pass only 4mKeyPress24m events to
     4mXmbLookupString24m, 4mXwcLookupString24m and 4mXutf8Lookup-0m
     4mString24m.  Their behavior when a client passes a
     4mKeyRelease24m event is undefined.


Clients should check the status_return argument before using
the other returned values.  These three functions each
return a value to status_return that indicates what has been
returned in the other arguments.  The possible values
returned are:

4mXBufferOverflow24m   The input string to be returned is too
		  large for the supplied buffer_return.	 The
		  required size (for 4mXmbLookupString24m,
		  4mXutf8LookupString24m in bytes; for 4mXwcLookup-0m
		  4mString24m in characters) is returned as the
		  value of the function, and the contents of
		  buffer_return and keysym_return are not
		  modified.  The client should recall the
		  function with the same event and a buffer
		  of adequate size to obtain the string.
4mXLookupNone24m       No consistent input has been composed so
		  far.	The contents of buffer_return and
		  keysym_return are not modified, and the
		  function returns zero.
4mXLookupChars24m      Some input characters have been composed.
		  They are placed in the buffer_return argu-
		  ment, using the encoding described above,
		  and the string length is returned as the
		  value of the function.  The content of the
		  keysym_return argument is not modified.




			     1m4910m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


4mXLookupKeySym24m     A KeySym has been returned instead of a
		  string and is returned in keysym_return.
		  The content of the buffer_return argument
		  is not modified, and the function returns
		  zero.
4mXLookupBoth24m       Both a KeySym and a string are returned;
		  4mXLookupChars24m and 4mXLookupKeySym24m occur simul-
		  taneously.


It does not make any difference if the input context passed
as an argument to 4mXmbLookupString24m, 4mXwcLookupString24m and
4mXutf8LookupString24m is the one currently in possession of the
focus or not.  Input may have been composed within an input
context before it lost the focus, and that input may be
returned on subsequent calls to 4mXmbLookupString24m, 4mXwcLookup-0m
4mString24m or 4mXutf8LookupString24m even though it does not have any
more keyboard focus.

The function 4mXutf8LookupString24m is an XFree86 extension
introduced in XFree86 4.0.2. Its presence is indicated by
the macro 4mX_HAVE_UTF8_STRING24m.

1m13.5.10.  Input Method Conventions0m

The input method architecture is transparent to the client.
However, clients should respect a number of conventions in
order to work properly.	 Clients must also be aware of pos-
sible effects of synchronization between input method and
library in the case of a remote input server.

1m13.5.10.1.  Client Conventions0m

A well-behaved client (or toolkit) should first query the
input method style.  If the client cannot satisfy the
requirements of the supported styles (in terms of geometry
management or callbacks), it should negotiate with the user
continuation of the program or raise an exception or error
of some sort.

1m13.5.10.2.  Synchronization Conventions0m

A 4mKeyPress24m event with a KeyCode of zero is used exclusively
as a signal that an input method has composed input that can
be returned by 4mXmbLookupString24m, 4mXwcLookupString24m or
4mXutf8LookupString24m.	 No other use is made of a 4mKeyPress24m event
with KeyCode of zero.

Such an event may be generated by either a front-end or a
back-end input method in an implementation-dependent manner.
Some possible ways to generate this event include:

·    A synthetic event sent by an input method server




			     1m4920m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


·    An artificial event created by a input method filter
     and pushed onto a client's event queue

·    A 4mKeyPress24m event whose KeyCode value is modified by an
     input method filter

When callback support is specified by the client, input
methods will not take action unless they explicitly called
back the client and obtained no response (the callback is
not specified or returned invalid data).

1m13.6.	 String Constants0m

The following symbols for string constants are defined in
<4mX11/Xlib.h24m>.  Although they are shown here with particular
macro definitions, they may be implemented as macros, as
global symbols, or as a mixture of the two.  The string
pointer value itself is not significant; clients must not
assume that inequality of two values implies inequality of
the actual string data.

#define	  4mXNVaNestedList24m		     "XNVaNestedList"
#define	  4mXNSeparatorofNestedList24m	     "separatorofNestedList"
#define	  4mXNQueryInputStyle24m	     "queryInputStyle"
#define	  4mXNClientWindow24m		     "clientWindow"
#define	  4mXNInputStyle24m		     "inputStyle"
#define	  4mXNFocusWindow24m		     "focusWindow"
#define	  4mXNResourceName24m		     "resourceName"
#define	  4mXNResourceClass24m		     "resourceClass"
#define	  4mXNGeometryCallback24m	     "geometryCallback"
#define	  4mXNDestroyCallback24m	     "destroyCallback"
#define	  4mXNFilterEvents24m		     "filterEvents"
#define	  4mXNPreeditStartCallback24m	     "preeditStartCallback"
#define	  4mXNPreeditDoneCallback24m	     "preeditDoneCallback"
#define	  4mXNPreeditDrawCallback24m	     "preeditDrawCallback"
#define	  4mXNPreeditCaretCallback24m	     "preeditCaretCallback"
#define	  4mXNPreeditStateNotifyCall-24m     "preeditStateNotifyCall-
	  4mback24m			     back"
#define	  4mXNPreeditAttributes24m	     "preeditAttributes"

#define	  4mXNStatusStartCallback24m	     "statusStartCallback"
#define	  4mXNStatusDoneCallback24m	     "statusDoneCallback"
#define	  4mXNStatusDrawCallback24m	     "statusDrawCallback"
#define	  4mXNStatusAttributes24m	     "statusAttributes"
#define	  4mXNArea24m			     "area"
#define	  4mXNAreaNeeded24m		     "areaNeeded"
#define	  4mXNSpotLocation24m		     "spotLocation"
#define	  4mXNColormap24m		     "colorMap"
#define	  4mXNStdColormap24m		     "stdColorMap"
#define	  4mXNForeground24m		     "foreground"
#define	  4mXNBackground24m		     "background"
#define	  4mXNBackgroundPixmap24m	     "backgroundPixmap"
#define	  4mXNFontSet24m		     "fontSet"




			     1m4930m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


#define	  4mXNLineSpace24m		     "lineSpace"
#define	  4mXNCursor24m			     "cursor"

#define	  4mXNQueryIMValuesList24m	     "queryIMValuesList"
#define	  4mXNQueryICValuesList24m	     "queryICValuesList"
#define	  4mXNStringConversionCallback24m    "stringConversionCall-
					back"
#define	  4mXNStringConversion24m	     "stringConversion"
#define	  4mXNResetState24m		     "resetState"
#define	  4mXNHotKey24m			     "hotkey"
#define	  4mXNHotKeyState24m		     "hotkeyState"
#define	  4mXNPreeditState24m		     "preeditState"
#define	  4mXNVisiblePosition24m	     "visiblePosition"
#define	  4mXNR6PreeditCallbackBehavior24m   "r6PreeditCallback"

#define	  4mXNRequiredCharSet24m	     "requiredCharSet"
#define	  4mXNQueryOrientation24m	     "queryOrientation"
#define	  4mXNDirectionalDependentDraw-24m   "directionalDependent-
	  4ming24m			     Drawing"
#define	  4mXNContextualDrawing24m	     "contextualDrawing"
#define	  4mXNBaseFontName24m		     "baseFontName"
#define	  4mXNMissingCharSet24m		     "missingCharSet"
#define	  4mXNDefaultString24m		     "defaultString"
#define	  4mXNOrientation24m		     "orientation"
#define	  4mXNFontInfo24m		     "fontInfo"
#define	  4mXNOMAutomatic24m		     "omAutomatic"































			     1m4940m





1mXlib - C Library			X11, Release 6.7 DRAFT0m




			 1mChapter 140m

	    1mInter-Client Communication Functions0m



The 4mInter-Client24m 4mCommunication24m 4mConventions24m 4mManual24m, hereafter
referred to as the ICCCM, details the X Consortium approved
conventions that govern inter-client communications.  These
conventions ensure peer-to-peer client cooperation in the
use of selections, cut buffers, and shared resources as well
as client cooperation with window and session managers.	 For
further information, see the 4mInter-Client24m 4mCommunication24m 4mCon-0m
4mventions24m 4mManual24m.

Xlib provides a number of standard properties and program-
ming interfaces that are ICCCM compliant.  The predefined
atoms for some of these properties are defined in the
<4mX11/Xatom.h24m> header file, where to avoid name conflicts
with user symbols their 4m#define24m name has an XA_ prefix.  For
further information about atoms and properties, see section
4.3.

Xlib's selection and cut buffer mechanisms provide the pri-
mary programming interfaces by which peer client applica-
tions communicate with each other (see sections 4.5 and
16.6).	The functions discussed in this chapter provide the
primary programming interfaces by which client applications
communicate with their window and session managers as well
as share standard colormaps.

The standard properties that are of special interest for
communicating with window and session managers are:

-----------------------------------------------------------------------
1mName			 Type		 Format	  Description0m
-----------------------------------------------------------------------
WM_CLASS	       STRING		 8	Set by application
						programs to allow win-
						dow and session man-
						agers to obtain the
						application's
						resources from the
						resource database.
WM_CLIENT_MACHINE      TEXT			The string name of the
						machine on which the
						client application is
						running.







			     1m4950m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


-----------------------------------------------------------------------
1mName			 Type		 Format	  Description0m
-----------------------------------------------------------------------
WM_COLORMAP_WINDOWS    WINDOW		 32	The list of window IDs
						that may need a dif-
						ferent colormap from
						that of their top-
						level window.
WM_COMMAND	       TEXT			The command and argu-
						ments, null-separated,
						used to invoke the
						application.
WM_HINTS	       WM_HINTS		 32	Additional hints set
						by the client for use
						by the window manager.
						The C type of this
						property is 4mXWMHints24m.
WM_ICON_NAME	       TEXT			The name to be used in
						an icon.
WM_ICON_SIZE	       WM_ICON_SIZE	 32	The window manager may
						set this property on
						the root window to
						specify the icon sizes
						it supports.  The C
						type of this property
						is 4mXIconSize24m.
WM_NAME		       TEXT			The name of the appli-
						cation.
WM_NORMAL_HINTS	       WM_SIZE_HINTS	 32	Size hints for a win-
						dow in its normal
						state.	The C type of
						this property is
						4mXSizeHints24m.
WM_PROTOCOLS	       ATOM		 32	List of atoms that
						identify the communi-
						cations protocols
						between the client and
						window manager in
						which the client is
						willing to partici-
						pate.
WM_STATE	       WM_STATE		 32	Intended for communi-
						cation between window
						and session managers
						only.
WM_TRANSIENT_FOR       WINDOW		 32	Set by application
						programs to indicate
						to the window manager
						that a transient top-
						level window, such as
						a dialog box.
-----------------------------------------------------------------------





			     1m4960m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


The remainder of this chapter discusses:

·    Client to window manager communication

·    Client to session manager communication

·    Standard colormaps

1m14.1.	 Client to Window Manager Communication0m

This section discusses how to:

·    Manipulate top-level windows

·    Convert string lists

·    Set and read text properties

·    Set and read the WM_NAME property

·    Set and read the WM_ICON_NAME property

·    Set and read the WM_HINTS property

·    Set and read the WM_NORMAL_HINTS property

·    Set and read the WM_CLASS property

·    Set and read the WM_TRANSIENT_FOR property

·    Set and read the WM_PROTOCOLS property

·    Set and read the WM_COLORMAP_WINDOWS property

·    Set and read the WM_ICON_SIZE property

·    Use window manager convenience functions

1m14.1.1.  Manipulating Top-Level Windows0m

Xlib provides functions that you can use to change the visi-
bility or size of top-level windows (that is, those that
were created as children of the root window).  Note that the
subwindows that you create are ignored by window managers.
Therefore, you should use the basic window functions
described in chapter 3 to manipulate your application's sub-
windows.

To request that a top-level window be iconified, use 4mXIconi-0m
4mfyWindow24m.







			     1m4970m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
Status XIconifyWindow(4mdisplay24m, 4mw24m, 4mscreen_number24m)
      Display *4mdisplay24m;
      Window 4mw24m;
      int 4mscreen_number24m;


4mdisplay24m   Specifies the connection to the X server.

4mw24m	       Specifies the window.

4mscreen_number0m
	  Specifies the appropriate screen number on the
	  host server.
|__

The 4mXIconifyWindow24m function sends a WM_CHANGE_STATE
4mClientMessage24m event with a format of 32 and a first data
element of 4mIconicState24m (as described in section 4.1.4 of the
4mInter-Client24m 4mCommunication24m 4mConventions24m 4mManual24m) and a window
of w to the root window of the specified screen with an
event mask set to 4mSubstructureNotifyMask24m| 4mSubstructureRedi-0m
4mrectMask24m.	Window managers may elect to receive this message
and if the window is in its normal state, may treat it as a
request to change the window's state from normal to iconic.
If the WM_CHANGE_STATE property cannot be interned, 4mXIconi-0m
4mfyWindow24m does not send a message and returns a zero status.
It returns a nonzero status if the client message is sent
successfully; otherwise, it returns a zero status.


To request that a top-level window be withdrawn, use 4mXWith-0m
4mdrawWindow24m.
__
|
Status XWithdrawWindow(4mdisplay24m, 4mw24m, 4mscreen_number24m)
      Display *4mdisplay24m;
      Window 4mw24m;
      int 4mscreen_number24m;


4mdisplay24m   Specifies the connection to the X server.

4mw24m	       Specifies the window.

4mscreen_number0m
	  Specifies the appropriate screen number on the
	  host server.
|__

The 4mXWithdrawWindow24m function unmaps the specified window and
sends a synthetic 4mUnmapNotify24m event to the root window of
the specified screen.  Window managers may elect to receive
this message and may treat it as a request to change the



			     1m4980m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


window's state to withdrawn.  When a window is in the with-
drawn state, neither its normal nor its iconic representa-
tions is visible.  It returns a nonzero status if the 4mUnmap-0m
4mNotify24m event is successfully sent; otherwise, it returns a
zero status.

4mXWithdrawWindow24m can generate a 4mBadWindow24m error.


To request that a top-level window be reconfigured, use 4mXRe-0m
4mconfigureWMWindow24m.
__
|
Status XReconfigureWMWindow(4mdisplay24m, 4mw24m, 4mscreen_number24m, 4mvalue_mask24m, 4mvalues24m)
      Display *4mdisplay24m;
      Window 4mw24m;
      int 4mscreen_number24m;
      unsigned int 4mvalue_mask24m;
      XWindowChanges *4mvalues24m;


4mdisplay24m   Specifies the connection to the X server.

4mw24m	       Specifies the window.

4mscreen_number0m
	  Specifies the appropriate screen number on the
	  host server.

4mvalue_mask0m
	  Specifies which values are to be set using infor-
	  mation in the values structure.  This mask is the
	  bitwise inclusive OR of the valid configure window
	  values bits.

4mvalues24m    Specifies the 4mXWindowChanges24m structure.
|__

The 4mXReconfigureWMWindow24m function issues a 4mConfigureWindow0m
request on the specified top-level window.  If the stacking
mode is changed and the request fails with a 4mBadMatch24m error,
the error is trapped by Xlib and a synthetic 4mConfigur-0m
4meRequestEvent24m containing the same configuration parameters
is sent to the root of the specified window.  Window man-
agers may elect to receive this event and treat it as a
request to reconfigure the indicated window.  It returns a
nonzero status if the request or event is successfully sent;
otherwise, it returns a zero status.

4mXReconfigureWMWindow24m can generate 4mBadValue24m and 4mBadWindow0m
errors.






			     1m4990m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


1m14.1.2.  Converting String Lists0m

Many of the text properties allow a variety of types and
formats.  Because the data stored in these properties are
not simple null-terminated strings, an 4mXTextProperty24m struc-
ture is used to describe the encoding, type, and length of
the text as well as its value.	The 4mXTextProperty24m structure
contains:
__
|
typedef struct {
     unsigned char *value;/* property data */
     Atom encoding;	 /* type of property */
     int format;	 /* 8, 16, or 32 */
     unsigned long nitems;/* number of items in value */
} XTextProperty;

|__

Xlib provides functions to convert localized text to or from
encodings that support the inter-client communication con-
ventions for text.  In addition, functions are provided for
converting between lists of pointers to character strings
and text properties in the STRING encoding.

The functions for localized text return a signed integer
error status that encodes 4mSuccess24m as zero, specific error
conditions as negative numbers, and partial conversion as a
count of unconvertible characters.

__
|
#define	  4mXNoMemory24m	      -1
#define	  4mXLocaleNotSupported24m    -2
#define	  4mXConverterNotFound24m     -3


typedef enum {
     XStringStyle,	 /* STRING */
     XCompoundTextStyle, /* COMPOUND_TEXT */
     XTextStyle,	 /* text in owner's encoding (current locale) */
     XStdICCTextStyle,	 /* STRING, else COMPOUND_TEXT */
     XUTF8StringStyle	 /* UTF8_STRING */
} XICCEncodingStyle;

|__

The value 4mXUTF8StringStyle24m is an XFree86 extension intro-
duced in XFree86 4.0.2. Its presence is indicated by the
macro 4mX_HAVE_UTF8_STRING24m.


To convert a list of text strings to an 4mXTextProperty24m struc-
ture, use 4mXmbTextListToTextProperty24m,



			     1m5000m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


4mXwcTextListToTextProperty24m or 4mXutf8TextListToTextProperty24m.
__
|
int XmbTextListToTextProperty(4mdisplay24m, 4mlist24m, 4mcount24m, 4mstyle24m, 4mtext_prop_return24m)
      Display *4mdisplay24m;
      char **4mlist24m;
      int 4mcount24m;
      XICCEncodingStyle 4mstyle24m;
      XTextProperty *4mtext_prop_return24m;


int XwcTextListToTextProperty(4mdisplay24m, 4mlist24m, 4mcount24m, 4mstyle24m, 4mtext_prop_return24m)
      Display *4mdisplay24m;
      wchar_t **4mlist24m;
      int 4mcount24m;
      XICCEncodingStyle 4mstyle24m;
      XTextProperty *4mtext_prop_return24m;


int Xutf8TextListToTextProperty(4mdisplay24m, 4mlist24m, 4mcount24m, 4mstyle24m, 4mtext_prop_return24m)
      Display *4mdisplay24m;
      char **4mlist24m;
      int 4mcount24m;
      XICCEncodingStyle 4mstyle24m;
      XTextProperty *4mtext_prop_return24m;


4mdisplay24m   Specifies the connection to the X server.

4mlist24m      Specifies a list of null-terminated character
	  strings.

4mcount24m     Specifies the number of strings specified.

4mstyle24m     Specifies the manner in which the property is
	  encoded.

4mtext_prop_return0m
	  Returns the 4mXTextProperty24m structure.
|__

The 4mXmbTextListToTextProperty24m, 4mXwcTextListToTextProperty24m and
4mXutf8TextListToTextProperty24m functions set the specified
4mXTextProperty24m value to a set of null-separated elements rep-
resenting the concatenation of the specified list of null-
terminated text strings. The input text strings must be
given in the current locale encoding (for 4mXmbTextListTo-0m
4mTextProperty24m and 4mXwcTextListToTextProperty24m), or in UTF-8
encoding (for 4mXutf8TextListToTextProperty24m).

The functions set the encoding field of text_prop_return to
an 4mAtom24m for the specified display naming the encoding deter-
mined by the specified style and convert the specified text
list to this encoding for storage in the text_prop_return



			     1m5010m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


value field.  If the style 4mXStringStyle24m or 4mXCompound-0m
4mTextStyle24m is specified, this encoding is ``STRING'' or
``COMPOUND_TEXT'', respectively.  If the style
4mXUTF8StringStyle24m is specified, this encoding is
``UTF8_STRING''. (This is an XFree86 extension introduced in
XFree86 4.0.2. Its presence is indicated by the macro
4mX_HAVE_UTF8_STRING24m.)  If the style 4mXTextStyle24m is specified,
this encoding is the encoding of the current locale.  If the
style 4mXStdICCTextStyle24m is specified, this encoding is
``STRING'' if the text is fully convertible to STRING, else
``COMPOUND_TEXT''.  A final terminating null byte is stored
at the end of the value field of text_prop_return but is not
included in the nitems member.

If insufficient memory is available for the new value
string, the functions return 4mXNoMemory24m.  If the current
locale is not supported, the functions return 4mXLocaleNotSup-0m
4mported24m.  In both of these error cases, the functions do not
set text_prop_return.

To determine if the functions are guaranteed not to return
4mXLocaleNotSupported24m, use 4mXSupportsLocale24m.

If the supplied text is not fully convertible to the speci-
fied encoding, the functions return the number of unconvert-
ible characters.  Each unconvertible character is converted
to an implementation-defined and encoding-specific default
string.	 Otherwise, the functions return 4mSuccess24m.	Note that
full convertibility to all styles except 4mXStringStyle24m is
guaranteed.

To free the storage for the value field, use 4mXFree24m.

The function 4mXutf8TextListToTextProperty24m is an XFree86
extension introduced in XFree86 4.0.2. Its presence is indi-
cated by the macro 4mX_HAVE_UTF8_STRING24m.


To obtain a list of text strings from an 4mXTextProperty0m
structure, use 4mXmbTextPropertyToTextList24m, 4mXwcTextPropertyTo-0m
4mTextList24m or 4mXutf8TextPropertyToTextList24m.
















			     1m5020m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
int XmbTextPropertyToTextList(4mdisplay24m, 4mtext_prop24m, 4mlist_return24m, 4mcount_return24m)
      Display *4mdisplay24m;
      XTextProperty *4mtext_prop24m;
      char ***4mlist_return24m;
      int *4mcount_return24m;


int XwcTextPropertyToTextList(4mdisplay24m, 4mtext_prop24m, 4mlist_return24m, 4mcount_return24m)
      Display *4mdisplay24m;
      XTextProperty *4mtext_prop24m;
      wchar_t ***4mlist_return24m;
      int *4mcount_return24m;


int Xutf8TextPropertyToTextList(4mdisplay24m, 4mtext_prop24m, 4mlist_return24m, 4mcount_return24m)
      Display *4mdisplay24m;
      XTextProperty *4mtext_prop24m;
      char ***4mlist_return24m;
      int *4mcount_return24m;


4mdisplay24m   Specifies the connection to the X server.

4mtext_prop24m Specifies the 4mXTextProperty24m structure to be used.

4mlist_return0m
	  Returns a list of null-terminated character
	  strings.

4mcount_return0m
	  Returns the number of strings.
|__

The 4mXmbTextPropertyToTextList24m, 4mXwcTextPropertyToTextList24m and
4mXutf8TextPropertyToTextList24m functions return a list of text
strings representing the null-separated elements of the
specified 4mXTextProperty24m structure. The returned strings are
encoded using the current locale encoding (for 4mXmbTextProp-0m
4mertyToTextList24m and 4mXwcTextPropertyToTextList24m) or in UTF-8
(for 4mXutf8TextPropertyToTextList24m).	 The data in text_prop
must be format 8.

Multiple elements of the property (for example, the strings
in a disjoint text selection) are separated by a null byte.
The contents of the property are not required to be null-
terminated; any terminating null should not be included in
text_prop.nitems.

If insufficient memory is available for the list and its
elements, 4mXmbTextPropertyToTextList24m, 4mXwcTextPropertyTo-0m
4mTextList24m and 4mXutf8TextPropertyToTextList24m return 4mXNoMemory24m.
If the current locale is not supported, the functions return
4mXLocaleNotSupported24m.  Otherwise, if the encoding field of



			     1m5030m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


text_prop is not convertible to the encoding of the current
locale, the functions return 4mXConverterNotFound24m.  For sup-
ported locales, existence of a converter from COMPOUND_TEXT,
STRING, UTF8_STRING or the encoding of the current locale is
guaranteed if 4mXSupportsLocale24m returns 4mTrue24m for the current
locale (but the actual text may contain unconvertible char-
acters).  Conversion of other encodings is implementation-
dependent.  In all of these error cases, the functions do
not set any return values.

Otherwise, 4mXmbTextPropertyToTextList24m, 4mXwcTextPropertyTo-0m
4mTextList24m and 4mXutf8TextPropertyToTextList24m return the list of
null-terminated text strings to list_return and the number
of text strings to count_return.

If the value field of text_prop is not fully convertible to
the encoding of the current locale, the functions return the
number of unconvertible characters.  Each unconvertible
character is converted to a string in the current locale
that is specific to the current locale.	 To obtain the value
of this string, use 4mXDefaultString24m.  Otherwise, 4mXmbTextProp-0m
4mertyToTextList24m, 4mXwcTextPropertyToTextList24m and 4mXutf8TextProp-0m
4mertyToTextList24m return 4mSuccess24m.

To free the storage for the list and its contents returned
by 4mXmbTextPropertyToTextList24m or 4mXutf8TextPropertyToTextList24m,
use 4mXFreeStringList24m.  To free the storage for the list and
its contents returned by 4mXwcTextPropertyToTextList24m, use
4mXwcFreeStringList24m.

The function 4mXutf8TextPropertyToTextList24m is an XFree86
extension introduced in XFree86 4.0.2. Its presence is indi-
cated by the macro 4mX_HAVE_UTF8_STRING24m.


To free the in-memory data associated with the specified
wide character string list, use 4mXwcFreeStringList24m.
__
|
void XwcFreeStringList(4mlist24m)
      wchar_t **4mlist24m;


4mlist24m      Specifies the list of strings to be freed.
|__

The 4mXwcFreeStringList24m function frees memory allocated by
4mXwcTextPropertyToTextList24m.


To obtain the default string for text conversion in the cur-
rent locale, use 4mXDefaultString24m.





			     1m5040m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
char *XDefaultString()

|__

The 4mXDefaultString24m function returns the default string used
by Xlib for text conversion (for example, in 4mXmbTextProper-0m
4mtyToTextList24m).  The default string is the string in the cur-
rent locale that is output when an unconvertible character
is found during text conversion.  If the string returned by
4mXDefaultString24m is the empty string (""), no character is
output in the converted text.  4mXDefaultString24m does not
return NULL.

The string returned by 4mXDefaultString24m is independent of the
default string for text drawing; see 4mXCreateFontSet24m to
obtain the default string for an 4mXFontSet24m.

The behavior when an invalid codepoint is supplied to any
Xlib function is undefined.

The returned string is null-terminated.	 It is owned by Xlib
and should not be modified or freed by the client.  It may
be freed after the current locale is changed.  Until freed,
it will not be modified by Xlib.


To set the specified list of strings in the STRING encoding
to a 4mXTextProperty24m structure, use 4mXStringListToTextProperty24m.
__
|
Status XStringListToTextProperty(4mlist24m, 4mcount24m, 4mtext_prop_return24m)
      char **4mlist24m;
      int 4mcount24m;
      XTextProperty *4mtext_prop_return24m;


4mlist24m      Specifies a list of null-terminated character
	  strings.

4mcount24m     Specifies the number of strings.

4mtext_prop_return0m
	  Returns the 4mXTextProperty24m structure.
|__

The 4mXStringListToTextProperty24m function sets the specified
4mXTextProperty24m to be of type STRING (format 8) with a value
representing the concatenation of the specified list of
null-separated character strings.  An extra null byte (which
is not included in the nitems member) is stored at the end
of the value field of text_prop_return.	 The strings are
assumed (without verification) to be in the STRING encoding.
If insufficient memory is available for the new value



			     1m5050m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


string, 4mXStringListToTextProperty24m does not set any fields in
the 4mXTextProperty24m structure and returns a zero status.  Oth-
erwise, it returns a nonzero status.  To free the storage
for the value field, use 4mXFree24m.


To obtain a list of strings from a specified 4mXTextProperty0m
structure in the STRING encoding, use 4mXTextProperty-0m
4mToStringList24m.
__
|
Status XTextPropertyToStringList(4mtext_prop24m, 4mlist_return24m, 4mcount_return24m)
       XTextProperty *4mtext_prop24m;
       char ***4mlist_return24m;
       int *4mcount_return24m;


4mtext_prop24m Specifies the 4mXTextProperty24m structure to be used.

4mlist_return0m
	  Returns a list of null-terminated character
	  strings.

4mcount_return0m
	  Returns the number of strings.
|__

The 4mXTextPropertyToStringList24m function returns a list of
strings representing the null-separated elements of the
specified 4mXTextProperty24m structure.	 The data in text_prop
must be of type STRING and format 8.  Multiple elements of
the property (for example, the strings in a disjoint text
selection) are separated by NULL (encoding 0).	The contents
of the property are not null-terminated.  If insufficient
memory is available for the list and its elements,
4mXTextPropertyToStringList24m sets no return values and returns
a zero status.	Otherwise, it returns a nonzero status.	 To
free the storage for the list and its contents, use
4mXFreeStringList24m.


To free the in-memory data associated with the specified
string list, use 4mXFreeStringList24m.
__
|
void XFreeStringList(4mlist24m)
      char **4mlist24m;


4mlist24m      Specifies the list of strings to be freed.
|__

The 4mXFreeStringList24m function releases memory allocated by
4mXmbTextPropertyToTextList24m, 4mXutf8TextPropertyToTextList24m and



			     1m5060m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


4mXTextPropertyToStringList24m and the missing charset list allo-
cated by 4mXCreateFontSet24m.

1m14.1.3.  Setting and Reading Text Properties0m

Xlib provides two functions that you can use to set and read
the text properties for a given window.	 You can use these
functions to set and read those properties of type TEXT
(WM_NAME, WM_ICON_NAME, WM_COMMAND, and WM_CLIENT_MACHINE).
In addition, Xlib provides separate convenience functions
that you can use to set each of these properties.  For fur-
ther information about these convenience functions, see sec-
tions 14.1.4, 14.1.5, 14.2.1, and 14.2.2, respectively.


To set one of a window's text properties, use 4mXSetTextProp-0m
4merty24m.
__
|
void XSetTextProperty(4mdisplay24m, 4mw24m, 4mtext_prop24m, 4mproperty24m)
      Display *4mdisplay24m;
      Window 4mw24m;
      XTextProperty *4mtext_prop24m;
      Atom 4mproperty24m;


4mdisplay24m   Specifies the connection to the X server.

4mw24m	       Specifies the window.

4mtext_prop24m Specifies the 4mXTextProperty24m structure to be used.

4mproperty24m  Specifies the property name.
|__

The 4mXSetTextProperty24m function replaces the existing speci-
fied property for the named window with the data, type, for-
mat, and number of items determined by the value field, the
encoding field, the format field, and the nitems field,
respectively, of the specified 4mXTextProperty24m structure.  If
the property does not already exist, 4mXSetTextProperty24m sets
it for the specified window.

4mXSetTextProperty24m can generate 4mBadAlloc24m, 4mBadAtom24m, 4mBadValue24m,
and 4mBadWindow24m errors.


To read one of a window's text properties, use 4mXGetTextProp-0m
4merty24m.








			     1m5070m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
Status XGetTextProperty(4mdisplay24m, 4mw24m, 4mtext_prop_return24m, 4mproperty24m)
       Display *4mdisplay24m;
       Window 4mw24m;
       XTextProperty *4mtext_prop_return24m;
       Atom 4mproperty24m;


4mdisplay24m   Specifies the connection to the X server.

4mw24m	       Specifies the window.

4mtext_prop_return0m
	  Returns the 4mXTextProperty24m structure.

4mproperty24m  Specifies the property name.
|__

The 4mXGetTextProperty24m function reads the specified property
from the window and stores the data in the returned
4mXTextProperty24m structure.  It stores the data in the value
field, the type of the data in the encoding field, the for-
mat of the data in the format field, and the number of items
of data in the nitems field.  An extra byte containing null
(which is not included in the nitems member) is stored at
the end of the value field of text_prop_return.	 The partic-
ular interpretation of the property's encoding and data as
text is left to the calling application.  If the specified
property does not exist on the window, 4mXGetTextProperty24m sets
the value field to NULL, the encoding field to 4mNone24m, the
format field to zero, and the nitems field to zero.

If it was able to read and store the data in the 4mXTextProp-0m
4merty24m structure, 4mXGetTextProperty24m returns a nonzero status;
otherwise, it returns a zero status.

4mXGetTextProperty24m can generate 4mBadAtom24m and 4mBadWindow24m errors.

1m14.1.4.  Setting and Reading the WM_NAME Property0m

Xlib provides convenience functions that you can use to set
and read the WM_NAME property for a given window.


To set a window's WM_NAME property with the supplied conve-
nience function, use 4mXSetWMName24m.











			     1m5080m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
void XSetWMName(4mdisplay24m, 4mw24m, 4mtext_prop24m)
      Display *4mdisplay24m;
      Window 4mw24m;
      XTextProperty *4mtext_prop24m;


4mdisplay24m   Specifies the connection to the X server.

4mw24m	       Specifies the window.

4mtext_prop24m Specifies the 4mXTextProperty24m structure to be used.
|__

The 4mXSetWMName24m convenience function calls 4mXSetTextProperty0m
to set the WM_NAME property.


To read a window's WM_NAME property with the supplied conve-
nience function, use 4mXGetWMName24m.
__
|
Status XGetWMName(4mdisplay24m, 4mw24m, 4mtext_prop_return24m)
      Display *4mdisplay24m;
      Window 4mw24m;
      XTextProperty *4mtext_prop_return24m;


4mdisplay24m   Specifies the connection to the X server.

4mw24m	       Specifies the window.

4mtext_prop_return0m
	  Returns the 4mXTextProperty24m structure.
|__

The 4mXGetWMName24m convenience function calls 4mXGetTextProperty0m
to obtain the WM_NAME property.	 It returns a nonzero status
on success; otherwise, it returns a zero status.

The following two functions have been superseded by 4mXSetWM-0m
4mName24m and 4mXGetWMName24m, respectively.  You can use these addi-
tional convenience functions for window names that are
encoded as STRING properties.


To assign a name to a window, use 4mXStoreName24m.










			     1m5090m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
XStoreName(4mdisplay24m, 4mw24m, 4mwindow_name24m)
      Display *4mdisplay24m;
      Window 4mw24m;
      char *4mwindow_name24m;


4mdisplay24m   Specifies the connection to the X server.

4mw24m	       Specifies the window.

4mwindow_name0m
	  Specifies the window name, which should be a null-
	  terminated string.
|__

The 4mXStoreName24m function assigns the name passed to win-
dow_name to the specified window.  A window manager can dis-
play the window name in some prominent place, such as the
title bar, to allow users to identify windows easily.  Some
window managers may display a window's name in the window's
icon, although they are encouraged to use the window's icon
name if one is provided by the application.  If the string
is not in the Host Portable Character Encoding, the result
is implementation-dependent.

4mXStoreName24m can generate 4mBadAlloc24m and 4mBadWindow24m errors.


To get the name of a window, use 4mXFetchName24m.
__
|
Status XFetchName(4mdisplay24m, 4mw24m, 4mwindow_name_return24m)
      Display *4mdisplay24m;
      Window 4mw24m;
      char **4mwindow_name_return24m;


4mdisplay24m   Specifies the connection to the X server.

4mw24m	       Specifies the window.

4mwindow_name_return0m
	  Returns the window name, which is a null-termi-
	  nated string.
|__

The 4mXFetchName24m function returns the name of the specified
window.	 If it succeeds, it returns a nonzero status; other-
wise, no name has been set for the window, and it returns
zero.  If the WM_NAME property has not been set for this
window, 4mXFetchName24m sets window_name_return to NULL.  If the
data returned by the server is in the Latin Portable Charac-
ter Encoding, then the returned string is in the Host



			     1m5100m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


Portable Character Encoding.  Otherwise, the result is
implementation-dependent.  When finished with it, a client
must free the window name string using 4mXFree24m.

4mXFetchName24m can generate a 4mBadWindow24m error.

1m14.1.5.  Setting and Reading the WM_ICON_NAME Property0m

Xlib provides convenience functions that you can use to set
and read the WM_ICON_NAME property for a given window.


To set a window's WM_ICON_NAME property, use 4mXSetWMIconName24m.
__
|
void XSetWMIconName(4mdisplay24m, 4mw24m, 4mtext_prop24m)
      Display *4mdisplay24m;
      Window 4mw24m;
      XTextProperty *4mtext_prop24m;


4mdisplay24m   Specifies the connection to the X server.

4mw24m	       Specifies the window.

4mtext_prop24m Specifies the 4mXTextProperty24m structure to be used.
|__

The 4mXSetWMIconName24m convenience function calls 4mXSetTextProp-0m
4merty24m to set the WM_ICON_NAME property.


To read a window's WM_ICON_NAME property, use 4mXGetWMIcon-0m
4mName24m.
__
|
Status XGetWMIconName(4mdisplay24m, 4mw24m, 4mtext_prop_return24m)
      Display *4mdisplay24m;
      Window 4mw24m;
      XTextProperty *4mtext_prop_return24m;


4mdisplay24m   Specifies the connection to the X server.

4mw24m	       Specifies the window.

4mtext_prop_return0m
	  Returns the 4mXTextProperty24m structure.
|__

The 4mXGetWMIconName24m convenience function calls 4mXGetTextProp-0m
4merty24m to obtain the WM_ICON_NAME property.	It returns a
nonzero status on success; otherwise, it returns a zero sta-
tus.



			     1m5110m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


The next two functions have been superseded by 4mXSetWMIcon-0m
4mName24m and 4mXGetWMIconName24m, respectively.  You can use these
additional convenience functions for window names that are
encoded as STRING properties.



To set the name to be displayed in a window's icon, use
4mXSetIconName24m.
__
|
XSetIconName(4mdisplay24m, 4mw24m, 4micon_name24m)
      Display *4mdisplay24m;
      Window 4mw24m;
      char *4micon_name24m;


4mdisplay24m   Specifies the connection to the X server.

4mw24m	       Specifies the window.

4micon_name24m Specifies the icon name, which should be a null-
	  terminated string.
|__

If the string is not in the Host Portable Character Encod-
ing, the result is implementation-dependent.  4mXSetIconName0m
can generate 4mBadAlloc24m and 4mBadWindow24m errors.


To get the name a window wants displayed in its icon, use
4mXGetIconName24m.
__
|
Status XGetIconName(4mdisplay24m, 4mw24m, 4micon_name_return24m)
      Display *4mdisplay24m;
      Window 4mw24m;
      char **4micon_name_return24m;


4mdisplay24m   Specifies the connection to the X server.

4mw24m	       Specifies the window.

4micon_name_return0m
	  Returns the window's icon name, which is a null-
	  terminated string.
|__

The 4mXGetIconName24m function returns the name to be displayed
in the specified window's icon.	 If it succeeds, it returns
a nonzero status; otherwise, if no icon name has been set
for the window, it returns zero.  If you never assigned a
name to the window, 4mXGetIconName24m sets icon_name_return to



			     1m5120m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


NULL.  If the data returned by the server is in the Latin
Portable Character Encoding, then the returned string is in
the Host Portable Character Encoding.  Otherwise, the result
is implementation-dependent.  When finished with it, a
client must free the icon name string using 4mXFree24m.

4mXGetIconName24m can generate a 4mBadWindow24m error.

1m14.1.6.  Setting and Reading the WM_HINTS Property0m

Xlib provides functions that you can use to set and read the
WM_HINTS property for a given window.  These functions use
the flags and the 4mXWMHints24m structure, as defined in the
<4mX11/Xutil.h24m> header file.


To allocate an 4mXWMHints24m structure, use 4mXAllocWMHints24m.
__
|
XWMHints *XAllocWMHints()

|__

The 4mXAllocWMHints24m function allocates and returns a pointer
to an 4mXWMHints24m structure.	Note that all fields in the
4mXWMHints24m structure are initially set to zero.  If insuffi-
cient memory is available, 4mXAllocWMHints24m returns NULL.  To
free the memory allocated to this structure, use 4mXFree24m.

The 4mXWMHints24m structure contains:



























			     1m5130m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|    /* Window manager hints mask bits */

#define	  4mInputHint24m		   (1L << 0)
#define	  4mStateHint24m		   (1L << 1)
#define	  4mIconPixmapHint24m		   (1L << 2)
#define	  4mIconWindowHint24m		   (1L << 3)
#define	  4mIconPositionHint24m		   (1L << 4)
#define	  4mIconMaskHint24m		   (1L << 5)
#define	  4mWindowGroupHint24m		   (1L << 6)
#define	  4mUrgencyHint24m		   (1L << 8)
#define	  4mAllHints24m			   (InputHint|State-
				      Hint|IconPixmapHint|
				      IconWindowHint|IconPosi-
				      tionHint|
				      IconMaskHint|Window-
				      GroupHint)


/* Values */

typedef struct {
     long flags;	 /* marks which fields in this structure are defined */
     Bool input;	 /* does this application rely on the window manager to
			 get keyboard input? */
     int initial_state;	 /* see below */
     Pixmap icon_pixmap; /* pixmap to be used as icon */
     Window icon_window; /* window to be used as icon */
     int icon_x, icon_y; /* initial position of icon */
     Pixmap icon_mask;	 /* pixmap to be used as mask for icon_pixmap */
     XID window_group;	 /* id of related window group */
     /* this structure may be extended in the future */
} XWMHints;

|__

The input member is used to communicate to the window man-
ager the input focus model used by the application.  Appli-
cations that expect input but never explicitly set focus to
any of their subwindows (that is, use the push model of
focus management), such as X Version 10 style applications
that use real-estate driven focus, should set this member to
4mTrue24m.  Similarly, applications that set input focus to their
subwindows only when it is given to their top-level window
by a window manager should also set this member to 4mTrue24m.
Applications that manage their own input focus by explicitly
setting focus to one of their subwindows whenever they want
keyboard input (that is, use the pull model of focus manage-
ment) should set this member to 4mFalse24m.  Applications that
never expect any keyboard input also should set this member
to 4mFalse24m.

Pull model window managers should make it possible for push
model applications to get input by setting input focus to
the top-level windows of applications whose input member is



			     1m5140m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


4mTrue24m.  Push model window managers should make sure that pull
model applications do not break them by resetting input
focus to 4mPointerRoot24m when it is appropriate (for example,
whenever an application whose input member is 4mFalse24m sets
input focus to one of its subwindows).

The definitions for the initial_state flag are:

#define	  4mWithdrawnState24m	      0
#define	  4mNormalState24m	      1	   /* most applications start
				      this way */
#define	  4mIconicState24m	      3	   /* application wants to
				      start as an icon */

The icon_mask specifies which pixels of the icon_pixmap
should be used as the icon.  This allows for nonrectangular
icons.	Both icon_pixmap and icon_mask must be bitmaps.	 The
icon_window lets an application provide a window for use as
an icon for window managers that support such use.  The win-
dow_group lets you specify that this window belongs to a
group of other windows.	 For example, if a single applica-
tion manipulates multiple top-level windows, this allows you
to provide enough information that a window manager can
iconify all of the windows rather than just the one window.

The 4mUrgencyHint24m flag, if set in the flags field, indicates
that the client deems the window contents to be urgent,
requiring the timely response of the user.  The window man-
ager will make some effort to draw the user's attention to
this window while this flag is set.  The client must provide
some means by which the user can cause the urgency flag to
be cleared (either mitigating the condition that made the
window urgent or merely shutting off the alarm) or the win-
dow to be withdrawn.


To set a window's WM_HINTS property, use 4mXSetWMHints24m.
__
|
XSetWMHints(4mdisplay24m, 4mw24m, 4mwmhints24m)
      Display *4mdisplay24m;
      Window 4mw24m;
      XWMHints *4mwmhints24m;



4mdisplay24m   Specifies the connection to the X server.

4mw24m	       Specifies the window.

4mwmhints24m   Specifies the 4mXWMHints24m structure to be used.
|__

The 4mXSetWMHints24m function sets the window manager hints that



			     1m5150m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


include icon information and location, the initial state of
the window, and whether the application relies on the window
manager to get keyboard input.

4mXSetWMHints24m can generate 4mBadAlloc24m and 4mBadWindow24m errors.


To read a window's WM_HINTS property, use 4mXGetWMHints24m.
__
|
XWMHints *XGetWMHints(4mdisplay24m, 4mw24m)
      Display *4mdisplay24m;
      Window 4mw24m;


4mdisplay24m   Specifies the connection to the X server.

4mw24m	       Specifies the window.
|__

The 4mXGetWMHints24m function reads the window manager hints and
returns NULL if no WM_HINTS property was set on the window
or returns a pointer to an 4mXWMHints24m structure if it suc-
ceeds.	When finished with the data, free the space used for
it by calling 4mXFree24m.

4mXGetWMHints24m can generate a 4mBadWindow24m error.

1m14.1.7.  Setting and Reading the WM_NORMAL_HINTS Property0m

Xlib provides functions that you can use to set or read the
WM_NORMAL_HINTS property for a given window.  The functions
use the flags and the 4mXSizeHints24m structure, as defined in
the <4mX11/Xutil.h24m> header file.

The size of the 4mXSizeHints24m structure may grow in future
releases, as new components are added to support new ICCCM
features.  Passing statically allocated instances of this
structure into Xlib may result in memory corruption when
running against a future release of the library.  As such,
it is recommended that only dynamically allocated instances
of the structure be used.


To allocate an 4mXSizeHints24m structure, use 4mXAllocSizeHints24m.
__
|
XSizeHints *XAllocSizeHints()

|__

The 4mXAllocSizeHints24m function allocates and returns a pointer
to an 4mXSizeHints24m structure.  Note that all fields in the
4mXSizeHints24m structure are initially set to zero.  If



			     1m5160m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


insufficient memory is available, 4mXAllocSizeHints24m returns
NULL.  To free the memory allocated to this structure, use
4mXFree24m.

The 4mXSizeHints24m structure contains:

__
|    /* Size hints mask bits */

#define	  4mUSPosition24m    (1L << 0)		/* user specified x, y */
#define	  4mUSSize24m	     (1L << 1)		/* user specified width, height
					   */
#define	  4mPPosition24m     (1L << 2)		/* program specified position
					   */
#define	  4mPSize24m	     (1L << 3)		/* program specified size */
#define	  4mPMinSize24m	     (1L << 4)		/* program specified minimum
					   size */
#define	  4mPMaxSize24m	     (1L << 5)		/* program specified maximum
					   size */
#define	  4mPResizeInc24m    (1L << 6)		/* program specified resize
					   increments */
#define	  4mPAspect24m	     (1L << 7)		/* program specified min and
					   max aspect ratios */
#define	  4mPBaseSize24m     (1L << 8)
#define	  4mPWinGravity24m   (1L << 9)
#define	  4mPAllHints24m     (PPosi-
			tion|PSize|
			PMinSize|PMax-
			Size|
			PRe-
			sizeInc|PAspect)


/* Values */

typedef struct {
     long flags;	 /* marks which fields in this structure are defined */
     int x, y;		 /* Obsolete */
     int width, height;	 /* Obsolete */
     int min_width, min_height;
     int max_width, max_height;
     int width_inc, height_inc;
     struct {
	    int x;	 /* numerator */
	    int y;	 /* denominator */
     } min_aspect, max_aspect;
     int base_width, base_height;
     int win_gravity;
     /* this structure may be extended in the future */
} XSizeHints;

|__

The x, y, width, and height members are now obsolete and are



			     1m5170m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


left solely for compatibility reasons.	The min_width and
min_height members specify the minimum window size that
still allows the application to be useful.  The max_width
and max_height members specify the maximum window size.	 The
width_inc and height_inc members define an arithmetic pro-
gression of sizes (minimum to maximum) into which the window
prefers to be resized.	The min_aspect and max_aspect mem-
bers are expressed as ratios of x and y, and they allow an
application to specify the range of aspect ratios it
prefers.  The base_width and base_height members define the
desired size of the window.  The window manager will inter-
pret the position of the window and its border width to
position the point of the outer rectangle of the overall
window specified by the win_gravity member.  The outer rec-
tangle of the window includes any borders or decorations
supplied by the window manager.	 In other words, if the win-
dow manager decides to place the window where the client
asked, the position on the parent window's border named by
the win_gravity will be placed where the client window would
have been placed in the absence of a window manager.

Note that use of the 4mPAllHints24m macro is highly discouraged.


To set a window's WM_NORMAL_HINTS property, use 4mXSetWMNor-0m
4mmalHints24m.
__
|
void XSetWMNormalHints(4mdisplay24m, 4mw24m, 4mhints24m)
      Display *4mdisplay24m;
      Window 4mw24m;
      XSizeHints *4mhints24m;


4mdisplay24m   Specifies the connection to the X server.

4mw24m	       Specifies the window.

4mhints24m     Specifies the size hints for the window in its
	  normal state.
|__

The 4mXSetWMNormalHints24m function replaces the size hints for
the WM_NORMAL_HINTS property on the specified window.  If
the property does not already exist, 4mXSetWMNormalHints24m sets
the size hints for the WM_NORMAL_HINTS property on the spec-
ified window.  The property is stored with a type of
WM_SIZE_HINTS and a format of 32.

4mXSetWMNormalHints24m can generate 4mBadAlloc24m and 4mBadWindow0m
errors.






			     1m5180m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


To read a window's WM_NORMAL_HINTS property, use 4mXGetWMNor-0m
4mmalHints24m.
__
|
Status XGetWMNormalHints(4mdisplay24m, 4mw24m, 4mhints_return24m, 4msupplied_return24m)
      Display *4mdisplay24m;
      Window 4mw24m;
      XSizeHints *4mhints_return24m;
      long *4msupplied_return24m;


4mdisplay24m   Specifies the connection to the X server.

4mw24m	       Specifies the window.

4mhints_return0m
	  Returns the size hints for the window in its
	  normal state.

4msupplied_return0m
	  Returns the hints that were supplied by the user.
|__

The 4mXGetWMNormalHints24m function returns the size hints stored
in the WM_NORMAL_HINTS property on the specified window.  If
the property is of type WM_SIZE_HINTS, is of format 32, and
is long enough to contain either an old (pre-ICCCM) or new
size hints structure, 4mXGetWMNormalHints24m sets the various
fields of the 4mXSizeHints24m structure, sets the supplied_return
argument to the list of fields that were supplied by the
user (whether or not they contained defined values), and
returns a nonzero status.  Otherwise, it returns a zero sta-
tus.

If 4mXGetWMNormalHints24m returns successfully and a pre-ICCCM
size hints property is read, the supplied_return argument
will contain the following bits:


     (USPosition|USSize|PPosition|PSize|PMinSize|
      PMaxSize|PResizeInc|PAspect)


If the property is large enough to contain the base size and
window gravity fields as well, the supplied_return argument
will also contain the following bits:


     PBaseSize|PWinGravity


4mXGetWMNormalHints24m can generate a 4mBadWindow24m error.





			     1m5190m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


To set a window's WM_SIZE_HINTS property, use 4mXSetWMSize-0m
4mHints24m.
__
|
void XSetWMSizeHints(4mdisplay24m, 4mw24m, 4mhints24m, 4mproperty24m)
      Display *4mdisplay24m;
      Window 4mw24m;
      XSizeHints *4mhints24m;
      Atom 4mproperty24m;


4mdisplay24m   Specifies the connection to the X server.

4mw24m	       Specifies the window.

4mhints24m     Specifies the 4mXSizeHints24m structure to be used.

4mproperty24m  Specifies the property name.
|__

The 4mXSetWMSizeHints24m function replaces the size hints for the
specified property on the named window.	 If the specified
property does not already exist, 4mXSetWMSizeHints24m sets the
size hints for the specified property on the named window.
The property is stored with a type of WM_SIZE_HINTS and a
format of 32.  To set a window's normal size hints, you can
use the 4mXSetWMNormalHints24m function.

4mXSetWMSizeHints24m can generate 4mBadAlloc24m, 4mBadAtom24m, and 4mBadWin-0m
4mdow24m errors.


To read a window's WM_SIZE_HINTS property, use 4mXGetWMSize-0m
4mHints24m.























			     1m5200m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
Status XGetWMSizeHints(4mdisplay24m, 4mw24m, 4mhints_return24m, 4msupplied_return24m, 4mproperty24m)
      Display *4mdisplay24m;
      Window 4mw24m;
      XSizeHints *4mhints_return24m;
      long *4msupplied_return24m;
      Atom 4mproperty24m;


4mdisplay24m   Specifies the connection to the X server.

4mw24m	       Specifies the window.

4mhints_return0m
	  Returns the 4mXSizeHints24m structure.

4msupplied_return0m
	  Returns the hints that were supplied by the user.

4mproperty24m  Specifies the property name.
|__

The 4mXGetWMSizeHints24m function returns the size hints stored
in the specified property on the named window.	If the prop-
erty is of type WM_SIZE_HINTS, is of format 32, and is long
enough to contain either an old (pre-ICCCM) or new size
hints structure, 4mXGetWMSizeHints24m sets the various fields of
the 4mXSizeHints24m structure, sets the supplied_return argument
to the list of fields that were supplied by the user
(whether or not they contained defined values), and returns
a nonzero status.  Otherwise, it returns a zero status.	 To
get a window's normal size hints, you can use the 4mXGetWMNor-0m
4mmalHints24m function.

If 4mXGetWMSizeHints24m returns successfully and a pre-ICCCM size
hints property is read, the supplied_return argument will
contain the following bits:


     (USPosition|USSize|PPosition|PSize|PMinSize|
      PMaxSize|PResizeInc|PAspect)


If the property is large enough to contain the base size and
window gravity fields as well, the supplied_return argument
will also contain the following bits:


     PBaseSize|PWinGravity


4mXGetWMSizeHints24m can generate 4mBadAtom24m and 4mBadWindow24m errors.





			     1m5210m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


1m14.1.8.  Setting and Reading the WM_CLASS Property0m

Xlib provides functions that you can use to set and get the
WM_CLASS property for a given window.  These functions use
the 4mXClassHint24m structure, which is defined in the
<4mX11/Xutil.h24m> header file.


To allocate an 4mXClassHint24m structure, use 4mXAllocClassHint24m.
__
|
XClassHint *XAllocClassHint()

|__

The 4mXAllocClassHint24m function allocates and returns a pointer
to an 4mXClassHint24m structure.  Note that the pointer fields in
the 4mXClassHint24m structure are initially set to NULL.  If
insufficient memory is available, 4mXAllocClassHint24m returns
NULL.  To free the memory allocated to this structure, use
4mXFree24m.

The 4mXClassHint24m contains:

__
|
typedef struct {
     char *res_name;
     char *res_class;
} XClassHint;

|__

The res_name member contains the application name, and the
res_class member contains the application class.  Note that
the name set in this property may differ from the name set
as WM_NAME.  That is, WM_NAME specifies what should be dis-
played in the title bar and, therefore, can contain temporal
information (for example, the name of a file currently in an
editor's buffer).  On the other hand, the name specified as
part of WM_CLASS is the formal name of the application that
should be used when retrieving the application's resources
from the resource database.


To set a window's WM_CLASS property, use 4mXSetClassHint24m.











			     1m5220m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
XSetClassHint(4mdisplay24m, 4mw24m, 4mclass_hints24m)
      Display *4mdisplay24m;
      Window 4mw24m;
      XClassHint *4mclass_hints24m;


4mdisplay24m   Specifies the connection to the X server.

4mw24m	       Specifies the window.

4mclass_hints0m
	  Specifies the 4mXClassHint24m structure that is to be
	  used.
|__

The 4mXSetClassHint24m function sets the class hint for the spec-
ified window.  If the strings are not in the Host Portable
Character Encoding, the result is implementation-dependent.

4mXSetClassHint24m can generate 4mBadAlloc24m and 4mBadWindow24m errors.


To read a window's WM_CLASS property, use 4mXGetClassHint24m.
__
|
Status XGetClassHint(4mdisplay24m, 4mw24m, 4mclass_hints_return24m)
      Display *4mdisplay24m;
      Window 4mw24m;
      XClassHint *4mclass_hints_return24m;


4mdisplay24m   Specifies the connection to the X server.

4mw24m	       Specifies the window.

4mclass_hints_return0m
	  Returns the 4mXClassHint24m structure.
|__

The 4mXGetClassHint24m function returns the class hint of the
specified window to the members of the supplied structure.
If the data returned by the server is in the Latin Portable
Character Encoding, then the returned strings are in the
Host Portable Character Encoding.  Otherwise, the result is
implementation-dependent.  It returns a nonzero status on
success; otherwise, it returns a zero status.  To free
res_name and res_class when finished with the strings, use
4mXFree24m on each individually.

4mXGetClassHint24m can generate a 4mBadWindow24m error.






			     1m5230m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


1m14.1.9.  Setting and Reading the WM_TRANSIENT_FOR Property0m

Xlib provides functions that you can use to set and read the
WM_TRANSIENT_FOR property for a given window.


To set a window's WM_TRANSIENT_FOR property, use 4mXSetTran-0m
4msientForHint24m.
__
|
XSetTransientForHint(4mdisplay24m, 4mw24m, 4mprop_window24m)
      Display *4mdisplay24m;
      Window 4mw24m;
      Window 4mprop_window24m;


4mdisplay24m   Specifies the connection to the X server.

4mw24m	       Specifies the window.

4mprop_window0m
	  Specifies the window that the WM_TRANSIENT_FOR
	  property is to be set to.
|__

The 4mXSetTransientForHint24m function sets the WM_TRANSIENT_FOR
property of the specified window to the specified prop_win-
dow.

4mXSetTransientForHint24m can generate 4mBadAlloc24m and 4mBadWindow0m
errors.


To read a window's WM_TRANSIENT_FOR property, use 4mXGetTran-0m
4msientForHint24m.
__
|
Status XGetTransientForHint(4mdisplay24m, 4mw24m, 4mprop_window_return24m)
      Display *4mdisplay24m;
      Window 4mw24m;
      Window *4mprop_window_return24m;


4mdisplay24m   Specifies the connection to the X server.

4mw24m	       Specifies the window.

4mprop_window_return0m
	  Returns the WM_TRANSIENT_FOR property of the spec-
	  ified window.
|__

The 4mXGetTransientForHint24m function returns the WM_TRAN-
SIENT_FOR property for the specified window.  It returns a



			     1m5240m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


nonzero status on success; otherwise, it returns a zero sta-
tus.

4mXGetTransientForHint24m can generate a 4mBadWindow24m error.

1m14.1.10.  Setting and Reading the WM_PROTOCOLS Property0m

Xlib provides functions that you can use to set and read the
WM_PROTOCOLS property for a given window.


To set a window's WM_PROTOCOLS property, use 4mXSetWMProto-0m
4mcols24m.
__
|
Status XSetWMProtocols(4mdisplay24m, 4mw24m, 4mprotocols24m, 4mcount24m)
      Display *4mdisplay24m;
      Window 4mw24m;
      Atom *4mprotocols24m;
      int 4mcount24m;


4mdisplay24m   Specifies the connection to the X server.

4mw24m	       Specifies the window.

4mprotocols24m Specifies the list of protocols.

4mcount24m     Specifies the number of protocols in the list.
|__

The 4mXSetWMProtocols24m function replaces the WM_PROTOCOLS prop-
erty on the specified window with the list of atoms speci-
fied by the protocols argument.	 If the property does not
already exist, 4mXSetWMProtocols24m sets the WM_PROTOCOLS prop-
erty on the specified window to the list of atoms specified
by the protocols argument.  The property is stored with a
type of ATOM and a format of 32.  If it cannot intern the
WM_PROTOCOLS atom, 4mXSetWMProtocols24m returns a zero status.
Otherwise, it returns a nonzero status.

4mXSetWMProtocols24m can generate 4mBadAlloc24m and 4mBadWindow24m errors.


To read a window's WM_PROTOCOLS property, use 4mXGetWMProto-0m
4mcols24m.











			     1m5250m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
Status XGetWMProtocols(4mdisplay24m, 4mw24m, 4mprotocols_return24m, 4mcount_return24m)
      Display *4mdisplay24m;
      Window 4mw24m;
      Atom **4mprotocols_return24m;
      int *4mcount_return24m;


4mdisplay24m   Specifies the connection to the X server.

4mw24m	       Specifies the window.

4mprotocols_return0m
	  Returns the list of protocols.

4mcount_return0m
	  Returns the number of protocols in the list.
|__

The 4mXGetWMProtocols24m function returns the list of atoms
stored in the WM_PROTOCOLS property on the specified window.
These atoms describe window manager protocols in which the
owner of this window is willing to participate.	 If the
property exists, is of type ATOM, is of format 32, and the
atom WM_PROTOCOLS can be interned, 4mXGetWMProtocols24m sets the
protocols_return argument to a list of atoms, sets the
count_return argument to the number of elements in the list,
and returns a nonzero status.  Otherwise, it sets neither of
the return arguments and returns a zero status.	 To release
the list of atoms, use 4mXFree24m.

4mXGetWMProtocols24m can generate a 4mBadWindow24m error.

1m14.1.11.  Setting and Reading the WM_COLORMAP_WINDOWS Prop-0m
1merty0m

Xlib provides functions that you can use to set and read the
WM_COLORMAP_WINDOWS property for a given window.


To set a window's WM_COLORMAP_WINDOWS property, use 4mXSetWM-0m
4mColormapWindows24m.















			     1m5260m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
Status XSetWMColormapWindows(4mdisplay24m, 4mw24m, 4mcolormap_windows24m, 4mcount24m)
      Display *4mdisplay24m;
      Window 4mw24m;
      Window *4mcolormap_windows24m;
      int 4mcount24m;


4mdisplay24m   Specifies the connection to the X server.

4mw24m	       Specifies the window.

4mcolormap_windows0m
	  Specifies the list of windows.

4mcount24m     Specifies the number of windows in the list.
|__

The 4mXSetWMColormapWindows24m function replaces the WM_COL-
ORMAP_WINDOWS property on the specified window with the list
of windows specified by the colormap_windows argument.	If
the property does not already exist, 4mXSetWMColormapWindows0m
sets the WM_COLORMAP_WINDOWS property on the specified win-
dow to the list of windows specified by the colormap_windows
argument.  The property is stored with a type of WINDOW and
a format of 32.	 If it cannot intern the WM_COLORMAP_WINDOWS
atom, 4mXSetWMColormapWindows24m returns a zero status.	 Other-
wise, it returns a nonzero status.

4mXSetWMColormapWindows24m can generate 4mBadAlloc24m and 4mBadWindow0m
errors.


To read a window's WM_COLORMAP_WINDOWS property, use 4mXGetWM-0m
4mColormapWindows24m.






















			     1m5270m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
Status XGetWMColormapWindows(4mdisplay24m, 4mw24m, 4mcolormap_windows_return24m, 4mcount_return24m)
      Display *4mdisplay24m;
      Window 4mw24m;
      Window **4mcolormap_windows_return24m;
      int *4mcount_return24m;


4mdisplay24m   Specifies the connection to the X server.

4mw24m	       Specifies the window.

4mcolormap_windows_return0m
	  Returns the list of windows.

4mcount_return0m
	  Returns the number of windows in the list.
|__

The 4mXGetWMColormapWindows24m function returns the list of win-
dow identifiers stored in the WM_COLORMAP_WINDOWS property
on the specified window.  These identifiers indicate the
colormaps that the window manager may need to install for
this window.  If the property exists, is of type WINDOW, is
of format 32, and the atom WM_COLORMAP_WINDOWS can be
interned, 4mXGetWMColormapWindows24m sets the windows_return
argument to a list of window identifiers, sets the
count_return argument to the number of elements in the list,
and returns a nonzero status.  Otherwise, it sets neither of
the return arguments and returns a zero status.	 To release
the list of window identifiers, use 4mXFree24m.

4mXGetWMColormapWindows24m can generate a 4mBadWindow24m error.

1m14.1.12.  Setting and Reading the WM_ICON_SIZE Property0m

Xlib provides functions that you can use to set and read the
WM_ICON_SIZE property for a given window.  These functions
use the 4mXIconSize24m structure, which is defined in the
<4mX11/Xutil.h24m> header file.


To allocate an 4mXIconSize24m structure, use 4mXAllocIconSize24m.
__
|
XIconSize *XAllocIconSize()

|__

The 4mXAllocIconSize24m function allocates and returns a pointer
to an 4mXIconSize24m structure.	 Note that all fields in the
4mXIconSize24m structure are initially set to zero.  If insuffi-
cient memory is available, 4mXAllocIconSize24m returns NULL.  To
free the memory allocated to this structure, use 4mXFree24m.



			     1m5280m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


The 4mXIconSize24m structure contains:

__
|
typedef struct {
     int min_width, min_height;
     int max_width, max_height;
     int width_inc, height_inc;
} XIconSize;

|__

The width_inc and height_inc members define an arithmetic
progression of sizes (minimum to maximum) that represent the
supported icon sizes.


To set a window's WM_ICON_SIZE property, use 4mXSetIconSizes24m.
__
|
XSetIconSizes(4mdisplay24m, 4mw24m, 4msize_list24m, 4mcount24m)
      Display *4mdisplay24m;
      Window 4mw24m;
      XIconSize *4msize_list24m;
      int 4mcount24m;


4mdisplay24m   Specifies the connection to the X server.

4mw24m	       Specifies the window.

4msize_list24m Specifies the size list.

4mcount24m     Specifies the number of items in the size list.
|__

The 4mXSetIconSizes24m function is used only by window managers
to set the supported icon sizes.

4mXSetIconSizes24m can generate 4mBadAlloc24m and 4mBadWindow24m errors.


To read a window's WM_ICON_SIZE property, use 4mXGetIconSizes24m.














			     1m5290m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
Status XGetIconSizes(4mdisplay24m, 4mw24m, 4msize_list_return24m, 4mcount_return24m)
      Display *4mdisplay24m;
      Window 4mw24m;
      XIconSize **4msize_list_return24m;
      int *4mcount_return24m;


4mdisplay24m   Specifies the connection to the X server.

4mw24m	       Specifies the window.

4msize_list_return0m
	  Returns the size list.

4mcount_return0m
	  Returns the number of items in the size list.
|__

The 4mXGetIconSizes24m function returns zero if a window manager
has not set icon sizes; otherwise, it returns nonzero.
4mXGetIconSizes24m should be called by an application that wants
to find out what icon sizes would be most appreciated by the
window manager under which the application is running.	The
application should then use 4mXSetWMHints24m to supply the window
manager with an icon pixmap or window in one of the sup-
ported sizes.  To free the data allocated in
size_list_return, use 4mXFree24m.

4mXGetIconSizes24m can generate a 4mBadWindow24m error.

1m14.1.13.  Using Window Manager Convenience Functions0m

The 4mXmbSetWMProperties24m and 4mXutf8SetWMProperties24m functions
store the standard set of window manager properties, with
text properties in standard encodings for internationalized
text communication.  The standard window manager properties
for a given window are WM_NAME, WM_ICON_NAME, WM_HINTS,
WM_NORMAL_HINTS, WM_CLASS, WM_COMMAND, WM_CLIENT_MACHINE,
and WM_LOCALE_NAME.

















			     1m5300m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
void XmbSetWMProperties(4mdisplay24m, 4mw24m, 4mwindow_name24m, 4micon_name24m, 4margv24m, 4margc24m,
		      4mnormal_hints24m, 4mwm_hints24m, 4mclass_hints24m)
      Display *4mdisplay24m;
      Window 4mw24m;
      char *4mwindow_name24m;
      char *4micon_name24m;
      char *4margv24m[];
      int 4margc24m;
      XSizeHints *4mnormal_hints24m;
      XWMHints *4mwm_hints24m;
      XClassHint *4mclass_hints24m;


void Xutf8SetWMProperties(4mdisplay24m, 4mw24m, 4mwindow_name24m, 4micon_name24m, 4margv24m, 4margc24m,
		      4mnormal_hints24m, 4mwm_hints24m, 4mclass_hints24m)
      Display *4mdisplay24m;
      Window 4mw24m;
      char *4mwindow_name24m;
      char *4micon_name24m;
      char *4margv24m[];
      int 4margc24m;
      XSizeHints *4mnormal_hints24m;
      XWMHints *4mwm_hints24m;
      XClassHint *4mclass_hints24m;


4mdisplay24m   Specifies the connection to the X server.

4mw24m	       Specifies the window.

4mwindow_name0m
	  Specifies the window name, which should be a null-
	  terminated string.

4micon_name24m Specifies the icon name, which should be a null-
	  terminated string.

4margv24m      Specifies the application's argument list.

4margc24m      Specifies the number of arguments.

4mhints24m     Specifies the size hints for the window in its
	  normal state.

4mwm_hints24m  Specifies the 4mXWMHints24m structure to be used.

4mclass_hints0m
	  Specifies the 4mXClassHint24m structure to be used.
|__

The 4mXmbSetWMProperties24m and 4mXutf8SetWMProperties24m convenience
functions provide a simple programming interface for setting
those essential window properties that are used for



			     1m5310m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


communicating with other clients (particularly window and
session managers).

If the window_name argument is non-NULL, they set the
WM_NAME property.  If the icon_name argument is non-NULL,
they set the WM_ICON_NAME property.  The window_name and
icon_name arguments are null-terminated strings, for 4mXmb-0m
4mSetWMProperties24m in the encoding of the current locale, for
4mXutf8SetWMProperties24m in UTF-8 encoding.  If the arguments
can be fully converted to the STRING encoding, the proper-
ties are created with type ``STRING''; otherwise, the argu-
ments are converted to Compound Text, and the properties are
created with type ``COMPOUND_TEXT''.

If the normal_hints argument is non-NULL, 4mXmbSetWMProperties0m
and 4mXutf8SetWMProperties24m call 4mXSetWMNormalHints24m, which sets
the WM_NORMAL_HINTS property (see section 14.1.7).  If the
wm_hints argument is non-NULL, 4mXmbSetWMProperties24m and
4mXutf8SetWMProperties24m call 4mXSetWMHints24m, which sets the
WM_HINTS property (see section 14.1.6).

If the argv argument is non-NULL, 4mXmbSetWMProperties24m and
4mXutf8SetWMProperties24m set the WM_COMMAND property from argv
and argc.  An argc of zero indicates a zero-length command.

The hostname of the machine is stored using 4mXSetWMClientMa-0m
4mchine24m (see section 14.2.2).

If the class_hints argument is non-NULL, 4mXmbSetWMProperties0m
and 4mXutf8SetWMProperties24m set the WM_CLASS property.  If the
res_name member in the 4mXClassHint24m structure is set to the
NULL pointer and the RESOURCE_NAME environment variable is
set, the value of the environment variable is substituted
for res_name.  If the res_name member is NULL, the environ-
ment variable is not set, and argv and argv[0] are set, then
the value of argv[0], stripped of any directory prefixes, is
substituted for res_name.

It is assumed that the supplied class_hints.res_name and
argv, the RESOURCE_NAME environment variable, and the host-
name of the machine are in the encoding of the current
locale.	 The corresponding WM_CLASS, WM_COMMAND, and
WM_CLIENT_MACHINE properties are typed according to the
local host locale announcer.  No encoding conversion is per-
formed for these strings prior to storage in the properties.

For clients that need to process the property text in a
locale, 4mXmbSetWMProperties24m and 4mXutf8SetWMProperties24m set the
WM_LOCALE_NAME property to be the name of the current
locale.	 The name is assumed to be in the Host Portable
Character Encoding and is converted to STRING for storage in
the property.





			     1m5320m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


4mXmbSetWMProperties24m and 4mXutf8SetWMProperties24m can generate
4mBadAlloc24m and 4mBadWindow24m errors.

The function 4mXutf8SetWMProperties24m is an XFree86 extension
introduced in XFree86 4.0.2. Its presence is indicated by
the macro 4mX_HAVE_UTF8_STRING24m.


To set a window's standard window manager properties with
strings in client-specified encodings, use 4mXSetWMProperties24m.
The standard window manager properties for a given window
are WM_NAME, WM_ICON_NAME, WM_HINTS, WM_NORMAL_HINTS,
WM_CLASS, WM_COMMAND, and WM_CLIENT_MACHINE.
__
|
void XSetWMProperties(4mdisplay24m, 4mw24m, 4mwindow_name24m, 4micon_name24m, 4margv24m, 4margc24m, 4mnormal_hints24m, 4mwm_hints24m, 4mclass_hints24m)
      Display *4mdisplay24m;
      Window 4mw24m;
      XTextProperty *4mwindow_name24m;
      XTextProperty *4micon_name24m;
      char **4margv24m;
      int 4margc24m;
      XSizeHints *4mnormal_hints24m;
      XWMHints *4mwm_hints24m;
      XClassHint *4mclass_hints24m;


4mdisplay24m   Specifies the connection to the X server.

4mw24m	       Specifies the window.

4mwindow_name0m
	  Specifies the window name, which should be a null-
	  terminated string.

4micon_name24m Specifies the icon name, which should be a null-
	  terminated string.

4margv24m      Specifies the application's argument list.

4margc24m      Specifies the number of arguments.

4mnormal_hints0m
	  Specifies the size hints for the window in its
	  normal state.

4mwm_hints24m  Specifies the 4mXWMHints24m structure to be used.

4mclass_hints0m
	  Specifies the 4mXClassHint24m structure to be used.
|__

The 4mXSetWMProperties24m convenience function provides a single
programming interface for setting those essential window



			     1m5330m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


properties that are used for communicating with other
clients (particularly window and session managers).

If the window_name argument is non-NULL, 4mXSetWMProperties0m
calls 4mXSetWMName24m, which, in turn, sets the WM_NAME property
(see section 14.1.4).  If the icon_name argument is non-
NULL, 4mXSetWMProperties24m calls 4mXSetWMIconName24m, which sets the
WM_ICON_NAME property (see section 14.1.5).  If the argv
argument is non-NULL, 4mXSetWMProperties24m calls 4mXSetCommand24m,
which sets the WM_COMMAND property (see section 14.2.1).
Note that an argc of zero is allowed to indicate a zero-
length command.	 Note also that the hostname of this machine
is stored using 4mXSetWMClientMachine24m (see section 14.2.2).

If the normal_hints argument is non-NULL, 4mXSetWMProperties0m
calls 4mXSetWMNormalHints24m, which sets the WM_NORMAL_HINTS
property (see section 14.1.7).	If the wm_hints argument is
non-NULL, 4mXSetWMProperties24m calls 4mXSetWMHints24m, which sets the
WM_HINTS property (see section 14.1.6).

If the class_hints argument is non-NULL, 4mXSetWMProperties0m
calls 4mXSetClassHint24m, which sets the WM_CLASS property (see
section 14.1.8).  If the res_name member in the 4mXClassHint0m
structure is set to the NULL pointer and the RESOURCE_NAME
environment variable is set, then the value of the environ-
ment variable is substituted for res_name.  If the res_name
member is NULL, the environment variable is not set, and
argv and argv[0] are set, then the value of argv[0],
stripped of any directory prefixes, is substituted for
res_name.

4mXSetWMProperties24m can generate 4mBadAlloc24m and 4mBadWindow24m errors.

1m14.2.	 Client to Session Manager Communication0m

This section discusses how to:

·    Set and read the WM_COMMAND property

·    Set and read the WM_CLIENT_MACHINE property

1m14.2.1.  Setting and Reading the WM_COMMAND Property0m

Xlib provides functions that you can use to set and read the
WM_COMMAND property for a given window.


To set a window's WM_COMMAND property, use 4mXSetCommand24m.









			     1m5340m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
XSetCommand(4mdisplay24m, 4mw24m, 4margv24m, 4margc24m)
      Display *4mdisplay24m;
      Window 4mw24m;
      char **4margv24m;
      int 4margc24m;


4mdisplay24m   Specifies the connection to the X server.

4mw24m	       Specifies the window.

4margv24m      Specifies the application's argument list.

4margc24m      Specifies the number of arguments.
|__

The 4mXSetCommand24m function sets the command and arguments used
to invoke the application.  (Typically, argv is the argv
array of your main program.)  If the strings are not in the
Host Portable Character Encoding, the result is implementa-
tion-dependent.

4mXSetCommand24m can generate 4mBadAlloc24m and 4mBadWindow24m errors.


To read a window's WM_COMMAND property, use 4mXGetCommand24m.
__
|
Status XGetCommand(4mdisplay24m, 4mw24m, 4margv_return24m, 4margc_return24m)
      Display *4mdisplay24m;
      Window 4mw24m;
      char ***4margv_return24m;
      int *4margc_return24m;


4mdisplay24m   Specifies the connection to the X server.

4mw24m	       Specifies the window.

4margv_return0m
	  Returns the application's argument list.

4margc_return0m
	  Returns the number of arguments returned.
|__

The 4mXGetCommand24m function reads the WM_COMMAND property from
the specified window and returns a string list.	 If the
WM_COMMAND property exists, it is of type STRING and format
8.  If sufficient memory can be allocated to contain the
string list, 4mXGetCommand24m fills in the argv_return and
argc_return arguments and returns a nonzero status.  Other-
wise, it returns a zero status.	 If the data returned by the



			     1m5350m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


server is in the Latin Portable Character Encoding, then the
returned strings are in the Host Portable Character Encod-
ing.  Otherwise, the result is implementation-dependent.  To
free the memory allocated to the string list, use
4mXFreeStringList24m.

1m14.2.2.  Setting and Reading the WM_CLIENT_MACHINE Property0m

Xlib provides functions that you can use to set and read the
WM_CLIENT_MACHINE property for a given window.


To set a window's WM_CLIENT_MACHINE property, use 4mXSetWM-0m
4mClientMachine24m.
__
|
void XSetWMClientMachine(4mdisplay24m, 4mw24m, 4mtext_prop24m)
      Display *4mdisplay24m;
      Window 4mw24m;
      XTextProperty *4mtext_prop24m;


4mdisplay24m   Specifies the connection to the X server.

4mw24m	       Specifies the window.

4mtext_prop24m Specifies the 4mXTextProperty24m structure to be used.
|__

The 4mXSetWMClientMachine24m convenience function calls 4mXSet-0m
4mTextProperty24m to set the WM_CLIENT_MACHINE property.


To read a window's WM_CLIENT_MACHINE property, use 4mXGetWM-0m
4mClientMachine24m.
__
|
Status XGetWMClientMachine(4mdisplay24m, 4mw24m, 4mtext_prop_return24m)
      Display *4mdisplay24m;
      Window 4mw24m;
      XTextProperty *4mtext_prop_return24m;


4mdisplay24m   Specifies the connection to the X server.

4mw24m	       Specifies the window.

4mtext_prop_return0m
	  Returns the 4mXTextProperty24m structure.
|__

The 4mXGetWMClientMachine24m convenience function performs an
4mXGetTextProperty24m on the WM_CLIENT_MACHINE property.  It
returns a nonzero status on success; otherwise, it returns a



			     1m5360m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


zero status.

1m14.3.	 Standard Colormaps0m

Applications with color palettes, smooth-shaded drawings, or
digitized images demand large numbers of colors.  In addi-
tion, these applications often require an efficient mapping
from color triples to pixel values that display the appro-
priate colors.

As an example, consider a three-dimensional display program
that wants to draw a smoothly shaded sphere.  At each pixel
in the image of the sphere, the program computes the inten-
sity and color of light reflected back to the viewer.  The
result of each computation is a triple of red, green, and
blue (RGB) coefficients in the range 0.0 to 1.0.  To draw
the sphere, the program needs a colormap that provides a
large range of uniformly distributed colors.  The colormap
should be arranged so that the program can convert its RGB
triples into pixel values very quickly, because drawing the
entire sphere requires many such conversions.

On many current workstations, the display is limited to 256
or fewer colors.  Applications must allocate colors care-
fully, not only to make sure they cover the entire range
they need but also to make use of as many of the available
colors as possible.  On a typical X display, many applica-
tions are active at once.  Most workstations have only one
hardware look-up table for colors, so only one application
colormap can be installed at a given time.  The application
using the installed colormap is displayed correctly, and the
other applications go technicolor and are displayed with
false colors.

As another example, consider a user who is running an image
processing program to display earth-resources data.  The
image processing program needs a colormap set up with 8
reds, 8 greens, and 4 blues, for a total of 256 colors.
Because some colors are already in use in the default col-
ormap, the image processing program allocates and installs a
new colormap.

The user decides to alter some of the colors in the image by
invoking a color palette program to mix and choose colors.
The color palette program also needs a colormap with eight
reds, eight greens, and four blues, so just like the image
processing program, it must allocate and install a new col-
ormap.

Because only one colormap can be installed at a time, the
color palette may be displayed incorrectly whenever the
image processing program is active.  Conversely, whenever
the palette program is active, the image may be displayed
incorrectly.  The user can never match or compare colors in



			     1m5370m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


the palette and image.	Contention for colormap resources
can be reduced if applications with similar color needs
share colormaps.

The image processing program and the color palette program
could share the same colormap if there existed a convention
that described how the colormap was set up.  Whenever either
program was active, both would be displayed correctly.

The standard colormap properties define a set of commonly
used colormaps.	 Applications that share these colormaps and
conventions display true colors more often and provide a
better interface to the user.

Standard colormaps allow applications to share commonly used
color resources.  This allows many applications to be dis-
played in true colors simultaneously, even when each appli-
cation needs an entirely filled colormap.

Several standard colormaps are described in this section.
Usually, a window manager creates these colormaps.  Applica-
tions should use the standard colormaps if they already
exist.


To allocate an 4mXStandardColormap24m structure, use 4mXAllocStan-0m
4mdardColormap24m.
__
|
XStandardColormap *XAllocStandardColormap()

|__

The 4mXAllocStandardColormap24m function allocates and returns a
pointer to an 4mXStandardColormap24m structure.	 Note that all
fields in the 4mXStandardColormap24m structure are initially set
to zero.  If insufficient memory is available, 4mXAllocStan-0m
4mdardColormap24m returns NULL.	 To free the memory allocated to
this structure, use 4mXFree24m.

The 4mXStandardColormap24m structure contains:
















			     1m5380m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|    /* Hints */

#define	  4mReleaseByFreeingCol-24m   ( (XID)
	  4mormap24m		      1L)

/* Values */

typedef struct {
     Colormap colormap;
     unsigned long red_max;
     unsigned long red_mult;
     unsigned long green_max;
     unsigned long green_mult;
     unsigned long blue_max;
     unsigned long blue_mult;
     unsigned long base_pixel;
     VisualID visualid;
     XID killid;
} XStandardColormap;

|__

The colormap member is the colormap created by the 4mXCreate-0m
4mColormap24m function.	 The red_max, green_max, and blue_max
members give the maximum red, green, and blue values,
respectively.  Each color coefficient ranges from zero to
its max, inclusive.  For example, a common colormap alloca-
tion is 3/3/2 (3 planes for red, 3 planes for green, and 2
planes for blue).  This colormap would have red_max = 7,
green_max = 7, and blue_max = 3.  An alternate allocation
that uses only 216 colors is red_max = 5, green_max = 5, and
blue_max = 5.

The red_mult, green_mult, and blue_mult members give the
scale factors used to compose a full pixel value.  (See the
discussion of the base_pixel members for further informa-
tion.)	For a 3/3/2 allocation, red_mult might be 32,
green_mult might be 4, and blue_mult might be 1.  For a
6-colors-each allocation, red_mult might be 36, green_mult
might be 6, and blue_mult might be 1.

The base_pixel member gives the base pixel value used to
compose a full pixel value.  Usually, the base_pixel is
obtained from a call to the 4mXAllocColorPlanes24m function.
Given integer red, green, and blue coefficients in their
appropriate ranges, one then can compute a corresponding
pixel value by using the following expression:


     (r * red_mult + g * green_mult + b * blue_mult + base_pixel) & 0xFFFFFFFF


For 4mGrayScale24m colormaps, only the colormap, red_max,
red_mult, and base_pixel members are defined.  The other



			     1m5390m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


members are ignored.  To compute a 4mGrayScale24m pixel value,
use the following expression:


     (gray * red_mult + base_pixel) & 0xFFFFFFFF


Negative multipliers can be represented by converting the
2's complement representation of the multiplier into an
unsigned long and storing the result in the appropriate
_mult field.  The step of masking by 0xFFFFFFFF effectively
converts the resulting positive multiplier into a negative
one.  The masking step will take place automatically on many
machine architectures, depending on the size of the integer
type used to do the computation.

The visualid member gives the ID number of the visual from
which the colormap was created.	 The killid member gives a
resource ID that indicates whether the cells held by this
standard colormap are to be released by freeing the colormap
ID or by calling the 4mXKillClient24m function on the indicated
resource.  (Note that this method is necessary for allocat-
ing out of an existing colormap.)

The properties containing the 4mXStandardColormap24m information
have the type RGB_COLOR_MAP.

The remainder of this section discusses standard colormap
properties and atoms as well as how to manipulate standard
colormaps.

1m14.3.1.  Standard Colormap Properties and Atoms0m

Several standard colormaps are available.  Each standard
colormap is defined by a property, and each such property is
identified by an atom.	The following list names the atoms
and describes the colormap associated with each one.  The
<4mX11/Xatom.h24m> header file contains the definitions for each
of the following atoms, which are prefixed with XA_.

RGB_DEFAULT_MAP
     This atom names a property.  The value of the property
     is an array of 4mXStandardColormap24m structures.	Each
     entry in the array describes an RGB subset of the
     default color map for the Visual specified by
     visual_id.

     Some applications only need a few RGB colors and may be
     able to allocate them from the system default colormap.
     This is the ideal situation because the fewer colormaps
     that are active in the system the more applications are
     displayed with correct colors at all times.





			     1m5400m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


     A typical allocation for the RGB_DEFAULT_MAP on 8-plane
     displays is 6 reds, 6 greens, and 6 blues.	 This gives
     216 uniformly distributed colors (6 intensities of 36
     different hues) and still leaves 40 elements of a
     256-element colormap available for special-purpose col-
     ors for text, borders, and so on.

RGB_BEST_MAP
     This atom names a property.  The value of the property
     is an 4mXStandardColormap24m.

     The property defines the best RGB colormap available on
     the screen.  (Of course, this is a subjective evalua-
     tion.)  Many image processing and three-dimensional
     applications need to use all available colormap cells
     and to distribute as many perceptually distinct colors
     as possible over those cells.  This implies that there
     may be more green values available than red, as well as
     more green or red than blue.

     For an 8-plane 4mPseudoColor24m visual, RGB_BEST_MAP is
     likely to be a 3/3/2 allocation.  For a 24-plane
     4mDirectColor24m visual, RGB_BEST_MAP is normally an 8/8/8
     allocation.

RGB_RED_MAP
RGB_GREEN_MAP
RGB_BLUE_MAP
     These atoms name properties.  The value of each prop-
     erty is an 4mXStandardColormap24m.

     The properties define all-red, all-green, and all-blue
     colormaps, respectively.  These maps are used by appli-
     cations that want to make color-separated images.	For
     example, a user might generate a full-color image on an
     8-plane display both by rendering an image three times
     (once with high color resolution in red, once with
     green, and once with blue) and by multiply exposing a
     single frame in a camera.

RGB_GRAY_MAP
     This atom names a property.  The value of the property
     is an 4mXStandardColormap24m.

     The property describes the best 4mGrayScale24m colormap
     available on the screen.  As previously mentioned, only
     the colormap, red_max, red_mult, and base_pixel members
     of the 4mXStandardColormap24m structure are used for
     4mGrayScale24m colormaps.

1m14.3.2.  Setting and Obtaining Standard Colormaps0m

Xlib provides functions that you can use to set and obtain
an 4mXStandardColormap24m structure.



			     1m5410m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


To set an 4mXStandardColormap24m structure, use 4mXSetRGBColormaps24m.
__
|
void XSetRGBColormaps(4mdisplay24m, 4mw24m, 4mstd_colormap24m, 4mcount24m, 4mproperty24m)
      Display *4mdisplay24m;
      Window 4mw24m;
      XStandardColormap *4mstd_colormap24m;
      int 4mcount24m;
      Atom 4mproperty24m;


4mdisplay24m   Specifies the connection to the X server.

4mw24m	       Specifies the window.

4mstd_colormap0m
	  Specifies the 4mXStandardColormap24m structure to be
	  used.

4mcount24m     Specifies the number of colormaps.

4mproperty24m  Specifies the property name.
|__

The 4mXSetRGBColormaps24m function replaces the RGB colormap def-
inition in the specified property on the named window.	If
the property does not already exist, 4mXSetRGBColormaps24m sets
the RGB colormap definition in the specified property on the
named window.  The property is stored with a type of
RGB_COLOR_MAP and a format of 32.  Note that it is the
caller's responsibility to honor the ICCCM restriction that
only RGB_DEFAULT_MAP contain more than one definition.

The 4mXSetRGBColormaps24m function usually is only used by window
or session managers.  To create a standard colormap, follow
this procedure:

1.   Open a new connection to the same server.

2.   Grab the server.

3.   See if the property is on the property list of the root
     window for the screen.

4.   If the desired property is not present:

     ·	  Create a colormap (unless you are using the
	  default colormap of the screen).

     ·	  Determine the color characteristics of the visual.

     ·	  Allocate cells in the colormap (or create it with
	  4mAllocAll24m).




			     1m5420m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


     ·	  Call 4mXStoreColors24m to store appropriate color val-
	  ues in the colormap.

     ·	  Fill in the descriptive members in the 4mXStandard-0m
	  4mColormap24m structure.

     ·	  Attach the property to the root window.

     ·	  Use 4mXSetCloseDownMode24m to make the resource perma-
	  nent.

5.   Ungrab the server.

4mXSetRGBColormaps24m can generate 4mBadAlloc24m, 4mBadAtom24m, and 4mBadWin-0m
4mdow24m errors.


To obtain the 4mXStandardColormap24m structure associated with
the specified property, use 4mXGetRGBColormaps24m.
__
|
Status XGetRGBColormaps(4mdisplay24m, 4mw24m, 4mstd_colormap_return24m, 4mcount_return24m, 4mproperty24m)
      Display *4mdisplay24m;
      Window 4mw24m;
      XStandardColormap **4mstd_colormap_return24m;
      int *4mcount_return24m;
      Atom 4mproperty24m;


4mdisplay24m   Specifies the connection to the X server.

4mw24m	       Specifies the window.

4mstd_colormap_return0m
	  Returns the 4mXStandardColormap24m structure.

4mcount_return0m
	  Returns the number of colormaps.

4mproperty24m  Specifies the property name.
|__

The 4mXGetRGBColormaps24m function returns the RGB colormap defi-
nitions stored in the specified property on the named win-
dow.  If the property exists, is of type RGB_COLOR_MAP, is
of format 32, and is long enough to contain a colormap defi-
nition, 4mXGetRGBColormaps24m allocates and fills in space for
the returned colormaps and returns a nonzero status.  If the
visualid is not present, 4mXGetRGBColormaps24m assumes the
default visual for the screen on which the window is
located; if the killid is not present, 4mNone24m is assumed,
which indicates that the resources cannot be released.	Oth-
erwise, none of the fields are set, and 4mXGetRGBColormaps0m
returns a zero status.	Note that it is the caller's



			     1m5430m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


responsibility to honor the ICCCM restriction that only
RGB_DEFAULT_MAP contain more than one definition.

4mXGetRGBColormaps24m can generate 4mBadAtom24m and 4mBadWindow24m errors.





















































			     1m5440m





1mXlib - C Library			X11, Release 6.7 DRAFT0m




			 1mChapter 150m

		 1mResource Manager Functions0m



A program often needs a variety of options in the X environ-
ment (for example, fonts, colors, icons, and cursors).
Specifying all of these options on the command line is awk-
ward because users may want to customize many aspects of the
program and need a convenient way to establish these cus-
tomizations as the default settings.  The resource manager
is provided for this purpose.  Resource specifications are
usually stored in human-readable files and in server proper-
ties.

The resource manager is a database manager with a twist.  In
most database systems, you perform a query using an impre-
cise specification, and you get back a set of records.	The
resource manager, however, allows you to specify a large set
of values with an imprecise specification, to query the
database with a precise specification, and to get back only
a single value.	 This should be used by applications that
need to know what the user prefers for colors, fonts, and
other resources.  It is this use as a database for dealing
with X resources that inspired the name ``Resource Man-
ager,'' although the resource manager can be and is used in
other ways.

For example, a user of your application may want to specify
that all windows should have a blue background but that all
mail-reading windows should have a red background.  With
well-engineered and coordinated applications, a user can
define this information using only two lines of specifica-
tions.

As an example of how the resource manager works, consider a
mail-reading application called xmh.  Assume that it is
designed so that it uses a complex window hierarchy all the
way down to individual command buttons, which may be actual
small subwindows in some toolkits.  These are often called
objects or widgets.  In such toolkit systems, each user
interface object can be composed of other objects and can be
assigned a name and a class.  Fully qualified names or
classes can have arbitrary numbers of component names, but a
fully qualified name always has the same number of component
names as a fully qualified class.  This generally reflects
the structure of the application as composed of these
objects, starting with the application itself.

For example, the xmh mail program has a name ``xmh'' and is
one of a class of ``Mail'' programs.  By convention, the



			     1m5450m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


first character of class components is capitalized, and the
first letter of name components is in lowercase.  Each name
and class finally has an attribute (for example, ``fore-
ground'' or ``font'').	If each window is properly assigned
a name and class, it is easy for the user to specify
attributes of any portion of the application.

At the top level, the application might consist of a paned
window (that is, a window divided into several sections)
named ``toc''.	One pane of the paned window is a button box
window named ``buttons'' and is filled with command buttons.
One of these command buttons is used to incorporate new mail
and has the name ``incorporate''.  This window has a fully
qualified name, ``xmh.toc.buttons.incorporate'', and a fully
qualified class, ``Xmh.Paned.Box.Command''.  Its fully qual-
ified name is the name of its parent, ``xmh.toc.buttons'',
followed by its name, ``incorporate''.	Its class is the
class of its parent, ``Xmh.Paned.Box'', followed by its par-
ticular class, ``Command''.  The fully qualified name of a
resource is the attribute's name appended to the object's
fully qualified name, and the fully qualified class is its
class appended to the object's class.

The incorporate button might need the following resources:
Title string, Font, Foreground color for its inactive state,
Background color for its inactive state, Foreground color
for its active state, and Background color for its active
state.	Each resource is considered to be an attribute of
the button and, as such, has a name and a class.  For exam-
ple, the foreground color for the button in its active state
might be named ``activeForeground'', and its class might be
``Foreground''.

When an application looks up a resource (for example, a
color), it passes the complete name and complete class of
the resource to a look-up routine.  The resource manager
compares this complete specification against the incomplete
specifications of entries in the resource database, finds
the best match, and returns the corresponding value for that
entry.

The definitions for the resource manager are contained in
<4mX11/Xresource.h24m>.

1m15.1.	 Resource File Syntax0m

The syntax of a resource file is a sequence of resource
lines terminated by newline characters or the end of the
file.  The syntax of an individual resource line is:


ResourceLine   = Comment | IncludeFile | ResourceSpec | <empty line>
Comment	       = "!" {<any character except null or newline>}
IncludeFile    = "#" WhiteSpace "include" WhiteSpace FileName WhiteSpace



			     1m5460m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


FileName       = <valid filename for operating system>
ResourceSpec   = WhiteSpace ResourceName WhiteSpace ":" WhiteSpace Value
ResourceName   = [Binding] {Component Binding} ComponentName
Binding	       = "." | "*"
WhiteSpace     = {<space> | <horizontal tab>}
Component      = "?" | ComponentName
ComponentName  = NameChar {NameChar}
NameChar       = "a"-"z" | "A"-"Z" | "0"-"9" | "_" | "-"
Value	       = {<any character except null or unescaped newline>}


Elements separated by vertical bar (|) are alternatives.
Curly braces ({...}) indicate zero or more repetitions of
the enclosed elements.	Square brackets ([...]) indicate
that the enclosed element is optional.	Quotes ("...") are
used around literal characters.

IncludeFile lines are interpreted by replacing the line with
the contents of the specified file.  The word ``include''
must be in lowercase.  The file name is interpreted relative
to the directory of the file in which the line occurs (for
example, if the file name contains no directory or contains
a relative directory specification).

If a ResourceName contains a contiguous sequence of two or
more Binding characters, the sequence will be replaced with
a single ``.'' character if the sequence contains only ``.''
characters; otherwise, the sequence will be replaced with a
single ``*'' character.

A resource database never contains more than one entry for a
given ResourceName.  If a resource file contains multiple
lines with the same ResourceName, the last line in the file
is used.

Any white space characters before or after the name or colon
in a ResourceSpec are ignored.	To allow a Value to begin
with white space, the two-character sequence ``\4mspace24m''
(backslash followed by space) is recognized and replaced by
a space character, and the two-character sequence ``\4mtab24m''
(backslash followed by horizontal tab) is recognized and
replaced by a horizontal tab character.	 To allow a Value to
contain embedded newline characters, the two-character
sequence ``\n'' is recognized and replaced by a newline
character.  To allow a Value to be broken across multiple
lines in a text file, the two-character sequence ``\4mnew-0m
4mline24m'' (backslash followed by newline) is recognized and
removed from the value.	 To allow a Value to contain arbi-
trary character codes, the four-character sequence ``\4mnnn24m'',
where each 4mn24m is a digit character in the range of
``0''-``7'', is recognized and replaced with a single byte
that contains the octal value specified by the sequence.
Finally, the two-character sequence ``\\'' is recognized and
replaced with a single backslash.



			     1m5470m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


As an example of these sequences, the following resource
line contains a value consisting of four characters: a back-
slash, a null, a ``z'', and a newline:

     magic.values: \\\000\
     z\n


1m15.2.	 Resource Manager Matching Rules0m

The algorithm for determining which resource database entry
matches a given query is the heart of the resource manager.
All queries must fully specify the name and class of the
desired resource (use of the characters ``*'' and ``?'' is
not permitted).	 The library supports up to 100 components
in a full name or class.  Resources are stored in the data-
base with only partially specified names and classes, using
pattern matching constructs.  An asterisk (*) is a loose
binding and is used to represent any number of intervening
components, including none.  A period (.) is a tight binding
and is used to separate immediately adjacent components.  A
question mark (?) is used to match any single component name
or class.  A database entry cannot end in a loose binding;
the final component (which cannot be the character ``?'')
must be specified.  The lookup algorithm searches the data-
base for the entry that most closely matches (is most spe-
cific for) the full name and class being queried.  When more
than one database entry matches the full name and class,
precedence rules are used to select just one.

The full name and class are scanned from left to right (from
highest level in the hierarchy to lowest), one component at
a time.	 At each level, the corresponding component and/or
binding of each matching entry is determined, and these
matching components and bindings are compared according to
precedence rules.  Each of the rules is applied at each
level before moving to the next level, until a rule selects
a single entry over all others.	 The rules, in order of
precedence, are:

1.   An entry that contains a matching component (whether
     name, class, or the character ``?'')  takes precedence
     over entries that elide the level (that is, entries
     that match the level in a loose binding).

2.   An entry with a matching name takes precedence over
     both entries with a matching class and entries that
     match using the character ``?''.  An entry with a
     matching class takes precedence over entries that match
     using the character ``?''.

3.   An entry preceded by a tight binding takes precedence
     over entries preceded by a loose binding.




			     1m5480m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


To illustrate these rules, consider the following resource
database entries:

     xmh*Paned*activeForeground:	red4m(entry24m 4mA)0m
     *incorporate.Foreground: blue	4m(entry24m 4mB)0m
     xmh.toc*Command*activeForeground:	green4m(entry24m 4mC)0m
     xmh.toc*?.Foreground:    white	4m(entry24m 4mD)0m
     xmh.toc*Command.activeForeground:	black4m(entry24m 4mE)0m


Consider a query for the resource:


     xmh.toc.messagefunctions.incorporate.activeForeground4m(name)0m
     Xmh.Paned.Box.Command.Foreground	4m(class)0m


At the first level (xmh, Xmh), rule 1 eliminates entry B.
At the second level (toc, Paned), rule 2 eliminates entry A.
At the third level (messagefunctions, Box), no entries are
eliminated.  At the fourth level (incorporate, Command),
rule 2 eliminates entry D.  At the fifth level (activeFore-
ground, Foreground), rule 3 eliminates entry C.

1m15.3.	 Quarks0m

Most uses of the resource manager involve defining names,
classes, and representation types as string constants.	How-
ever, always referring to strings in the resource manager
can be slow, because it is so heavily used in some toolkits.
To solve this problem, a shorthand for a string is used in
place of the string in many of the resource manager func-
tions.	Simple comparisons can be performed rather than
string comparisons.  The shorthand name for a string is
called a quark and is the type 4mXrmQuark24m.  On some occasions,
you may want to allocate a quark that has no string equiva-
lent.

A quark is to a string what an atom is to a string in the
server, but its use is entirely local to your application.


To allocate a new quark, use 4mXrmUniqueQuark24m.
__
|
XrmQuark XrmUniqueQuark()

|__

The 4mXrmUniqueQuark24m function allocates a quark that is guar-
anteed not to represent any string that is known to the
resource manager.





			     1m5490m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


Each name, class, and representation type is typedef'd as an
4mXrmQuark24m.

__
|
typedef int XrmQuark, *XrmQuarkList;
typedef XrmQuark XrmName;
typedef XrmQuark XrmClass;
typedef XrmQuark XrmRepresentation;
#define NULLQUARK ((XrmQuark) 0)

|__

Lists are represented as null-terminated arrays of quarks.
The size of the array must be large enough for the number of
components used.

__
|
typedef XrmQuarkList XrmNameList;
typedef XrmQuarkList XrmClassList;

|__


To convert a string to a quark, use 4mXrmStringToQuark24m or 4mXrm-0m
4mPermStringToQuark24m.
__
|
#define XrmStringToName(string) XrmStringToQuark(string)
#define XrmStringToClass(string) XrmStringToQuark(string)
#define XrmStringToRepresentation(string) XrmStringToQuark(string)

XrmQuark XrmStringToQuark(4mstring24m)
     char *4mstring24m;

XrmQuark XrmPermStringToQuark(4mstring24m)
     char *4mstring24m;


4mstring24m    Specifies the string for which a quark is to be
	  allocated.
|__

These functions can be used to convert from string to quark
representation.	 If the string is not in the Host Portable
Character Encoding, the conversion is implementation-depen-
dent.  The string argument to 4mXrmStringToQuark24m need not be
permanently allocated storage.	4mXrmPermStringToQuark24m is just
like 4mXrmStringToQuark24m, except that Xlib is permitted to
assume the string argument is permanently allocated, and,
hence, that it can be used as the value to be returned by
4mXrmQuarkToString24m.




			     1m5500m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


For any given quark, if 4mXrmStringToQuark24m returns a non-NULL
value, all future calls will return the same value (identi-
cal address).


To convert a quark to a string, use 4mXrmQuarkToString24m.
__
|
#define XrmNameToString(name) XrmQuarkToString(name)
#define XrmClassToString(class) XrmQuarkToString(class)
#define XrmRepresentationToString(type) XrmQuarkToString(type)

char *XrmQuarkToString(4mquark24m)
     XrmQuark 4mquark24m;


4mquark24m     Specifies the quark for which the equivalent
	  string is desired.
|__

These functions can be used to convert from quark represen-
tation to string.  The string pointed to by the return value
must not be modified or freed.	The returned string is byte-
for-byte equal to the original string passed to one of the
string-to-quark routines.  If no string exists for that
quark, 4mXrmQuarkToString24m returns NULL.  For any given quark,
if 4mXrmQuarkToString24m returns a non-NULL value, all future
calls will return the same value (identical address).


To convert a string with one or more components to a quark
list, use 4mXrmStringToQuarkList24m.
__
|
#define XrmStringToNameList(str, name)	XrmStringToQuarkList((str), (name))
#define XrmStringToClassList(str, class) XrmStringToQuarkList((str), (class))

void XrmStringToQuarkList(4mstring24m, 4mquarks_return24m)
     char *4mstring24m;
     XrmQuarkList 4mquarks_return24m;


4mstring24m    Specifies the string for which a quark list is to
	  be allocated.

4mquarks_return0m
	  Returns the list of quarks.  The caller must allo-
	  cate sufficient space for the quarks list before
	  calling 4mXrmStringToQuarkList24m.
|__

The 4mXrmStringToQuarkList24m function converts the null-termi-
nated string (generally a fully qualified name) to a list of
quarks.	 Note that the string must be in the valid



			     1m5510m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


ResourceName format (see section 15.1).	 If the string is
not in the Host Portable Character Encoding, the conversion
is implementation-dependent.

A binding list is a list of type 4mXrmBindingList24m and indi-
cates if components of name or class lists are bound tightly
or loosely (that is, if wildcarding of intermediate compo-
nents is specified).


typedef enum {XrmBindTightly, XrmBindLoosely} XrmBinding, *XrmBindingList;


4mXrmBindTightly24m indicates that a period separates the compo-
nents, and 4mXrmBindLoosely24m indicates that an asterisk sepa-
rates the components.


To convert a string with one or more components to a binding
list and a quark list, use 4mXrmStringToBindingQuarkList24m.
__
|
XrmStringToBindingQuarkList(4mstring24m, 4mbindings_return24m, 4mquarks_return24m)
     char *4mstring24m;
     XrmBindingList 4mbindings_return24m;
     XrmQuarkList 4mquarks_return24m;


4mstring24m    Specifies the string for which a quark list is to
	  be allocated.

4mbindings_return0m
	  Returns the binding list.  The caller must allo-
	  cate sufficient space for the binding list before
	  calling 4mXrmStringToBindingQuarkList24m.

4mquarks_return0m
	  Returns the list of quarks.  The caller must allo-
	  cate sufficient space for the quarks list before
	  calling 4mXrmStringToBindingQuarkList24m.
|__

Component names in the list are separated by a period or an
asterisk character.  The string must be in the format of a
valid ResourceName (see section 15.1).	If the string does
not start with a period or an asterisk, a tight binding is
assumed.  For example, the string ``*a.b*c'' becomes:


quarks:	       a      bc
bindings:      loose  tightloose






			     1m5520m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


1m15.4.	 Creating and Storing Databases0m

A resource database is an opaque type, 4mXrmDatabase24m.  Each
database value is stored in an 4mXrmValue24m structure.	 This
structure consists of a size, an address, and a representa-
tion type.  The size is specified in bytes.  The representa-
tion type is a way for you to store data tagged by some
application-defined type (for example, the strings ``font''
or ``color'').	It has nothing to do with the C data type or
with its class.	 The 4mXrmValue24m structure is defined as:

__
|
typedef struct {
     unsigned int size;
     XPointer addr;
} XrmValue, *XrmValuePtr;

|__


To initialize the resource manager, use 4mXrmInitialize24m.
__
|
void XrmInitialize();

|__

To retrieve a database from disk, use 4mXrmGetFileDatabase24m.
__
|
XrmDatabase XrmGetFileDatabase(4mfilename24m)
     char *4mfilename24m;


4mfilename24m  Specifies the resource database file name.
|__

The 4mXrmGetFileDatabase24m function opens the specified file,
creates a new resource database, and loads it with the spec-
ifications read in from the specified file.  The specified
file should contain a sequence of entries in valid Resource-
Line format (see section 15.1); the database that results
from reading a file with incorrect syntax is implementation-
dependent.  The file is parsed in the current locale, and
the database is created in the current locale.	If it cannot
open the specified file, 4mXrmGetFileDatabase24m returns NULL.


To store a copy of a database to disk, use 4mXrmPutFile-0m
4mDatabase24m.






			     1m5530m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
void XrmPutFileDatabase(4mdatabase24m, 4mstored_db24m)
     XrmDatabase 4mdatabase24m;
     char *4mstored_db24m;


4mdatabase24m  Specifies the database that is to be used.

4mstored_db24m Specifies the file name for the stored database.
|__

The 4mXrmPutFileDatabase24m function stores a copy of the speci-
fied database in the specified file.  Text is written to the
file as a sequence of entries in valid ResourceLine format
(see section 15.1).  The file is written in the locale of
the database.  Entries containing resource names that are
not in the Host Portable Character Encoding or containing
values that are not in the encoding of the database locale,
are written in an implementation-dependent manner.  The
order in which entries are written is implementation-depen-
dent.  Entries with representation types other than
``String'' are ignored.


To obtain a pointer to the screen-independent resources of a
display, use 4mXResourceManagerString24m.
__
|
char *XResourceManagerString(4mdisplay24m)
      Display *4mdisplay24m;


4mdisplay24m   Specifies the connection to the X server.
|__

The 4mXResourceManagerString24m function returns the
RESOURCE_MANAGER property from the server's root window of
screen zero, which was returned when the connection was
opened using 4mXOpenDisplay24m.	 The property is converted from
type STRING to the current locale.  The conversion is iden-
tical to that produced by 4mXmbTextPropertyToTextList24m for a
single element STRING property.	 The returned string is
owned by Xlib and should not be freed by the client.  The
property value must be in a format that is acceptable to
4mXrmGetStringDatabase24m.  If no property exists, NULL is
returned.


To obtain a pointer to the screen-specific resources of a
screen, use 4mXScreenResourceString24m.







			     1m5540m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
char *XScreenResourceString(4mscreen24m)
      Screen *4mscreen24m;


4mscreen24m    Specifies the screen.
|__

The 4mXScreenResourceString24m function returns the
SCREEN_RESOURCES property from the root window of the speci-
fied screen.  The property is converted from type STRING to
the current locale.  The conversion is identical to that
produced by 4mXmbTextPropertyToTextList24m for a single element
STRING property.  The property value must be in a format
that is acceptable to 4mXrmGetStringDatabase24m.  If no property
exists, NULL is returned.  The caller is responsible for
freeing the returned string by using 4mXFree24m.


To create a database from a string, use 4mXrmGetString-0m
4mDatabase24m.
__
|
XrmDatabase XrmGetStringDatabase(4mdata24m)
     char *4mdata24m;


4mdata24m      Specifies the database contents using a string.
|__

The 4mXrmGetStringDatabase24m function creates a new database and
stores the resources specified in the specified null-termi-
nated string.  4mXrmGetStringDatabase24m is similar to 4mXrmGet-0m
4mFileDatabase24m except that it reads the information out of a
string instead of out of a file.  The string should contain
a sequence of entries in valid ResourceLine format (see sec-
tion 15.1) terminated by a null character; the database that
results from using a string with incorrect syntax is imple-
mentation-dependent.  The string is parsed in the current
locale, and the database is created in the current locale.


To obtain the locale name of a database, use 4mXrmLocaleOf-0m
4mDatabase24m.
__
|
char *XrmLocaleOfDatabase(4mdatabase24m)
      XrmDatabase 4mdatabase24m;


4mdatabase24m  Specifies the resource database.
|__

The 4mXrmLocaleOfDatabase24m function returns the name of the



			     1m5550m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


locale bound to the specified database, as a null-terminated
string.	 The returned locale name string is owned by Xlib
and should not be modified or freed by the client.  Xlib is
not permitted to free the string until the database is
destroyed.  Until the string is freed, it will not be modi-
fied by Xlib.


To destroy a resource database and free its allocated mem-
ory, use 4mXrmDestroyDatabase24m.
__
|
void XrmDestroyDatabase(4mdatabase24m)
      XrmDatabase 4mdatabase24m;


4mdatabase24m  Specifies the resource database.
|__

If database is NULL, 4mXrmDestroyDatabase24m returns immediately.


To associate a resource database with a display, use 4mXrmSet-0m
4mDatabase24m.
__
|
void XrmSetDatabase(4mdisplay24m, 4mdatabase24m)
      Display *4mdisplay24m;
      XrmDatabase 4mdatabase24m;


4mdisplay24m   Specifies the connection to the X server.

4mdatabase24m  Specifies the resource database.
|__

The 4mXrmSetDatabase24m function associates the specified
resource database (or NULL) with the specified display.	 The
database previously associated with the display (if any) is
not destroyed.	A client or toolkit may find this function
convenient for retaining a database once it is constructed.


To get the resource database associated with a display, use
4mXrmGetDatabase24m.












			     1m5560m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
XrmDatabase XrmGetDatabase(4mdisplay24m)
      Display *4mdisplay24m;


4mdisplay24m   Specifies the connection to the X server.
|__

The 4mXrmGetDatabase24m function returns the database associated
with the specified display.  It returns NULL if a database
has not yet been set.

1m15.5.	 Merging Resource Databases0m

To merge the contents of a resource file into a database,
use 4mXrmCombineFileDatabase24m.
__
|
Status XrmCombineFileDatabase(4mfilename24m, 4mtarget_db24m, 4moverride24m)
      char *4mfilename24m;
      XrmDatabase *4mtarget_db24m;
      Bool 4moverride24m;


4mfilename24m  Specifies the resource database file name.

4mtarget_db24m Specifies the resource database into which the
	  source database is to be merged.

4moverride24m  Specifies whether source entries override target
	  ones.
|__

The 4mXrmCombineFileDatabase24m function merges the contents of a
resource file into a database.	If the same specifier is
used for an entry in both the file and the database, the
entry in the file will replace the entry in the database if
override is 4mTrue24m; otherwise, the entry in the file is dis-
carded.	 The file is parsed in the current locale.  If the
file cannot be read, a zero status is returned; otherwise, a
nonzero status is returned.  If target_db contains NULL,
4mXrmCombineFileDatabase24m creates and returns a new database to
it.  Otherwise, the database pointed to by target_db is not
destroyed by the merge.	 The database entries are merged
without changing values or types, regardless of the locale
of the database.  The locale of the target database is not
modified.


To merge the contents of one database into another database,
use 4mXrmCombineDatabase24m.






			     1m5570m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
void XrmCombineDatabase(4msource_db24m, 4mtarget_db24m, 4moverride24m)
      XrmDatabase 4msource_db24m, *4mtarget_db24m;
      Bool 4moverride24m;


4msource_db24m Specifies the resource database that is to be
	  merged into the target database.

4mtarget_db24m Specifies the resource database into which the
	  source database is to be merged.

4moverride24m  Specifies whether source entries override target
	  ones.
|__

The 4mXrmCombineDatabase24m function merges the contents of one
database into another.	If the same specifier is used for an
entry in both databases, the entry in the source_db will
replace the entry in the target_db if override is 4mTrue24m; oth-
erwise, the entry in source_db is discarded.  If target_db
contains NULL, 4mXrmCombineDatabase24m simply stores source_db in
it.  Otherwise, source_db is destroyed by the merge, but the
database pointed to by target_db is not destroyed.  The
database entries are merged without changing values or
types, regardless of the locales of the databases.  The
locale of the target database is not modified.


To merge the contents of one database into another database
with override semantics, use 4mXrmMergeDatabases24m.
__
|
void XrmMergeDatabases(4msource_db24m, 4mtarget_db24m)
      XrmDatabase 4msource_db24m, *4mtarget_db24m;


4msource_db24m Specifies the resource database that is to be
	  merged into the target database.

4mtarget_db24m Specifies the resource database into which the
	  source database is to be merged.
|__

Calling the 4mXrmMergeDatabases24m function is equivalent to
calling the 4mXrmCombineDatabase24m function with an override
argument of 4mTrue24m.

1m15.6.	 Looking Up Resources0m

To retrieve a resource from a resource database, use 4mXrmGe-0m
4mtResource24m, 4mXrmQGetResource24m, or 4mXrmQGetSearchResource24m.





			     1m5580m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
Bool XrmGetResource(4mdatabase24m, 4mstr_name24m, 4mstr_class24m, 4mstr_type_return24m, 4mvalue_return24m)
     XrmDatabase 4mdatabase24m;
     char *4mstr_name24m;
     char *4mstr_class24m;
     char **4mstr_type_return24m;
     XrmValue *4mvalue_return24m;


4mdatabase24m  Specifies the database that is to be used.

4mstr_name24m  Specifies the fully qualified name of the value
	  being retrieved (as a string).

4mstr_class24m Specifies the fully qualified class of the value
	  being retrieved (as a string).

4mstr_type_return0m
	  Returns the representation type of the destination
	  (as a string).

4mvalue_return0m
	  Returns the value in the database.
|__

































			     1m5590m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
Bool XrmQGetResource(4mdatabase24m, 4mquark_name24m, 4mquark_class24m, 4mquark_type_return24m, 4mvalue_return24m)
     XrmDatabase 4mdatabase24m;
     XrmNameList 4mquark_name24m;
     XrmClassList 4mquark_class24m;
     XrmRepresentation *4mquark_type_return24m;
     XrmValue *4mvalue_return24m;


4mdatabase24m  Specifies the database that is to be used.

4mquark_name0m
	  Specifies the fully qualified name of the value
	  being retrieved (as a quark).

4mquark_class0m
	  Specifies the fully qualified class of the value
	  being retrieved (as a quark).

4mquark_type_return0m
	  Returns the representation type of the destination
	  (as a quark).

4mvalue_return0m
	  Returns the value in the database.
|__

The 4mXrmGetResource24m and 4mXrmQGetResource24m functions retrieve a
resource from the specified database.  Both take a fully
qualified name/class pair, a destination resource represen-
tation, and the address of a value (size/address pair).	 The
value and returned type point into database memory; there-
fore, you must not modify the data.

The database only frees or overwrites entries on 4mXrmPutRe-0m
4msource24m, 4mXrmQPutResource24m, or 4mXrmMergeDatabases24m.  A client
that is not storing new values into the database or is not
merging the database should be safe using the address passed
back at any time until it exits.  If a resource was found,
both 4mXrmGetResource24m and 4mXrmQGetResource24m return 4mTrue24m; other-
wise, they return 4mFalse24m.



Most applications and toolkits do not make random probes
into a resource database to fetch resources.  The X toolkit
access pattern for a resource database is quite stylized.  A
series of from 1 to 20 probes is made with only the last
name/class differing in each probe.  The 4mXrmGetResource0m
function is at worst a 24mn24m algorithm, where 4mn24m is the length
of the name/class list.	 This can be improved upon by the
application programmer by prefetching a list of database
levels that might match the first part of a name/class list.




			     1m5600m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


To obtain a list of database levels, use 4mXrmQGetSearchList24m.
__
|
typedef XrmHashTable *XrmSearchList;

Bool XrmQGetSearchList(4mdatabase24m, 4mnames24m, 4mclasses24m, 4mlist_return24m, 4mlist_length24m)
     XrmDatabase 4mdatabase24m;
     XrmNameList 4mnames24m;
     XrmClassList 4mclasses24m;
     XrmSearchList 4mlist_return24m;
     int 4mlist_length24m;


4mdatabase24m  Specifies the database that is to be used.

4mnames24m     Specifies a list of resource names.

4mclasses24m   Specifies a list of resource classes.

4mlist_return0m
	  Returns a search list for further use.  The caller
	  must allocate sufficient space for the list before
	  calling 4mXrmQGetSearchList24m.

4mlist_length0m
	  Specifies the number of entries (not the byte
	  size) allocated for list_return.
|__

The 4mXrmQGetSearchList24m function takes a list of names and
classes and returns a list of database levels where a match
might occur.  The returned list is in best-to-worst order
and uses the same algorithm as 4mXrmGetResource24m for determin-
ing precedence.	 If list_return was large enough for the
search list, 4mXrmQGetSearchList24m returns 4mTrue24m; otherwise, it
returns 4mFalse24m.

The size of the search list that the caller must allocate is
dependent upon the number of levels and wildcards in the
resource specifiers that are stored in the database.  The
worst case length is 34mn24m, where 4mn24m is the number of name or
class components in names or classes.

When using 4mXrmQGetSearchList24m followed by multiple probes for
resources with a common name and class prefix, only the com-
mon prefix should be specified in the name and class list to
4mXrmQGetSearchList24m.


To search resource database levels for a given resource, use
4mXrmQGetSearchResource24m.






			     1m5610m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
Bool XrmQGetSearchResource(4mlist24m, 4mname24m, 4mclass24m, 4mtype_return24m, 4mvalue_return24m)
     XrmSearchList 4mlist24m;
     XrmName 4mname24m;
     XrmClass 4mclass24m;
     XrmRepresentation *4mtype_return24m;
     XrmValue *4mvalue_return24m;


4mlist24m      Specifies the search list returned by 4mXrmQGet-0m
	  4mSearchList24m.

4mname24m      Specifies the resource name.

4mclass24m     Specifies the resource class.

4mtype_return0m
	  Returns data representation type.

4mvalue_return0m
	  Returns the value in the database.
|__

The 4mXrmQGetSearchResource24m function searches the specified
database levels for the resource that is fully identified by
the specified name and class.  The search stops with the
first match.  4mXrmQGetSearchResource24m returns 4mTrue24m if the
resource was found; otherwise, it returns 4mFalse24m.

A call to 4mXrmQGetSearchList24m with a name and class list con-
taining all but the last component of a resource name fol-
lowed by a call to 4mXrmQGetSearchResource24m with the last com-
ponent name and class returns the same database entry as
4mXrmGetResource24m and 4mXrmQGetResource24m with the fully qualified
name and class.

1m15.7.	 Storing into a Resource Database0m

To store resources into the database, use 4mXrmPutResource24m or
4mXrmQPutResource24m.  Both functions take a partial resource
specification, a representation type, and a value.  This
value is copied into the specified database.















			     1m5620m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
void XrmPutResource(4mdatabase24m, 4mspecifier24m, 4mtype24m, 4mvalue24m)
     XrmDatabase *4mdatabase24m;
     char *4mspecifier24m;
     char *4mtype24m;
     XrmValue *4mvalue24m;


4mdatabase24m  Specifies the resource database.

4mspecifier24m Specifies a complete or partial specification of
	  the resource.

4mtype24m      Specifies the type of the resource.

4mvalue24m     Specifies the value of the resource, which is
	  specified as a string.
|__

If database contains NULL, 4mXrmPutResource24m creates a new
database and returns a pointer to it.  4mXrmPutResource24m is a
convenience function that calls 4mXrmStringToBindingQuarkList0m
followed by:


     XrmQPutResource(database, bindings, quarks, XrmStringToQuark(type), value)

If the specifier and type are not in the Host Portable Char-
acter Encoding, the result is implementation-dependent.	 The
value is stored in the database without modification.



























			     1m5630m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
void XrmQPutResource(4mdatabase24m, 4mbindings24m, 4mquarks24m, 4mtype24m, 4mvalue24m)
     XrmDatabase *4mdatabase24m;
     XrmBindingList 4mbindings24m;
     XrmQuarkList 4mquarks24m;
     XrmRepresentation 4mtype24m;
     XrmValue *4mvalue24m;


4mdatabase24m  Specifies the resource database.

4mbindings24m  Specifies a list of bindings.

4mquarks24m    Specifies the complete or partial name or the
	  class list of the resource.

4mtype24m      Specifies the type of the resource.

4mvalue24m     Specifies the value of the resource, which is
	  specified as a string.
|__

If database contains NULL, 4mXrmQPutResource24m creates a new
database and returns a pointer to it.  If a resource entry
with the identical bindings and quarks already exists in the
database, the previous type and value are replaced by the
new specified type and value.  The value is stored in the
database without modification.


To add a resource that is specified as a string, use 4mXrmPut-0m
4mStringResource24m.
__
|
void XrmPutStringResource(4mdatabase24m, 4mspecifier24m, 4mvalue24m)
     XrmDatabase *4mdatabase24m;
     char *4mspecifier24m;
     char *4mvalue24m;


4mdatabase24m  Specifies the resource database.

4mspecifier24m Specifies a complete or partial specification of
	  the resource.

4mvalue24m     Specifies the value of the resource, which is
	  specified as a string.
|__

If database contains NULL, 4mXrmPutStringResource24m creates a
new database and returns a pointer to it.  4mXrmPutStringRe-0m
4msource24m adds a resource with the specified value to the spec-
ified database.	 4mXrmPutStringResource24m is a convenience func-
tion that first calls 4mXrmStringToBindingQuarkList24m on the



			     1m5640m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


specifier and then calls 4mXrmQPutResource24m, using a ``String''
representation type.  If the specifier is not in the Host
Portable Character Encoding, the result is implementation-
dependent.  The value is stored in the database without mod-
ification.


To add a string resource using quarks as a specification,
use 4mXrmQPutStringResource24m.
__
|
void XrmQPutStringResource(4mdatabase24m, 4mbindings24m, 4mquarks24m, 4mvalue24m)
     XrmDatabase *4mdatabase24m;
     XrmBindingList 4mbindings24m;
     XrmQuarkList 4mquarks24m;
     char *4mvalue24m;


4mdatabase24m  Specifies the resource database.

4mbindings24m  Specifies a list of bindings.

4mquarks24m    Specifies the complete or partial name or the
	  class list of the resource.

4mvalue24m     Specifies the value of the resource, which is
	  specified as a string.
|__

If database contains NULL, 4mXrmQPutStringResource24m creates a
new database and returns a pointer to it.  4mXrmQPutStringRe-0m
4msource24m is a convenience routine that constructs an 4mXrmValue0m
for the value string (by calling 4mstrlen24m to compute the size)
and then calls 4mXrmQPutResource24m, using a ``String'' represen-
tation type.  The value is stored in the database without
modification.


To add a single resource entry that is specified as a string
that contains both a name and a value, use 4mXrmPutLineRe-0m
4msource24m.
















			     1m5650m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
void XrmPutLineResource(4mdatabase24m, 4mline24m)
     XrmDatabase *4mdatabase24m;
     char *4mline24m;


4mdatabase24m  Specifies the resource database.

4mline24m      Specifies the resource name and value pair as a
	  single string.
|__

If database contains NULL, 4mXrmPutLineResource24m creates a new
database and returns a pointer to it.  4mXrmPutLineResource0m
adds a single resource entry to the specified database.	 The
line should be in valid ResourceLine format (see section
15.1) terminated by a newline or null character; the data-
base that results from using a string with incorrect syntax
is implementation-dependent.  The string is parsed in the
locale of the database.	 If the 4mResourceName24m is not in the
Host Portable Character Encoding, the result is implementa-
tion-dependent.	 Note that comment lines are not stored.

1m15.8.	 Enumerating Database Entries0m

To enumerate the entries of a database, use 4mXrmEnumerate-0m
4mDatabase24m.






























			     1m5660m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
#define	  4mXrmEnumAllLevels24m	      0
#define	  4mXrmEnumOneLevel24m	      1


Bool XrmEnumerateDatabase(4mdatabase24m, 4mname_prefix24m, 4mclass_prefix24m, 4mmode24m, 4mproc24m, 4marg24m)
      XrmDatabase 4mdatabase24m;
      XrmNameList 4mname_prefix24m;
      XrmClassList 4mclass_prefix24m;
      int 4mmode24m;
      Bool (*4mproc24m)();
      XPointer 4marg24m;


4mdatabase24m  Specifies the resource database.

4mname_prefix0m
	  Specifies the resource name prefix.

4mclass_prefix0m
	  Specifies the resource class prefix.

4mmode24m      Specifies the number of levels to enumerate.

4mproc24m      Specifies the procedure that is to be called for
	  each matching entry.

4marg24m       Specifies the user-supplied argument that will be
	  passed to the procedure.
|__

The 4mXrmEnumerateDatabase24m function calls the specified proce-
dure for each resource in the database that would match some
completion of the given name/class resource prefix.  The
order in which resources are found is implementation-depen-
dent.  If mode is 4mXrmEnumOneLevel24m, a resource must match the
given name/class prefix with just a single name and class
appended.  If mode is 4mXrmEnumAllLevels24m, the resource must
match the given name/class prefix with one or more names and
classes appended.  If the procedure returns 4mTrue24m, the enu-
meration terminates and the function returns 4mTrue24m.	 If the
procedure always returns 4mFalse24m, all matching resources are
enumerated and the function returns 4mFalse24m.

The procedure is called with the following arguments:


(*4mproc24m)(4mdatabase24m, 4mbindings24m, 4mquarks24m, 4mtype24m, 4mvalue24m, 4marg24m)
     XrmDatabase *4mdatabase24m;
     XrmBindingList 4mbindings24m;
     XrmQuarkList 4mquarks24m;
     XrmRepresentation *4mtype24m;
     XrmValue *4mvalue24m;
     XPointer 4marg24m;



			     1m5670m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


The bindings and quarks lists are terminated by 4mNULLQUARK24m.
Note that pointers to the database and type are passed, but
these values should not be modified.

The procedure must not modify the database.  If Xlib has
been initialized for threads, the procedure is called with
the database locked and the result of a call by the proce-
dure to any Xlib function using the same database is not
defined.

1m15.9.	 Parsing Command Line Options0m

The 4mXrmParseCommand24m function can be used to parse the com-
mand line arguments to a program and modify a resource data-
base with selected entries from the command line.

__
|
typedef enum {
     XrmoptionNoArg,	 /* Value is specified in XrmOptionDescRec.value */
     XrmoptionIsArg,	 /* Value is the option string itself */
     XrmoptionStickyArg, /* Value is characters immediately following option */
     XrmoptionSepArg,	 /* Value is next argument in argv */
     XrmoptionResArg,	 /* Resource and value in next argument in argv */
     XrmoptionSkipArg,	 /* Ignore this option and the next argument in argv */
     XrmoptionSkipLine,	 /* Ignore this option and the rest of argv */
     XrmoptionSkipNArgs	 /* Ignore this option and the next
			    XrmOptionDescRec.value arguments in argv */
} XrmOptionKind;

|__

Note that 4mXrmoptionSkipArg24m is equivalent to 4mXrmoptionSkip-0m
4mNArgs24m with the 4mXrmOptionDescRec.value24m field containing the
value one.  Note also that the value zero for 4mXrmoptionSkip-0m
4mNArgs24m indicates that only the option itself is to be
skipped.

__
|
typedef struct {
     char *option;	 /* Option specification string in argv	   */
     char *specifier;	 /* Binding and resource name (sans application name)	 */
     XrmOptionKind argKind;/* Which style of option it is    */
     XPointer value;	 /* Value to provide if XrmoptionNoArg or
			    XrmoptionSkipNArgs	 */
} XrmOptionDescRec, *XrmOptionDescList;

|__


To load a resource database from a C command line, use 4mXrm-0m
4mParseCommand24m.




			     1m5680m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
void XrmParseCommand(4mdatabase24m, 4mtable24m, 4mtable_count24m, 4mname24m, 4margc_in_out24m, 4margv_in_out24m)
      XrmDatabase *4mdatabase24m;
      XrmOptionDescList 4mtable24m;
      int 4mtable_count24m;
      char *4mname24m;
      int *4margc_in_out24m;
      char **4margv_in_out24m;


4mdatabase24m  Specifies the resource database.

4mtable24m     Specifies the table of command line arguments to
	  be parsed.

4mtable_count0m
	  Specifies the number of entries in the table.

4mname24m      Specifies the application name.

4margc_in_out0m
	  Specifies the number of arguments and returns the
	  number of remaining arguments.

4margv_in_out0m
	  Specifies the command line arguments and returns
	  the remaining arguments.
|__

The 4mXrmParseCommand24m function parses an (argc, argv) pair
according to the specified option table, loads recognized
options into the specified database with type ``String,''
and modifies the (argc, argv) pair to remove all recognized
options.  If database contains NULL, 4mXrmParseCommand24m creates
a new database and returns a pointer to it.  Otherwise,
entries are added to the database specified.  If a database
is created, it is created in the current locale.

The specified table is used to parse the command line.	Rec-
ognized options in the table are removed from argv, and
entries are added to the specified resource database in the
order they occur in argv.  The table entries contain infor-
mation on the option string, the option name, the style of
option, and a value to provide if the option kind is 4mXrmop-0m
4mtionNoArg24m.	 The option names are compared byte-for-byte to
arguments in argv, independent of any locale.  The resource
values given in the table are stored in the resource data-
base without modification.  All resource database entries
are created using a ``String'' representation type.  The
argc argument specifies the number of arguments in argv and
is set on return to the remaining number of arguments that
were not parsed.  The name argument should be the name of
your application for use in building the database entry.
The name argument is prefixed to the resourceName in the



			     1m5690m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


option table before storing a database entry.  The name
argument is treated as a single component, even if it has
embedded periods.  No separating (binding) character is
inserted, so the table must contain either a period (.) or
an asterisk (*) as the first character in each resourceName
entry.	To specify a more completely qualified resource
name, the resourceName entry can contain multiple compo-
nents.	If the name argument and the resourceNames are not
in the Host Portable Character Encoding, the result is
implementation-dependent.

The following provides a sample option table:


static XrmOptionDescRec opTable[] = {
{"-background",			"*background", XrmoptionSepArg,(XPointer) NULL},
{"-bd",	    "*borderColor",	XrmoptionSepArg,(XPointer) NULL},
{"-bg",	    "*background",	XrmoptionSepArg,(XPointer) NULL},
{"-borderwidth",		"*TopLevelShell.borderWidth",XrmoptionSepArg,(XPointer) NULL},
{"-bordercolor",		"*borderColor",XrmoptionSepArg,(XPointer) NULL},
{"-bw",	    "*TopLevelShell.borderWidth",      XrmoptionSepArg,(XPointer) NULL},
{"-display",			".display",    XrmoptionSepArg,(XPointer) NULL},
{"-fg",	    "*foreground",	XrmoptionSepArg,(XPointer) NULL},
{"-fn",	    "*font",		XrmoptionSepArg,(XPointer) NULL},
{"-font",   "*font",		XrmoptionSepArg,(XPointer) NULL},
{"-foreground",			"*foreground", XrmoptionSepArg,(XPointer) NULL},
{"-geometry",			".TopLevelShell.geometry",XrmoptionSepArg,(XPointer) NULL},
{"-iconic", ".TopLevelShell.iconic",	       XrmoptionNoArg,(XPointer) "on"},
{"-name",   ".name",		XrmoptionSepArg,(XPointer) NULL},
{"-reverse",			"*reverseVideo",XrmoptionNoArg,(XPointer) "on"},
{"-rv",	    "*reverseVideo",	XrmoptionNoArg,(XPointer) "on"},
{"-synchronous",		"*synchronous",XrmoptionNoArg,(XPointer) "on"},
{"-title",  ".TopLevelShell.title",	       XrmoptionSepArg,(XPointer) NULL},
{"-xrm",    NULL,		XrmoptionResArg,(XPointer) NULL},
};


In this table, if the -background (or -bg) option is used to
set background colors, the stored resource specifier matches
all resources of attribute background.	If the -borderwidth
option is used, the stored resource specifier applies only
to border width attributes of class TopLevelShell (that is,
outer-most windows, including pop-up windows).	If the
-title option is used to set a window name, only the topmost
application windows receive the resource.

When parsing the command line, any unique unambiguous abbre-
viation for an option name in the table is considered a
match for the option.  Note that uppercase and lowercase
matter.







			     1m5700m





1mXlib - C Library			X11, Release 6.7 DRAFT0m




			 1mChapter 160m

	       1mApplication Utility Functions0m



Once you have initialized the X system, you can use the Xlib
utility functions to:

·    Use keyboard utility functions

·    Use Latin-1 keyboard event functions

·    Allocate permanent storage

·    Parse the window geometry

·    Manipulate regions

·    Use cut buffers

·    Determine the appropriate visual type

·    Manipulate images

·    Manipulate bitmaps

·    Use the context manager

As a group, the functions discussed in this chapter provide
the functionality that is frequently needed and that spans
toolkits.  Many of these functions do not generate actual
protocol requests to the server.

1m16.1.	 Using Keyboard Utility Functions0m

This section discusses mapping between KeyCodes and KeySyms,
classifying KeySyms, and mapping between KeySyms and string
names.	The first three functions in this section operate on
a cached copy of the server keyboard mapping.  The first
four KeySyms for each KeyCode are modified according to the
rules given in section 12.7.  To obtain the untransformed
KeySyms defined for a key, use the functions described in
section 12.7.


To obtain a KeySym for the KeyCode of an event, use 4mXLookup-0m
4mKeysym24m.







			     1m5710m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
KeySym XLookupKeysym(4mkey_event24m, 4mindex24m)
      XKeyEvent *4mkey_event24m;
      int 4mindex24m;


4mkey_event24m Specifies the 4mKeyPress24m or 4mKeyRelease24m event.

4mindex24m     Specifies the index into the KeySyms list for the
	  event's KeyCode.
|__

The 4mXLookupKeysym24m function uses a given keyboard event and
the index you specified to return the KeySym from the list
that corresponds to the KeyCode member in the 4mXKeyPressedE-0m
4mvent24m or 4mXKeyReleasedEvent24m structure.	If no KeySym is
defined for the KeyCode of the event, 4mXLookupKeysym24m returns
4mNoSymbol24m.


To obtain a KeySym for a specific KeyCode, use 4mXKey-0m
4mcodeToKeysym24m.
__
|
KeySym XKeycodeToKeysym(4mdisplay24m, 4mkeycode24m, 4mindex24m)
      Display *4mdisplay24m;
      KeyCode 4mkeycode24m;
      int 4mindex24m;


4mdisplay24m   Specifies the connection to the X server.

4mkeycode24m   Specifies the KeyCode.

4mindex24m     Specifies the element of KeyCode vector.
|__

The 4mXKeycodeToKeysym24m function uses internal Xlib tables and
returns the KeySym defined for the specified KeyCode and the
element of the KeyCode vector.	If no symbol is defined,
4mXKeycodeToKeysym24m returns 4mNoSymbol24m.


To obtain a KeyCode for a key having a specific KeySym, use
4mXKeysymToKeycode24m.












			     1m5720m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
KeyCode XKeysymToKeycode(4mdisplay24m, 4mkeysym24m)
      Display *4mdisplay24m;
      KeySym 4mkeysym24m;


4mdisplay24m   Specifies the connection to the X server.

4mkeysym24m    Specifies the KeySym that is to be searched for.
|__

If the specified KeySym is not defined for any KeyCode,
4mXKeysymToKeycode24m returns zero.


The mapping between KeyCodes and KeySyms is cached internal
to Xlib.  When this information is changed at the server, an
Xlib function must be called to refresh the cache.  To
refresh the stored modifier and keymap information, use 4mXRe-0m
4mfreshKeyboardMapping24m.
__
|
XRefreshKeyboardMapping(4mevent_map24m)
      XMappingEvent *4mevent_map24m;


4mevent_map24m Specifies the mapping event that is to be used.
|__

The 4mXRefreshKeyboardMapping24m function refreshes the stored
modifier and keymap information.  You usually call this
function when a 4mMappingNotify24m event with a request member of
4mMappingKeyboard24m or 4mMappingModifier24m occurs.  The result is to
update Xlib's knowledge of the keyboard.


To obtain the uppercase and lowercase forms of a KeySym, use
4mXConvertCase24m.



















			     1m5730m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
void XConvertCase(4mkeysym24m, 4mlower_return24m, 4mupper_return24m)
      KeySym 4mkeysym24m;
      KeySym *4mlower_return24m;
      KeySym *4mupper_return24m;


4mkeysym24m    Specifies the KeySym that is to be converted.

4mlower_return0m
	  Returns the lowercase form of keysym, or keysym.

4mupper_return0m
	  Returns the uppercase form of keysym, or keysym.
|__

The 4mXConvertCase24m function returns the uppercase and lower-
case forms of the specified Keysym, if the KeySym is subject
to case conversion; otherwise, the specified KeySym is
returned to both lower_return and upper_return.	 Support for
conversion of other than Latin and Cyrillic KeySyms is
implementation-dependent.


KeySyms have string names as well as numeric codes.  To con-
vert the name of the KeySym to the KeySym code, use 4mXString-0m
4mToKeysym24m.
__
|
KeySym XStringToKeysym(4mstring24m)
      char *4mstring24m;


4mstring24m    Specifies the name of the KeySym that is to be
	  converted.
|__

Standard KeySym names are obtained from <4mX11/keysymdef.h24m> by
removing the XK_ prefix from each name.	 KeySyms that are
not part of the Xlib standard also may be obtained with this
function.  The set of KeySyms that are available in this
manner and the mechanisms by which Xlib obtains them is
implementation-dependent.

If the KeySym name is not in the Host Portable Character
Encoding, the result is implementation-dependent.  If the
specified string does not match a valid KeySym, 4mXString-0m
4mToKeysym24m returns 4mNoSymbol24m.


To convert a KeySym code to the name of the KeySym, use
4mXKeysymToString24m.





			     1m5740m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
char *XKeysymToString(4mkeysym24m)
      KeySym 4mkeysym24m;


4mkeysym24m    Specifies the KeySym that is to be converted.
|__

The returned string is in a static area and must not be mod-
ified.	The returned string is in the Host Portable Charac-
ter Encoding.  If the specified KeySym is not defined,
4mXKeysymToString24m returns a NULL.

1m16.1.1.  KeySym Classification Macros0m

You may want to test if a KeySym is, for example, on the
keypad or on one of the function keys.	You can use KeySym
macros to perform the following tests.


__
|
IsCursorKey(4mkeysym24m)


4mkeysym24m    Specifies the KeySym that is to be tested.
|__

Returns 4mTrue24m if the specified KeySym is a cursor key.


__
|
IsFunctionKey(4mkeysym24m)


4mkeysym24m    Specifies the KeySym that is to be tested.
|__

Returns 4mTrue24m if the specified KeySym is a function key.


__
|
IsKeypadKey(4mkeysym24m)


4mkeysym24m    Specifies the KeySym that is to be tested.
|__

Returns 4mTrue24m if the specified KeySym is a standard keypad
key.





			     1m5750m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
IsPrivateKeypadKey(4mkeysym24m)


4mkeysym24m    Specifies the KeySym that is to be tested.
|__

Returns 4mTrue24m if the specified KeySym is a vendor-private
keypad key.


__
|
IsMiscFunctionKey(4mkeysym24m)


4mkeysym24m    Specifies the KeySym that is to be tested.
|__

Returns 4mTrue24m if the specified KeySym is a miscellaneous
function key.


__
|
IsModifierKey(4mkeysym24m)


4mkeysym24m    Specifies the KeySym that is to be tested.
|__

Returns 4mTrue24m if the specified KeySym is a modifier key.


__
|
IsPFKey(4mkeysym24m)


4mkeysym24m    Specifies the KeySym that is to be tested.
|__

Returns 4mTrue24m if the specified KeySym is a PF key.

1m16.2.	 Using Latin-1 Keyboard Event Functions0m

Chapter 13 describes internationalized text input facili-
ties, but sometimes it is expedient to write an application
that only deals with Latin-1 characters and ASCII controls,
so Xlib provides a simple function for that purpose.
4mXLookupString24m handles the standard modifier semantics
described in section 12.7.  This function does not use any
of the input method facilities described in chapter 13 and
does not depend on the current locale.



			     1m5760m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


To map a key event to an ISO Latin-1 string, use 4mXLookup-0m
4mString24m.
__
|
int XLookupString(4mevent_struct24m, 4mbuffer_return24m, 4mbytes_buffer24m, 4mkeysym_return24m, 4mstatus_in_out24m)
      XKeyEvent *4mevent_struct24m;
      char *4mbuffer_return24m;
      int 4mbytes_buffer24m;
      KeySym *4mkeysym_return24m;
      XComposeStatus *4mstatus_in_out24m;


4mevent_struct0m
	  Specifies the key event structure to be used.	 You
	  can pass 4mXKeyPressedEvent24m or 4mXKeyReleasedEvent24m.

4mbuffer_return0m
	  Returns the translated characters.

4mbytes_buffer0m
	  Specifies the length of the buffer.  No more than
	  bytes_buffer of translation are returned.

4mkeysym_return0m
	  Returns the KeySym computed from the event if this
	  argument is not NULL.

4mstatus_in_out0m
	  Specifies or returns the 4mXComposeStatus24m structure
	  or NULL.
|__

The 4mXLookupString24m function translates a key event to a
KeySym and a string.  The KeySym is obtained by using the
standard interpretation of the 4mShift24m, 4mLock24m, group, and num-
lock modifiers as defined in the X Protocol specification.
If the KeySym has been rebound (see 4mXRebindKeysym24m), the
bound string will be stored in the buffer.  Otherwise, the
KeySym is mapped, if possible, to an ISO Latin-1 character
or (if the Control modifier is on) to an ASCII control char-
acter, and that character is stored in the buffer.  4mXLookup-0m
4mString24m returns the number of characters that are stored in
the buffer.

If present (non-NULL), the 4mXComposeStatus24m structure records
the state, which is private to Xlib, that needs preservation
across calls to 4mXLookupString24m to implement compose process-
ing.  The creation of 4mXComposeStatus24m structures is implemen-
tation-dependent; a portable program must pass NULL for this
argument.

4mXLookupString24m depends on the cached keyboard information
mentioned in the previous section, so it is necessary to use
4mXRefreshKeyboardMapping24m to keep this information up-to-date.



			     1m5770m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


To rebind the meaning of a KeySym for 4mXLookupString24m, use
4mXRebindKeysym24m.
__
|
XRebindKeysym(4mdisplay24m, 4mkeysym24m, 4mlist24m, 4mmod_count24m, 4mstring24m, 4mnum_bytes24m)
      Display *4mdisplay24m;
      KeySym 4mkeysym24m;
      KeySym 4mlist24m[];
      int 4mmod_count24m;
      unsigned char *4mstring24m;
      int 4mnum_bytes24m;


4mdisplay24m   Specifies the connection to the X server.

4mkeysym24m    Specifies the KeySym that is to be rebound.

4mlist24m      Specifies the KeySyms to be used as modifiers.

4mmod_count24m Specifies the number of modifiers in the modifier
	  list.

4mstring24m    Specifies the string that is copied and will be
	  returned by 4mXLookupString24m.

4mnum_bytes24m Specifies the number of bytes in the string argu-
	  ment.
|__

The 4mXRebindKeysym24m function can be used to rebind the meaning
of a KeySym for the client.  It does not redefine any key in
the X server but merely provides an easy way for long
strings to be attached to keys.	 4mXLookupString24m returns this
string when the appropriate set of modifier keys are pressed
and when the KeySym would have been used for the transla-
tion.  No text conversions are performed; the client is
responsible for supplying appropriately encoded strings.
Note that you can rebind a KeySym that may not exist.

1m16.3.	 Allocating Permanent Storage0m

To allocate some memory you will never give back, use
4mXpermalloc24m.
__
|
char *Xpermalloc(4msize24m)
     unsigned int 4msize24m;

|__

The 4mXpermalloc24m function allocates storage that can never be
freed for the life of the program.  The memory is allocated
with alignment for the C type double.  This function may
provide some performance and space savings over the standard



			     1m5780m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


operating system memory allocator.

1m16.4.	 Parsing the Window Geometry0m

To parse standard window geometry strings, use 4mXParseGeome-0m
4mtry24m.

__
|
int XParseGeometry(4mparsestring24m, 4mx_return24m, 4my_return24m, 4mwidth_return24m, 4mheight_return24m)
      char *4mparsestring24m;
      int *4mx_return24m, *4my_return24m;
      unsigned int *4mwidth_return24m, *4mheight_return24m;


4mparsestring0m
	  Specifies the string you want to parse.

4mx_return0m
4my_return24m  Return the x and y offsets.

4mwidth_return0m
4mheight_return0m
	  Return the width and height determined.
|__

By convention, X applications use a standard string to indi-
cate window size and placement.	 4mXParseGeometry24m makes it
easier to conform to this standard because it allows you to
parse the standard window geometry.  Specifically, this
function lets you parse strings of the form:


     [=][<4mwidth24m>{xX}<4mheight24m>][{+-}<4mxoffset24m>{+-}<4myoffset24m>]


The fields map into the arguments associated with this func-
tion.  (Items enclosed in <> are integers, items in [] are
optional, and items enclosed in {} indicate ``choose one
of.''  Note that the brackets should not appear in the
actual string.)	 If the string is not in the Host Portable
Character Encoding, the result is implementation-dependent.

The 4mXParseGeometry24m function returns a bitmask that indicates
which of the four values (width, height, xoffset, and yoff-
set) were actually found in the string and whether the x and
y values are negative.	By convention, -0 is not equal to
+0, because the user needs to be able to say ``position the
window relative to the right or bottom edge.''	For each
value found, the corresponding argument is updated.  For
each value not found, the argument is left unchanged.  The
bits are represented by 4mXValue24m, 4mYValue24m, 4mWidthValue24m, 4mHeight-0m
4mValue24m, 4mXNegative24m, or 4mYNegative24m and are defined in
<4mX11/Xutil.h24m>.  They will be set whenever one of the values



			     1m5790m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


is defined or one of the signs is set.

If the function returns either the 4mXValue24m or 4mYValue24m flag,
you should place the window at the requested position.


To construct a window's geometry information, use 4mXWMGeome-0m
4mtry24m.
__
|
int XWMGeometry(4mdisplay24m, 4mscreen24m, 4muser_geom24m, 4mdef_geom24m, 4mbwidth24m, 4mhints24m, 4mx_return24m, 4my_return24m,
		4mwidth_return24m, 4mheight_return24m, 4mgravity_return24m)
      Display *4mdisplay24m;
      int 4mscreen24m;
      char *4muser_geom24m;
      char *4mdef_geom24m;
      unsigned int 4mbwidth24m;
      XSizeHints *4mhints24m;
      int *4mx_return24m, *4my_return24m;
      int *4mwidth_return24m;
      int *4mheight_return24m;
      int *4mgravity_return24m;


4mdisplay24m   Specifies the connection to the X server.

4mscreen24m    Specifies the screen.

4muser_geom24m Specifies the user-specified geometry or NULL.

4mdef_geom24m  Specifies the application's default geometry or
	  NULL.

4mbwidth24m    Specifies the border width.

4mhints24m     Specifies the size hints for the window in its
	  normal state.

4mx_return0m
4my_return24m  Return the x and y offsets.

4mwidth_return0m
4mheight_return0m
	  Return the width and height determined.

4mgravity_return0m
	  Returns the window gravity.
|__

The 4mXWMGeometry24m function combines any geometry information
(given in the format used by 4mXParseGeometry24m) specified by
the user and by the calling program with size hints (usually
the ones to be stored in WM_NORMAL_HINTS) and returns the
position, size, and gravity (4mNorthWestGravity24m,



			     1m5800m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


4mNorthEastGravity24m, 4mSouthEastGravity24m, or 4mSouthWestGravity24m)
that describe the window.  If the base size is not set in
the 4mXSizeHints24m structure, the minimum size is used if set.
Otherwise, a base size of zero is assumed.  If no minimum
size is set in the hints structure, the base size is used.
A mask (in the form returned by 4mXParseGeometry24m) that
describes which values came from the user specification and
whether or not the position coordinates are relative to the
right and bottom edges is returned.  Note that these coordi-
nates will have already been accounted for in the x_return
and y_return values.

Note that invalid geometry specifications can cause a width
or height of zero to be returned.  The caller may pass the
address of the hints win_gravity field as gravity_return to
update the hints directly.

1m16.5.	 Manipulating Regions0m

Regions are arbitrary sets of pixel locations.	Xlib pro-
vides functions for manipulating regions.  The opaque type
4mRegion24m is defined in <4mX11/Xutil.h24m>.  Xlib provides functions
that you can use to manipulate regions.	 This section dis-
cusses how to:

·    Create, copy, or destroy regions

·    Move or shrink regions

·    Compute with regions

·    Determine if regions are empty or equal

·    Locate a point or rectangle in a region

1m16.5.1.  Creating, Copying, or Destroying Regions0m

To create a new empty region, use 4mXCreateRegion24m.
__
|
Region XCreateRegion()

|__


To generate a region from a polygon, use 4mXPolygonRegion24m.











			     1m5810m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
Region XPolygonRegion(4mpoints24m, 4mn24m, 4mfill_rule24m)
      XPoint 4mpoints[]24m;
      int 4mn24m;
      int 4mfill_rule24m;


4mpoints24m    Specifies an array of points.

4mn24m	       Specifies the number of points in the polygon.

4mfill_rule24m Specifies the fill-rule you want to set for the
	  specified GC.	 You can pass 4mEvenOddRule24m or 4mWindin-0m
	  4mgRule24m.
|__

The 4mXPolygonRegion24m function returns a region for the polygon
defined by the points array.  For an explanation of
fill_rule, see 4mXCreateGC24m.


To set the clip-mask of a GC to a region, use 4mXSetRegion24m.
__
|
XSetRegion(4mdisplay24m, 4mgc24m, 4mr24m)
      Display *4mdisplay24m;
      GC 4mgc24m;
      Region 4mr24m;


4mdisplay24m   Specifies the connection to the X server.

4mgc24m	       Specifies the GC.

4mr24m	       Specifies the region.
|__

The 4mXSetRegion24m function sets the clip-mask in the GC to the
specified region.  The region is specified relative to the
drawable's origin.  The resulting GC clip origin is imple-
mentation-dependent.  Once it is set in the GC, the region
can be destroyed.


To deallocate the storage associated with a specified
region, use 4mXDestroyRegion24m.











			     1m5820m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
XDestroyRegion(4mr24m)
      Region 4mr24m;


4mr24m	       Specifies the region.
|__


1m16.5.2.  Moving or Shrinking Regions0m

To move a region by a specified amount, use 4mXOffsetRegion24m.
__
|
XOffsetRegion(4mr24m, 4mdx24m, 4mdy24m)
      Region 4mr24m;
      int 4mdx24m, 4mdy24m;


4mr24m	       Specifies the region.

4mdx0m
4mdy24m	       Specify the x and y coordinates, which define the
	  amount you want to move the specified region.
|__


To reduce a region by a specified amount, use 4mXShrinkRegion24m.
__
|
XShrinkRegion(4mr24m, 4mdx24m, 4mdy24m)
      Region 4mr24m;
      int 4mdx24m, 4mdy24m;


4mr24m	       Specifies the region.

4mdx0m
4mdy24m	       Specify the x and y coordinates, which define the
	  amount you want to shrink the specified region.
|__

Positive values shrink the size of the region, and negative
values expand the region.

1m16.5.3.  Computing with Regions0m


To generate the smallest rectangle enclosing a region, use
4mXClipBox24m.







			     1m5830m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
XClipBox(4mr24m, 4mrect_return24m)
      Region 4mr24m;
      XRectangle *4mrect_return24m;


4mr24m	       Specifies the region.

4mrect_return0m
	  Returns the smallest enclosing rectangle.
|__

The 4mXClipBox24m function returns the smallest rectangle enclos-
ing the specified region.


To compute the intersection of two regions, use 4mXIntersec-0m
4mtRegion24m.
__
|
XIntersectRegion(4msra24m, 4msrb24m, 4mdr_return24m)
      Region 4msra24m, 4msrb24m, 4mdr_return24m;


4msra0m
4msrb24m       Specify the two regions with which you want to
	  perform the computation.

4mdr_return24m Returns the result of the computation.
|__


To compute the union of two regions, use 4mXUnionRegion24m.
__
|
XUnionRegion(4msra24m, 4msrb24m, 4mdr_return24m)
      Region 4msra24m, 4msrb24m, 4mdr_return24m;


4msra0m
4msrb24m       Specify the two regions with which you want to
	  perform the computation.

4mdr_return24m Returns the result of the computation.
|__


To create a union of a source region and a rectangle, use
4mXUnionRectWithRegion24m.








			     1m5840m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
XUnionRectWithRegion(4mrectangle24m, 4msrc_region24m, 4mdest_region_return24m)
     XRectangle *4mrectangle24m;
     Region 4msrc_region24m;
     Region 4mdest_region_return24m;


4mrectangle24m Specifies the rectangle.

4msrc_region0m
	  Specifies the source region to be used.

4mdest_region_return0m
	  Returns the destination region.
|__

The 4mXUnionRectWithRegion24m function updates the destination
region from a union of the specified rectangle and the spec-
ified source region.


To subtract two regions, use 4mXSubtractRegion24m.
__
|
XSubtractRegion(4msra24m, 4msrb24m, 4mdr_return24m)
      Region 4msra24m, 4msrb24m, 4mdr_return24m;


4msra0m
4msrb24m       Specify the two regions with which you want to
	  perform the computation.

4mdr_return24m Returns the result of the computation.
|__

The 4mXSubtractRegion24m function subtracts srb from sra and
stores the results in dr_return.


To calculate the difference between the union and intersec-
tion of two regions, use 4mXXorRegion24m.
















			     1m5850m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
XXorRegion(4msra24m, 4msrb24m, 4mdr_return24m)
      Region 4msra24m, 4msrb24m, 4mdr_return24m;


4msra0m
4msrb24m       Specify the two regions with which you want to
	  perform the computation.

4mdr_return24m Returns the result of the computation.
|__


1m16.5.4.  Determining if Regions Are Empty or Equal0m

To determine if the specified region is empty, use 4mXEmptyRe-0m
4mgion24m.
__
|
Bool XEmptyRegion(4mr24m)
      Region 4mr24m;


4mr24m	       Specifies the region.
|__

The 4mXEmptyRegion24m function returns 4mTrue24m if the region is
empty.


To determine if two regions have the same offset, size, and
shape, use 4mXEqualRegion24m.
__
|
Bool XEqualRegion(4mr124m, 4mr224m)
      Region 4mr124m, 4mr224m;


4mr10m
4mr224m	       Specify the two regions.
|__

The 4mXEqualRegion24m function returns 4mTrue24m if the two regions
have the same offset, size, and shape.

1m16.5.5.  Locating a Point or a Rectangle in a Region0m

To determine if a specified point resides in a specified
region, use 4mXPointInRegion24m.








			     1m5860m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
Bool XPointInRegion(4mr24m, 4mx24m, 4my24m)
      Region 4mr24m;
      int 4mx24m, 4my24m;


4mr24m	       Specifies the region.

4mx0m
4my24m	       Specify the x and y coordinates, which define the
	  point.
|__

The 4mXPointInRegion24m function returns 4mTrue24m if the point (x, y)
is contained in the region r.


To determine if a specified rectangle is inside a region,
use 4mXRectInRegion24m.
__
|
int XRectInRegion(4mr24m, 4mx24m, 4my24m, 4mwidth24m, 4mheight24m)
      Region 4mr24m;
      int 4mx24m, 4my24m;
      unsigned int 4mwidth24m, 4mheight24m;


4mr24m	       Specifies the region.

4mx0m
4my24m	       Specify the x and y coordinates, which define the
	  coordinates of the upper-left corner of the rec-
	  tangle.

4mwidth0m
4mheight24m    Specify the width and height, which define the
	  rectangle.
|__

The 4mXRectInRegion24m function returns 4mRectangleIn24m if the rec-
tangle is entirely in the specified region, 4mRectangleOut24m if
the rectangle is entirely out of the specified region, and
4mRectanglePart24m if the rectangle is partially in the specified
region.

1m16.6.	 Using Cut Buffers0m

Xlib provides functions to manipulate cut buffers, a very
simple form of cut-and-paste inter-client communication.
Selections are a much more powerful and useful mechanism for
interchanging data between clients (see section 4.5) and
generally should be used instead of cut buffers.





			     1m5870m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


Cut buffers are implemented as properties on the first root
window of the display.	The buffers can only contain text,
in the STRING encoding.	 The text encoding is not changed by
Xlib when fetching or storing.	Eight buffers are provided
and can be accessed as a ring or as explicit buffers (num-
bered 0 through 7).


To store data in cut buffer 0, use 4mXStoreBytes24m.
__
|
XStoreBytes(4mdisplay24m, 4mbytes24m, 4mnbytes24m)
      Display *4mdisplay24m;
      char *4mbytes24m;
      int 4mnbytes24m;


4mdisplay24m   Specifies the connection to the X server.

4mbytes24m     Specifies the bytes, which are not necessarily
	  ASCII or null-terminated.

4mnbytes24m    Specifies the number of bytes to be stored.
|__

The data can have embedded null characters and need not be
null-terminated.  The cut buffer's contents can be retrieved
later by any client calling 4mXFetchBytes24m.

4mXStoreBytes24m can generate a 4mBadAlloc24m error.


To store data in a specified cut buffer, use 4mXStoreBuffer24m.
__
|
XStoreBuffer(4mdisplay24m, 4mbytes24m, 4mnbytes24m, 4mbuffer24m)
      Display *4mdisplay24m;
      char *4mbytes24m;
      int 4mnbytes24m;
      int 4mbuffer24m;


4mdisplay24m   Specifies the connection to the X server.

4mbytes24m     Specifies the bytes, which are not necessarily
	  ASCII or null-terminated.

4mnbytes24m    Specifies the number of bytes to be stored.

4mbuffer24m    Specifies the buffer in which you want to store
	  the bytes.
|__

If an invalid buffer is specified, the call has no effect.



			     1m5880m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


The data can have embedded null characters and need not be
null-terminated.

4mXStoreBuffer24m can generate a 4mBadAlloc24m error.


To return data from cut buffer 0, use 4mXFetchBytes24m.
__
|
char *XFetchBytes(4mdisplay24m, 4mnbytes_return24m)
      Display *4mdisplay24m;
      int *4mnbytes_return24m;


4mdisplay24m   Specifies the connection to the X server.

4mnbytes_return0m
	  Returns the number of bytes in the buffer.
|__

The 4mXFetchBytes24m function returns the number of bytes in the
nbytes_return argument, if the buffer contains data.  Other-
wise, the function returns NULL and sets nbytes to 0.  The
appropriate amount of storage is allocated and the pointer
returned.  The client must free this storage when finished
with it by calling 4mXFree24m.


To return data from a specified cut buffer, use 4mXFetch-0m
4mBuffer24m.
__
|
char *XFetchBuffer(4mdisplay24m, 4mnbytes_return24m, 4mbuffer24m)
      Display *4mdisplay24m;
      int *4mnbytes_return24m;
      int 4mbuffer24m;


4mdisplay24m   Specifies the connection to the X server.

4mnbytes_return0m
	  Returns the number of bytes in the buffer.

4mbuffer24m    Specifies the buffer from which you want the
	  stored data returned.
|__

The 4mXFetchBuffer24m function returns zero to the nbytes_return
argument if there is no data in the buffer or if an invalid
buffer is specified.


To rotate the cut buffers, use 4mXRotateBuffers24m.




			     1m5890m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
XRotateBuffers(4mdisplay24m, 4mrotate24m)
      Display *4mdisplay24m;
      int 4mrotate24m;


4mdisplay24m   Specifies the connection to the X server.

4mrotate24m    Specifies how much to rotate the cut buffers.
|__

The 4mXRotateBuffers24m function rotates the cut buffers, such
that buffer 0 becomes buffer n, buffer 1 becomes n + 1 mod
8, and so on.  This cut buffer numbering is global to the
display.  Note that 4mXRotateBuffers24m generates 4mBadMatch24m errors
if any of the eight buffers have not been created.

1m16.7.	 Determining the Appropriate Visual Type0m

A single display can support multiple screens.	Each screen
can have several different visual types supported at differ-
ent depths.  You can use the functions described in this
section to determine which visual to use for your applica-
tion.

The functions in this section use the visual information
masks and the 4mXVisualInfo24m structure, which is defined in
<4mX11/Xutil.h24m> and contains:





























			     1m5900m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
/* Visual information mask bits */

#define	  4mVisualNoMask24m		   0x0
#define	  4mVisualIDMask24m		   0x1
#define	  4mVisualScreenMask24m		   0x2
#define	  4mVisualDepthMask24m		   0x4
#define	  4mVisualClassMask24m		   0x8
#define	  4mVisualRedMaskMask24m	   0x10
#define	  4mVisualGreenMaskMask24m	   0x20
#define	  4mVisualBlueMaskMask24m	   0x40
#define	  4mVisualColormapSizeMask24m	   0x80
#define	  4mVisualBitsPerRGBMask24m	   0x100
#define	  4mVisualAllMask24m		   0x1FF


/* Values */

typedef struct {
     Visual *visual;
     VisualID visualid;
     int screen;
     unsigned int depth;
     int class;
     unsigned long red_mask;
     unsigned long green_mask;
     unsigned long blue_mask;
     int colormap_size;
     int bits_per_rgb;
} XVisualInfo;

|__

To obtain a list of visual information structures that match
a specified template, use 4mXGetVisualInfo24m.






















			     1m5910m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
XVisualInfo *XGetVisualInfo(4mdisplay24m, 4mvinfo_mask24m, 4mvinfo_template24m, 4mnitems_return24m)
      Display *4mdisplay24m;
      long 4mvinfo_mask24m;
      XVisualInfo *4mvinfo_template24m;
      int *4mnitems_return24m;


4mdisplay24m   Specifies the connection to the X server.

4mvinfo_mask0m
	  Specifies the visual mask value.

4mvinfo_template0m
	  Specifies the visual attributes that are to be
	  used in matching the visual structures.

4mnitems_return0m
	  Returns the number of matching visual structures.
|__

The 4mXGetVisualInfo24m function returns a list of visual struc-
tures that have attributes equal to the attributes specified
by vinfo_template.  If no visual structures match the tem-
plate using the specified vinfo_mask, 4mXGetVisualInfo24m returns
a NULL.	 To free the data returned by this function, use
4mXFree24m.


To obtain the visual information that matches the specified
depth and class of the screen, use 4mXMatchVisualInfo24m.
__
|
Status XMatchVisualInfo(4mdisplay24m, 4mscreen24m, 4mdepth24m, 4mclass24m, 4mvinfo_return24m)
      Display *4mdisplay24m;
      int 4mscreen24m;
      int 4mdepth24m;
      int 4mclass24m;
      XVisualInfo *4mvinfo_return24m;


4mdisplay24m   Specifies the connection to the X server.

4mscreen24m    Specifies the screen.

4mdepth24m     Specifies the depth of the screen.

4mclass24m     Specifies the class of the screen.

4mvinfo_return0m
	  Returns the matched visual information.
|__

The 4mXMatchVisualInfo24m function returns the visual information



			     1m5920m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


for a visual that matches the specified depth and class for
a screen.  Because multiple visuals that match the specified
depth and class can exist, the exact visual chosen is unde-
fined.	If a visual is found, 4mXMatchVisualInfo24m returns
nonzero and the information on the visual to vinfo_return.
Otherwise, when a visual is not found, 4mXMatchVisualInfo0m
returns zero.

1m16.8.	 Manipulating Images0m

Xlib provides several functions that perform basic opera-
tions on images.  All operations on images are defined using
an 4mXImage24m structure, as defined in <4mX11/Xlib.h24m>.  Because
the number of different types of image formats can be very
large, this hides details of image storage properly from
applications.

This section describes the functions for generic operations
on images.  Manufacturers can provide very fast implementa-
tions of these for the formats frequently encountered on
their hardware.	 These functions are neither sufficient nor
desirable to use for general image processing.	Rather, they
are here to provide minimal functions on screen format
images.	 The basic operations for getting and putting images
are 4mXGetImage24m and 4mXPutImage24m.

Note that no functions have been defined, as yet, to read
and write images to and from disk files.

The 4mXImage24m structure describes an image as it exists in the
client's memory.  The user can request that some of the mem-
bers such as height, width, and xoffset be changed when the
image is sent to the server.  Note that bytes_per_line in
concert with offset can be used to extract a subset of the
image.	Other members (for example, byte order, bitmap_unit,
and so forth) are characteristics of both the image and the
server.	 If these members differ between the image and the
server, 4mXPutImage24m makes the appropriate conversions.  The
first byte of the first line of plane n must be located at
the address (data + (n * height * bytes_per_line)).  For a
description of the 4mXImage24m structure, see section 8.7.


To allocate an 4mXImage24m structure and initialize it with image
format values from a display, use 4mXCreateImage24m.












			     1m5930m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
XImage *XCreateImage(4mdisplay24m, 4mvisual24m, 4mdepth24m, 4mformat24m, 4moffset24m, 4mdata24m, 4mwidth24m, 4mheight24m, 4mbitmap_pad24m,
			4mbytes_per_line24m)
      Display *4mdisplay24m;
      Visual *4mvisual24m;
      unsigned int 4mdepth24m;
      int 4mformat24m;
      int 4moffset24m;
      char *4mdata24m;
      unsigned int 4mwidth24m;
      unsigned int 4mheight24m;
      int 4mbitmap_pad24m;
      int 4mbytes_per_line24m;


4mdisplay24m   Specifies the connection to the X server.

4mvisual24m    Specifies the 4mVisual24m structure.

4mdepth24m     Specifies the depth of the image.

4mformat24m    Specifies the format for the image.  You can pass
	  4mXYBitmap24m, 4mXYPixmap24m, or 4mZPixmap24m.

4moffset24m    Specifies the number of pixels to ignore at the
	  beginning of the scanline.

4mdata24m      Specifies the image data.

4mwidth24m     Specifies the width of the image, in pixels.

4mheight24m    Specifies the height of the image, in pixels.

4mbitmap_pad0m
	  Specifies the quantum of a scanline (8, 16, or
	  32).	In other words, the start of one scanline is
	  separated in client memory from the start of the
	  next scanline by an integer multiple of this many
	  bits.

4mbytes_per_line0m
	  Specifies the number of bytes in the client image
	  between the start of one scanline and the start of
	  the next.
|__

The 4mXCreateImage24m function allocates the memory needed for an
4mXImage24m structure for the specified display but does not
allocate space for the image itself.  Rather, it initializes
the structure byte-order, bit-order, and bitmap-unit values
from the display and returns a pointer to the 4mXImage24m struc-
ture.  The red, green, and blue mask values are defined for
Z format images only and are derived from the 4mVisual24m struc-
ture passed in.	 Other values also are passed in.  The



			     1m5940m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


offset permits the rapid displaying of the image without
requiring each scanline to be shifted into position.  If you
pass a zero value in bytes_per_line, Xlib assumes that the
scanlines are contiguous in memory and calculates the value
of bytes_per_line itself.

Note that when the image is created using 4mXCreateImage24m, 4mXGe-0m
4mtImage24m, or 4mXSubImage24m, the destroy procedure that the 4mXDe-0m
4mstroyImage24m function calls frees both the image structure and
the data pointed to by the image structure.

The basic functions used to get a pixel, set a pixel, create
a subimage, and add a constant value to an image are defined
in the image object.  The functions in this section are
really macro invocations of the functions in the image
object and are defined in <4mX11/Xutil.h24m>.


To obtain a pixel value in an image, use 4mXGetPixel24m.
__
|
unsigned long XGetPixel(4mximage24m, 4mx24m, 4my24m)
      XImage *4mximage24m;
      int 4mx24m;
      int 4my24m;


4mximage24m    Specifies the image.

4mx0m
4my24m	       Specify the x and y coordinates.
|__

The 4mXGetPixel24m function returns the specified pixel from the
named image.  The pixel value is returned in normalized for-
mat (that is, the least significant byte of the long is the
least significant byte of the pixel).  The image must con-
tain the x and y coordinates.


To set a pixel value in an image, use 4mXPutPixel24m.
















			     1m5950m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
XPutPixel(4mximage24m, 4mx24m, 4my24m, 4mpixel24m)
      XImage *4mximage24m;
      int 4mx24m;
      int 4my24m;
      unsigned long 4mpixel24m;


4mximage24m    Specifies the image.

4mx0m
4my24m	       Specify the x and y coordinates.

4mpixel24m     Specifies the new pixel value.
|__

The 4mXPutPixel24m function overwrites the pixel in the named
image with the specified pixel value.  The input pixel value
must be in normalized format (that is, the least significant
byte of the long is the least significant byte of the
pixel).	 The image must contain the x and y coordinates.


To create a subimage, use 4mXSubImage24m.
__
|
XImage *XSubImage(4mximage24m, 4mx24m, 4my24m, 4msubimage_width24m, 4msubimage_height24m)
      XImage *4mximage24m;
      int 4mx24m;
      int 4my24m;
      unsigned int 4msubimage_width24m;
      unsigned int 4msubimage_height24m;


4mximage24m    Specifies the image.

4mx0m
4my24m	       Specify the x and y coordinates.

4msubimage_width0m
	  Specifies the width of the new subimage, in pix-
	  els.

4msubimage_height0m
	  Specifies the height of the new subimage, in pix-
	  els.
|__

The 4mXSubImage24m function creates a new image that is a subsec-
tion of an existing one.  It allocates the memory necessary
for the new 4mXImage24m structure and returns a pointer to the
new image.  The data is copied from the source image, and
the image must contain the rectangle defined by x, y, subim-
age_width, and subimage_height.



			     1m5960m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


To increment each pixel in an image by a constant value, use
4mXAddPixel24m.
__
|
XAddPixel(4mximage24m, 4mvalue24m)
      XImage *4mximage24m;
      long 4mvalue24m;


4mximage24m    Specifies the image.

4mvalue24m     Specifies the constant value that is to be added.
|__

The 4mXAddPixel24m function adds a constant value to every pixel
in an image.  It is useful when you have a base pixel value
from allocating color resources and need to manipulate the
image to that form.


To deallocate the memory allocated in a previous call to
4mXCreateImage24m, use 4mXDestroyImage24m.
__
|
XDestroyImage(4mximage24m)
	XImage *4mximage24m;


4mximage24m    Specifies the image.
|__

The 4mXDestroyImage24m function deallocates the memory associated
with the 4mXImage24m structure.

Note that when the image is created using 4mXCreateImage24m, 4mXGe-0m
4mtImage24m, or 4mXSubImage24m, the destroy procedure that this macro
calls frees both the image structure and the data pointed to
by the image structure.

1m16.9.	 Manipulating Bitmaps0m

Xlib provides functions that you can use to read a bitmap
from a file, save a bitmap to a file, or create a bitmap.
This section describes those functions that transfer bitmaps
to and from the client's file system, thus allowing their
reuse in a later connection (for example, from an entirely
different client or to a different display or server).

The X version 11 bitmap file format is:








			     1m5970m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
#define 4mname24m_width 4mwidth0m
#define 4mname24m_height 4mheight0m
#define 4mname24m_x_hot 4mx0m
#define 4mname24m_y_hot 4my0m
static unsigned char 4mname24m_bits[] = { 0x4mNN24m,... }

|__

The lines for the variables ending with _x_hot and _y_hot
suffixes are optional because they are present only if a
hotspot has been defined for this bitmap.  The lines for the
other variables are required.  The word ``unsigned'' is
optional; that is, the type of the _bits array can be
``char'' or ``unsigned char''.	The _bits array must be
large enough to contain the size bitmap.  The bitmap unit is
8.


To read a bitmap from a file and store it in a pixmap, use
4mXReadBitmapFile24m.
__
|
int XReadBitmapFile(4mdisplay24m, 4md24m, 4mfilename24m, 4mwidth_return24m, 4mheight_return24m, 4mbitmap_return24m, 4mx_hot_return24m,
		       4my_hot_return24m)
      Display *4mdisplay24m;
      Drawable 4md24m;
      char *4mfilename24m;
      unsigned int *4mwidth_return24m, *4mheight_return24m;
      Pixmap *4mbitmap_return24m;
      int *4mx_hot_return24m, *4my_hot_return24m;


4mdisplay24m   Specifies the connection to the X server.

4md24m	       Specifies the drawable that indicates the screen.

4mfilename24m  Specifies the file name to use.	The format of the
	  file name is operating-system dependent.

4mwidth_return0m
4mheight_return0m
	  Return the width and height values of the read in
	  bitmap file.

4mbitmap_return0m
	  Returns the bitmap that is created.

4mx_hot_return0m
4my_hot_return0m
	  Return the hotspot coordinates.
|__

The 4mXReadBitmapFile24m function reads in a file containing a



			     1m5980m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


bitmap.	 The file is parsed in the encoding of the current
locale.	 The ability to read other than the standard format
is implementation-dependent.  If the file cannot be opened,
4mXReadBitmapFile24m returns 4mBitmapOpenFailed24m.  If the file can
be opened but does not contain valid bitmap data, it returns
4mBitmapFileInvalid24m.	 If insufficient working storage is allo-
cated, it returns 4mBitmapNoMemory24m.	If the file is readable
and valid, it returns 4mBitmapSuccess24m.

4mXReadBitmapFile24m returns the bitmap's height and width, as
read from the file, to width_return and height_return.	It
then creates a pixmap of the appropriate size, reads the
bitmap data from the file into the pixmap, and assigns the
pixmap to the caller's variable bitmap.	 The caller must
free the bitmap using 4mXFreePixmap24m when finished.  If
4mname24m_x_hot and 4mname24m_y_hot exist, 4mXReadBitmapFile24m returns
them to x_hot_return and y_hot_return; otherwise, it returns
-1,-1.

4mXReadBitmapFile24m can generate 4mBadAlloc24m, 4mBadDrawable24m, and
4mBadGC24m errors.


To read a bitmap from a file and return it as data, use
4mXReadBitmapFileData24m.
__
|
int XReadBitmapFileData(4mfilename24m, 4mwidth_return24m, 4mheight_return24m, 4mdata_return24m, 4mx_hot_return24m, 4my_hot_return24m)
      char *4mfilename24m;
      unsigned int *4mwidth_return24m, *4mheight_return24m;
      unsigned char *4mdata_return24m;
      int *4mx_hot_return24m, *4my_hot_return24m;


4mfilename24m  Specifies the file name to use.	The format of the
	  file name is operating-system dependent.

4mwidth_return0m
4mheight_return0m
	  Return the width and height values of the read in
	  bitmap file.

4mdata_return0m
	  Returns the bitmap data.

4mx_hot_return0m
4my_hot_return0m
	  Return the hotspot coordinates.
|__

The 4mXReadBitmapFileData24m function reads in a file containing
a bitmap, in the same manner as 4mXReadBitmapFile24m, but returns
the data directly rather than creating a pixmap in the
server.	 The bitmap data is returned in data_return; the



			     1m5990m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


client must free this storage when finished with it by call-
ing 4mXFree24m.	 The status and other return values are the same
as for 4mXReadBitmapFile24m.


To write out a bitmap from a pixmap to a file, use
4mXWriteBitmapFile24m.
__
|
int XWriteBitmapFile(4mdisplay24m, 4mfilename24m, 4mbitmap24m, 4mwidth24m, 4mheight24m, 4mx_hot24m, 4my_hot24m)
      Display *4mdisplay24m;
      char *4mfilename24m;
      Pixmap 4mbitmap24m;
      unsigned int 4mwidth24m, 4mheight24m;
      int 4mx_hot24m, 4my_hot24m;


4mdisplay24m   Specifies the connection to the X server.

4mfilename24m  Specifies the file name to use.	The format of the
	  file name is operating-system dependent.

4mbitmap24m    Specifies the bitmap.

4mwidth0m
4mheight24m    Specify the width and height.

4mx_hot0m
4my_hot24m     Specify where to place the hotspot coordinates (or
	  -1,-1 if none are present) in the file.
|__

The 4mXWriteBitmapFile24m function writes a bitmap out to a file
in the X Version 11 format.  The name used in the output
file is derived from the file name by deleting the directory
prefix.	 The file is written in the encoding of the current
locale.	 If the file cannot be opened for writing, it
returns 4mBitmapOpenFailed24m.	If insufficient memory is allo-
cated, 4mXWriteBitmapFile24m returns 4mBitmapNoMemory24m; otherwise,
on no error, it returns 4mBitmapSuccess24m.  If x_hot and y_hot
are not -1, -1, 4mXWriteBitmapFile24m writes them out as the
hotspot coordinates for the bitmap.

4mXWriteBitmapFile24m can generate 4mBadDrawable24m and 4mBadMatch0m
errors.


To create a pixmap and then store bitmap-format data into
it, use 4mXCreatePixmapFromBitmapData24m.








			     1m6000m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
Pixmap XCreatePixmapFromBitmapData(4mdisplay24m, 4md24m, 4mdata24m, 4mwidth24m, 4mheight24m, 4mfg24m, 4mbg24m, 4mdepth24m)
     Display *4mdisplay24m;
     Drawable 4md24m;
     char *4mdata24m;
     unsigned int 4mwidth24m, 4mheight24m;
     unsigned long 4mfg24m, 4mbg24m;
     unsigned int 4mdepth24m;


4mdisplay24m   Specifies the connection to the X server.

4md24m	       Specifies the drawable that indicates the screen.

4mdata24m      Specifies the data in bitmap format.

4mwidth0m
4mheight24m    Specify the width and height.

4mfg0m
4mbg24m	       Specify the foreground and background pixel values
	  to use.

4mdepth24m     Specifies the depth of the pixmap.
|__

The 4mXCreatePixmapFromBitmapData24m function creates a pixmap of
the given depth and then does a bitmap-format 4mXPutImage24m of
the data into it.  The depth must be supported by the screen
of the specified drawable, or a 4mBadMatch24m error results.

4mXCreatePixmapFromBitmapData24m can generate 4mBadAlloc24m, 4mBadDraw-0m
4mable24m, 4mBadGC24m, and 4mBadValue24m errors.


To include a bitmap written out by 4mXWriteBitmapFile24m in a
program directly, as opposed to reading it in every time at
run time, use 4mXCreateBitmapFromData24m.



















			     1m6010m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
Pixmap XCreateBitmapFromData(4mdisplay24m, 4md24m, 4mdata24m, 4mwidth24m, 4mheight24m)
      Display *4mdisplay24m;
      Drawable 4md24m;
      char *4mdata24m;
      unsigned int 4mwidth24m, 4mheight24m;


4mdisplay24m   Specifies the connection to the X server.

4md24m	       Specifies the drawable that indicates the screen.

4mdata24m      Specifies the location of the bitmap data.

4mwidth0m
4mheight24m    Specify the width and height.
|__

The 4mXCreateBitmapFromData24m function allows you to include in
your C program (using 4m#include24m) a bitmap file that was writ-
ten out by 4mXWriteBitmapFile24m (X version 11 format only) with-
out reading in the bitmap file.	 The following example cre-
ates a gray bitmap:


#include "gray.bitmap"
Pixmap bitmap;
bitmap = XCreateBitmapFromData(display, window, gray_bits, gray_width, gray_height);


If insufficient working storage was allocated, 4mXCre-0m
4mateBitmapFromData24m returns 4mNone24m.  It is your responsibility
to free the bitmap using 4mXFreePixmap24m when finished.

4mXCreateBitmapFromData24m can generate 4mBadAlloc24m and 4mBadGC0m
errors.

1m16.10.  Using the Context Manager0m

The context manager provides a way of associating data with
an X resource ID (mostly typically a window) in your pro-
gram.  Note that this is local to your program; the data is
not stored in the server on a property list.  Any amount of
data in any number of pieces can be associated with a
resource ID, and each piece of data has a type associated
with it.  The context manager requires knowledge of the
resource ID and type to store or retrieve data.

Essentially, the context manager can be viewed as a two-
dimensional, sparse array:  one dimension is subscripted by
the X resource ID and the other by a context type field.
Each entry in the array contains a pointer to the data.
Xlib provides context management functions with which you
can save data values, get data values, delete entries, and



			     1m6020m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


create a unique context type.  The symbols used are in
<4mX11/Xutil.h24m>.


To save a data value that corresponds to a resource ID and
context type, use 4mXSaveContext24m.
__
|
int XSaveContext(4mdisplay24m, 4mrid24m, 4mcontext24m, 4mdata24m)
      Display *4mdisplay24m;
      XID 4mrid24m;
      XContext 4mcontext24m;
      XPointer 4mdata24m;


4mdisplay24m   Specifies the connection to the X server.

4mrid24m       Specifies the resource ID with which the data is
	  associated.

4mcontext24m   Specifies the context type to which the data
	  belongs.

4mdata24m      Specifies the data to be associated with the win-
	  dow and type.
|__

If an entry with the specified resource ID and type already
exists, 4mXSaveContext24m overrides it with the specified con-
text.  The 4mXSaveContext24m function returns a nonzero error
code if an error has occurred and zero otherwise.  Possible
errors are 4mXCNOMEM24m (out of memory).


To get the data associated with a resource ID and type, use
4mXFindContext24m.





















			     1m6030m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
int XFindContext(4mdisplay24m, 4mrid24m, 4mcontext24m, 4mdata_return24m)
      Display *4mdisplay24m;
      XID 4mrid24m;
      XContext 4mcontext24m;
      XPointer *4mdata_return24m;


4mdisplay24m   Specifies the connection to the X server.

4mrid24m       Specifies the resource ID with which the data is
	  associated.

4mcontext24m   Specifies the context type to which the data
	  belongs.

4mdata_return0m
	  Returns the data.
|__

Because it is a return value, the data is a pointer.  The
4mXFindContext24m function returns a nonzero error code if an
error has occurred and zero otherwise.	Possible errors are
4mXCNOENT24m (context-not-found).


To delete an entry for a given resource ID and type, use
4mXDeleteContext24m.
__
|
int XDeleteContext(4mdisplay24m, 4mrid24m, 4mcontext24m)
      Display *4mdisplay24m;
      XID 4mrid24m;
      XContext 4mcontext24m;


4mdisplay24m   Specifies the connection to the X server.

4mrid24m       Specifies the resource ID with which the data is
	  associated.

4mcontext24m   Specifies the context type to which the data
	  belongs.
|__

The 4mXDeleteContext24m function deletes the entry for the given
resource ID and type from the data structure.  This function
returns the same error codes that 4mXFindContext24m returns if
called with the same arguments.	 4mXDeleteContext24m does not
free the data whose address was saved.


To create a unique context type that may be used in subse-
quent calls to 4mXSaveContext24m and 4mXFindContext24m, use



			     1m6040m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


4mXUniqueContext24m.
__
|
XContext XUniqueContext()

|__



















































			     1m6050m





1mXlib - C Library			X11, Release 6.7 DRAFT0m




			 1mAppendix A0m

	    1mXlib Functions and Protocol Requests0m



This appendix provides two tables that relate to Xlib func-
tions and the X protocol.  The following table lists each
Xlib function (in alphabetical order) and the corresponding
protocol request that it generates.


-------------------------------------------------------
1mXlib Function		       Protocol Request0m
-------------------------------------------------------
XActivateScreenSaver	     ForceScreenSaver
XAddHost		     ChangeHosts
XAddHosts		     ChangeHosts
XAddToSaveSet		     ChangeSaveSet
XAllocColor		     AllocColor
XAllocColorCells	     AllocColorCells
XAllocColorPlanes	     AllocColorPlanes
XAllocNamedColor	     AllocNamedColor
XAllowEvents		     AllowEvents
XAutoRepeatOff		     ChangeKeyboardControl
XAutoRepeatOn		     ChangeKeyboardControl
XBell			     Bell
XChangeActivePointerGrab     ChangeActivePointerGrab
XChangeGC		     ChangeGC
XChangeKeyboardControl	     ChangeKeyboardControl
XChangeKeyboardMapping	     ChangeKeyboardMapping
XChangePointerControl	     ChangePointerControl
XChangeProperty		     ChangeProperty
XChangeSaveSet		     ChangeSaveSet
XChangeWindowAttributes	     ChangeWindowAttributes
XCirculateSubwindows	     CirculateWindow
XCirculateSubwindowsDown     CirculateWindow
XCirculateSubwindowsUp	     CirculateWindow
XClearArea		     ClearArea
XClearWindow		     ClearArea
XConfigureWindow	     ConfigureWindow
XConvertSelection	     ConvertSelection
XCopyArea		     CopyArea
XCopyColormapAndFree	     CopyColormapAndFree
XCopyGC			     CopyGC
XCopyPlane		     CopyPlane
XCreateBitmapFromData	     CreateGC
			     CreatePixmap
			     FreeGC
			     PutImage
XCreateColormap		     CreateColormap




			     1m6060m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


-------------------------------------------------------
1mXlib Function		       Protocol Request0m
-------------------------------------------------------
XCreateFontCursor	     CreateGlyphCursor
XCreateGC		     CreateGC
XCreateGlyphCursor	     CreateGlyphCursor
XCreatePixmap		     CreatePixmap
XCreatePixmapCursor	     CreateCursor
XCreatePixmapFromData	     CreateGC
			     CreatePixmap
			     FreeGC
			     PutImage
XCreateSimpleWindow	     CreateWindow
XCreateWindow		     CreateWindow
XDefineCursor		     ChangeWindowAttributes
XDeleteProperty		     DeleteProperty
XDestroySubwindows	     DestroySubwindows
XDestroyWindow		     DestroyWindow
XDisableAccessControl	     SetAccessControl
XDrawArc		     PolyArc
XDrawArcs		     PolyArc
XDrawImageString	     ImageText8
XDrawImageString16	     ImageText16
XDrawLine		     PolySegment
XDrawLines		     PolyLine
XDrawPoint		     PolyPoint
XDrawPoints		     PolyPoint
XDrawRectangle		     PolyRectangle
XDrawRectangles		     PolyRectangle
XDrawSegments		     PolySegment
XDrawString		     PolyText8
XDrawString16		     PolyText16
XDrawText		     PolyText8
XDrawText16		     PolyText16
XEnableAccessControl	     SetAccessControl
XFetchBytes		     GetProperty
XFetchName		     GetProperty
XFillArc		     PolyFillArc
XFillArcs		     PolyFillArc
XFillPolygon		     FillPoly
XFillRectangle		     PolyFillRectangle
XFillRectangles		     PolyFillRectangle
XForceScreenSaver	     ForceScreenSaver
XFreeColormap		     FreeColormap
XFreeColors		     FreeColors
XFreeCursor		     FreeCursor
XFreeFont		     CloseFont
XFreeGC			     FreeGC
XFreePixmap		     FreePixmap
XGetAtomName		     GetAtomName
XGetClassHint		     GetProperty
XGetFontPath		     GetFontPath
XGetGeometry		     GetGeometry




			     1m6070m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


-------------------------------------------------------
1mXlib Function		       Protocol Request0m
-------------------------------------------------------
XGetIconName		     GetProperty
XGetIconSizes		     GetProperty
XGetImage		     GetImage
XGetInputFocus		     GetInputFocus
XGetKeyboardControl	     GetKeyboardControl
XGetKeyboardMapping	     GetKeyboardMapping
XGetModifierMapping	     GetModifierMapping
XGetMotionEvents	     GetMotionEvents
XGetNormalHints		     GetProperty
XGetPointerControl	     GetPointerControl
XGetPointerMapping	     GetPointerMapping
XGetRGBColormaps	     GetProperty
XGetScreenSaver		     GetScreenSaver
XGetSelectionOwner	     GetSelectionOwner
XGetSizeHints		     GetProperty
XGetTextProperty	     GetProperty
XGetTransientForHint	     GetProperty
XGetWMClientMachine	     GetProperty
XGetWMColormapWindows	     GetProperty
			     InternAtom
XGetWMHints		     GetProperty
XGetWMIconName		     GetProperty
XGetWMName		     GetProperty
XGetWMNormalHints	     GetProperty
XGetWMProtocols		     GetProperty
			     InternAtom
XGetWMSizeHints		     GetProperty
XGetWindowAttributes	     GetWindowAttributes
			     GetGeometry
XGetWindowProperty	     GetProperty
XGetZoomHints		     GetProperty
XGrabButton		     GrabButton
XGrabKey		     GrabKey
XGrabKeyboard		     GrabKeyboard
XGrabPointer		     GrabPointer
XGrabServer		     GrabServer
XIconifyWindow		     InternAtom
			     SendEvent
XInitExtension		     QueryExtension
XInstallColormap	     InstallColormap
XInternAtom		     InternAtom
XKillClient		     KillClient
XListExtensions		     ListExtensions
XListFonts		     ListFonts
XListFontsWithInfo	     ListFontsWithInfo
XListHosts		     ListHosts
XListInstalledColormaps	     ListInstalledColormaps
XListProperties		     ListProperties
XLoadFont		     OpenFont
XLoadQueryFont		     OpenFont




			     1m6080m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


-------------------------------------------------------
1mXlib Function		       Protocol Request0m
-------------------------------------------------------
			     QueryFont
XLookupColor		     LookupColor
XLowerWindow		     ConfigureWindow
XMapRaised		     ConfigureWindow
			     MapWindow
XMapSubwindows		     MapSubwindows
XMapWindow		     MapWindow
XMoveResizeWindow	     ConfigureWindow
XMoveWindow		     ConfigureWindow
XNoOp			     NoOperation
XOpenDisplay		     CreateGC
XParseColor		     LookupColor
XPutImage		     PutImage
XQueryBestCursor	     QueryBestSize
XQueryBestSize		     QueryBestSize
XQueryBestStipple	     QueryBestSize
XQueryBestTile		     QueryBestSize
XQueryColor		     QueryColors
XQueryColors		     QueryColors
XQueryExtension		     QueryExtension
XQueryFont		     QueryFont
XQueryKeymap		     QueryKeymap
XQueryPointer		     QueryPointer
XQueryTextExtents	     QueryTextExtents
XQueryTextExtents16	     QueryTextExtents
XQueryTree		     QueryTree
XRaiseWindow		     ConfigureWindow
XReadBitmapFile		     CreateGC
			     CreatePixmap
			     FreeGC
			     PutImage
XRecolorCursor		     RecolorCursor
XReconfigureWMWindow	     ConfigureWindow
			     SendEvent
XRemoveFromSaveSet	     ChangeSaveSet
XRemoveHost		     ChangeHosts
XRemoveHosts		     ChangeHosts
XReparentWindow		     ReparentWindow
XResetScreenSaver	     ForceScreenSaver
XResizeWindow		     ConfigureWindow
XRestackWindows		     ConfigureWindow
XRotateBuffers		     RotateProperties
XRotateWindowProperties	     RotateProperties
XSelectInput		     ChangeWindowAttributes
XSendEvent		     SendEvent
XSetAccessControl	     SetAccessControl
XSetArcMode		     ChangeGC
XSetBackground		     ChangeGC
XSetClassHint		     ChangeProperty
XSetClipMask		     ChangeGC




			     1m6090m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


-------------------------------------------------------
1mXlib Function		       Protocol Request0m
-------------------------------------------------------
XSetClipOrigin		     ChangeGC
XSetClipRectangles	     SetClipRectangles
XSetCloseDownMode	     SetCloseDownMode
XSetCommand		     ChangeProperty
XSetDashes		     SetDashes
XSetFillRule		     ChangeGC
XSetFillStyle		     ChangeGC
XSetFont		     ChangeGC
XSetFontPath		     SetFontPath
XSetForeground		     ChangeGC
XSetFunction		     ChangeGC
XSetGraphicsExposures	     ChangeGC
XSetIconName		     ChangeProperty
XSetIconSizes		     ChangeProperty
XSetInputFocus		     SetInputFocus
XSetLineAttributes	     ChangeGC
XSetModifierMapping	     SetModifierMapping
XSetNormalHints		     ChangeProperty
XSetPlaneMask		     ChangeGC
XSetPointerMapping	     SetPointerMapping
XSetRGBColormaps	     ChangeProperty
XSetScreenSaver		     SetScreenSaver
XSetSelectionOwner	     SetSelectionOwner
XSetSizeHints		     ChangeProperty
XSetStandardProperties	     ChangeProperty
XSetState		     ChangeGC
XSetStipple		     ChangeGC
XSetSubwindowMode	     ChangeGC
XSetTextProperty	     ChangeProperty
XSetTile		     ChangeGC
XSetTransientForHint	     ChangeProperty
XSetTSOrigin		     ChangeGC
XSetWMClientMachine	     ChangeProperty
XSetWMColormapWindows	     ChangeProperty
			     InternAtom
XSetWMHints		     ChangeProperty
XSetWMIconName		     ChangeProperty
XSetWMName		     ChangeProperty
XSetWMNormalHints	     ChangeProperty
XSetWMProperties	     ChangeProperty
XSetWMProtocols		     ChangeProperty
			     InternAtom
XSetWMSizeHints		     ChangeProperty
XSetWindowBackground	     ChangeWindowAttributes
XSetWindowBackgroundPixmap   ChangeWindowAttributes
XSetWindowBorder	     ChangeWindowAttributes
XSetWindowBorderPixmap	     ChangeWindowAttributes
XSetWindowBorderWidth	     ConfigureWindow
XSetWindowColormap	     ChangeWindowAttributes
XSetZoomHints		     ChangeProperty




			     1m6100m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


-------------------------------------------------------
1mXlib Function		       Protocol Request0m
-------------------------------------------------------
XStoreBuffer		     ChangeProperty
XStoreBytes		     ChangeProperty
XStoreColor		     StoreColors
XStoreColors		     StoreColors
XStoreName		     ChangeProperty
XStoreNamedColor	     StoreNamedColor
XSync			     GetInputFocus
XSynchronize		     GetInputFocus
XTranslateCoordinates	     TranslateCoordinates
XUndefineCursor		     ChangeWindowAttributes
XUngrabButton		     UngrabButton
XUngrabKey		     UngrabKey
XUngrabKeyboard		     UngrabKeyboard
XUngrabPointer		     UngrabPointer
XUngrabServer		     UngrabServer
XUninstallColormap	     UninstallColormap
XUnloadFont		     CloseFont
XUnmapSubwindows	     UnmapSubwindows
XUnmapWindow		     UnmapWindow
XWarpPointer		     WarpPointer
XWithdrawWindow		     SendEvent
			     UnmapWindow
































			     1m6110m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


The following table lists each X protocol request (in alpha-
betical order) and the Xlib functions that reference it.

-------------------------------------------------------
1mProtocol Request	      Xlib Function0m
-------------------------------------------------------
AllocColor		    XAllocColor
AllocColorCells		    XAllocColorCells
AllocColorPlanes	    XAllocColorPlanes
AllocNamedColor		    XAllocNamedColor
AllowEvents		    XAllowEvents
Bell			    XBell
ChangeActivePointerGrab	    XChangeActivePointerGrab
ChangeGC		    XChangeGC
			    XSetArcMode
			    XSetBackground
			    XSetClipMask
			    XSetClipOrigin
			    XSetFillRule
			    XSetFillStyle
			    XSetFont
			    XSetForeground
			    XSetFunction
			    XSetGraphicsExposures
			    XSetLineAttributes
			    XSetPlaneMask
			    XSetState
			    XSetStipple
			    XSetSubwindowMode
			    XSetTile
			    XSetTSOrigin
ChangeHosts		    XAddHost
			    XAddHosts
			    XRemoveHost
			    XRemoveHosts
ChangeKeyboardControl	    XAutoRepeatOff
			    XAutoRepeatOn
			    XChangeKeyboardControl
ChangeKeyboardMapping	    XChangeKeyboardMapping
ChangePointerControl	    XChangePointerControl
ChangeProperty		    XChangeProperty
			    XSetClassHint
			    XSetCommand
			    XSetIconName
			    XSetIconSizes
			    XSetNormalHints
			    XSetRGBColormaps
			    XSetSizeHints
			    XSetStandardProperties
			    XSetTextProperty
			    XSetTransientForHint
			    XSetWMClientMachine
			    XSetWMColormapWindows




			     1m6120m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


-------------------------------------------------------
1mProtocol Request	      Xlib Function0m
-------------------------------------------------------
			    XSetWMHints
			    XSetWMIconName
			    XSetWMName
			    XSetWMNormalHints
			    XSetWMProperties
			    XSetWMProtocols
			    XSetWMSizeHints
			    XSetZoomHints
			    XStoreBuffer
			    XStoreBytes
			    XStoreName
ChangeSaveSet		    XAddToSaveSet
			    XChangeSaveSet
			    XRemoveFromSaveSet
ChangeWindowAttributes	    XChangeWindowAttributes
			    XDefineCursor
			    XSelectInput
			    XSetWindowBackground
			    XSetWindowBackgroundPixmap
			    XSetWindowBorder
			    XSetWindowBorderPixmap
			    XSetWindowColormap
			    XUndefineCursor
CirculateWindow		    XCirculateSubwindowsDown
			    XCirculateSubwindowsUp
			    XCirculateSubwindows
ClearArea		    XClearArea
			    XClearWindow
CloseFont		    XFreeFont
			    XUnloadFont
ConfigureWindow		    XConfigureWindow
			    XLowerWindow
			    XMapRaised
			    XMoveResizeWindow
			    XMoveWindow
			    XRaiseWindow
			    XReconfigureWMWindow
			    XResizeWindow
			    XRestackWindows
			    XSetWindowBorderWidth
ConvertSelection	    XConvertSelection
CopyArea		    XCopyArea
CopyColormapAndFree	    XCopyColormapAndFree
CopyGC			    XCopyGC
CopyPlane		    XCopyPlane
CreateColormap		    XCreateColormap
CreateCursor		    XCreatePixmapCursor
CreateGC		    XCreateGC
			    XCreateBitmapFromData
			    XCreatePixmapFromData




			     1m6130m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


-------------------------------------------------------
1mProtocol Request	      Xlib Function0m
-------------------------------------------------------
			    XOpenDisplay
			    XReadBitmapFile
CreateGlyphCursor	    XCreateFontCursor
			    XCreateGlyphCursor
CreatePixmap		    XCreatePixmap
			    XCreateBitmapFromData
			    XCreatePixmapFromData
			    XReadBitmapFile
CreateWindow		    XCreateSimpleWindow
			    XCreateWindow
DeleteProperty		    XDeleteProperty
DestroySubwindows	    XDestroySubwindows
DestroyWindow		    XDestroyWindow
FillPoly		    XFillPolygon
ForceScreenSaver	    XActivateScreenSaver
			    XForceScreenSaver
			    XResetScreenSaver
FreeColormap		    XFreeColormap
FreeColors		    XFreeColors
FreeCursor		    XFreeCursor
FreeGC			    XFreeGC
			    XCreateBitmapFromData
			    XCreatePixmapFromData
			    XReadBitmapFile
FreePixmap		    XFreePixmap
GetAtomName		    XGetAtomName
GetFontPath		    XGetFontPath
GetGeometry		    XGetGeometry
			    XGetWindowAttributes
GetImage		    XGetImage
GetInputFocus		    XGetInputFocus
			    XSync
			    XSynchronize
GetKeyboardControl	    XGetKeyboardControl
GetKeyboardMapping	    XGetKeyboardMapping
GetModifierMapping	    XGetModifierMapping
GetMotionEvents		    XGetMotionEvents
GetPointerControl	    XGetPointerControl
GetPointerMapping	    XGetPointerMapping
GetProperty		    XFetchBytes
			    XFetchName
			    XGetClassHint
			    XGetIconName
			    XGetIconSizes
			    XGetNormalHints
			    XGetRGBColormaps
			    XGetSizeHints
			    XGetTextProperty
			    XGetTransientForHint
			    XGetWMClientMachine




			     1m6140m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


-------------------------------------------------------
1mProtocol Request	      Xlib Function0m
-------------------------------------------------------
			    XGetWMColormapWindows
			    XGetWMHints
			    XGetWMIconName
			    XGetWMName
			    XGetWMNormalHints
			    XGetWMProtocols
			    XGetWMSizeHints
			    XGetWindowProperty
			    XGetZoomHints
GetSelectionOwner	    XGetSelectionOwner
GetWindowAttributes	    XGetWindowAttributes
GrabButton		    XGrabButton
GrabKey			    XGrabKey
GrabKeyboard		    XGrabKeyboard
GrabPointer		    XGrabPointer
GrabServer		    XGrabServer
ImageText8		    XDrawImageString
ImageText16		    XDrawImageString16
InstallColormap		    XInstallColormap
InternAtom		    XGetWMColormapWindows
			    XGetWMProtocols
			    XIconifyWindow
			    XInternAtom
			    XSetWMColormapWindows
			    XSetWMProtocols
KillClient		    XKillClient
ListExtensions		    XListExtensions
ListFonts		    XListFonts
ListFontsWithInfo	    XListFontsWithInfo
ListHosts		    XListHosts
ListInstalledColormaps	    XListInstalledColormaps
ListProperties		    XListProperties
LookupColor		    XLookupColor
			    XParseColor
MapSubwindows		    XMapSubwindows
MapWindow		    XMapRaised
			    XMapWindow
NoOperation		    XNoOp
OpenFont		    XLoadFont
			    XLoadQueryFont
PolyArc			    XDrawArc
			    XDrawArcs
PolyFillArc		    XFillArc
			    XFillArcs
PolyFillRectangle	    XFillRectangle
			    XFillRectangles
PolyLine		    XDrawLines
PolyPoint		    XDrawPoint
			    XDrawPoints
PolyRectangle		    XDrawRectangle




			     1m6150m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


-------------------------------------------------------
1mProtocol Request	      Xlib Function0m
-------------------------------------------------------
			    XDrawRectangles
PolySegment		    XDrawLine
			    XDrawSegments
PolyText8		    XDrawString
			    XDrawText
PolyText16		    XDrawString16
			    XDrawText16
PutImage		    XPutImage
			    XCreateBitmapFromData
			    XCreatePixmapFromData
			    XReadBitmapFile
QueryBestSize		    XQueryBestCursor
			    XQueryBestSize
			    XQueryBestStipple
			    XQueryBestTile
QueryColors		    XQueryColor
			    XQueryColors
QueryExtension		    XInitExtension
			    XQueryExtension
QueryFont		    XLoadQueryFont
			    XQueryFont
QueryKeymap		    XQueryKeymap
QueryPointer		    XQueryPointer
QueryTextExtents	    XQueryTextExtents
			    XQueryTextExtents16
QueryTree		    XQueryTree
RecolorCursor		    XRecolorCursor
ReparentWindow		    XReparentWindow
RotateProperties	    XRotateBuffers
			    XRotateWindowProperties
SendEvent		    XIconifyWindow
			    XReconfigureWMWindow
			    XSendEvent
			    XWithdrawWindow
SetAccessControl	    XDisableAccessControl
			    XEnableAccessControl
			    XSetAccessControl
SetClipRectangles	    XSetClipRectangles
SetCloseDownMode	    XSetCloseDownMode
SetDashes		    XSetDashes
SetFontPath		    XSetFontPath
SetInputFocus		    XSetInputFocus
SetModifierMapping	    XSetModifierMapping
SetPointerMapping	    XSetPointerMapping
SetScreenSaver		    XGetScreenSaver
			    XSetScreenSaver
SetSelectionOwner	    XSetSelectionOwner
StoreColors		    XStoreColor
			    XStoreColors
StoreNamedColor		    XStoreNamedColor




			     1m6160m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


-------------------------------------------------------
1mProtocol Request	      Xlib Function0m
-------------------------------------------------------
TranslateCoordinates	    XTranslateCoordinates
UngrabButton		    XUngrabButton
UngrabKey		    XUngrabKey
UngrabKeyboard		    XUngrabKeyboard
UngrabPointer		    XUngrabPointer
UngrabServer		    XUngrabServer
UninstallColormap	    XUninstallColormap
UnmapSubwindows		    XUnmapSubWindows
UnmapWindow		    XUnmapWindow
			    XWithdrawWindow
WarpPointer		    XWarpPointer











































			     1m6170m





1mXlib - C Library			X11, Release 6.7 DRAFT0m




			 1mAppendix B0m

		       1mX Font Cursors0m



The following are the available cursors that can be used
with 4mXCreateFontCursor24m.


#define XC_X_cursor 0	      #define XC_ll_angle 76
#define XC_arrow 2	      #define XC_lr_angle 78
#define XC_based_arrow_down 4 #define XC_man 80
#define XC_based_arrow_up 6   #define XC_middlebutton 82
#define XC_boat 8	      #define XC_mouse 84
#define XC_bogosity 10	      #define XC_pencil 86
#define XC_bottom_left_corner 12#define XC_pirate 88
#define XC_bottom_right_corner 14#define XC_plus 90
#define XC_bottom_side 16     #define XC_question_arrow 92
#define XC_bottom_tee 18      #define XC_right_ptr 94
#define XC_box_spiral 20      #define XC_right_side 96
#define XC_center_ptr 22      #define XC_right_tee 98
#define XC_circle 24	      #define XC_rightbutton 100
#define XC_clock 26	      #define XC_rtl_logo 102
#define XC_coffee_mug 28      #define XC_sailboat 104
#define XC_cross 30	      #define XC_sb_down_arrow 106
#define XC_cross_reverse 32   #define XC_sb_h_double_arrow 108
#define XC_crosshair 34	      #define XC_sb_left_arrow 110
#define XC_diamond_cross 36   #define XC_sb_right_arrow 112
#define XC_dot 38	      #define XC_sb_up_arrow 114
#define XC_dot_box_mask 40    #define XC_sb_v_double_arrow 116
#define XC_double_arrow 42    #define XC_shuttle 118
#define XC_draft_large 44     #define XC_sizing 120
#define XC_draft_small 46     #define XC_spider 122
#define XC_draped_box 48      #define XC_spraycan 124
#define XC_exchange 50	      #define XC_star 126
#define XC_fleur 52	      #define XC_target 128
#define XC_gobbler 54	      #define XC_tcross 130
#define XC_gumby 56	      #define XC_top_left_arrow 132
#define XC_hand1 58	      #define XC_top_left_corner 134
#define XC_hand2 60	      #define XC_top_right_corner 136
#define XC_heart 62	      #define XC_top_side 138
#define XC_icon 64	      #define XC_top_tee 140
#define XC_iron_cross 66      #define XC_trek 142
#define XC_left_ptr 68	      #define XC_ul_angle 144
#define XC_left_side 70	      #define XC_umbrella 146
#define XC_left_tee 72	      #define XC_ur_angle 148
#define XC_leftbutton 74      #define XC_watch 150
			      #define XC_xterm 152






			     1m6180m





1mXlib - C Library			X11, Release 6.7 DRAFT0m




			 1mAppendix C0m

			 1mExtensions0m



Because X can evolve by extensions to the core protocol, it
is important that extensions not be perceived as second-
class citizens.	 At some point, your favorite extensions may
be adopted as additional parts of the X Standard.

Therefore, there should be little to distinguish the use of
an extension from that of the core protocol.  To avoid hav-
ing to initialize extensions explicitly in application pro-
grams, it is also important that extensions perform lazy
evaluations, automatically initializing themselves when
called for the first time.

This appendix describes techniques for writing extensions to
Xlib that will run at essentially the same performance as
the core protocol requests.

			    Note

     It is expected that a given extension to X con-
     sists of multiple requests.  Defining 10 new fea-
     tures as 10 separate extensions is a bad practice.
     Rather, they should be packaged into a single
     extension and should use minor opcodes to distin-
     guish the requests.


The symbols and macros used for writing stubs to Xlib are
listed in <4mX11/Xlibint.h24m>.

1mBasic Protocol Support Routines0m

The basic protocol requests for extensions are 4mXQueryExten-0m
4msion24m and 4mXListExtensions24m.
















			     1m6190m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
Bool XQueryExtension(4mdisplay24m, 4mname24m, 4mmajor_opcode_return24m, 4mfirst_event_return24m, 4mfirst_error_return24m)
      Display *4mdisplay24m;
      char *4mname;0m
      int *4mmajor_opcode_return24m;
      int *4mfirst_event_return24m;
      int *4mfirst_error_return24m;


4mdisplay24m   Specifies the connection to the X server.

4mname24m      Specifies the extension name.

4mmajor_opcode_return0m
	  Returns the major opcode.

4mfirst_event_return0m
	  Returns the first event code, if any.

4mfirst_error_return0m
	  Returns the first error code, if any.
|__

The 4mXQueryExtension24m function determines if the named exten-
sion is present.  If the extension is not present, 4mXQueryEx-0m
4mtension24m returns 4mFalse24m; otherwise, it returns 4mTrue24m.  If the
extension is present, 4mXQueryExtension24m returns the major
opcode for the extension to major_opcode_return; otherwise,
it returns zero.  Any minor opcode and the request formats
are specific to the extension.	If the extension involves
additional event types, 4mXQueryExtension24m returns the base
event type code to first_event_return; otherwise, it returns
zero.  The format of the events is specific to the exten-
sion.  If the extension involves additional error codes,
4mXQueryExtension24m returns the base error code to
first_error_return; otherwise, it returns zero.	 The format
of additional data in the errors is specific to the exten-
sion.

If the extension name is not in the Host Portable Character
Encoding the result is implementation-dependent.  Uppercase
and lowercase matter; the strings ``thing'', ``Thing'', and
``thinG'' are all considered different names.














			     1m6200m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
char **XListExtensions(4mdisplay24m, 4mnextensions_return24m)
      Display *4mdisplay24m;
      int *4mnextensions_return24m;


4mdisplay24m   Specifies the connection to the X server.

4mnextensions_return0m
	  Returns the number of extensions listed.
|__

The 4mXListExtensions24m function returns a list of all exten-
sions supported by the server.	If the data returned by the
server is in the Latin Portable Character Encoding, then the
returned strings are in the Host Portable Character Encod-
ing.  Otherwise, the result is implementation-dependent.
__
|
XFreeExtensionList(4mlist24m)
      char **4mlist24m;


4mlist24m      Specifies the list of extension names.
|__

The 4mXFreeExtensionList24m function frees the memory allocated
by 4mXListExtensions24m.

1mHooking into Xlib0m

These functions allow you to hook into the library.  They
are not normally used by application programmers but are
used by people who need to extend the core X protocol and
the X library interface.  The functions, which generate pro-
tocol requests for X, are typically called stubs.

In extensions, stubs first should check to see if they have
initialized themselves on a connection.	 If they have not,
they then should call 4mXInitExtension24m to attempt to initial-
ize themselves on the connection.

If the extension needs to be informed of GC/font allocation
or deallocation or if the extension defines new event types,
the functions described here allow the extension to be
called when these events occur.

The 4mXExtCodes24m structure returns the information from 4mXIni-0m
4mtExtension24m and is defined in <4mX11/Xlib.h24m>:








			     1m6210m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
typedef struct _XExtCodes {   /* public to extension, cannot be changed */
     int extension;	      /* extension number */
     int major_opcode;	      /* major op-code assigned by server */
     int first_event;	      /* first event number for the extension */
     int first_error;	      /* first error number for the extension */
} XExtCodes;

|__

__
|
XExtCodes *XInitExtension(4mdisplay24m, 4mname24m)
      Display *4mdisplay24m;
      char *4mname24m;


4mdisplay24m   Specifies the connection to the X server.

4mname24m      Specifies the extension name.
|__

The 4mXInitExtension24m function determines if the named exten-
sion exists.  Then, it allocates storage for maintaining the
information about the extension on the connection, chains
this onto the extension list for the connection, and returns
the information the stub implementor will need to access the
extension.  If the extension does not exist, 4mXInitExtension0m
returns NULL.

If the extension name is not in the Host Portable Character
Encoding, the result is implementation-dependent.  Uppercase
and lowercase matter; the strings ``thing'', ``Thing'', and
``thinG'' are all considered different names.

The extension number in the 4mXExtCodes24m structure is needed in
the other calls that follow.  This extension number is
unique only to a single connection.

__
|
XExtCodes *XAddExtension(4mdisplay24m)
	Display *4mdisplay24m;


4mdisplay24m   Specifies the connection to the X server.
|__

For local Xlib extensions, the 4mXAddExtension24m function allo-
cates the 4mXExtCodes24m structure, bumps the extension number
count, and chains the extension onto the extension list.
(This permits extensions to Xlib without requiring server
extensions.)




			     1m6220m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


1mHooks into the Library0m

These functions allow you to define procedures that are to
be called when various circumstances occur.  The procedures
include the creation of a new GC for a connection, the copy-
ing of a GC, the freeing of a GC, the creating and freeing
of fonts, the conversion of events defined by extensions to
and from wire format, and the handling of errors.

All of these functions return the previous procedure defined
for this extension.
__
|
int (*XESetCloseDisplay(4mdisplay24m, 4mextension24m, 4mproc24m))()
      Display *4mdisplay24m;
      int 4mextension24m;
      int (*4mproc24m)();


4mdisplay24m   Specifies the connection to the X server.

4mextension24m Specifies the extension number.

4mproc24m      Specifies the procedure to call when the display
	  is closed.
|__

The 4mXESetCloseDisplay24m function defines a procedure to be
called whenever 4mXCloseDisplay24m is called.  It returns any
previously defined procedure, usually NULL.

When 4mXCloseDisplay24m is called, your procedure is called with
these arguments:

__
|
(*4mproc24m)(4mdisplay24m, 4mcodes24m)
     Display *4mdisplay24m;
     XExtCodes *4mcodes24m;

|__
















			     1m6230m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
int (*XESetCreateGC(4mdisplay24m, 4mextension24m, 4mproc24m))()
      Display *4mdisplay24m;
      int 4mextension24m;
      int (*4mproc24m)();


4mdisplay24m   Specifies the connection to the X server.

4mextension24m Specifies the extension number.

4mproc24m      Specifies the procedure to call when a GC is
	  closed.
|__

The 4mXESetCreateGC24m function defines a procedure to be called
whenever a new GC is created.  It returns any previously
defined procedure, usually NULL.

When a GC is created, your procedure is called with these
arguments:

__
|
(*4mproc24m)(4mdisplay24m, 4mgc24m, 4mcodes24m)
     Display *4mdisplay24m;
     GC 4mgc24m;
     XExtCodes *4mcodes24m;

|__

__
|
int (*XESetCopyGC(4mdisplay24m, 4mextension24m, 4mproc24m))()
      Display *4mdisplay24m;
      int 4mextension24m;
      int (*4mproc24m)();


4mdisplay24m   Specifies the connection to the X server.

4mextension24m Specifies the extension number.

4mproc24m      Specifies the procedure to call when GC components
	  are copied.
|__

The 4mXESetCopyGC24m function defines a procedure to be called
whenever a GC is copied.  It returns any previously defined
procedure, usually NULL.

When a GC is copied, your procedure is called with these
arguments:




			     1m6240m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
(*4mproc24m)(4mdisplay24m, 4mgc24m, 4mcodes24m)
     Display *4mdisplay24m;
     GC 4mgc24m;
     XExtCodes *4mcodes24m;

|__

__
|
int (*XESetFreeGC(4mdisplay24m, 4mextension24m, 4mproc)24m)()
      Display *4mdisplay24m;
      int 4mextension24m;
      int (*4mproc24m)();


4mdisplay24m   Specifies the connection to the X server.

4mextension24m Specifies the extension number.

4mproc24m      Specifies the procedure to call when a GC is
	  freed.
|__

The 4mXESetFreeGC24m function defines a procedure to be called
whenever a GC is freed.	 It returns any previously defined
procedure, usually NULL.

When a GC is freed, your procedure is called with these
arguments:

__
|
(*4mproc24m)(4mdisplay24m, 4mgc24m, 4mcodes24m)
     Display *4mdisplay24m;
     GC 4mgc24m;
     XExtCodes *4mcodes24m;

|__


















			     1m6250m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
int (*XESetCreateFont(4mdisplay24m, 4mextension24m, 4mproc24m))()
      Display *4mdisplay24m;
      int 4mextension24m;
      int (*4mproc24m)();


4mdisplay24m   Specifies the connection to the X server.

4mextension24m Specifies the extension number.

4mproc24m      Specifies the procedure to call when a font is
	  created.
|__

The 4mXESetCreateFont24m function defines a procedure to be
called whenever 4mXLoadQueryFont24m and 4mXQueryFont24m are called.
It returns any previously defined procedure, usually NULL.

When 4mXLoadQueryFont24m or 4mXQueryFont24m is called, your procedure
is called with these arguments:

__
|
(*4mproc24m)(4mdisplay24m, 4mfs24m, 4mcodes24m)
     Display *4mdisplay24m;
     XFontStruct *4mfs24m;
     XExtCodes *4mcodes24m;

|__

__
|
int (*XESetFreeFont(4mdisplay24m, 4mextension24m, 4mproc24m))()
      Display *4mdisplay24m;
      int 4mextension24m;
      int (*4mproc24m)();


4mdisplay24m   Specifies the connection to the X server.

4mextension24m Specifies the extension number.

4mproc24m      Specifies the procedure to call when a font is
	  freed.
|__

The 4mXESetFreeFont24m function defines a procedure to be called
whenever 4mXFreeFont24m is called.  It returns any previously
defined procedure, usually NULL.

When 4mXFreeFont24m is called, your procedure is called with
these arguments:




			     1m6260m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
(*4mproc24m)(4mdisplay24m, 4mfs24m, 4mcodes24m)
     Display *4mdisplay24m;
     XFontStruct *4mfs24m;
     XExtCodes *4mcodes24m;

|__

The 4mXESetWireToEvent24m and 4mXESetEventToWire24m functions allow
you to define new events to the library.  An 4mXEvent24m struc-
ture always has a type code (type 4mint24m) as the first compo-
nent.  This uniquely identifies what kind of event it is.
The second component is always the serial number (type
4munsigned24m 4mlong24m) of the last request processed by the server.
The third component is always a Boolean (type 4mBool24m) indicat-
ing whether the event came from a 4mSendEvent24m protocol
request.  The fourth component is always a pointer to the
display the event was read from.  The fifth component is
always a resource ID of one kind or another, usually a win-
dow, carefully selected to be useful to toolkit dispatchers.
The fifth component should always exist, even if the event
does not have a natural destination; if there is no value
from the protocol to put in this component, initialize it to
zero.

			    Note

     There is an implementation limit such that your
     host event structure size cannot be bigger than
     the size of the 4mXEvent24m union of structures.  There
     also is no way to guarantee that more than 24 ele-
     ments or 96 characters in the structure will be
     fully portable between machines.

__
|
int (*XESetWireToEvent(4mdisplay24m, 4mevent_number24m, 4mproc24m))()
      Display *4mdisplay24m;
      int 4mevent_number24m;
      Status (*4mproc24m)();


4mdisplay24m   Specifies the connection to the X server.

4mevent_number0m
	  Specifies the event code.

4mproc24m      Specifies the procedure to call when converting an
	  event.
|__

The 4mXESetWireToEvent24m function defines a procedure to be
called when an event needs to be converted from wire format
(4mxEvent24m) to host format (4mXEvent24m).  The event number defines



			     1m6270m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


which protocol event number to install a conversion proce-
dure for.  4mXESetWireToEvent24m returns any previously defined
procedure.

			    Note

     You can replace a core event conversion function
     with one of your own, although this is not encour-
     aged.  It would, however, allow you to intercept a
     core event and modify it before being placed in
     the queue or otherwise examined.

When Xlib needs to convert an event from wire format to host
format, your procedure is called with these arguments:

__
|
Status (*4mproc24m)(4mdisplay24m, 4mre24m, 4mevent24m)
     Display *4mdisplay24m;
     XEvent *4mre24m;
     xEvent *4mevent24m;

|__

Your procedure must return status to indicate if the conver-
sion succeeded.	 The re argument is a pointer to where the
host format event should be stored, and the event argument
is the 32-byte wire event structure.  In the 4mXEvent24m struc-
ture you are creating, you must fill in the five required
members of the event structure.	 You should fill in the type
member with the type specified for the 4mxEvent24m structure.
You should copy all other members from the 4mxEvent24m structure
(wire format) to the 4mXEvent24m structure (host format).  Your
conversion procedure should return 4mTrue24m if the event should
be placed in the queue or 4mFalse24m if it should not be placed
in the queue.

To initialize the serial number component of the event, call
4m_XSetLastRequestRead24m with the event and use the return
value.

__
|
unsigned long _XSetLastRequestRead(4mdisplay24m, 4mrep24m)
      Display *4mdisplay24m;
      xGenericReply *4mrep24m;


4mdisplay24m   Specifies the connection to the X server.

4mrep24m       Specifies the wire event structure.
|__

The 4m_XSetLastRequestRead24m function computes and returns a



			     1m6280m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


complete serial number from the partial serial number in the
event.


__
|
Status (*XESetEventToWire(4mdisplay24m, 4mevent_number24m, 4mproc24m))()
      Display *4mdisplay24m;
      int 4mevent_number24m;
      int (*4mproc24m)();


4mdisplay24m   Specifies the connection to the X server.

4mevent_number0m
	  Specifies the event code.

4mproc24m      Specifies the procedure to call when converting an
	  event.
|__

The 4mXESetEventToWire24m function defines a procedure to be
called when an event needs to be converted from host format
(4mXEvent24m) to wire format (4mxEvent24m) form.  The event number
defines which protocol event number to install a conversion
procedure for.	4mXESetEventToWire24m returns any previously
defined procedure.  It returns zero if the conversion fails
or nonzero otherwise.

			    Note

     You can replace a core event conversion function
     with one of your own, although this is not encour-
     aged.  It would, however, allow you to intercept a
     core event and modify it before being sent to
     another client.

When Xlib needs to convert an event from host format to wire
format, your procedure is called with these arguments:

__
|
(*4mproc24m)(4mdisplay24m, 4mre24m, 4mevent24m)
     Display *4mdisplay24m;
     XEvent *4mre24m;
     xEvent *4mevent24m;

|__

The re argument is a pointer to the host format event, and
the event argument is a pointer to where the 32-byte wire
event structure should be stored.  You should fill in the
type with the type from the 4mXEvent24m structure.  All other
members then should be copied from the host format to the



			     1m6290m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


4mxEvent24m structure.
__
|
Bool (*XESetWireToError(4mdisplay24m, 4merror_number24m, 4mproc24m)()
      Display *4mdisplay24m;
      int 4merror_number24m;
      Bool (*4mproc24m)();


4mdisplay24m   Specifies the connection to the X server.

4merror_number0m
	  Specifies the error code.

4mproc24m      Specifies the procedure to call when an error is
	  received.
|__

The 4mXESetWireToError24m function defines a procedure to be
called when an extension error needs to be converted from
wire format to host format.  The error number defines which
protocol error code to install the conversion procedure for.
4mXESetWireToError24m returns any previously defined procedure.

Use this function for extension errors that contain addi-
tional error values beyond those in a core X error, when
multiple wire errors must be combined into a single Xlib
error, or when it is necessary to intercept an X error
before it is otherwise examined.

When Xlib needs to convert an error from wire format to host
format, the procedure is called with these arguments:

__
|
Bool (*4mproc24m)(4mdisplay24m, 4mhe24m, 4mwe24m)
     Display *4mdisplay24m;
     XErrorEvent *4mhe24m;
     xError *4mwe24m;

|__

The he argument is a pointer to where the host format error
should be stored.  The structure pointed at by he is guaran-
teed to be as large as an 4mXEvent24m structure and so can be
cast to a type larger than an 4mXErrorEvent24m to store addi-
tional values.	If the error is to be completely ignored by
Xlib (for example, several protocol error structures will be
combined into one Xlib error), then the function should
return 4mFalse24m; otherwise, it should return 4mTrue24m.







			     1m6300m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
int (*XESetError(4mdisplay24m, 4mextension24m, 4mproc24m))()
      Display *4mdisplay24m;
      int 4mextension24m;
      int (*4mproc24m)();


4mdisplay24m   Specifies the connection to the X server.

4mextension24m Specifies the extension number.

4mproc24m      Specifies the procedure to call when an error is
	  received.
|__

Inside Xlib, there are times that you may want to suppress
the calling of the external error handling when an error
occurs.	 This allows status to be returned on a call at the
cost of the call being synchronous (though most such func-
tions are query operations, in any case, and are typically
programmed to be synchronous).

When Xlib detects a protocol error in 4m_XReply24m, it calls your
procedure with these arguments:

__
|
int (*4mproc24m)(4mdisplay24m, 4merr24m, 4mcodes24m, 4mret_code24m)
     Display *4mdisplay24m;
     xError *4merr24m;
     XExtCodes *4mcodes24m;
     int *4mret_code24m;

|__

The err argument is a pointer to the 32-byte wire format
error.	The codes argument is a pointer to the extension
codes structure.  The ret_code argument is the return code
you may want 4m_XReply24m returned to.

If your procedure returns a zero value, the error is not
suppressed, and the client's error handler is called.  (For
further information, see section 11.8.2.)  If your procedure
returns nonzero, the error is suppressed, and 4m_XReply0m
returns the value of ret_code.












			     1m6310m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
char  *(*XESetErrorString(4mdisplay24m, 4mextension24m, 4mproc24m))()
      Display *4mdisplay24m;
      int 4mextension24m;
      char *(*4mproc24m)();


4mdisplay24m   Specifies the connection to the X server.

4mextension24m Specifies the extension number.

4mproc24m      Specifies the procedure to call to obtain an error
	  string.
|__

The 4mXGetErrorText24m function returns a string to the user for
an error.  4mXESetErrorString24m allows you to define a procedure
to be called that should return a pointer to the error mes-
sage.  The following is an example.

__
|
(*4mproc24m)(4mdisplay24m, 4mcode24m, 4mcodes24m, 4mbuffer24m, 4mnbytes24m)
     Display *4mdisplay24m;
     int 4mcode24m;
     XExtCodes *4mcodes24m;
     char *4mbuffer24m;
     int 4mnbytes24m;

|__

Your procedure is called with the error code for every error
detected.  You should copy nbytes of a null-terminated
string containing the error message into buffer.
__
|
void (*XESetPrintErrorValues(4mdisplay24m, 4mextension24m, 4mproc24m))()
      Display *4mdisplay24m;
      int 4mextension24m;
      void (*4mproc24m)();


4mdisplay24m   Specifies the connection to the X server.

4mextension24m Specifies the extension number.

4mproc24m      Specifies the procedure to call when an error is
	  printed.
|__

The 4mXESetPrintErrorValues24m function defines a procedure to be
called when an extension error is printed, to print the
error values.  Use this function for extension errors that
contain additional error values beyond those in a core X



			     1m6320m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


error.	It returns any previously defined procedure.

When Xlib needs to print an error, the procedure is called
with these arguments:

__
|
void (*4mproc24m)(4mdisplay24m, 4mev24m, 4mfp24m)
     Display *4mdisplay24m;
     XErrorEvent *4mev24m;
     void *4mfp24m;

|__

The structure pointed at by ev is guaranteed to be as large
as an 4mXEvent24m structure and so can be cast to a type larger
than an 4mXErrorEvent24m to obtain additional values set by using
4mXESetWireToError24m.	The underlying type of the fp argument is
system dependent; on a POSIX-compliant system, fp should be
cast to type FILE*.
__
|
int (*XESetFlushGC(4mdisplay24m, 4mextension24m, 4mproc24m))()
      Display *4mdisplay24m;
      int 4mextension24m;
      int *(*4mproc24m)();


4mdisplay24m   Specifies the connection to the X server.

4mextension24m Specifies the extension number.

4mproc24m      Specifies the procedure to call when a GC is
	  flushed.
|__

The procedure set by the 4mXESetFlushGC24m function has the same
interface as the procedure set by the 4mXESetCopyGC24m function,
but is called when a GC cache needs to be updated in the
server.

















			     1m6330m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
int (*XESetBeforeFlush(4mdisplay24m, 4mextension24m, 4mproc24m))()
      Display *4mdisplay24m;
      int 4mextension24m;
      int *(*4mproc24m)();


4mdisplay24m   Specifies the connection to the X server.

4mextension24m Specifies the extension number.

4mproc24m      Specifies the procedure to call when a buffer is
	  flushed.
|__

The 4mXESetBeforeFlush24m function defines a procedure to be
called when data is about to be sent to the server.  When
data is about to be sent, your procedure is called one or
more times with these arguments:

__
|
void (*4mproc24m)(4mdisplay24m, 4mcodes24m, 4mdata24m, 4mlen24m)
     Display *4mdisplay24m;
     XExtCodes *4mcodes24m;
     char *4mdata24m;
     long 4mlen24m;

|__

The data argument specifies a portion of the outgoing data
buffer, and its length in bytes is specified by the len
argument.  Your procedure must not alter the contents of the
data and must not do additional protocol requests to the
same display.

1mHooks onto Xlib Data Structures0m

Various Xlib data structures have provisions for extension
procedures to chain extension supplied data onto a list.
These structures are 4mGC24m, 4mVisual24m, 4mScreen24m, 4mScreenFormat24m, 4mDis-0m
4mplay24m, and 4mXFontStruct24m.  Because the list pointer is always
the first member in the structure, a single set of proce-
dures can be used to manipulate the data on these lists.

The following structure is used in the functions in this
section and is defined in <4mX11/Xlib.h24m>:










			     1m6340m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
typedef struct _XExtData {
     int number;	      /* number returned by XInitExtension */
     struct _XExtData *next;  /* next item on list of data for structure */
     int (*free_private)();   /* if defined,  called to free private */
     XPointer private_data;   /* data private to this extension. */
} XExtData;

|__

When any of the data structures listed above are freed, the
list is walked, and the structure's free procedure (if any)
is called.  If free is NULL, then the library frees both the
data pointed to by the private_data member and the structure
itself.

__
|
union {Display *display;
     GC gc;
     Visual *visual;
     Screen *screen;
     ScreenFormat *pixmap_format;
     XFontStruct *font } XEDataObject;

|__

__
|
XExtData **XEHeadOfExtensionList(4mobject24m)
     XEDataObject 4mobject24m;


4mobject24m    Specifies the object.
|__

The 4mXEHeadOfExtensionList24m function returns a pointer to the
list of extension structures attached to the specified
object.	 In concert with 4mXAddToExtensionList24m, 4mXEHeadOfExten-0m
4msionList24m allows an extension to attach arbitrary data to any
of the structures of types contained in 4mXEDataObject24m.
















			     1m6350m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
XAddToExtensionList(4mstructure24m, 4mext_data24m)
      XExtData **4mstructure24m;
      XExtData *4mext_data24m;


4mstructure24m Specifies the extension list.

4mext_data24m  Specifies the extension data structure to add.
|__

The structure argument is a pointer to one of the data
structures enumerated above.  You must initialize
ext_data->number with the extension number before calling
this function.
__
|
XExtData *XFindOnExtensionList(4mstructure24m, 4mnumber24m)
      struct _XExtData **4mstructure24m;
      int 4mnumber24m;


4mstructure24m Specifies the extension list.

4mnumber24m    Specifies the extension number from 4mXInitExten-0m
	  4msion24m.
|__

The 4mXFindOnExtensionList24m function returns the first exten-
sion data structure for the extension numbered number.	It
is expected that an extension will add at most one extension
data structure to any single data structure's extension data
list.  There is no way to find additional structures.

The 4mXAllocID24m macro, which allocates and returns a resource
ID, is defined in <4mX11/Xlib.h24m>.
__
|
XAllocID(4mdisplay24m)
     Display *4mdisplay24m;


4mdisplay24m   Specifies the connection to the X server.
|__

This macro is a call through the 4mDisplay24m structure to an
internal resource ID allocator.	 It returns a resource ID
that you can use when creating new resources.

The 4mXAllocIDs24m macro allocates and returns an array of
resource ID.






			     1m6360m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
XAllocIDs(4mdisplay24m, 4mids_return24m, 4mcount24m)
     Display *4mdisplay24m;
     XID *4mids_return24m;
     int 4mcount24m;


4mdisplay24m   Specifies the connection to the X server.

4mids_return0m
	  Returns the resource IDs.

4mrep24m       Specifies the number of resource IDs requested.
|__

This macro is a call through the 4mDisplay24m structure to an
internal resource ID allocator.	 It returns resource IDs to
the array supplied by the caller.  To correctly handle auto-
matic reuse of resource IDs, you must call 4mXAllocIDs24m when
requesting multiple resource IDs.  This call might generate
protocol requests.

1mGC Caching0m

GCs are cached by the library to allow merging of indepen-
dent change requests to the same GC into single protocol
requests.  This is typically called a write-back cache.	 Any
extension procedure whose behavior depends on the contents
of a GC must flush the GC cache to make sure the server has
up-to-date contents in its GC.

The 4mFlushGC24m macro checks the dirty bits in the library's GC
structure and calls 4m_XFlushGCCache24m if any elements have
changed.  The 4mFlushGC24m macro is defined as follows:
__
|
FlushGC(4mdisplay24m, 4mgc24m)
      Display *4mdisplay24m;
      GC 4mgc24m;


4mdisplay24m   Specifies the connection to the X server.

4mgc24m	       Specifies the GC.
|__

Note that if you extend the GC to add additional resource ID
components, you should ensure that the library stub sends
the change request immediately.	 This is because a client
can free a resource immediately after using it, so if you
only stored the value in the cache without forcing a proto-
col request, the resource might be destroyed before being
set into the GC.  You can use the 4m_XFlushGCCache24m procedure
to force the cache to be flushed.  The 4m_XFlushGCCache0m



			     1m6370m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


procedure is defined as follows:
__
|
_XFlushGCCache(4mdisplay24m, 4mgc24m)
      Display *4mdisplay24m;
      GC 4mgc24m;


4mdisplay24m   Specifies the connection to the X server.

4mgc24m	       Specifies the GC.
|__


1mGraphics Batching0m

If you extend X to add more poly graphics primitives, you
may be able to take advantage of facilities in the library
to allow back-to-back single calls to be transformed into
poly requests.	This may dramatically improve performance of
programs that are not written using poly requests.  A
pointer to an 4mxReq24m, called last_req in the display struc-
ture, is the last request being processed.  By checking that
the last request type, drawable, gc, and other options are
the same as the new one and that there is enough space left
in the buffer, you may be able to just extend the previous
graphics request by extending the length field of the
request and appending the data to the buffer.  This can
improve performance by five times or more in naive programs.
For example, here is the source for the 4mXDrawPoint24m stub.
(Writing extension stubs is discussed in the next section.)


























			     1m6380m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

 __
|
     #include <X11/Xlibint.h>

     /* precompute the maximum size of batching request allowed */

     static int size = sizeof(xPolyPointReq) + EPERBATCH * sizeof(xPoint);

     XDrawPoint(dpy, d, gc, x, y)
	 register Display *dpy;
	 Drawable d;
	 GC gc;
	 int x, y; /* INT16 */
     {
	 xPoint *point;
	 LockDisplay(dpy);
	 FlushGC(dpy, gc);
	 {
	 register xPolyPointReq *req = (xPolyPointReq *) dpy->last_req;
	 /* if same as previous request, with same drawable, batch requests */
	 if (
	       (req->reqType == X_PolyPoint)
	    && (req->drawable == d)
	    && (req->gc == gc->gid)
	    && (req->coordMode == CoordModeOrigin)
	    && ((dpy->bufptr + sizeof (xPoint)) <= dpy->bufmax)
	    && (((char *)dpy->bufptr - (char *)req) < size) ) {
	      point = (xPoint *) dpy->bufptr;
	      req->length += sizeof (xPoint) >> 2;
	      dpy->bufptr += sizeof (xPoint);
	      }

	 else {
	     GetReqExtra(PolyPoint, 4, req); /* 1 point = 4 bytes */
	     req->drawable = d;
	     req->gc = gc->gid;
	     req->coordMode = CoordModeOrigin;
	     point = (xPoint *) (req + 1);
	     }
	 point->x = x;
	 point->y = y;
	 }
	 UnlockDisplay(dpy);
	 SyncHandle();
     }
|__

To keep clients from generating very long requests that may
monopolize the server, there is a symbol defined in
<4mX11/Xlibint.h24m> of EPERBATCH on the number of requests
batched.  Most of the performance benefit occurs in the
first few merged requests.  Note that 4mFlushGC24m is called
4mbefore24m picking up the value of last_req, because it may mod-
ify this field.




			     1m6390m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


1mWriting Extension Stubs0m

All X requests always contain the length of the request,
expressed as a 16-bit quantity of 32 bits.  This means that
a single request can be no more than 256K bytes in length.
Some servers may not support single requests of such a
length.	 The value of dpy->max_request_size contains the
maximum length as defined by the server implementation.	 For
further information, see ``X Window System Protocol.''

1mRequests, Replies, and Xproto.h0m

The <4mX11/Xproto.h24m> file contains three sets of definitions
that are of interest to the stub implementor: request names,
request structures, and reply structures.

You need to generate a file equivalent to <4mX11/Xproto.h24m> for
your extension and need to include it in your stub proce-
dure.  Each stub procedure also must include <4mX11/Xlib-0m
4mint.h24m>.

The identifiers are deliberately chosen in such a way that,
if the request is called X_DoSomething, then its request
structure is xDoSomethingReq, and its reply is xDoSomethin-
gReply.	 The GetReq family of macros, defined in <4mX11/Xlib-0m
4mint.h24m>, takes advantage of this naming scheme.

For each X request, there is a definition in <4mX11/Xproto.h24m>
that looks similar to this:


     #define X_DoSomething   42

In your extension header file, this will be a minor opcode,
instead of a major opcode.

1mRequest Format0m

Every request contains an 8-bit major opcode and a 16-bit
length field expressed in units of 4 bytes.  Every request
consists of 4 bytes of header (containing the major opcode,
the length field, and a data byte) followed by zero or more
additional bytes of data.  The length field defines the
total length of the request, including the header.  The
length field in a request must equal the minimum length
required to contain the request.  If the specified length is
smaller or larger than the required length, the server
should generate a 4mBadLength24m error.	 Unused bytes in a
request are not required to be zero.  Extensions should be
designed in such a way that long protocol requests can be
split up into smaller requests, if it is possible to exceed
the maximum request size of the server.	 The protocol guar-
antees the maximum request size to be no smaller than 4096
units (16384 bytes).



			     1m6400m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


Major opcodes 128 through 255 are reserved for extensions.
Extensions are intended to contain multiple requests, so
extension requests typically have an additional minor opcode
encoded in the second data byte in the request header, but
the placement and interpretation of this minor opcode as
well as all other fields in extension requests are not
defined by the core protocol.  Every request is implicitly
assigned a sequence number (starting with one) used in
replies, errors, and events.

To help but not cure portability problems to certain
machines, the 4mB1624m and 4mB3224m macros have been defined so that
they can become bitfield specifications on some machines.
For example, on a Cray, these should be used for all 16-bit
and 32-bit quantities, as discussed below.

Most protocol requests have a corresponding structure type-
def in <4mX11/Xproto.h24m>, which looks like:

__
|
typedef struct _DoSomethingReq {
     CARD8 reqType;	      /* X_DoSomething */
     CARD8 someDatum;	      /* used differently in different requests */
     CARD16 length B16;	      /* total # of bytes in request, divided by 4 */
     ...
     /* request-specific data */
     ...
} xDoSomethingReq;

|__

If a core protocol request has a single 32-bit argument, you
need not declare a request structure in your extension
header file.  Instead, such requests use the 4mxResourceReq0m
structure in <4mX11/Xproto.h24m>.  This structure is used for any
request whose single argument is a 4mWindow24m, 4mPixmap24m, 4mDrawable24m,
4mGContext24m, 4mFont24m, 4mCursor24m, 4mColormap24m, 4mAtom24m, or 4mVisualID24m.

__
|
typedef struct _ResourceReq {
     CARD8 reqType;	      /* the request type, e.g. X_DoSomething */
     BYTE pad;		      /* not used */
     CARD16 length B16;	      /* 2 (= total # of bytes in request, divided by 4) */
     CARD32 id B32;	      /* the Window, Drawable, Font, GContext, etc. */
} xResourceReq;

|__

If convenient, you can do something similar in your exten-
sion header file.





			     1m6410m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


In both of these structures, the reqType field identifies
the type of the request (for example, X_MapWindow or X_Cre-
atePixmap).  The length field tells how long the request is
in units of 4-byte longwords.  This length includes both the
request structure itself and any variable-length data, such
as strings or lists, that follow the request structure.
Request structures come in different sizes, but all requests
are padded to be multiples of four bytes long.

A few protocol requests take no arguments at all.  Instead,
they use the 4mxReq24m structure in <4mX11/Xproto.h24m>, which con-
tains only a reqType and a length (and a pad byte).

If the protocol request requires a reply, then
<4mX11/Xproto.h24m> also contains a reply structure typedef:

__
|
typedef struct _DoSomethingReply {
     BYTE type;		      /* always X_Reply */
     BYTE someDatum;	      /* used differently in different requests */
     CARD16 sequenceNumber B16;/* # of requests sent so far */
     CARD32 length B32;	      /* # of additional bytes, divided by 4 */
     ...
     /* request-specific data */
     ...
} xDoSomethingReply;

|__

Most of these reply structures are 32 bytes long.  If there
are not that many reply values, then they contain a suffi-
cient number of pad fields to bring them up to 32 bytes.
The length field is the total number of bytes in the request
minus 32, divided by 4.	 This length will be nonzero only
if:

·    The reply structure is followed by variable-length
     data, such as a list or string.

·    The reply structure is longer than 32 bytes.

Only 4mGetWindowAttributes24m, 4mQueryFont24m, 4mQueryKeymap24m, and
4mGetKeyboardControl24m have reply structures longer than 32
bytes in the core protocol.

A few protocol requests return replies that contain no data.
<4mX11/Xproto.h24m> does not define reply structures for these.
Instead, they use the 4mxGenericReply24m structure, which con-
tains only a type, length, and sequence number (and suffi-
cient padding to make it 32 bytes long).






			     1m6420m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


1mStarting to Write a Stub Procedure0m

An Xlib stub procedure should start like this:


     #include "<X11/Xlibint.h>

     XDoSomething (arguments, ... )
     /* argument declarations */
     {

     register XDoSomethingReq *req;
     ...

If the protocol request has a reply, then the variable dec-
larations should include the reply structure for the
request.  The following is an example:


     xDoSomethingReply rep;


1mLocking Data Structures0m

To lock the display structure for systems that want to sup-
port multithreaded access to a single display connection,
each stub will need to lock its critical section.  Gener-
ally, this section is the point from just before the appro-
priate GetReq call until all arguments to the call have been
stored into the buffer.	 The precise instructions needed for
this locking depend upon the machine architecture.  Two
calls, which are generally implemented as macros, have been
provided.
__
|
LockDisplay(4mdisplay24m)
      Display *4mdisplay24m;



UnlockDisplay(4mdisplay24m)
      Display *4mdisplay24m;


4mdisplay24m   Specifies the connection to the X server.
|__


1mSending the Protocol Request and Arguments0m

After the variable declarations, a stub procedure should
call one of four macros defined in <4mX11/Xlibint.h24m>: 4mGetReq24m,
4mGetReqExtra24m, 4mGetResReq24m, or 4mGetEmptyReq24m.	All of these macros
take, as their first argument, the name of the protocol



			     1m6430m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


request as declared in <4mX11/Xproto.h24m> except with X_
removed.  Each one declares a 4mDisplay24m structure pointer,
called dpy, and a pointer to a request structure, called
req, which is of the appropriate type.	The macro then
appends the request structure to the output buffer, fills in
its type and length field, and sets req to point to it.

If the protocol request has no arguments (for instance,
X_GrabServer), then use 4mGetEmptyReq24m.


     GetEmptyReq (DoSomething, req);

If the protocol request has a single 32-bit argument (such
as a 4mPixmap24m, 4mWindow24m, 4mDrawable24m, 4mAtom24m, and so on), then use
4mGetResReq24m.	 The second argument to the macro is the 32-bit
object.	 4mX_MapWindow24m is a good example.


     GetResReq (DoSomething, rid, req);

The rid argument is the 4mPixmap24m, 4mWindow24m, or other resource
ID.

If the protocol request takes any other argument list, then
call 4mGetReq24m.  After the 4mGetReq24m, you need to set all the
other fields in the request structure, usually from argu-
ments to the stub procedure.


     GetReq (DoSomething, req);
     /* fill in arguments here */
     req->arg1 = arg1;
     req->arg2 = arg2;
     ...

A few stub procedures (such as 4mXCreateGC24m and 4mXCreatePixmap24m)
return a resource ID to the caller but pass a resource ID as
an argument to the protocol request.  Such procedures use
the macro 4mXAllocID24m to allocate a resource ID from the range
of IDs that were assigned to this client when it opened the
connection.


     rid = req->rid = XAllocID();
     ...
     return (rid);

Finally, some stub procedures transmit a fixed amount of
variable-length data after the request.	 Typically, these
procedures (such as 4mXMoveWindow24m and 4mXSetBackground24m) are spe-
cial cases of more general functions like 4mXMoveResizeWindow0m
and 4mXChangeGC24m.  These procedures use 4mGetReqExtra24m, which is
the same as 4mGetReq24m except that it takes an additional



			     1m6440m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


argument (the number of extra bytes to allocate in the out-
put buffer after the request structure).  This number should
always be a multiple of four.

1mVariable Length Arguments0m

Some protocol requests take additional variable-length data
that follow the 4mxDoSomethingReq24m structure.	 The format of
this data varies from request to request.  Some requests
require a sequence of 8-bit bytes, others a sequence of
16-bit or 32-bit entities, and still others a sequence of
structures.

It is necessary to add the length of any variable-length
data to the length field of the request structure.  That
length field is in units of 32-bit longwords.  If the data
is a string or other sequence of 8-bit bytes, then you must
round the length up and shift it before adding:


     req->length += (nbytes+3)>>2;

To transmit variable-length data, use the 4mData24m macros.  If
the data fits into the output buffer, then this macro copies
it to the buffer.  If it does not fit, however, the 4mData0m
macro calls 4m_XSend24m, which transmits first the contents of
the buffer and then your data.	The 4mData24m macros take three
arguments: the display, a pointer to the beginning of the
data, and the number of bytes to be sent.
__
|
Data(4mdisplay24m, (char *) 4mdata24m, 4mnbytes24m);

Data16(4mdisplay24m, (short *) 4mdata24m, 4mnbytes24m);

Data32(4mdisplay24m, (long *) 4mdata24m, 4mnbytes24m);

|__

4mData24m, 4mData1624m, and 4mData3224m are macros that may use their last
argument more than once, so that argument should be a vari-
able rather than an expression such as
``nitems*sizeof(item)''.  You should do that kind of compu-
tation in a separate statement before calling them.  Use the
appropriate macro when sending byte, short, or long data.

If the protocol request requires a reply, then call the pro-
cedure 4m_XSend24m instead of the 4mData24m macro.  4m_XSend24m takes the
same arguments, but because it sends your data immediately
instead of copying it into the output buffer (which would
later be flushed anyway by the following call on 4m_XReply24m),
it is faster.





			     1m6450m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


1mReplies0m

If the protocol request has a reply, then call 4m_XReply24m after
you have finished dealing with all the fixed-length and
variable-length arguments.  4m_XReply24m flushes the output
buffer and waits for an 4mxReply24m packet to arrive.  If any
events arrive in the meantime, 4m_XReply24m places them in the
queue for later use.
__
|
Status _XReply(4mdisplay24m, 4mrep24m, 4mextra24m, 4mdiscard24m)
      Display *4mdisplay24m;
      xReply *4mrep24m;
      int 4mextra24m;
      Bool 4mdiscard24m;


4mdisplay24m   Specifies the connection to the X server.

4mrep24m       Specifies the reply structure.

4mextra24m     Specifies the number of 32-bit words expected
	  after the replay.

4mdiscard24m   Specifies if any data beyond that specified in the
	  extra argument should be discarded.
|__

The 4m_XReply24m function waits for a reply packet and copies its
contents into the specified rep.  4m_XReply24m handles error and
event packets that occur before the reply is received.
4m_XReply24m takes four arguments:

·    A 4mDisplay24m * structure

·    A pointer to a reply structure (which must be cast to
     an 4mxReply24m *)

·    The number of additional 32-bit words (beyond
     sizeof(4mxReply24m) = 32 bytes) in the reply structure

·    A Boolean that indicates whether 4m_XReply24m is to discard
     any additional bytes beyond those it was told to read

Because most reply structures are 32 bytes long, the third
argument is usually 0.	The only core protocol exceptions
are the replies to 4mGetWindowAttributes24m, 4mQueryFont24m,
4mQueryKeymap24m, and 4mGetKeyboardControl24m, which have longer
replies.

The last argument should be 4mFalse24m if the reply structure is
followed by additional variable-length data (such as a list
or string).  It should be 4mTrue24m if there is not any variable-
length data.



			     1m6460m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


			    Note

     This last argument is provided for upward-compati-
     bility reasons to allow a client to communicate
     properly with a hypothetical later version of the
     server that sends more data than the client
     expected.	For example, some later version of
     4mGetWindowAttributes24m might use a larger, but com-
     patible, 4mxGetWindowAttributesReply24m that contains
     additional attribute data at the end.

4m_XReply24m returns 4mTrue24m if it received a reply successfully or
4mFalse24m if it received any sort of error.

For a request with a reply that is not followed by variable-
length data, you write something like:


     _XReply(display, (xReply *)&rep, 0, True);
     *ret1 = rep.ret1;
     *ret2 = rep.ret2;
     *ret3 = rep.ret3;
     ...
     UnlockDisplay(dpy);
     SyncHandle();
     return (rep.ret4);
     }

If there is variable-length data after the reply, change the
4mTrue24m to 4mFalse24m, and use the appropriate 4m_XRead24m function to
read the variable-length data.

__
|
_XRead(4mdisplay24m, 4mdata_return24m, 4mnbytes24m)
       Display *4mdisplay24m;
       char *4mdata_return24m;
       long 4mnbytes24m;


4mdisplay24m   Specifies the connection to the X server.

4mdata_return0m
	  Specifies the buffer.

4mnbytes24m    Specifies the number of bytes required.
|__

The 4m_XRead24m function reads the specified number of bytes into
data_return.







			     1m6470m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
_XRead16(4mdisplay24m, 4mdata_return24m, 4mnbytes24m)
       Display *4mdisplay24m;
       short *4mdata_return24m;
       long 4mnbytes24m;


4mdisplay24m   Specifies the connection to the X server.

4mdata_return0m
	  Specifies the buffer.

4mnbytes24m    Specifies the number of bytes required.
|__

The 4m_XRead1624m function reads the specified number of bytes,
unpacking them as 16-bit quantities, into the specified
array as shorts.

__
|
_XRead32(4mdisplay24m, 4mdata_return24m, 4mnbytes24m)
       Display *4mdisplay24m;
       long *4mdata_return24m;
       long 4mnbytes24m;


4mdisplay24m   Specifies the connection to the X server.

4mdata_return0m
	  Specifies the buffer.

4mnbytes24m    Specifies the number of bytes required.
|__

The 4m_XRead3224m function reads the specified number of bytes,
unpacking them as 32-bit quantities, into the specified
array as longs.



















			     1m6480m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
_XRead16Pad(4mdisplay24m, 4mdata_return24m, 4mnbytes24m)
       Display *4mdisplay24m;
       short *4mdata_return24m;
       long 4mnbytes24m;


4mdisplay24m   Specifies the connection to the X server.

4mdata_return0m
	  Specifies the buffer.

4mnbytes24m    Specifies the number of bytes required.
|__

The 4m_XRead16Pad24m function reads the specified number of
bytes, unpacking them as 16-bit quantities, into the speci-
fied array as shorts.  If the number of bytes is not a mul-
tiple of four, 4m_XRead16Pad24m reads and discards up to two
additional pad bytes.

__
|
_XReadPad(4mdisplay24m, 4mdata_return24m, 4mnbytes24m)
       Display *4mdisplay24m;
       char *4mdata_return24m;
       long 4mnbytes24m;


4mdisplay24m   Specifies the connection to the X server.

4mdata_return0m
	  Specifies the buffer.

4mnbytes24m    Specifies the number of bytes required.
|__

The 4m_XReadPad24m function reads the specified number of bytes
into data_return.  If the number of bytes is not a multiple
of four, 4m_XReadPad24m reads and discards up to three additional
pad bytes.

Each protocol request is a little different.  For further
information, see the Xlib sources for examples.

1mSynchronous Calling0m

Each procedure should have a call, just before returning to
the user, to a macro called 4mSyncHandle24m.  If synchronous mode
is enabled (see 4mXSynchronize24m), the request is sent immedi-
ately.	The library, however, waits until any error the pro-
cedure could generate at the server has been handled.





			     1m6490m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


1mAllocating and Deallocating Memory0m

To support the possible reentry of these procedures, you
must observe several conventions when allocating and deallo-
cating memory, most often done when returning data to the
user from the window system of a size the caller could not
know in advance (for example, a list of fonts or a list of
extensions).  The standard C library functions on many sys-
tems are not protected against signals or other multi-
threaded uses.	The following analogies to standard I/O
library functions have been defined:

4mXmalloc24m()	 Replaces 4mmalloc24m()
4mXFree24m()	 Replaces 4mfree24m()
4mXcalloc24m()	 Replaces 4mcalloc24m()


These should be used in place of any calls you would make to
the normal C library functions.

If you need a single scratch buffer inside a critical sec-
tion (for example, to pack and unpack data to and from the
wire protocol), the general memory allocators may be too
expensive to use (particularly in output functions, which
are performance critical).  The following function returns a
scratch buffer for use within a critical section:
__
|
char *_XAllocScratch(4mdisplay24m, 4mnbytes24m)
      Display *4mdisplay24m;
      unsigned long 4mnbytes24m;


4mdisplay24m   Specifies the connection to the X server.

4mnbytes24m    Specifies the number of bytes required.
|__

This storage must only be used inside of a critical section
of your stub.  The returned pointer cannot be assumed valid
after any call that might permit another thread to execute
inside Xlib.  For example, the pointer cannot be assumed
valid after any use of the 4mGetReq24m or 4mData24m families of
macros, after any use of 4m_XReply24m, or after any use of the
4m_XSend24m or 4m_XRead24m families of functions.


The following function returns a scratch buffer for use
across critical sections:








			     1m6500m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
char *_XAllocTemp(4mdisplay24m, 4mnbytes24m)
      Display *4mdisplay24m;
      unsigned long 4mnbytes24m;


4mdisplay24m   Specifies the connection to the X server.

4mnbytes24m    Specifies the number of bytes required.
|__

This storage can be used across calls that might permit
another thread to execute inside Xlib.	The storage must be
explicitly returned to Xlib.  The following function returns
the storage:
__
|
void _XFreeTemp(4mdisplay24m, 4mbuf24m, 4mnbytes24m)
      Display *4mdisplay24m;
      char *4mbuf24m;
      unsigned long 4mnbytes24m;


4mdisplay24m   Specifies the connection to the X server.

4mbuf24m       Specifies the buffer to return.

4mnbytes24m    Specifies the size of the buffer.
|__

You must pass back the same pointer and size that were
returned by 4m_XAllocTemp24m.

1mPortability Considerations0m

Many machine architectures, including many of the more
recent RISC architectures, do not correctly access data at
unaligned locations; their compilers pad out structures to
preserve this characteristic.  Many other machines capable
of unaligned references pad inside of structures as well to
preserve alignment, because accessing aligned data is usu-
ally much faster.  Because the library and the server use
structures to access data at arbitrary points in a byte
stream, all data in request and reply packets 4mmust24m be natu-
rally aligned; that is, 16-bit data starts on 16-bit bound-
aries in the request and 32-bit data on 32-bit boundaries.
All requests 4mmust24m be a multiple of 32 bits in length to pre-
serve the natural alignment in the data stream.	 You must
pad structures out to 32-bit boundaries.  Pad information
does not have to be zeroed unless you want to preserve such
fields for future use in your protocol requests.  Floating
point varies radically between machines and should be
avoided completely if at all possible.




			     1m6510m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


This code may run on machines with 16-bit ints.	 So, if any
integer argument, variable, or return value either can take
only nonnegative values or is declared as a 4mCARD1624m in the
protocol, be sure to declare it as 4munsigned24m 4mint24m and not as
4mint24m.  (This, of course, does not apply to Booleans or enu-
merations.)

Similarly, if any integer argument or return value is
declared 4mCARD3224m in the protocol, declare it as an 4munsigned0m
4mlong24m and not as 4mint24m or 4mlong24m.  This also goes for any inter-
nal variables that may take on values larger than the maxi-
mum 16-bit 4munsigned24m 4mint24m.

The library currently assumes that a 4mchar24m is 8 bits, a 4mshort0m
is 16 bits, an 4mint24m is 16 or 32 bits, and a 4mlong24m is 32 bits.
The 4mPackData24m macro is a half-hearted attempt to deal with
the possibility of 32 bit shorts.  However, much more work
is needed to make this work properly.

1mDeriving the Correct Extension Opcode0m

The remaining problem a writer of an extension stub proce-
dure faces that the core protocol does not face is to map
from the call to the proper major and minor opcodes.  While
there are a number of strategies, the simplest and fastest
is outlined below.

1.   Declare an array of pointers, _NFILE long (this is nor-
     mally found in <4mstdio.h24m> and is the number of file
     descriptors supported on the system) of type 4mXExtCodes24m.
     Make sure these are all initialized to NULL.

2.   When your stub is entered, your initialization test is
     just to use the display pointer passed in to access the
     file descriptor and an index into the array.  If the
     entry is NULL, then this is the first time you are
     entering the procedure for this display.  Call your
     initialization procedure and pass to it the display
     pointer.

3.   Once in your initialization procedure, call 4mXInitExten-0m
     4msion24m; if it succeeds, store the pointer returned into
     this array.  Make sure to establish a close display
     handler to allow you to zero the entry.  Do whatever
     other initialization your extension requires.  (For
     example, install event handlers and so on.)  Your ini-
     tialization procedure would normally return a pointer
     to the 4mXExtCodes24m structure for this extension, which is
     what would normally be found in your array of pointers.

4.   After returning from your initialization procedure, the
     stub can now continue normally, because it has its
     major opcode safely in its hand in the 4mXExtCodes24m struc-
     ture.



			     1m6520m





1mXlib - C Library			X11, Release 6.7 DRAFT0m




			   1mAppendix D0m

		     1mCompatibility Functions0m




The X Version 11 and X Version 10 functions discussed in
this appendix are obsolete, have been superseded by newer X
Version 11 functions, and are maintained for compatibility
reasons only.

1mX Version 11 Compatibility Functions0m

You can use the X Version 11 compatibility functions to:

·    Set standard properties

·    Set and get window sizing hints

·    Set and get an 4mXStandardColormap24m structure

·    Parse window geometry

·    Get X environment defaults

1mSetting Standard Properties0m

To specify a minimum set of properties describing the sim-
plest application, use 4mXSetStandardProperties24m.  This func-
tion has been superseded by 4mXSetWMProperties24m and sets all or
portions of the WM_NAME, WM_ICON_NAME, WM_HINTS, WM_COMMAND,
and WM_NORMAL_HINTS properties.






















			     1m6530m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
XSetStandardProperties(4mdisplay24m, 4mw24m, 4mwindow_name24m, 4micon_name24m, 4micon_pixmap24m, 4margv24m, 4margc24m, 4mhints24m)
      Display *4mdisplay24m;
      Window 4mw24m;
      char *4mwindow_name24m;
      char *4micon_name24m;
      Pixmap 4micon_pixmap24m;
      char **4margv24m;
      int 4margc24m;
      XSizeHints *4mhints24m;


4mdisplay24m   Specifies the connection to the X server.

4mw24m	       Specifies the window.

4mwindow_name0m
	  Specifies the window name, which should be a null-
	  terminated string.

4micon_name24m Specifies the icon name, which should be a null-
	  terminated string.

4micon_pixmap0m
	  Specifies the bitmap that is to be used for the
	  icon or 4mNone24m.

4margv24m      Specifies the application's argument list.

4margc24m      Specifies the number of arguments.

4mhints24m     Specifies a pointer to the size hints for the win-
	  dow in its normal state.
|__

The 4mXSetStandardProperties24m function provides a means by
which simple applications set the most essential properties
with a single call.  4mXSetStandardProperties24m should be used
to give a window manager some information about your pro-
gram's preferences.  It should not be used by applications
that need to communicate more information than is possible
with 4mXSetStandardProperties24m.  (Typically, argv is the argv
array of your main program.)  If the strings are not in the
Host Portable Character Encoding, the result is implementa-
tion-dependent.

4mXSetStandardProperties24m can generate 4mBadAlloc24m and 4mBadWindow0m
errors.

1mSetting and Getting Window Sizing Hints0m

Xlib provides functions that you can use to set or get win-
dow sizing hints.  The functions discussed in this section
use the flags and the 4mXSizeHints24m structure, as defined in



			     1m6540m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


the <4mX11/Xutil.h24m> header file and use the WM_NORMAL_HINTS
property.


To set the size hints for a given window in its normal
state, use 4mXSetNormalHints24m.  This function has been super-
seded by 4mXSetWMNormalHints24m.
__
|
XSetNormalHints(4mdisplay24m, 4mw24m, 4mhints24m)
      Display *4mdisplay24m;
      Window 4mw24m;
      XSizeHints *4mhints24m;


4mdisplay24m   Specifies the connection to the X server.

4mw24m	       Specifies the window.

4mhints24m     Specifies a pointer to the size hints for the win-
	  dow in its normal state.
|__

The 4mXSetNormalHints24m function sets the size hints structure
for the specified window.  Applications use 4mXSetNormalHints0m
to inform the window manager of the size or position desir-
able for that window.  In addition, an application that
wants to move or resize itself should call 4mXSetNormalHints0m
and specify its new desired location and size as well as
making direct Xlib calls to move or resize.  This is because
window managers may ignore redirected configure requests,
but they pay attention to property changes.

To set size hints, an application not only must assign val-
ues to the appropriate members in the hints structure but
also must set the flags member of the structure to indicate
which information is present and where it came from.  A call
to 4mXSetNormalHints24m is meaningless, unless the flags member
is set to indicate which members of the structure have been
assigned values.

4mXSetNormalHints24m can generate 4mBadAlloc24m and 4mBadWindow24m errors.


To return the size hints for a window in its normal state,
use 4mXGetNormalHints24m.  This function has been superseded by
4mXGetWMNormalHints24m.










			     1m6550m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
Status XGetNormalHints(4mdisplay24m, 4mw24m, 4mhints_return24m)
      Display *4mdisplay24m;
      Window 4mw24m;
      XSizeHints *4mhints_return24m;


4mdisplay24m   Specifies the connection to the X server.

4mw24m	       Specifies the window.

4mhints_return0m
	  Returns the size hints for the window in its
	  normal state.
|__

The 4mXGetNormalHints24m function returns the size hints for a
window in its normal state.  It returns a nonzero status if
it succeeds or zero if the application specified no normal
size hints for this window.

4mXGetNormalHints24m can generate a 4mBadWindow24m error.


The next two functions set and read the WM_ZOOM_HINTS prop-
erty.

To set the zoom hints for a window, use 4mXSetZoomHints24m.  This
function is no longer supported by the 4mInter-Client24m 4mCommuni-0m
4mcation24m 4mConventions24m 4mManual24m.
__
|
XSetZoomHints(4mdisplay24m, 4mw24m, 4mzhints24m)
      Display *4mdisplay24m;
      Window 4mw24m;
      XSizeHints *4mzhints24m;


4mdisplay24m   Specifies the connection to the X server.

4mw24m	       Specifies the window.

4mzhints24m    Specifies a pointer to the zoom hints.
|__

Many window managers think of windows in one of three
states: iconic, normal, or zoomed.  The 4mXSetZoomHints24m func-
tion provides the window manager with information for the
window in the zoomed state.

4mXSetZoomHints24m can generate 4mBadAlloc24m and 4mBadWindow24m errors.


To read the zoom hints for a window, use 4mXGetZoomHints24m.



			     1m6560m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


This function is no longer supported by the 4mInter-Client0m
4mCommunication24m 4mConventions24m 4mManual24m.
__
|
Status XGetZoomHints(4mdisplay24m, 4mw24m, 4mzhints_return24m)
      Display *4mdisplay24m;
      Window 4mw24m;
      XSizeHints *4mzhints_return24m;


4mdisplay24m   Specifies the connection to the X server.

4mw24m	       Specifies the window.

4mzhints_return0m
	  Returns the zoom hints.
|__

The 4mXGetZoomHints24m function returns the size hints for a win-
dow in its zoomed state.  It returns a nonzero status if it
succeeds or zero if the application specified no zoom size
hints for this window.

4mXGetZoomHints24m can generate a 4mBadWindow24m error.


To set the value of any property of type WM_SIZE_HINTS, use
4mXSetSizeHints24m.  This function has been superseded by 4mXSetWM-0m
4mSizeHints24m.
__
|
XSetSizeHints(4mdisplay24m, 4mw24m, 4mhints24m, 4mproperty24m)
      Display *4mdisplay24m;
      Window 4mw24m;
      XSizeHints *4mhints24m;
      Atom 4mproperty24m;


4mdisplay24m   Specifies the connection to the X server.

4mw24m	       Specifies the window.

4mhints24m     Specifies a pointer to the size hints.

4mproperty24m  Specifies the property name.
|__

The 4mXSetSizeHints24m function sets the 4mXSizeHints24m structure for
the named property and the specified window.  This is used
by 4mXSetNormalHints24m and 4mXSetZoomHints24m and can be used to set
the value of any property of type WM_SIZE_HINTS.  Thus, it
may be useful if other properties of that type get defined.





			     1m6570m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


4mXSetSizeHints24m can generate 4mBadAlloc24m, 4mBadAtom24m, and 4mBadWindow0m
errors.


To read the value of any property of type WM_SIZE_HINTS, use
4mXGetSizeHints24m.  This function has been superseded by 4mXGetWM-0m
4mSizeHints24m.
__
|
Status XGetSizeHints(4mdisplay24m, 4mw24m, 4mhints_return24m, 4mproperty24m)
      Display *4mdisplay24m;
      Window 4mw24m;
      XSizeHints *4mhints_return24m;
      Atom 4mproperty24m;


4mdisplay24m   Specifies the connection to the X server.

4mw24m	       Specifies the window.

4mhints_return0m
	  Returns the size hints.

4mproperty24m  Specifies the property name.
|__

The 4mXGetSizeHints24m function returns the 4mXSizeHints24m structure
for the named property and the specified window.  This is
used by 4mXGetNormalHints24m and 4mXGetZoomHints24m.  It also can be
used to retrieve the value of any property of type
WM_SIZE_HINTS.	Thus, it may be useful if other properties
of that type get defined.  4mXGetSizeHints24m returns a nonzero
status if a size hint was defined or zero otherwise.

4mXGetSizeHints24m can generate 4mBadAtom24m and 4mBadWindow24m errors.

1mGetting and Setting an XStandardColormap Structure0m

To get the 4mXStandardColormap24m structure associated with one
of the described atoms, use 4mXGetStandardColormap24m.	This
function has been superseded by 4mXGetRGBColormap24m.
















			     1m6580m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
Status XGetStandardColormap(4mdisplay24m, 4mw24m, 4mcolormap_return24m, 4mproperty24m)
      Display *4mdisplay24m;
      Window 4mw24m;
      XStandardColormap *4mcolormap_return24m;
      Atom 4mproperty24m;	   /* RGB_BEST_MAP, etc. */


4mdisplay24m   Specifies the connection to the X server.

4mw24m	       Specifies the window.

4mcolormap_return0m
	  Returns the colormap associated with the specified
	  atom.

4mproperty24m  Specifies the property name.
|__

The 4mXGetStandardColormap24m function returns the colormap defi-
nition associated with the atom supplied as the property
argument.  4mXGetStandardColormap24m returns a nonzero status if
successful and zero otherwise.	For example, to fetch the
standard 4mGrayScale24m colormap for a display, you use 4mXGetStan-0m
4mdardColormap24m with the following syntax:

__
|
XGetStandardColormap(dpy, DefaultRootWindow(dpy), &cmap, XA_RGB_GRAY_MAP);

|__

See section 14.3 for the semantics of standard colormaps.

4mXGetStandardColormap24m can generate 4mBadAtom24m and 4mBadWindow0m
errors.


To set a standard colormap, use 4mXSetStandardColormap24m.  This
function has been superseded by 4mXSetRGBColormap24m.

















			     1m6590m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
XSetStandardColormap(4mdisplay24m, 4mw24m, 4mcolormap24m, 4mproperty24m)
      Display *4mdisplay24m;
      Window 4mw24m;
      XStandardColormap *4mcolormap24m;
      Atom 4mproperty24m;	   /* RGB_BEST_MAP, etc. */


4mdisplay24m   Specifies the connection to the X server.

4mw24m	       Specifies the window.

4mcolormap24m  Specifies the colormap.

4mproperty24m  Specifies the property name.
|__

The 4mXSetStandardColormap24m function usually is only used by
window or session managers.

4mXSetStandardColormap24m can generate 4mBadAlloc24m, 4mBadAtom24m, 4mBad-0m
4mDrawable24m, and 4mBadWindow24m errors.

1mParsing Window Geometry0m

To parse window geometry given a user-specified position and
a default position, use 4mXGeometry24m.	 This function has been
superseded by 4mXWMGeometry24m.





























			     1m6600m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
int XGeometry(4mdisplay24m, 4mscreen24m, 4mposition24m, 4mdefault_position24m, 4mbwidth24m, 4mfwidth24m, 4mfheight24m, 4mxadder24m,
		  4myadder24m, 4mx_return24m, 4my_return24m, 4mwidth_return24m, 4mheight_return24m)
      Display *4mdisplay24m;
      int 4mscreen24m;
      char *4mposition24m, *4mdefault_position24m;
      unsigned int 4mbwidth24m;
      unsigned int 4mfwidth24m, 4mfheight24m;
      int 4mxadder24m, 4myadder24m;
      int *4mx_return24m, *4my_return24m;
      int *4mwidth_return24m, *4mheight_return24m;


4mdisplay24m   Specifies the connection to the X server.

4mscreen24m    Specifies the screen.

4mposition0m
4mdefault_position0m
	  Specify the geometry specifications.

4mbwidth24m    Specifies the border width.

4mfheight0m
4mfwidth24m    Specify the font height and width in pixels
	  (increment size).

4mxadder0m
4myadder24m    Specify additional interior padding needed in the
	  window.

4mx_return0m
4my_return24m  Return the x and y offsets.

4mwidth_return0m
4mheight_return0m
	  Return the width and height determined.
|__

You pass in the border width (bwidth), size of the incre-
ments fwidth and fheight (typically font width and height),
and any additional interior space (xadder and yadder) to
make it easy to compute the resulting size.  The 4mXGeometry0m
function returns the position the window should be placed
given a position and a default position.  4mXGeometry24m deter-
mines the placement of a window using a geometry specifica-
tion as specified by 4mXParseGeometry24m and the additional
information about the window.  Given a fully qualified
default geometry specification and an incomplete geometry
specification, 4mXParseGeometry24m returns a bitmask value as
defined above in the 4mXParseGeometry24m call, by using the posi-
tion argument.





			     1m6610m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


The returned width and height will be the width and height
specified by default_position as overridden by any user-
specified position.  They are not affected by fwidth,
fheight, xadder, or yadder.  The x and y coordinates are
computed by using the border width, the screen width and
height, padding as specified by xadder and yadder, and the
fheight and fwidth times the width and height from the geom-
etry specifications.

1mGetting the X Environment Defaults0m

The 4mXGetDefault24m function provides a primitive interface to
the resource manager facilities discussed in chapter 15.  It
is only useful in very simple applications.


__
|
char *XGetDefault(4mdisplay24m, 4mprogram24m, 4moption24m)
      Display *4mdisplay24m;
      char *4mprogram24m;
      char *4moption24m;


4mdisplay24m   Specifies the connection to the X server.

4mprogram24m   Specifies the program name for the Xlib defaults
	  (usually argv[0] of the main program).

4moption24m    Specifies the option name.
|__

The 4mXGetDefault24m function returns the value of the resource
4mprog24m.4moption24m, where 4mprog24m is the program argument with the
directory prefix removed and 4moption24m must be a single compo-
nent.  Note that multilevel resources cannot be used with
4mXGetDefault24m.  The class "Program.Name" is always used for
the resource lookup.  If the specified option name does not
exist for this program, 4mXGetDefault24m returns NULL.	The
strings returned by 4mXGetDefault24m are owned by Xlib and should
not be modified or freed by the client.

If a database has been set with 4mXrmSetDatabase24m, that data-
base is used for the lookup.  Otherwise, a database is cre-
ated and is set in the display (as if by calling 4mXrmSet-0m
4mDatabase24m).	 The database is created in the current locale.
To create a database, 4mXGetDefault24m uses resources from the
RESOURCE_MANAGER property on the root window of screen zero.
If no such property exists, a resource file in the user's
home directory is used.	 On a POSIX-conformant system, this
file is 4m$HOME/.Xdefaults24m.	After loading these defaults,
4mXGetDefault24m merges additional defaults specified by the XEN-
VIRONMENT environment variable.	 If XENVIRONMENT is defined,
it contains a full path name for the additional resource



			     1m6620m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


file.  If XENVIRONMENT is not defined, 4mXGetDefault24m looks for
4m$HOME/.Xdefaults-name,24m 4mwhere24m 4mname24m 4mspecifies24m 4mthe24m 4mname24m 4mof24m 4mthe0m
4mmachine24m 4mon24m 4mwhich24m 4mthe24m 4mapplication24m 4mis24m 4mrunning.0m

1mX Version 10 Compatibility Functions0m

You can use the X Version 10 compatibility functions to:

·    Draw and fill polygons and curves

·    Associate user data with a value

1mDrawing and Filling Polygons and Curves0m

Xlib provides functions that you can use to draw or fill
arbitrary polygons or curves.  These functions are provided
mainly for compatibility with X Version 10 and have no
server support.	 That is, they call other Xlib functions,
not the server directly.  Thus, if you just have straight
lines to draw, using 4mXDrawLines24m or 4mXDrawSegments24m is much
faster.

The functions discussed here provide all the functionality
of the X Version 10 functions 4mXDraw24m, 4mXDrawFilled24m, 4mXDrawPat-0m
4mterned24m, 4mXDrawDashed24m, and 4mXDrawTiled24m.  They are as compatible
as possible given X Version 11's new line-drawing functions.
One thing to note, however, is that 4mVertexDrawLastPoint24m is
no longer supported.  Also, the error status returned is the
opposite of what it was under X Version 10 (this is the X
Version 11 standard error status).  4mXAppendVertex24m and
4mXClearVertexFlag24m from X Version 10 also are not supported.

Just how the graphics context you use is set up actually
determines whether you get dashes or not, and so on.  Lines
are properly joined if they connect and include the closing
of a closed figure  (see 4mXDrawLines24m).  The functions dis-
cussed here fail (return zero) only if they run out of mem-
ory or are passed a 4mVertex24m list that has a 4mVertex24m with 4mVer-0m
4mtexStartClosed24m set that is not followed by a 4mVertex24m with
4mVertexEndClosed24m set.


To achieve the effects of the X Version 10 4mXDraw24m, 4mXDraw-0m
4mDashed24m, and 4mXDrawPatterned24m, use 4mXDraw24m.













			     1m6630m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
#include <X11/X10.h>

Status XDraw(4mdisplay24m, 4md24m, 4mgc24m, 4mvlist24m, 4mvcount24m)
     Display *4mdisplay24m;
     Drawable 4md24m;
     GC 4mgc24m;
     Vertex *4mvlist24m;
     int 4mvcount24m;


4mdisplay24m   Specifies the connection to the X server.

4md24m	       Specifies the drawable.

4mgc24m	       Specifies the GC.

4mvlist24m     Specifies a pointer to the list of vertices that
	  indicate what to draw.

4mvcount24m    Specifies how many vertices are in vlist.
|__

The 4mXDraw24m function draws an arbitrary polygon or curve.  The
figure drawn is defined by the specified list of vertices
(vlist).  The points are connected by lines as specified in
the flags in the vertex structure.

Each Vertex, as defined in <4mX11/X10.h24m>, is a structure with
the following members:

__
|
typedef struct _Vertex {
     short x,y;
     unsigned short flags;
} Vertex;

|__

The x and y members are the coordinates of the vertex that
are relative to either the upper left inside corner of the
drawable (if 4mVertexRelative24m is zero) or the previous vertex
(if 4mVertexRelative24m is one).

The flags, as defined in <4mX11/X10.h24m>, are as follows:











			     1m6640m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
4mVertexRelative24m    0x0001	/* else abso-
			   lute */
4mVertexDontDraw24m    0x0002	/* else draw */
4mVertexCurved24m      0x0004	/* else
			   straight */
4mVertexStart-24m      0x0008	/* else not */
4mClosed0m
4mVertexEndClosed24m   0x0010	/* else not */

|__


·    If 4mVertexRelative24m is not set, the coordinates are abso-
     lute (that is, relative to the drawable's origin).	 The
     first vertex must be an absolute vertex.

·    If 4mVertexDontDraw24m is one, no line or curve is drawn
     from the previous vertex to this one.  This is analo-
     gous to picking up the pen and moving to another place
     before drawing another line.

·    If 4mVertexCurved24m is one, a spline algorithm is used to
     draw a smooth curve from the previous vertex through
     this one to the next vertex.  Otherwise, a straight
     line is drawn from the previous vertex to this one.  It
     makes sense to set 4mVertexCurved24m to one only if a previ-
     ous and next vertex are both defined (either explicitly
     in the array or through the definition of a closed
     curve).

·    It is permissible for 4mVertexDontDraw24m bits and 4mVertex-0m
     4mCurved24m bits both to be one.  This is useful if you want
     to define the previous point for the smooth curve but
     do not want an actual curve drawing to start until this
     point.

·    If 4mVertexStartClosed24m is one, then this point marks the
     beginning of a closed curve.  This vertex must be fol-
     lowed later in the array by another vertex whose effec-
     tive coordinates are identical and that has a 4mVertex-0m
     4mEndClosed24m bit of one.	 The points in between form a
     cycle to determine predecessor and successor vertices
     for the spline algorithm.

This function uses these GC components: function, plane-
mask, line-width, line-style, cap-style, join-style, fill-
style, subwindow-mode, clip-x-origin, clip-y-origin, and
clip-mask.  It also uses these GC mode-dependent components:
foreground, background, tile, stipple, tile-stipple-x-ori-
gin, tile-stipple-y-origin, dash-offset, and dash-list.


To achieve the effects of the X Version 10 4mXDrawTiled24m and



			     1m6650m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


4mXDrawFilled24m, use 4mXDrawFilled24m.
__
|
#include <X11/X10.h>

Status XDrawFilled(4mdisplay24m, 4md24m, 4mgc24m, 4mvlist24m, 4mvcount24m)
     Display *4mdisplay24m;
     Drawable 4md24m;
     GC 4mgc24m;
     Vertex *4mvlist24m;
     int 4mvcount24m;


4mdisplay24m   Specifies the connection to the X server.

4md24m	       Specifies the drawable.

4mgc24m	       Specifies the GC.

4mvlist24m     Specifies a pointer to the list of vertices that
	  indicate what to draw.

4mvcount24m    Specifies how many vertices are in vlist.
|__

The 4mXDrawFilled24m function draws arbitrary polygons or curves
and then fills them.

This function uses these GC components: function, plane-
mask, line-width, line-style, cap-style, join-style, fill-
style, subwindow-mode, clip-x-origin, clip-y-origin, and
clip-mask.  It also uses these GC mode-dependent components:
foreground, background, tile, stipple, tile-stipple-x-ori-
gin, tile-stipple-y-origin, dash-offset, dash-list, fill-
style, and fill-rule.

1mAssociating User Data with a Value0m

These functions have been superseded by the context manage-
ment functions (see section 16.10).  It is often necessary
to associate arbitrary information with resource IDs.  Xlib
provides the 4mXAssocTable24m functions that you can use to make
such an association.  Application programs often need to be
able to easily refer to their own data structures when an
event arrives.	The 4mXAssocTable24m system provides users of the
X library with a method for associating their own data
structures with X resources (4mPixmaps24m, 4mFonts24m, 4mWindows24m, and so
on).

An 4mXAssocTable24m can be used to type X resources.  For exam-
ple, the user may want to have three or four types of win-
dows, each with different properties.  This can be accom-
plished by associating each X window ID with a pointer to a
window property data structure	defined	 by  the user.	A



			     1m6660m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


generic type has been defined in the X library for resource
IDs.  It is called an XID.

There are a few	 guidelines  that  should be observed when
using an 4mXAssocTable24m:

·    All  XIDs	are  relative  to  the	specified display.

·    Because  of  the  hashing	scheme	used  by  the  asso-
     ciation mechanism, the following rules for determining
     the size of a 4mXAssocTable24m should be followed.	 Associa-
     tions will be  made  and  looked  up  more efficiently
     if	 the  table  size  (number  of	buckets in the hash-
     ing system) is a power of two and if there are not more
     than 8 XIDs  per bucket.


To return a pointer to a new 4mXAssocTable24m, use 4mXCreateAs-0m
4msocTable24m.
__
|
XAssocTable *XCreateAssocTable(4msize24m)
      int 4msize24m;


4msize24m      Specifies the number of buckets in the hash system
	  of 4mXAssocTable24m.
|__

The size argument specifies the number of buckets in the
hash system of 4mXAssocTable24m.  For  reasons	of  efficiency
the number of buckets should be a power of two.	 Some size
suggestions  might  be:	 use  32 buckets  per  100  objects,
and a reasonable maximum number of objects per buckets is 8.
If  an	error  allocating  memory  for	the 4mXAssocTable0m
occurs, a NULL pointer is returned.


To create an entry in a given 4mXAssocTable24m, use 4mXMakeAssoc24m.


















			     1m6670m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
XMakeAssoc(4mdisplay24m, 4mtable24m, 4mx_id24m, 4mdata24m)
      Display *4mdisplay24m;
      XAssocTable *4mtable24m;
      XID 4mx_id24m;
      char *4mdata24m;


4mdisplay24m   Specifies the connection to the X server.

4mtable24m     Specifies the assoc table.

4mx_id24m      Specifies the X resource ID.

4mdata24m      Specifies the data to be associated with the X
	  resource ID.
|__

The 4mXMakeAssoc24m function inserts data into an 4mXAssocTable0m
keyed on an XID.  Data is inserted into the table only once.
Redundant inserts are ignored.	The queue in each associa-
tion bucket is sorted from the lowest XID to the highest
XID.


To obtain data from a given 4mXAssocTable24m, use 4mXLookUpAssoc24m.
__
|
char *XLookUpAssoc(4mdisplay24m, 4mtable24m, 4mx_id24m)
      Display *4mdisplay24m;
      XAssocTable *4mtable24m;
      XID 4mx_id24m;


4mdisplay24m   Specifies the connection to the X server.

4mtable24m     Specifies the assoc table.

4mx_id24m      Specifies the X resource ID.
|__

The 4mXLookUpAssoc24m function retrieves the data stored in an
4mXAssocTable24m by its XID.  If  an appropriately  matching XID
can be found in the table, 4mXLookUpAssoc24m returns the data
associated with it.  If the x_id cannot be found in the ta-
ble, it returns NULL.


To delete an entry from a given 4mXAssocTable24m, use 4mXDeleteAs-0m
4msoc24m.







			     1m6680m





1mXlib - C Library			X11, Release 6.7 DRAFT0m

__
|
XDeleteAssoc(4mdisplay24m, 4mtable24m, 4mx_id24m)
      Display *4mdisplay24m;
      XAssocTable *4mtable24m;
      XID 4mx_id24m;


4mdisplay24m   Specifies the connection to the X server.

4mtable24m     Specifies the assoc table.

4mx_id24m      Specifies the X resource ID.
|__

The 4mXDeleteAssoc24m function deletes an association in an 4mXAs-0m
4msocTable24m keyed on its XID.	 Redundant deletes (and deletes
of nonexistent XIDs) are ignored.  Deleting associations in
no way impairs the performance of an 4mXAssocTable24m.


To free the memory associated with a given 4mXAssocTable24m, use
4mXDestroyAssocTable24m.
__
|
XDestroyAssocTable(4mtable24m)
      XAssocTable *4mtable24m;


4mtable24m     Specifies the assoc table.
|__



























			     1m6690m





1mXlib - C Library			X11, Release 6.7 DRAFT0m




			  1mGlossary0m



1mAccess control list0m

     X maintains a list of hosts from which client programs
     can be run.  By default, only programs on the local
     host and hosts specified in an initial list read by the
     server can use the display.  This access control list
     can be changed by clients on the local host.  Some
     server implementations can also implement other autho-
     rization mechanisms in addition to or in place of this
     mechanism.	 The action of this mechanism can be condi-
     tional based on the authorization protocol name and
     data received by the server at connection setup.

1mActive grab0m

     A grab is active when the pointer or keyboard is actu-
     ally owned by the single grabbing client.

1mAncestors0m

     If W is an inferior of A, then A is an ancestor of W.

1mAtom0m

     An atom is a unique ID corresponding to a string name.
     Atoms are used to identify properties, types, and
     selections.

1mBackground0m

     An 4mInputOutput24m window can have a background, which is
     defined as a pixmap.  When regions of the window have
     their contents lost or invalidated, the server automat-
     ically tiles those regions with the background.

1mBacking store0m

     When a server maintains the contents of a window, the
     pixels saved off-screen are known as a backing store.












			     1m6700m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


1mBase font name0m

     A font name used to select a family of fonts whose mem-
     bers may be encoded in various charsets.  The 4mCharSe-0m
     4mtRegistry24m and 4mCharSetEncoding24m fields of an XLFD name
     identify the charset of the font.	A base font name may
     be a full XLFD name, with all fourteen '-' delimiters,
     or an abbreviated XLFD name containing only the first
     12 fields of an XLFD name, up to but not including
     4mCharSetRegistry24m, with or without the thirteenth '-', or
     a non-XLFD name.  Any XLFD fields may contain wild
     cards.

     When creating an 4mXFontSet24m, Xlib accepts from the client
     a list of one or more base font names which select one
     or more font families.  They are combined with charset
     names obtained from the encoding of the locale to load
     the fonts required to render text.

1mBit gravity0m

     When a window is resized, the contents of the window
     are not necessarily discarded.  It is possible to
     request that the server relocate the previous contents
     to some region of the window (though no guarantees are
     made).  This attraction of window contents for some
     location of a window is known as bit gravity.

1mBit plane0m

     When a pixmap or window is thought of as a stack of
     bitmaps, each bitmap is called a bit plane or plane.

1mBitmap0m

     A bitmap is a pixmap of depth one.

1mBorder0m

     An 4mInputOutput24m window can have a border of equal thick-
     ness on all four sides of the window.  The contents of
     the border are defined by a pixmap, and the server
     automatically maintains the contents of the border.
     Exposure events are never generated for border regions.

1mButton grabbing0m

     Buttons on the pointer can be passively grabbed by a
     client.  When the button is pressed, the pointer is
     then actively grabbed by the client.







			     1m6710m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


1mByte order0m

     For image (pixmap/bitmap) data, the server defines the
     byte order, and clients with different native byte
     ordering must swap bytes as necessary.  For all other
     parts of the protocol, the client defines the byte
     order, and the server swaps bytes as necessary.

1mCharacter0m

     A member of a set of elements used for the organiza-
     tion, control, or representation of text (ISO2022, as
     adapted by XPG3).	Note that in ISO2022 terms, a char-
     acter is not bound to a coded value until it is identi-
     fied as part of a coded character set.

1mCharacter glyph0m

     The abstract graphical symbol for a character.  Charac-
     ter glyphs may or may not map one-to-one to font
     glyphs, and may be context-dependent, varying with the
     adjacent characters.  Multiple characters may map to a
     single character glyph.

1mCharacter set0m

     A collection of characters.

1mCharset0m

     An encoding with a uniform, state-independent mapping
     from characters to codepoints.  A coded character set.

     For display in X, there can be a direct mapping from a
     charset to one font, if the width of all characters in
     the charset is either one or two bytes.  A text string
     encoded in an encoding such as Shift-JIS cannot be
     passed directly to the X server, because the text imag-
     ing requests accept only single-width charsets (either
     8 or 16 bits).  Charsets which meet these restrictions
     can serve as ``font charsets''.  Font charsets strictly
     speaking map font indices to font glyphs, not charac-
     ters to character glyphs.

     Note that a single font charset is sometimes used as
     the encoding of a locale, for example, ISO8859-1.

1mChildren0m

     The children of a window are its first-level subwin-
     dows.






			     1m6720m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


1mClass0m

     Windows can be of different classes or types.  See the
     entries for 4mInputOnly24m and 4mInputOutput24m windows for fur-
     ther information about valid window types.

1mClient0m

     An application program connects to the window system
     server by some interprocess communication (IPC) path,
     such as a TCP connection or a shared memory buffer.
     This program is referred to as a client of the window
     system server.  More precisely, the client is the IPC
     path itself.  A program with multiple paths open to the
     server is viewed as multiple clients by the protocol.
     Resource lifetimes are controlled by connection life-
     times, not by program lifetimes.

1mClipping region0m

     In a graphics context, a bitmap or list of rectangles
     can be specified to restrict output to a particular
     region of the window.  The image defined by the bitmap
     or rectangles is called a clipping region.

1mCoded character0m

     A character bound to a codepoint.

1mCoded character set0m

     A set of unambiguous rules that establishes a character
     set and the one-to-one relationship between each char-
     acter of the set and its bit representation.  (ISO2022,
     as adapted by XPG3) A definition of a one-to-one map-
     ping of a set of characters to a set of codepoints.

1mCodepoint0m

     The coded representation of a single character in a
     coded character set.

1mColormap0m

     A colormap consists of a set of entries defining color
     values.  The colormap associated with a window is used
     to display the contents of the window; each pixel value
     indexes the colormap to produce an RGB value that
     drives the guns of a monitor.  Depending on hardware
     limitations, one or more colormaps can be installed at
     one time so that windows associated with those maps
     display with true colors.





			     1m6730m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


1mConnection0m

     The IPC path between the server and client program is
     known as a connection.  A client program typically (but
     not necessarily) has one connection to the server over
     which requests and events are sent.

1mContainment0m

     A window contains the pointer if the window is viewable
     and the hotspot of the cursor is within a visible
     region of the window or a visible region of one of its
     inferiors.	 The border of the window is included as
     part of the window for containment.  The pointer is in
     a window if the window contains the pointer but no
     inferior contains the pointer.

1mCoordinate system0m

     The coordinate system has X horizontal and Y vertical,
     with the origin [0, 0] at the upper left.	Coordinates
     are integral and coincide with pixel centers.  Each
     window and pixmap has its own coordinate system.  For a
     window, the origin is inside the border at the inside
     upper-left corner.

1mCursor0m

     A cursor is the visible shape of the pointer on a
     screen.  It consists of a hotspot, a source bitmap, a
     shape bitmap, and a pair of colors.  The cursor defined
     for a window controls the visible appearance when the
     pointer is in that window.

1mDepth0m

     The depth of a window or pixmap is the number of bits
     per pixel it has.	The depth of a graphics context is
     the depth of the drawables it can be used in conjunc-
     tion with graphics output.

1mDevice0m

     Keyboards, mice, tablets, track-balls, button boxes,
     and so on are all collectively known as input devices.
     Pointers can have one or more buttons (the most common
     number is three).	The core protocol only deals with
     two devices: the keyboard and the pointer.









			     1m6740m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


1mDirectColor0m

     4mDirectColor24m is a class of colormap in which a pixel
     value is decomposed into three separate subfields for
     indexing.	The first subfield indexes an array to pro-
     duce red intensity values.	 The second subfield indexes
     a second array to produce blue intensity values.  The
     third subfield indexes a third array to produce green
     intensity values.	The RGB (red, green, and blue) val-
     ues in the colormap entry can be changed dynamically.

1mDisplay0m

     A server, together with its screens and input devices,
     is called a display.  The Xlib 4mDisplay24m structure con-
     tains all information about the particular display and
     its screens as well as the state that Xlib needs to
     communicate with the display over a particular connec-
     tion.

1mDrawable0m

     Both windows and pixmaps can be used as sources and
     destinations in graphics operations.  These windows and
     pixmaps are collectively known as drawables.  However,
     an 4mInputOnly24m window cannot be used as a source or des-
     tination in a graphics operation.

1mEncoding0m

     A set of unambiguous rules that establishes a character
     set and a relationship between the characters and their
     representations.  The character set does not have to be
     fixed to a finite pre-defined set of characters.  The
     representations do not have to be of uniform length.
     Examples are an ISO2022 graphic set, a state-indepen-
     dent or state-dependent combination of graphic sets,
     possibly including control sets, the X Compound Text
     encoding, and the UTF-8 ISO10646/Unicode encoding.

     In X, encodings are identified by a string which
     appears as: the 4mCharSetRegistry24m and 4mCharSetEncoding0m
     components of an XLFD name; the name of a charset of
     the locale for which a font could not be found; or an
     atom which identifies the encoding of a text property
     or which names an encoding for a text selection target
     type.  Encoding names should be composed of characters
     from the X Portable Character Set.









			     1m6750m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


1mEscapement0m

     The escapement of a string is the distance in pixels in
     the primary draw direction from the drawing origin to
     the origin of the next character (that is, the one fol-
     lowing the given string) to be drawn.

1mEvent0m

     Clients are informed of information asynchronously by
     means of events.  These events can be either asyn-
     chronously generated from devices or generated as side
     effects of client requests.  Events are grouped into
     types.  The server never sends an event to a client
     unless the client has specifically asked to be informed
     of that type of event.  However, clients can force
     events to be sent to other clients.  Events are typi-
     cally reported relative to a window.

1mEvent mask0m

     Events are requested relative to a window.	 The set of
     event types a client requests relative to a window is
     described by using an event mask.

1mEvent propagation0m

     Device-related events propagate from the source window
     to ancestor windows until some client has expressed
     interest in handling that type of event or until the
     event is discarded explicitly.

1mEvent source0m

     The deepest viewable window that the pointer is in is
     called the source of a device-related event.

1mEvent synchronization0m

     There are certain race conditions possible when demul-
     tiplexing device events to clients (in particular,
     deciding where pointer and keyboard events should be
     sent when in the middle of window management opera-
     tions).  The event synchronization mechanism allows
     synchronous processing of device events.

1mExposure event0m

     Servers do not guarantee to preserve the contents of
     windows when windows are obscured or reconfigured.
     Exposure events are sent to clients to inform them when
     contents of regions of windows have been lost.





			     1m6760m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


1mExtension0m

     Named extensions to the core protocol can be defined to
     extend the system.	 Extensions to output requests,
     resources, and event types are all possible and
     expected.

1mFont0m

     A font is an array of glyphs (typically characters).
     The protocol does no translation or interpretation of
     character sets.  The client simply indicates values
     used to index the glyph array.  A font contains addi-
     tional metric information to determine interglyph and
     interline spacing.

1mFont glyph0m

     The abstract graphical symbol for an index into a font.

1mFrozen events0m

     Clients can freeze event processing during keyboard and
     pointer grabs.

1mGC0m

     GC is an abbreviation for graphics context.  See 1mGraph-0m
     1mics context22m.

1mGlyph0m

     An identified abstract graphical symbol independent of
     any actual image.	(ISO/IEC/DIS 9541-1) An abstract
     visual representation of a graphic character, not bound
     to a codepoint.

1mGlyph image0m

     An image of a glyph, as obtained from a glyph represen-
     tation displayed on a presentation surface.
     (ISO/IEC/DIS 9541-1)

1mGrab0m

     Keyboard keys, the keyboard, pointer buttons, the
     pointer, and the server can be grabbed for exclusive
     use by a client.  In general, these facilities are not
     intended to be used by normal applications but are
     intended for various input and window managers to
     implement various styles of user interfaces.






			     1m6770m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


1mGraphics context0m

     Various information for graphics output is stored in a
     graphics context (GC), such as foreground pixel, back-
     ground pixel, line width, clipping region, and so on.
     A graphics context can only be used with drawables that
     have the same root and the same depth as the graphics
     context.

1mGravity0m

     The contents of windows and windows themselves have a
     gravity, which determines how the contents move when a
     window is resized.	 See 1mBit gravity 22mand 1mWindow gravity22m.

1mGrayScale0m

     4mGrayScale24m can be viewed as a degenerate case of 4mPseudo-0m
     4mColor24m, in which the red, green, and blue values in any
     given colormap entry are equal and thus, produce shades
     of gray.  The gray values can be changed dynamically.

1mHost Portable Character Encoding0m

     The encoding of the X Portable Character Set on the
     host.  The encoding itself is not defined by this stan-
     dard, but the encoding must be the same in all locales
     supported by Xlib on the host.  If a string is said to
     be in the Host Portable Character Encoding, then it
     only contains characters from the X Portable Character
     Set, in the host encoding.

1mHotspot0m

     A cursor has an associated hotspot, which defines the
     point in the cursor corresponding to the coordinates
     reported for the pointer.

1mIdentifier0m

     An identifier is a unique value associated with a
     resource that clients use to name that resource.  The
     identifier can be used over any connection to name the
     resource.

1mInferiors0m

     The inferiors of a window are all of the subwindows
     nested below it: the children, the children's children,
     and so on.







			     1m6780m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


1mInput focus0m

     The input focus is usually a window defining the scope
     for processing of keyboard input.	If a generated key-
     board event usually would be reported to this window or
     one of its inferiors, the event is reported as usual.
     Otherwise, the event is reported with respect to the
     focus window.  The input focus also can be set such
     that all keyboard events are discarded and such that
     the focus window is dynamically taken to be the root
     window of whatever screen the pointer is on at each
     keyboard event.

1mInput manager0m

     Control over keyboard input is typically provided by an
     input manager client, which usually is part of a window
     manager.

1mInputOnly window0m

     An 4mInputOnly24m window is a window that cannot be used for
     graphics requests.	 4mInputOnly24m windows are invisible and
     are used to control such things as cursors, input event
     generation, and grabbing.	4mInputOnly24m windows cannot
     have 4mInputOutput24m windows as inferiors.

1mInputOutput window0m

     An 4mInputOutput24m window is the normal kind of window that
     is used for both input and output.	 4mInputOutput24m windows
     can have both 4mInputOutput24m and 4mInputOnly24m windows as
     inferiors.

1mInternationalization0m

     The process of making software adaptable to the
     requirements of different native languages, local cus-
     toms, and character string encodings.  Making a com-
     puter program adaptable to different locales without
     program source modifications or recompilation.

1mISO20220m

     ISO standard for code extension techniques for 7-bit
     and 8-bit coded character sets.

1mKey grabbing0m

     Keys on the keyboard can be passively grabbed by a
     client.  When the key is pressed, the keyboard is then
     actively grabbed by the client.





			     1m6790m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


1mKeyboard grabbing0m

     A client can actively grab control of the keyboard, and
     key events will be sent to that client rather than the
     client the events would normally have been sent to.

1mKeysym0m

     An encoding of a symbol on a keycap on a keyboard.

1mLatin-10m

     The coded character set defined by the ISO8859-1 stan-
     dard.

1mLatin Portable Character Encoding0m

     The encoding of the X Portable Character Set using the
     Latin-1 codepoints plus ASCII control characters.	If a
     string is said to be in the Latin Portable Character
     Encoding, then it only contains characters from the X
     Portable Character Set, not all of Latin-1.

1mLocale0m

     The international environment of a computer program
     defining the ``localized'' behavior of that program at
     run-time.	This information can be established from one
     or more sets of localization data.	 ANSI C defines
     locale-specific processing by C system library calls.
     See ANSI C and the X/Open Portability Guide specifica-
     tions for more details.  In this specification, on
     implementations that conform to the ANSI C library, the
     ``current locale'' is the current setting of the
     LC_CTYPE 4msetlocale24m category.	Associated with each
     locale is a text encoding.	 When text is processed in
     the context of a locale, the text must be in the encod-
     ing of the locale.	 The current locale affects Xlib in
     its:

     ·	  Encoding and processing of input method text

     ·	  Encoding of resource files and values

     ·	  Encoding and imaging of text strings

     ·	  Encoding and decoding for inter-client text commu-
	  nication









			     1m6800m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


1mLocale name0m

     The identifier used to select the desired locale for
     the host C library and X library functions.  On ANSI C
     library compliant systems, the locale argument to the
     4msetlocale24m function.

1mLocalization0m

     The process of establishing information within a com-
     puter system specific to the operation of particular
     native languages, local customs and coded character
     sets.  (XPG3)

1mMapped0m

     A window is said to be mapped if a map call has been
     performed on it.  Unmapped windows and their inferiors
     are never viewable or visible.

1mModifier keys0m

     Shift, Control, Meta, Super, Hyper, Alt, Compose,
     Apple, CapsLock, ShiftLock, and similar keys are called
     modifier keys.

1mMonochrome0m

     Monochrome is a special case of 4mStaticGray24m in which
     there are only two colormap entries.

1mMultibyte0m

     A character whose codepoint is stored in more than one
     byte; any encoding which can contain multibyte charac-
     ters; text in a multibyte encoding.  The ``char *''
     null-terminated string datatype in ANSI C.	 Note that
     references in this document to multibyte strings imply
     only that the strings 4mmay24m contain multibyte characters.

1mObscure0m

     A window is obscured if some other window obscures it.
     A window can be partially obscured and so still have
     visible regions.  Window A obscures window B if both
     are viewable 4mInputOutput24m windows, if A is higher in the
     global stacking order, and if the rectangle defined by
     the outside edges of A intersects the rectangle defined
     by the outside edges of B.	 Note the distinction
     between obscures and occludes.  Also note that window
     borders are included in the calculation.






			     1m6810m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


1mOcclude0m

     A window is occluded if some other window occludes it.
     Window A occludes window B if both are mapped, if A is
     higher in the global stacking order, and if the rectan-
     gle defined by the outside edges of A intersects the
     rectangle defined by the outside edges of B.  Note the
     distinction between occludes and obscures.	 Also note
     that window borders are included in the calculation and
     that 4mInputOnly24m windows never obscure other windows but
     can occlude other windows.

1mPadding0m

     Some padding bytes are inserted in the data stream to
     maintain alignment of the protocol requests on natural
     boundaries.  This increases ease of portability to some
     machine architectures.

1mParent window0m

     If C is a child of P, then P is the parent of C.

1mPassive grab0m

     Grabbing a key or button is a passive grab.  The grab
     activates when the key or button is actually pressed.

1mPixel value0m

     A pixel is an N-bit value, where N is the number of bit
     planes used in a particular window or pixmap (that is,
     is the depth of the window or pixmap).  A pixel in a
     window indexes a colormap to derive an actual color to
     be displayed.

1mPixmap0m


     A pixmap is a three-dimensional array of bits.  A
     pixmap is normally thought of as a two-dimensional
     array of pixels, where each pixel can be a value from 0
     to 24mN24m-1, and where N is the depth (z axis) of the
     pixmap.  A pixmap can also be thought of as a stack of
     N bitmaps.	 A pixmap can only be used on the screen
     that it was created in.

1mPlane0m

     When a pixmap or window is thought of as a stack of
     bitmaps, each bitmap is called a plane or bit plane.






			     1m6820m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


1mPlane mask0m

     Graphics operations can be restricted to only affect a
     subset of bit planes of a destination.  A plane mask is
     a bit mask describing which planes are to be modified.
     The plane mask is stored in a graphics context.

1mPointer0m

     The pointer is the pointing device currently attached
     to the cursor and tracked on the screens.

1mPointer grabbing0m

     A client can actively grab control of the pointer.
     Then button and motion events will be sent to that
     client rather than the client the events would normally
     have been sent to.

1mPointing device0m

     A pointing device is typically a mouse, tablet, or some
     other device with effective dimensional motion.  The
     core protocol defines only one visible cursor, which
     tracks whatever pointing device is attached as the
     pointer.

1mPOSIX0m

     Portable Operating System Interface, ISO/IEC 9945-1
     (IEEE Std 1003.1).

1mPOSIX Portable Filename Character Set0m

     The set of 65 characters which can be used in naming
     files on a POSIX-compliant host that are correctly pro-
     cessed in all locales.  The set is:


     a..z A..Z 0..9 ._-


1mProperty0m

     Windows can have associated properties that consist of
     a name, a type, a data format, and some data.  The pro-
     tocol places no interpretation on properties.  They are
     intended as a general-purpose naming mechanism for
     clients.  For example, clients might use properties to
     share information such as resize hints, program names,
     and icon formats with a window manager.






			     1m6830m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


1mProperty list0m

     The property list of a window is the list of properties
     that have been defined for the window.

1mPseudoColor0m

     4mPseudoColor24m is a class of colormap in which a pixel
     value indexes the colormap entry to produce an indepen-
     dent RGB value; that is, the colormap is viewed as an
     array of triples (RGB values).  The RGB values can be
     changed dynamically.

1mRectangle0m

     A rectangle specified by [x,y,w,h] has an infinitely
     thin outline path with corners at [x,y], [x+w,y],
     [x+w,y+h], and [x, y+h].  When a rectangle is filled,
     the lower-right edges are not drawn.  For example, if
     w=h=0, nothing would be drawn.  For w=h=1, a single
     pixel would be drawn.

1mRedirecting control0m

     Window managers (or client programs) may enforce window
     layout policy in various ways.  When a client attempts
     to change the size or position of a window, the opera-
     tion may be redirected to a specified client rather
     than the operation actually being performed.

1mReply0m

     Information requested by a client program using the X
     protocol is sent back to the client with a reply.	Both
     events and replies are multiplexed on the same connec-
     tion.  Most requests do not generate replies, but some
     requests generate multiple replies.

1mRequest0m

     A command to the server is called a request.  It is a
     single block of data sent over a connection.

1mResource0m

     Windows, pixmaps, cursors, fonts, graphics contexts,
     and colormaps are known as resources.  They all have
     unique identifiers associated with them for naming pur-
     poses.  The lifetime of a resource usually is bounded
     by the lifetime of the connection over which the
     resource was created.






			     1m6840m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


1mRGB values0m

     RGB values are the red, green, and blue intensity val-
     ues that are used to define a color.  These values are
     always represented as 16-bit, unsigned numbers, with 0
     the minimum intensity and 65535 the maximum intensity.
     The X server scales these values to match the display
     hardware.

1mRoot0m

     The root of a pixmap or graphics context is the same as
     the root of whatever drawable was used when the pixmap
     or GC was created.	 The root of a window is the root
     window under which the window was created.

1mRoot window0m

     Each screen has a root window covering it.	 The root
     window cannot be reconfigured or unmapped, but other-
     wise it acts as a full-fledged window.  A root window
     has no parent.

1mSave set0m

     The save set of a client is a list of other clients'
     windows that, if they are inferiors of one of the
     client's windows at connection close, should not be
     destroyed and that should be remapped if currently
     unmapped.	Save sets are typically used by window man-
     agers to avoid lost windows if the manager should ter-
     minate abnormally.

1mScanline0m

     A scanline is a list of pixel or bit values viewed as a
     horizontal row (all values having the same y coordi-
     nate) of an image, with the values ordered by increas-
     ing the x coordinate.

1mScanline order0m

     An image represented in scanline order contains scan-
     lines ordered by increasing the y coordinate.

1mScreen0m

     A server can provide several independent screens, which
     typically have physically independent monitors.  This
     would be the expected configuration when there is only
     a single keyboard and pointer shared among the screens.
     A 4mScreen24m structure contains the information about that
     screen and is linked to the 4mDisplay24m structure.




			     1m6850m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


1mSelection0m

     A selection can be thought of as an indirect property
     with dynamic type.	 That is, rather than having the
     property stored in the X server, it is maintained by
     some client (the owner).  A selection is global and is
     thought of as belonging to the user and being main-
     tained by clients, rather than being private to a par-
     ticular window subhierarchy or a particular set of
     clients.  When a client asks for the contents of a
     selection, it specifies a selection target type, which
     can be used to control the transmitted representation
     of the contents.  For example, if the selection is
     ``the last thing the user clicked on,'' and that is
     currently an image, then the target type might specify
     whether the contents of the image should be sent in XY
     format or Z format.

     The target type can also be used to control the class
     of contents transmitted; for example, asking for the
     ``looks'' (fonts, line spacing, indentation, and so
     forth) of a paragraph selection, rather than the text
     of the paragraph.	The target type can also be used for
     other purposes.  The protocol does not constrain the
     semantics.

1mServer0m

     The server, which is also referred to as the X server,
     provides the basic windowing mechanism.  It handles IPC
     connections from clients, multiplexes graphics requests
     onto the screens, and demultiplexes input back to the
     appropriate clients.

1mServer grabbing0m

     The server can be grabbed by a single client for exclu-
     sive use.	This prevents processing of any requests
     from other client connections until the grab is com-
     pleted.  This is typically only a transient state for
     such things as rubber-banding, pop-up menus, or execut-
     ing requests indivisibly.

1mShift sequence0m

     ISO2022 defines control characters and escape sequences
     which temporarily (single shift) or permanently (lock-
     ing shift) cause a different character set to be in
     effect (``invoking'' a character set).








			     1m6860m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


1mSibling0m

     Children of the same parent window are known as sibling
     windows.

1mStacking order0m

     Sibling windows, similar to sheets of paper on a desk,
     can stack on top of each other.  Windows above both
     obscure and occlude lower windows.	 The relationship
     between sibling windows is known as the stacking order.

1mState-dependent encoding0m

     An encoding in which an invocation of a charset can
     apply to multiple characters in sequence.	A state-
     dependent encoding begins in an ``initial state'' and
     enters other ``shift states'' when specific ``shift
     sequences'' are encountered in the byte sequence.	In
     ISO2022 terms, this means use of locking shifts, not
     single shifts.

1mState-independent encoding0m

     Any encoding in which the invocations of the charsets
     are fixed, or span only a single character.  In ISO2022
     terms, this means use of at most single shifts, not
     locking shifts.

1mStaticColor0m

     4mStaticColor24m can be viewed as a degenerate case of 4mPseu-0m
     4mdoColor24m in which the RGB values are predefined and
     read-only.

1mStaticGray0m

     4mStaticGray24m can be viewed as a degenerate case of
     4mGrayScale24m in which the gray values are predefined and
     read-only.	 The values are typically linear or near-
     linear increasing ramps.

1mStatus0m

     Many Xlib functions return a success status.  If the
     function does not succeed, however, its arguments are
     not disturbed.

1mStipple0m

     A stipple pattern is a bitmap that is used to tile a
     region to serve as an additional clip mask for a fill
     operation with the foreground color.




			     1m6870m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


1mSTRING encoding0m

     Latin-1, plus tab and newline.

1mString Equivalence0m

     Two ISO Latin-1 STRING8 values are considered equal if
     they are the same length and if corresponding bytes are
     either equal or are equivalent as follows:	 decimal
     values 65 to 90 inclusive (characters ``A'' to ``Z'')
     are pairwise equivalent to decimal values 97 to 122
     inclusive (characters ``a'' to ``z''), decimal values
     192 to 214 inclusive (characters ``A grave'' to ``O
     diaeresis'') are pairwise equivalent to decimal values
     224 to 246 inclusive (characters ``a grave'' to ``o
     diaeresis''), and decimal values 216 to 222 inclusive
     (characters ``O oblique'' to ``THORN'') are pairwise
     equivalent to decimal values 246 to 254 inclusive
     (characters ``o oblique'' to ``thorn'').

1mTile0m

     A pixmap can be replicated in two dimensions to tile a
     region.  The pixmap itself is also known as a tile.

1mTimestamp0m

     A timestamp is a time value expressed in milliseconds.
     It is typically the time since the last server reset.
     Timestamp values wrap around (after about 49.7 days).
     The server, given its current time is represented by
     timestamp T, always interprets timestamps from clients
     by treating half of the timestamp space as being ear-
     lier in time than T and half of the timestamp space as
     being later in time than T.  One timestamp value, rep-
     resented by the constant 4mCurrentTime24m, is never gener-
     ated by the server.  This value is reserved for use in
     requests to represent the current server time.

1mTrueColor0m

     4mTrueColor24m can be viewed as a degenerate case of 4mDirect-0m
     4mColor24m in which the subfields in the pixel value
     directly encode the corresponding RGB values.  That is,
     the colormap has predefined read-only RGB values.	The
     values are typically linear or near-linear increasing
     ramps.










			     1m6880m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


1mType0m

     A type is an arbitrary atom used to identify the inter-
     pretation of property data.  Types are completely unin-
     terpreted by the server.  They are solely for the bene-
     fit of clients.  X predefines type atoms for many fre-
     quently used types, and clients also can define new
     types.

1mViewable0m

     A window is viewable if it and all of its ancestors are
     mapped.  This does not imply that any portion of the
     window is actually visible.  Graphics requests can be
     performed on a window when it is not viewable, but out-
     put will not be retained unless the server is maintain-
     ing backing store.

1mVisible0m

     A region of a window is visible if someone looking at
     the screen can actually see it; that is, the window is
     viewable and the region is not occluded by any other
     window.

1mWhitespace0m

     Any spacing character.  On implementations that conform
     to the ANSI C library, whitespace is any character for
     which 4misspace24m returns true.

1mWindow gravity0m

     When windows are resized, subwindows may be reposi-
     tioned automatically relative to some position in the
     window.  This attraction of a subwindow to some part of
     its parent is known as window gravity.

1mWindow manager0m

     Manipulation of windows on the screen and much of the
     user interface (policy) is typically provided by a win-
     dow manager client.














			     1m6890m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


1mX Portable Character Set0m

     A basic set of 97 characters which are assumed to exist
     in all locales supported by Xlib.	This set contains
     the following characters:



a..z A..Z 0..9 !"#$%&'()*+,-./:;<=>?@[\]^_`{|}~ <space>,
<tab>, and <newline>



     This is the left/lower half (also called the G0 set) of
     the graphic character set of ISO8859-1 plus <space>,
     <tab>, and <newline>.  It is also the set of graphic
     characters in 7-bit ASCII plus the same three control
     characters.  The actual encoding of these characters on
     the host is system dependent; see the Host Portable
     Character Encoding.

1mXLFD0m

     The X Logical Font Description Conventions that define
     a standard syntax for structured font names.

1mXY format0m

     The data for a pixmap is said to be in XY format if it
     is organized as a set of bitmaps representing individ-
     ual bit planes with the planes appearing from most-sig-
     nificant to least-significant bit order.

1mZ format0m

     The data for a pixmap is said to be in Z format if it
     is organized as a set of pixel values in scanline
     order.

1mReferences0m

ANSI Programming Language - C: ANSI X3.159-1989, December
14, 1989.

Draft Proposed Multibyte Extension of ANSI C, Draft 1.1,
November 30, 1989, SC22/C WG/SWG IPSJ/ITSCJ Japan.

ISO2022: Information processing - ISO 7-bit and 8-bit coded
character sets - Code extension techniques.

ISO8859-1: Information processing - 8-bit single-byte coded
graphic character sets - Part 1: Latin alphabet No. 1.





			     1m6900m





1mXlib - C Library			X11, Release 6.7 DRAFT0m


POSIX: Information Technology - Portable Operating System
Interface (POSIX) - Part 1: System Application Program
Interface (API) [C Language], ISO/IEC 9945-1.

Text of ISO/IEC/DIS 9541-1, Information Processing - Font
Information Interchange - Part 1:  Architecture.

X/Open Portability Guide, Issue 3, December 1988 (XPG3),
X/Open Company, Ltd, Prentice-Hall, Inc. 1989. ISBN
0-13-685835-8.	(See especially Volume 3:  XSI Supplementary
Definitions.)














































			     1m6910m





1mXlib - C Library			X11, Release 6.7 DRAFT0m



























































			     1m6920m











		     1mTable of Contents0m


Table of Contents  . . . . . . . . . . . . . . . . . . .  ii
Acknowledgments	 . . . . . . . . . . . . . . . . . . . . iii
Chapter 1: Introduction to Xlib	 . . . . . . . . . . . .   1
1.1. Overview of the X Window System . . . . . . . . . .   2
1.2. Errors  . . . . . . . . . . . . . . . . . . . . . .   4
1.3. Standard Header Files . . . . . . . . . . . . . . .   4
1.4. Generic Values and Types  . . . . . . . . . . . . .   6
1.5. Naming and Argument Conventions within Xlib . . . .   6
1.6. Programming Considerations	 . . . . . . . . . . . .   8
1.7. Character Sets and Encodings  . . . . . . . . . . .   8
1.8. Formatting Conventions  . . . . . . . . . . . . . .   9
Chapter 2: Display Functions . . . . . . . . . . . . . .  11
2.1. Opening the Display . . . . . . . . . . . . . . . .  11
2.2. Obtaining Information about the Display, Image
Formats, or Screens  . . . . . . . . . . . . . . . . . .  13
2.2.1. Display Macros  . . . . . . . . . . . . . . . . .  14
2.2.2. Image Format Functions and Macros . . . . . . . .  23
2.2.3. Screen Information Macros . . . . . . . . . . . .  27
2.3. Generating a NoOperation Protocol Request . . . . .  33
2.4. Freeing Client-Created Data . . . . . . . . . . . .  34
2.5. Closing the Display . . . . . . . . . . . . . . . .  34
2.6. Using X Server Connection Close Operations	 . . . .  35
2.7. Using Xlib with Threads . . . . . . . . . . . . . .  37
2.8. Using Internal Connections	 . . . . . . . . . . . .  38
Chapter 3: Window Functions  . . . . . . . . . . . . . .  42
3.1. Visual Types  . . . . . . . . . . . . . . . . . . .  42
3.2. Window Attributes . . . . . . . . . . . . . . . . .  44
3.2.1. Background Attribute  . . . . . . . . . . . . . .  48
3.2.2. Border Attribute	 . . . . . . . . . . . . . . . .  49
3.2.3. Gravity Attributes  . . . . . . . . . . . . . . .  50
3.2.4. Backing Store Attribute . . . . . . . . . . . . .  51
3.2.5. Save Under Flag . . . . . . . . . . . . . . . . .  52
3.2.6. Backing Planes and Backing Pixel Attributes
 . . . . . . . . . . . . . . . . . . . . . . . . . . . .  52
3.2.7. Event Mask and Do Not Propagate Mask
Attributes . . . . . . . . . . . . . . . . . . . . . . .  53
3.2.8. Override Redirect Flag  . . . . . . . . . . . . .  53
3.2.9. Colormap Attribute  . . . . . . . . . . . . . . .  53
3.2.10. Cursor Attribute . . . . . . . . . . . . . . . .  54
3.3. Creating Windows  . . . . . . . . . . . . . . . . .  54
3.4. Destroying Windows	 . . . . . . . . . . . . . . . .  59
3.5. Mapping Windows . . . . . . . . . . . . . . . . . .  60
3.6. Unmapping Windows . . . . . . . . . . . . . . . . .  62
3.7. Configuring Windows . . . . . . . . . . . . . . . .  63
3.8. Changing Window Stacking Order  . . . . . . . . . .  70
3.9. Changing Window Attributes	 . . . . . . . . . . . .  74
Chapter 4: Window Information Functions	 . . . . . . . .  81
4.1. Obtaining Window Information  . . . . . . . . . . .  81












4.2. Translating Screen Coordinates  . . . . . . . . . .  87
4.3. Properties and Atoms  . . . . . . . . . . . . . . .  89
4.4. Obtaining and Changing Window Properties  . . . . .  94
4.5. Selections	 . . . . . . . . . . . . . . . . . . . . 101
Chapter 5: Pixmap and Cursor Functions . . . . . . . . . 105
5.1. Creating and Freeing Pixmaps  . . . . . . . . . . . 105
5.2. Creating, Recoloring, and Freeing Cursors . . . . . 106
Chapter 6: Color Management Functions  . . . . . . . . . 112
6.1. Color Structures  . . . . . . . . . . . . . . . . . 113
6.2. Color Strings . . . . . . . . . . . . . . . . . . . 117
6.2.1. RGB Device String Specification . . . . . . . . . 118
6.2.2. RGB Intensity String Specification  . . . . . . . 119
6.2.3. Device-Independent String Specifications	 . . . . 119
6.3. Color Conversion Contexts and Gamut Mapping . . . . 120
6.4. Creating, Copying, and Destroying Colormaps . . . . 121
6.5. Mapping Color Names to Values . . . . . . . . . . . 123
6.6. Allocating and Freeing Color Cells	 . . . . . . . . 127
6.7. Modifying and Querying Colormap Cells . . . . . . . 135
6.8. Color Conversion Context Functions	 . . . . . . . . 142
6.8.1. Getting and Setting the Color Conversion Con-
text of a Colormap . . . . . . . . . . . . . . . . . . . 143
6.8.2. Obtaining the Default Color Conversion Con-
text . . . . . . . . . . . . . . . . . . . . . . . . . . 144
6.8.3. Color Conversion Context Macros . . . . . . . . . 144
6.8.4. Modifying Attributes of a Color Conversion
Context	 . . . . . . . . . . . . . . . . . . . . . . . . 146
6.8.5. Creating and Freeing a Color Conversion Con-
text . . . . . . . . . . . . . . . . . . . . . . . . . . 148
6.9. Converting between Color Spaces . . . . . . . . . . 150
6.10. Callback Functions . . . . . . . . . . . . . . . . 151
6.10.1. Prototype Gamut Compression Procedure  . . . . . 152
6.10.2. Supplied Gamut Compression Procedures  . . . . . 154
6.10.3. Prototype White Point Adjustment Procedure
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . 156
6.10.4. Supplied White Point Adjustment Procedures
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . 157
6.11. Gamut Querying Functions . . . . . . . . . . . . . 159
6.11.1. Red, Green, and Blue Queries . . . . . . . . . . 160
6.11.2. CIELab Queries . . . . . . . . . . . . . . . . . 163
6.11.3. CIELuv Queries . . . . . . . . . . . . . . . . . 167
6.11.4. TekHVC Queries . . . . . . . . . . . . . . . . . 171
6.12. Color Management Extensions  . . . . . . . . . . . 176
6.12.1. Color Spaces . . . . . . . . . . . . . . . . . . 177
6.12.2. Adding Device-Independent Color Spaces . . . . . 177
6.12.3. Querying Color Space Format and Prefix . . . . . 178
6.12.4. Creating Additional Color Spaces . . . . . . . . 178
6.12.5. Parse String Callback  . . . . . . . . . . . . . 180
6.12.6. Color Specification Conversion Callback	 . . . . 180
6.12.7. Function Sets  . . . . . . . . . . . . . . . . . 183
6.12.8. Adding Function Sets . . . . . . . . . . . . . . 183
6.12.9. Creating Additional Function Sets  . . . . . . . 184
Chapter 7: Graphics Context Functions  . . . . . . . . . 187
7.1. Manipulating Graphics Context/State . . . . . . . . 187
7.2. Using Graphics Context Convenience Routines . . . . 201












7.2.1. Setting the Foreground, Background, Function,
or Plane Mask  . . . . . . . . . . . . . . . . . . . . . 201
7.2.2. Setting the Line Attributes and Dashes  . . . . . 204
7.2.3. Setting the Fill Style and Fill Rule  . . . . . . 207
7.2.4. Setting the Fill Tile and Stipple . . . . . . . . 207
7.2.5. Setting the Current Font	 . . . . . . . . . . . . 212
7.2.6. Setting the Clip Region . . . . . . . . . . . . . 212
7.2.7. Setting the Arc Mode, Subwindow Mode, and
Graphics Exposure  . . . . . . . . . . . . . . . . . . . 215
Chapter 8: Graphics Functions  . . . . . . . . . . . . . 217
8.1. Clearing Areas  . . . . . . . . . . . . . . . . . . 217
8.2. Copying Areas . . . . . . . . . . . . . . . . . . . 219
8.3. Drawing Points, Lines, Rectangles, and Arcs . . . . 222
8.3.1. Drawing Single and Multiple Points  . . . . . . . 223
8.3.2. Drawing Single and Multiple Lines . . . . . . . . 225
8.3.3. Drawing Single and Multiple Rectangles  . . . . . 227
8.3.4. Drawing Single and Multiple Arcs	 . . . . . . . . 229
8.4. Filling Areas . . . . . . . . . . . . . . . . . . . 232
8.4.1. Filling Single and Multiple Rectangles  . . . . . 233
8.4.2. Filling a Single Polygon	 . . . . . . . . . . . . 234
8.4.3. Filling Single and Multiple Arcs	 . . . . . . . . 236
8.5. Font Metrics  . . . . . . . . . . . . . . . . . . . 237
8.5.1. Loading and Freeing Fonts . . . . . . . . . . . . 242
8.5.2. Obtaining and Freeing Font Names and Informa-
tion . . . . . . . . . . . . . . . . . . . . . . . . . . 246
8.5.3. Computing Character String Sizes	 . . . . . . . . 248
8.5.4. Computing Logical Extents . . . . . . . . . . . . 249
8.5.5. Querying Character String Sizes . . . . . . . . . 252
8.6. Drawing Text  . . . . . . . . . . . . . . . . . . . 254
8.6.1. Drawing Complex Text  . . . . . . . . . . . . . . 255
8.6.2. Drawing Text Characters . . . . . . . . . . . . . 257
8.6.3. Drawing Image Text Characters . . . . . . . . . . 258
8.7. Transferring Images between Client and Server
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . 261
Chapter 9: Window and Session Manager Functions	 . . . . 269
9.1. Changing the Parent of a Window . . . . . . . . . . 269
9.2. Controlling the Lifetime of a Window  . . . . . . . 271
9.3. Managing Installed Colormaps  . . . . . . . . . . . 272
9.4. Setting and Retrieving the Font Search Path . . . . 275
9.5. Grabbing the Server . . . . . . . . . . . . . . . . 276
9.6. Killing Clients . . . . . . . . . . . . . . . . . . 277
9.7. Controlling the Screen Saver  . . . . . . . . . . . 278
9.8. Controlling Host Access . . . . . . . . . . . . . . 281
9.8.1. Adding, Getting, or Removing Hosts  . . . . . . . 281
9.8.2. Changing, Enabling, or Disabling Access Con-
trol . . . . . . . . . . . . . . . . . . . . . . . . . . 284
Chapter 10: Events . . . . . . . . . . . . . . . . . . . 287
10.1. Event Types  . . . . . . . . . . . . . . . . . . . 287
10.2. Event Structures . . . . . . . . . . . . . . . . . 288
10.3. Event Masks  . . . . . . . . . . . . . . . . . . . 291
10.4. Event Processing Overview	 . . . . . . . . . . . . 292
10.5. Keyboard and Pointer Events  . . . . . . . . . . . 294
10.5.1. Pointer Button Events  . . . . . . . . . . . . . 294
10.5.2. Keyboard and Pointer Events  . . . . . . . . . . 295












10.6. Window Entry/Exit Events . . . . . . . . . . . . . 299
10.6.1. Normal Entry/Exit Events . . . . . . . . . . . . 301
10.6.2. Grab and Ungrab Entry/Exit Events  . . . . . . . 303
10.7. Input Focus Events . . . . . . . . . . . . . . . . 304
10.7.1. Normal Focus Events and Focus Events While
Grabbed	 . . . . . . . . . . . . . . . . . . . . . . . . 305
10.7.2. Focus Events Generated by Grabs	 . . . . . . . . 309
10.8. Key Map State Notification Events	 . . . . . . . . 309
10.9. Exposure Events  . . . . . . . . . . . . . . . . . 310
10.9.1. Expose Events  . . . . . . . . . . . . . . . . . 310
10.9.2. GraphicsExpose and NoExpose Events . . . . . . . 311
10.10. Window State Change Events  . . . . . . . . . . . 313
10.10.1. CirculateNotify Events	 . . . . . . . . . . . . 313
10.10.2. ConfigureNotify Events	 . . . . . . . . . . . . 314
10.10.3. CreateNotify Events . . . . . . . . . . . . . . 315
10.10.4. DestroyNotify Events  . . . . . . . . . . . . . 316
10.10.5. GravityNotify Events  . . . . . . . . . . . . . 317
10.10.6. MapNotify Events  . . . . . . . . . . . . . . . 318
10.10.7. MappingNotify Events  . . . . . . . . . . . . . 318
10.10.8. ReparentNotify Events . . . . . . . . . . . . . 319
10.10.9. UnmapNotify Events  . . . . . . . . . . . . . . 320
10.10.10. VisibilityNotify Events  . . . . . . . . . . . 321
10.11. Structure Control Events	 . . . . . . . . . . . . 322
10.11.1. CirculateRequest Events . . . . . . . . . . . . 323
10.11.2. ConfigureRequest Events . . . . . . . . . . . . 323
10.11.3. MapRequest Events . . . . . . . . . . . . . . . 324
10.11.4. ResizeRequest Events  . . . . . . . . . . . . . 325
10.12. Colormap State Change Events  . . . . . . . . . . 326
10.13. Client Communication Events . . . . . . . . . . . 327
10.13.1. ClientMessage Events  . . . . . . . . . . . . . 327
10.13.2. PropertyNotify Events . . . . . . . . . . . . . 328
10.13.3. SelectionClear Events . . . . . . . . . . . . . 328
10.13.4. SelectionRequest Events . . . . . . . . . . . . 329
10.13.5. SelectionNotify Events	 . . . . . . . . . . . . 330
Chapter 11: Event Handling Functions . . . . . . . . . . 332
11.1. Selecting Events . . . . . . . . . . . . . . . . . 332
11.2. Handling the Output Buffer . . . . . . . . . . . . 333
11.3. Event Queue Management . . . . . . . . . . . . . . 335
11.4. Manipulating the Event Queue . . . . . . . . . . . 336
11.4.1. Returning the Next Event . . . . . . . . . . . . 336
11.4.2. Selecting Events Using a Predicate Procedure
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . 337
11.4.3. Selecting Events Using a Window or Event
Mask . . . . . . . . . . . . . . . . . . . . . . . . . . 340
11.5. Putting an Event Back into the Queue . . . . . . . 345
11.6. Sending Events to Other Applications . . . . . . . 345
11.7. Getting Pointer Motion History . . . . . . . . . . 347
11.8. Handling Protocol Errors . . . . . . . . . . . . . 349
11.8.1. Enabling or Disabling Synchronization  . . . . . 349
11.8.2. Using the Default Error Handlers . . . . . . . . 350
Chapter 12: Input Device Functions . . . . . . . . . . . 356
12.1. Pointer Grabbing . . . . . . . . . . . . . . . . . 356
12.2. Keyboard Grabbing	 . . . . . . . . . . . . . . . . 364
12.3. Resuming Event Processing	 . . . . . . . . . . . . 369












12.4. Moving the Pointer . . . . . . . . . . . . . . . . 372
12.5. Controlling Input Focus  . . . . . . . . . . . . . 373
12.6. Manipulating the Keyboard and Pointer Settings
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . 375
12.7. Manipulating the Keyboard Encoding . . . . . . . . 383
Chapter 13: Locales and Internationalized Text Func-
tions  . . . . . . . . . . . . . . . . . . . . . . . . . 393
13.1. X Locale Management  . . . . . . . . . . . . . . . 394
13.2. Locale and Modifier Dependencies . . . . . . . . . 396
13.3. Variable Argument Lists  . . . . . . . . . . . . . 398
13.4. Output Methods . . . . . . . . . . . . . . . . . . 399
13.4.1. Output Method Overview . . . . . . . . . . . . . 399
13.4.2. Output Method Functions	 . . . . . . . . . . . . 400
13.4.3. X Output Method Values . . . . . . . . . . . . . 403
13.4.3.1. Required Char Set  . . . . . . . . . . . . . . 404
>N Query Orientation . . . . . . . . . . . . . . . . . . 404
13.4.3.3. Directional Dependent Drawing	 . . . . . . . . 405
13.4.3.4. Context Dependent Drawing  . . . . . . . . . . 406
13.4.4. Output Context Functions . . . . . . . . . . . . 406
13.4.5. Output Context Values  . . . . . . . . . . . . . 409
13.4.5.1. Base Font Name . . . . . . . . . . . . . . . . 409
13.4.5.2. Missing CharSet  . . . . . . . . . . . . . . . 410
13.4.5.3. Default String . . . . . . . . . . . . . . . . 410
13.4.5.4. Orientation  . . . . . . . . . . . . . . . . . 411
13.4.5.5. Resource Name and Class  . . . . . . . . . . . 411
13.4.5.6. Font Info  . . . . . . . . . . . . . . . . . . 412
13.4.5.7. OM Automatic . . . . . . . . . . . . . . . . . 412
13.4.6. Creating and Freeing a Font Set	 . . . . . . . . 413
13.4.7. Obtaining Font Set Metrics . . . . . . . . . . . 419
13.4.8. Drawing Text Using Font Sets . . . . . . . . . . 427
13.5. Input Methods  . . . . . . . . . . . . . . . . . . 434
13.5.1. Input Method Overview  . . . . . . . . . . . . . 434
13.5.1.1. Input Method Architecture  . . . . . . . . . . 436
13.5.1.2. Input Contexts . . . . . . . . . . . . . . . . 439
13.5.1.3. Getting Keyboard Input . . . . . . . . . . . . 439
13.5.1.4. Focus Management . . . . . . . . . . . . . . . 440
13.5.1.5. Geometry Management  . . . . . . . . . . . . . 440
13.5.1.6. Event Filtering  . . . . . . . . . . . . . . . 442
13.5.1.7. Callbacks  . . . . . . . . . . . . . . . . . . 442
13.5.1.8. Visible Position Feedback Masks  . . . . . . . 443
13.5.1.9. Preedit String Management  . . . . . . . . . . 443
13.5.2. Input Method Management	 . . . . . . . . . . . . 446
13.5.2.1. Hot Keys . . . . . . . . . . . . . . . . . . . 447
13.5.2.2. Preedit State Operation  . . . . . . . . . . . 447
13.5.3. Input Method Functions . . . . . . . . . . . . . 448
13.5.4. Input Method Values  . . . . . . . . . . . . . . 452
13.5.4.1. Query Input Style  . . . . . . . . . . . . . . 453
13.5.4.2. Resource Name and Class  . . . . . . . . . . . 455
13.5.4.3. Destroy Callback . . . . . . . . . . . . . . . 455
13.5.4.4. Query IM/IC Values List  . . . . . . . . . . . 456
13.5.4.5. Visible Position . . . . . . . . . . . . . . . 456
13.5.4.6. Preedit Callback Behavior  . . . . . . . . . . 457
13.5.5. Input Context Functions	 . . . . . . . . . . . . 457
13.5.6. Input Context Values . . . . . . . . . . . . . . 462












13.5.6.1. Input Style  . . . . . . . . . . . . . . . . . 464
13.5.6.2. Client Window	 . . . . . . . . . . . . . . . . 464
13.5.6.3. Focus Window . . . . . . . . . . . . . . . . . 465
13.5.6.4. Resource Name and Class  . . . . . . . . . . . 465
13.5.6.5. Geometry Callback  . . . . . . . . . . . . . . 465
13.5.6.6. Filter Events	 . . . . . . . . . . . . . . . . 466
13.5.6.7. Destroy Callback . . . . . . . . . . . . . . . 466
13.5.6.8. String Conversion Callback . . . . . . . . . . 466
13.5.6.9. String Conversion  . . . . . . . . . . . . . . 467
13.5.6.10. Reset State . . . . . . . . . . . . . . . . . 467
13.5.6.11. Hot Keys  . . . . . . . . . . . . . . . . . . 468
13.5.6.12. Hot Key State . . . . . . . . . . . . . . . . 469
13.5.6.13. Preedit and Status Attributes . . . . . . . . 470
13.5.6.13.1. Area  . . . . . . . . . . . . . . . . . . . 470
13.5.6.13.2. Area Needed . . . . . . . . . . . . . . . . 470
13.5.6.13.3. Spot Location . . . . . . . . . . . . . . . 471
13.5.6.13.4. Colormap  . . . . . . . . . . . . . . . . . 471
13.5.6.13.5. Foreground and Background . . . . . . . . . 471
13.5.6.13.6. Background Pixmap . . . . . . . . . . . . . 472
13.5.6.13.7. Font Set  . . . . . . . . . . . . . . . . . 472
13.5.6.13.8. Line Spacing  . . . . . . . . . . . . . . . 472
13.5.6.13.9. Cursor  . . . . . . . . . . . . . . . . . . 472
13.5.6.13.10. Preedit State  . . . . . . . . . . . . . . 472
13.5.6.13.11. Preedit State Notify Callback  . . . . . . 473
13.5.6.13.12. Preedit and Status Callbacks . . . . . . . 474
13.5.7. Input Method Callback Semantics	 . . . . . . . . 475
13.5.7.1. Geometry Callback  . . . . . . . . . . . . . . 476
13.5.7.2. Destroy Callback . . . . . . . . . . . . . . . 477
13.5.7.3. String Conversion Callback . . . . . . . . . . 477
13.5.7.4. Preedit State Callbacks  . . . . . . . . . . . 479
13.5.7.5. Preedit Draw Callback	 . . . . . . . . . . . . 480
13.5.7.6. Preedit Caret Callback . . . . . . . . . . . . 484
13.5.7.7. Status Callbacks . . . . . . . . . . . . . . . 486
13.5.8. Event Filtering	 . . . . . . . . . . . . . . . . 488
13.5.9. Getting Keyboard Input . . . . . . . . . . . . . 489
13.5.10. Input Method Conventions  . . . . . . . . . . . 492
13.5.10.1. Client Conventions  . . . . . . . . . . . . . 492
13.5.10.2. Synchronization Conventions . . . . . . . . . 492
13.6. String Constants . . . . . . . . . . . . . . . . . 493
Chapter 14: Inter-Client Communication Functions . . . . 495
14.1. Client to Window Manager Communication . . . . . . 497
14.1.1. Manipulating Top-Level Windows . . . . . . . . . 497
14.1.2. Converting String Lists	 . . . . . . . . . . . . 500
14.1.3. Setting and Reading Text Properties  . . . . . . 507
14.1.4. Setting and Reading the WM_NAME Property . . . . 508
14.1.5. Setting and Reading the WM_ICON_NAME Prop-
erty . . . . . . . . . . . . . . . . . . . . . . . . . . 511
14.1.6. Setting and Reading the WM_HINTS Property
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . 513
14.1.7. Setting and Reading the WM_NORMAL_HINTS
Property . . . . . . . . . . . . . . . . . . . . . . . . 516
14.1.8. Setting and Reading the WM_CLASS Property
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . 522
14.1.9. Setting and Reading the WM_TRANSIENT_FOR












Property . . . . . . . . . . . . . . . . . . . . . . . . 524
14.1.10. Setting and Reading the WM_PROTOCOLS Prop-
erty . . . . . . . . . . . . . . . . . . . . . . . . . . 525
14.1.11. Setting and Reading the WM_COLORMAP_WINDOWS
Property . . . . . . . . . . . . . . . . . . . . . . . . 526
14.1.12. Setting and Reading the WM_ICON_SIZE Prop-
erty . . . . . . . . . . . . . . . . . . . . . . . . . . 528
14.1.13. Using Window Manager Convenience Functions
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . 530
14.2. Client to Session Manager Communication  . . . . . 534
14.2.1. Setting and Reading the WM_COMMAND Property
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . 534
14.2.2. Setting and Reading the WM_CLIENT_MACHINE
Property . . . . . . . . . . . . . . . . . . . . . . . . 536
14.3. Standard Colormaps . . . . . . . . . . . . . . . . 537
14.3.1. Standard Colormap Properties and Atoms . . . . . 540
14.3.2. Setting and Obtaining Standard Colormaps . . . . 541
Chapter 15: Resource Manager Functions . . . . . . . . . 545
15.1. Resource File Syntax . . . . . . . . . . . . . . . 546
15.2. Resource Manager Matching Rules  . . . . . . . . . 548
15.3. Quarks . . . . . . . . . . . . . . . . . . . . . . 549
15.4. Creating and Storing Databases . . . . . . . . . . 553
15.5. Merging Resource Databases . . . . . . . . . . . . 557
15.6. Looking Up Resources . . . . . . . . . . . . . . . 558
15.7. Storing into a Resource Database . . . . . . . . . 562
15.8. Enumerating Database Entries . . . . . . . . . . . 566
15.9. Parsing Command Line Options . . . . . . . . . . . 568
Chapter 16: Application Utility Functions  . . . . . . . 571
16.1. Using Keyboard Utility Functions . . . . . . . . . 571
16.1.1. KeySym Classification Macros . . . . . . . . . . 575
16.2. Using Latin-1 Keyboard Event Functions . . . . . . 576
16.3. Allocating Permanent Storage . . . . . . . . . . . 578
16.4. Parsing the Window Geometry  . . . . . . . . . . . 579
16.5. Manipulating Regions . . . . . . . . . . . . . . . 581
16.5.1. Creating, Copying, or Destroying Regions . . . . 581
16.5.2. Moving or Shrinking Regions  . . . . . . . . . . 583
16.5.3. Computing with Regions . . . . . . . . . . . . . 583
16.5.4. Determining if Regions Are Empty or Equal
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . 586
16.5.5. Locating a Point or a Rectangle in a Region
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . 586
16.6. Using Cut Buffers	 . . . . . . . . . . . . . . . . 587
16.7. Determining the Appropriate Visual Type  . . . . . 590
16.8. Manipulating Images  . . . . . . . . . . . . . . . 593
16.9. Manipulating Bitmaps . . . . . . . . . . . . . . . 597
16.10. Using the Context Manager . . . . . . . . . . . . 602
Appendix A: Xlib Functions and Protocol Requests . . . . 606
Appendix B:  X Font Cursors  . . . . . . . . . . . . . . 618
Appendix C: Extensions . . . . . . . . . . . . . . . . . 619
Appendix D: Compatibility Functions  . . . . . . . . . . 653
Glossary . . . . . . . . . . . . . . . . . . . . . . . . 670
Index  . . . . . . . . . . . . . . . . . . . . . . . . . 693








