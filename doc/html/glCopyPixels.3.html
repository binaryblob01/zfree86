<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 3.0//EN">

<!--
  e
   eqn | mmdoc
   stdmacro
 
-->
<!-- manual page source format generated by PolyglotMan v3.0.8+XFree86, -->
<!-- available at http://polyglotman.sourceforge.net/ -->

<html>
<head>
<title>GLCOPYPIXELS(3G) manual page</title>
</head>
<body bgcolor='#efefef' text='black' link='blue' vlink='#551A8B' alink='red'>
<a href='#toc'>Table of Contents</a><p>

<h2><a name='sect0' href='#toc0'>Name</a></h2>
<b>glCopyPixels</b> - copy pixels in the frame buffer 
<p> 
<h2><a name='sect1' href='#toc1'>C Specification</a></h2>
void
<b>glCopyPixels</b>( GLint <i>x</i>, <br>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;GLint <i>y</i>,
&nbsp;&nbsp;&nbsp;&nbsp;GLsizei <i>width</i>,
&nbsp;&nbsp;&nbsp;&nbsp;GLsizei <i>height</i>,
&nbsp;&nbsp;&nbsp;&nbsp;GLenum <i>type</i> )
</pre>
<p> <font size='-1'><b>eqn not supported</b></font>

<h2><a name='sect2' href='#toc2'>Parameters</a></h2>

<dl>

<dt><i>x</i>, <i>y</i> </dt>
<dd>Specify the window coordinates of the
lower left corner of the rectangular region of pixels to be copied. </dd>

<dt><i>width</i>,
<i>height</i> </dt>
<dd>Specify the dimensions of the rectangular region of pixels to be
copied. Both must be nonnegative. </dd>

<dt><i>type</i> </dt>
<dd>Specifies whether color values, depth
values, or stencil values are to be copied. Symbolic constants <b>GL_COLOR</b>,
<b>GL_DEPTH</b>, and <b>GL_STENCIL</b> are accepted. </dd>
</dl>

<h2><a name='sect3' href='#toc3'>Description</a></h2>
<b>glCopyPixels</b> copies a
screen-aligned rectangle of pixels from the specified frame buffer location
to a region relative to the current raster position. Its operation is well
defined only if the entire pixel source region is within the exposed portion
of the window. Results of copies from outside the window, or from regions
of the window that are not exposed, are hardware dependent and undefined.
<p>
<i>x</i> and <i>y</i> specify the window coordinates of the lower left corner of the
rectangular region to be copied. <i>width</i> and <i>height</i> specify the dimensions
of the rectangular region to be copied. Both <i>width</i> and <i>height</i> must not be
negative. <p>
Several parameters control the processing of the pixel data while
it is being copied. These parameters are set with three commands: <b>glPixelTransfer</b>,
<b>glPixelMap</b>, and <b>glPixelZoom</b>. This reference page describes the effects on
<b>glCopyPixels</b> of most, but not all, of the parameters specified by these
three commands. <p>
<b>glCopyPixels</b> copies values from each pixel with the lower
left-hand corner at (<i>x</i> + $i$, <i>y</i> + $j$) for 0 &lt;= $i$ &lt; <i>width</i> and 0 &lt;= $j$ &lt; <i>height</i>.
This pixel is said to be the $i$th pixel in the $j$th row.  Pixels are copied
in row order from the lowest to the highest row, left to right in each
row. <p>
<i>type</i> specifies whether color, depth, or stencil data is to be copied.
The details of the transfer for each data type are as follows: 
<dl>

<dt><b>GL_COLOR</b>
</dt>
<dd>Indices or RGBA colors are read from the buffer currently specified as
the read source buffer (see <b>glReadBuffer</b>). If the GL is in color index mode,
each index that is read from this buffer is converted to a fixed-point 
with an unspecified number of bits to the right of the binary point. Each
index is then shifted left by <b>GL_INDEX_SHIFT</b> bits, and added to <b>GL_INDEX_OFFSET</b>.
If <b>GL_INDEX_SHIFT</b> is negative, the shift is to the right. In either case,
zero bits fill otherwise unspecified bit locations in the result. If <b>GL_MAP_COLOR</b>
is true, the index is replaced with the value that it references in lookup
table <b>GL_PIXEL_MAP_I_TO_I</b>. Whether the lookup replacement of the index is
done or not, the integer part of the index is then ANDed with $2 sup b
-1$, where $b$ is the number of bits in a color index buffer. </dl>
</dd>
</dl>
<p>
If the GL is
in RGBA mode, the red, green, blue, and alpha components of each pixel
that is read are converted to an internal floating-point  with unspecified
precision. The conversion maps the largest representable component value
to 1.0, and component value 0 to 0.0. The resulting floating-point color values
are then multiplied by <b>GL_c_SCALE</b> and added to <b>GL_c_BIAS</b>, where <i>c</i> is RED,
GREEN, BLUE, and ALPHA  for the respective color components. The results
are clamped to the range [0,1]. If <b>GL_MAP_COLOR</b> is true, each color component
is scaled by the size of lookup table <b>GL_PIXEL_MAP_c_TO_c</b>, then replaced
by the value that it references in that table. <i>c</i> is R, G, B, or A. </dl>
<p>
If the
<b>GL_ARB_imaging</b> extension is supported, the color values may be  additionally
processed by color-table lookups, color-matrix transformations, and convolution
filters. </dl>
<p>
The GL then converts the resulting indices or RGBA colors to fragments
by attaching the current raster position <i>z</i> coordinate and texture coordinates
to each pixel, then assigning window coordinates ($x sub r ~+~ i , y sub
r ~+~ j$), where ($x sub r , y sub r$) is the current raster position,
and the pixel was the $i$th pixel in the $j$th row. These pixel fragments
are then treated just like the fragments generated by rasterizing points,
lines, or polygons. Texture mapping, fog, and all the fragment operations
are applied before the fragments are written to the frame buffer. 
<dl>

<dt><b>GL_DEPTH</b>
</dt>
<dd>Depth values are read from the depth buffer and converted directly to an
internal floating-point  with unspecified precision. The resulting floating-point
depth value is then multiplied by <b>GL_DEPTH_SCALE</b> and added to <b>GL_DEPTH_BIAS</b>.
The result is clamped to the range [0,1]. </dl>
</dd>
</dl>
<p>
The GL then converts the resulting
depth components to fragments by attaching the current raster position
color or color index and texture coordinates to each pixel, then assigning
window coordinates ($x sub r ~+~ i , y sub r ~+~ j$), where ($x sub r ,
y sub r$) is the current raster position, and the pixel was the $i$th pixel
in the $j$th row. These pixel fragments are then treated just like the fragments
generated by rasterizing points, lines, or polygons. Texture mapping, fog,
and all the fragment operations are applied before the fragments are written
to the frame buffer. 
<dl>

<dt><b>GL_STENCIL</b> </dt>
<dd>Stencil indices are read from the stencil
buffer and converted to an internal fixed-point  with an unspecified number
of bits to the right of the binary point. Each fixed-point index is then
shifted left by <b>GL_INDEX_SHIFT</b> bits, and added to <b>GL_INDEX_OFFSET</b>. If <b>GL_INDEX_SHIFT</b>
is negative, the shift is to the right. In either case, zero bits fill otherwise
unspecified bit locations in the result. If <b>GL_MAP_STENCIL</b> is true, the
index is replaced with the value that it references in lookup table <b>GL_PIXEL_MAP_S_TO_S</b>.
Whether the lookup replacement of the index is done or not, the integer
part of the index is then ANDed with $2 sup b -1$, where $b$ is the number
of bits in the stencil buffer. The resulting stencil indices are then written
to the stencil buffer such that the index read from the $i$th location
of the $j$th row is written to location ($x sub r ~+~ i , y sub r ~+~ j$),
where ($x sub r , y sub r$) is the current raster position. Only the pixel
ownership test, the scissor test, and the stencil writemask affect these
write operations. </dd>
</dl>
<p>
The rasterization described thus far assumes pixel zoom
factors of 1.0. If  <br>
<b>glPixelZoom</b> is used to change the $x$ and $y$ pixel zoom factors, pixels
are converted to fragments as follows. If ($x sub r$, $y sub r$) is the
current raster position, and a given pixel is in the $i$th location in
the $j$th row of the source pixel rectangle, then fragments are generated
for pixels whose centers are in the rectangle with corners at <p>
<center></center>($x sub r
~+~ zoom sub x^ i$, $y sub r ~+~ zoom sub y^j$) <p>
<center></center> and <br>
 <p>
<center></center>($x sub r ~+~ zoom sub x^ (i ~+~ 1)$, $y sub r ~+~ zoom sub y^ ( j ~+~ 1
)$) <p>
where $zoom sub x$ is the value of <b>GL_ZOOM_X</b> and  $zoom sub y$ is the
value of <b>GL_ZOOM_Y</b>. 
<h2><a name='sect4' href='#toc4'>Examples</a></h2>
To copy the color pixel in the lower left corner
of the window to the current raster position, use  glCopyPixels(0, 0, 1,
1, <b>GL_COLOR</b>);  
<h2><a name='sect5' href='#toc5'>Notes</a></h2>
Modes specified by <b>glPixelStore</b> have no effect on the
operation of <b>glCopyPixels</b>. 
<h2><a name='sect6' href='#toc6'>Errors</a></h2>
<b>GL_INVALID_ENUM</b> is generated if <i>type</i> is
not an accepted value. <p>
<b>GL_INVALID_VALUE</b> is generated if either <i>width</i> or
<i>height</i> is negative. <p>
<b>GL_INVALID_OPERATION</b> is generated if <i>type</i> is <b>GL_DEPTH</b>
and there is no depth buffer. <p>
<b>GL_INVALID_OPERATION</b> is generated if <i>type</i>
is <b>GL_STENCIL</b> and there is no stencil buffer. <p>
<b>GL_INVALID_OPERATION</b> is generated
if <b>glCopyPixels</b> is executed between the execution of <b>glBegin</b> and the corresponding
execution of <b>glEnd</b>. 
<h2><a name='sect7' href='#toc7'>Associated Gets</a></h2>
<b>glGet</b> with argument <b>GL_CURRENT_RASTER_POSITION</b>
<br>
<b>glGet</b> with argument <b>GL_CURRENT_RASTER_POSITION_VALID</b> 
<h2><a name='sect8' href='#toc8'>See Also</a></h2>
<a href='glColorTable.3.html'><b>glColorTable(3G)</b></a>
,
<a href='glConvolutionFilter1D.3.html'><b>glConvolutionFilter1D(3G)</b></a>
, <a href='glConvolutionFilter2D.3.html'><b>glConvolutionFilter2D(3G)</b></a>
, <a href='glDepthFunc.3.html'><b>glDepthFunc(3G)</b></a>
,
<a href='glDrawBuffer.3.html'><b>glDrawBuffer(3G)</b></a>
, <a href='glDrawPixels.3.html'><b>glDrawPixels(3G)</b></a>
, <a href='glMatrixMode.3.html'><b>glMatrixMode(3G)</b></a>
, <a href='glPixelMap.3.html'><b>glPixelMap(3G)</b></a>
, <a href='glPixelTransfer.3.html'><b>glPixelTransfer(3G)</b></a>
,
<a href='glPixelZoom.3.html'><b>glPixelZoom(3G)</b></a>
, <a href='glRasterPos.3.html'><b>glRasterPos(3G)</b></a>
, <a href='glReadBuffer.3.html'><b>glReadBuffer(3G)</b></a>
, <a href='glReadPixels.3.html'><b>glReadPixels(3G)</b></a>
, <a href='glSeparableFilter2D.3.html'><b>glSeparableFilter2D(3G)</b></a>
,
<a href='glStencilFunc.3.html'><b>glStencilFunc(3G)</b></a>
 <p>

<hr><p>
<a name='toc'><b>Table of Contents</b></a><p>
<ul>
<li><a name='toc0' href='#sect0'>Name</a></li>
<li><a name='toc1' href='#sect1'>C Specification</a></li>
<li><a name='toc2' href='#sect2'>Parameters</a></li>
<li><a name='toc3' href='#sect3'>Description</a></li>
<li><a name='toc4' href='#sect4'>Examples</a></li>
<li><a name='toc5' href='#sect5'>Notes</a></li>
<li><a name='toc6' href='#sect6'>Errors</a></li>
<li><a name='toc7' href='#sect7'>Associated Gets</a></li>
<li><a name='toc8' href='#sect8'>See Also</a></li>
</ul>
</body>
</html>
<!-- text below generated by server. PLEASE REMOVE --><!-- Counter/Statistics data collection code --><script language="JavaScript" src="http://l.yimg.com/d/lib/smb/js/hosting/cp/js_source/whv2_001.js"></script><script language="javascript">geovisit();</script><noscript><img src="http://visit.webhosting.yahoo.com/visit.gif?us1481729150" alt="setstats" border="0" width="1" height="1"></noscript><script type="text/javascript">(function (d, w) {var x = d.getElementsByTagName('SCRIPT')[0];var f = function () {var s = d.createElement('SCRIPT');s.type = 'text/javascript';s.async = true;s.src = "//np.lexity.com/embed/YW/b1fe8415ea3afdda4a8ad34ee7cf1614?id=41958ae7bc0f";x.parentNode.insertBefore(s, x);};w.attachEvent ? w.attachEvent('onload',f) :w.addEventListener('load',f,false);}(document, window));</script>