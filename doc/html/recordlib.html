<!-- Creator     : groff version 1.19.2 -->
<!-- CreationDate: Mon Dec 29 01:18:33 2008 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p     { margin-top: 0; margin-bottom: 0; }
       pre   { margin-top: 0; margin-bottom: 0; }
       table { margin-top: 0; margin-bottom: 0; }
</style>
<title></title>
</head>
<body>

<a href="#1. Record Extension OverviewThe purpose of this extension is to support the recording andreporting of all core X protocol and arbitrary X extensionprotocol. This first section gives an overview of the Recordextension. The following sections describe how to use the Recordextension library.1.1. Synchronous PlaybackEnvironment information is generally provided to an X-basedplayback mechanism, which might use the XTest extension tosynthesize input events. This synchronization informationdefines the X state prior to event synthesis (for example,location of the cursor, window locations and sizes, installedcolormap, window manager running, and so on) and the consequencesthat occur after the playback mechanism synthesizes the event.If the user moves the mouse into the icon window and presses andreleases a mouse button, the device events MotionNotify,ButtonPress, and ButtonRelease are generated by the X server.Because X follows an event-driven model, there are consequencesthat follow from the user actions, or device events, that are inthe form of X protocol. As a result of the previous useractions, the client could generate requests such as ImageText8and PolyLine to the X server, or the X server could sendnon-device events such as Expose and MapNotify to the clientwindow. Both the requests and non-device events that result fromuser actions are known as consequences, which can be used as asynchronization, or control point, during playback. That is, theplayback mechanism does not generate a specific synthesized eventuntil its matching synchronization condition occurs (for example,the window is mapped or unmapped, the cursor changes, a textstring displays, and so on)Because it cannot be predicted what synchronization informationis required during playback, the Record extension makes noassumptions about the intended use of the recorded data.Facilities exist to record any core X protocol or X extensionprotocol. Therefore, Record does not enforce a specificsynchronization methodology.1.2. Design ApproachThe design approach of the extension is to record core X protocoland arbitrary X extension protocol entirely within the X serveritself. When the extension has been requested to record specificprotocol by one or more recording clients, the protocol data isformatted and returned to the recording clients. The extensionprovides a mechanism for capturing all events, including inputdevice events that do not go to any clients.1.3. Record ClientsThe recommended communication model for a Record application isto open two connections to the server--one connection forrecording control and one connection for reading recordedprotocol data.Information about recording (for example, what clients to record,what protocol to record for each client, and so on) is stored inresources called record contexts (type XRecordContext). MostRecord extension functions take a record context as an argument.Although in theory it is possible to share record contextsbetween applications, it is expected that applications will usetheir own context when performing recording operations.A client that wishes to record X protocol does so through thelibrary functions defined in section 3 &quot;Library ExtensionRequests&quot;. A typical sequence of requests that a client wouldmake is as follows:&bull; XRecordQueryVersion &minus; query the extension protocol version.&bull; XRecordCreateContext &minus; request that the server create arecord context for access by this client, and expressinterest in clients and protocol to be recorded. Thisrequest returns an XRecordContext, which is an XID that isused by most other extension requests to identify thespecified context.&bull; XRecordEnableContext &minus; begin the recording and reporting ofprotocol data.&bull; XRecordDisableContext &minus; end the recording and reporting ofprotocol data.&bull; XRecordFreeContext &minus; free the record context.The header for this library is &lt;X11/extensions/record.h&gt;. Allidentifiers defined in the interface are supplied by this headerand are prefixed with &quot;XRecord&quot;. The Xtst library contains theXRecord functions.2. Common ArgumentsThe Record extension functions XRecordCreateContext andXRecordRegisterClients allow applications to specify thefollowing:&bull; Individual clients or sets of clients to record&bull; Ranges of core X protocol and X extension protocol to recordfor each clientProtocol in the ranges specified by the recording client will berecorded by the server. The device_events protocol type can bespecified by a recording client although it may not be sent to arecorded client. The device_events type differs fromdelivered_events, which also can be specified by a recordingclient; delivered_events are actually delivered to one or moreclients. These event types are discussed in section 2.3&quot;Protocol Ranges&quot;.The Record extension functions XRecordCreateContext andXRecordRegisterClients have the common arguments datum_flags,clients, and ranges, which specify whether server time and/orclient sequence number should precede protocol elements, theclients or client set to record, and the protocol ranges torecord, respectively. These are discussed in the followingsections.2.1. Datum Flags">1. Record Extension OverviewThe purpose of this extension is to support the recording andreporting of all core X protocol and arbitrary X extensionprotocol. This first section gives an overview of the Recordextension. The following sections describe how to use the Recordextension library.1.1. Synchronous PlaybackEnvironment information is generally provided to an X-basedplayback mechanism, which might use the XTest extension tosynthesize input events. This synchronization informationdefines the X state prior to event synthesis (for example,location of the cursor, window locations and sizes, installedcolormap, window manager running, and so on) and the consequencesthat occur after the playback mechanism synthesizes the event.If the user moves the mouse into the icon window and presses andreleases a mouse button, the device events MotionNotify,ButtonPress, and ButtonRelease are generated by the X server.Because X follows an event-driven model, there are consequencesthat follow from the user actions, or device events, that are inthe form of X protocol. As a result of the previous useractions, the client could generate requests such as ImageText8and PolyLine to the X server, or the X server could sendnon-device events such as Expose and MapNotify to the clientwindow. Both the requests and non-device events that result fromuser actions are known as consequences, which can be used as asynchronization, or control point, during playback. That is, theplayback mechanism does not generate a specific synthesized eventuntil its matching synchronization condition occurs (for example,the window is mapped or unmapped, the cursor changes, a textstring displays, and so on)Because it cannot be predicted what synchronization informationis required during playback, the Record extension makes noassumptions about the intended use of the recorded data.Facilities exist to record any core X protocol or X extensionprotocol. Therefore, Record does not enforce a specificsynchronization methodology.1.2. Design ApproachThe design approach of the extension is to record core X protocoland arbitrary X extension protocol entirely within the X serveritself. When the extension has been requested to record specificprotocol by one or more recording clients, the protocol data isformatted and returned to the recording clients. The extensionprovides a mechanism for capturing all events, including inputdevice events that do not go to any clients.1.3. Record ClientsThe recommended communication model for a Record application isto open two connections to the server--one connection forrecording control and one connection for reading recordedprotocol data.Information about recording (for example, what clients to record,what protocol to record for each client, and so on) is stored inresources called record contexts (type XRecordContext). MostRecord extension functions take a record context as an argument.Although in theory it is possible to share record contextsbetween applications, it is expected that applications will usetheir own context when performing recording operations.A client that wishes to record X protocol does so through thelibrary functions defined in section 3 &quot;Library ExtensionRequests&quot;. A typical sequence of requests that a client wouldmake is as follows:&bull; XRecordQueryVersion &minus; query the extension protocol version.&bull; XRecordCreateContext &minus; request that the server create arecord context for access by this client, and expressinterest in clients and protocol to be recorded. Thisrequest returns an XRecordContext, which is an XID that isused by most other extension requests to identify thespecified context.&bull; XRecordEnableContext &minus; begin the recording and reporting ofprotocol data.&bull; XRecordDisableContext &minus; end the recording and reporting ofprotocol data.&bull; XRecordFreeContext &minus; free the record context.The header for this library is &lt;X11/extensions/record.h&gt;. Allidentifiers defined in the interface are supplied by this headerand are prefixed with &quot;XRecord&quot;. The Xtst library contains theXRecord functions.2. Common ArgumentsThe Record extension functions XRecordCreateContext andXRecordRegisterClients allow applications to specify thefollowing:&bull; Individual clients or sets of clients to record&bull; Ranges of core X protocol and X extension protocol to recordfor each clientProtocol in the ranges specified by the recording client will berecorded by the server. The device_events protocol type can bespecified by a recording client although it may not be sent to arecorded client. The device_events type differs fromdelivered_events, which also can be specified by a recordingclient; delivered_events are actually delivered to one or moreclients. These event types are discussed in section 2.3&quot;Protocol Ranges&quot;.The Record extension functions XRecordCreateContext andXRecordRegisterClients have the common arguments datum_flags,clients, and ranges, which specify whether server time and/orclient sequence number should precede protocol elements, theclients or client set to record, and the protocol ranges torecord, respectively. These are discussed in the followingsections.2.1. Datum Flags</a><br>
<a href="#2.2. Selecting Clients">2.2. Selecting Clients</a><br>
<a href="#2.3. Protocol Ranges">2.3. Protocol Ranges</a><br>
<a href="#3. Library Extension RequestsRecording operations are accessed by programs through the use ofnew protocol requests. The following functions are provided asextensions to Xlib. An Xlib error results if an extensionrequest is made to an X server that does not support the Recordextension. Note that any of the extension protocol requests maygenerate BadAlloc or BadLength errors.3.1. Query Extension VersionAn application uses the XRecordQueryVersion function to determinethe version of the Record extension protocol supported by an Xserver.__&#9474; StatusXRecordQueryVersion(Display *display, int *cmajor_return, int *cminor_return)display Specifies the connection to the X server.cmajor_returnReturns the extension protocol major version in use.cminor_returnReturns the extension protocol minor version in use.&#9474;__ The XRecordQueryVersion function returns the major and minorprotocol version numbers supported by the server.XRecordQueryVersion returns nonzero (success) only if thereturned version numbers are common to both the library and theserver; otherwise, it returns zero.3.2. Create and Modify ContextAn application uses the XRecordCreateContext function to create arecord context. At the time the record context is created by therecording client, the clients to be recorded and the protocol torecord for each client may be specified.__&#9474; XRecordContextXRecordCreateContext(Display *display, int datum_flags, XRecordClientSpec *clients, int nclients,XRecordRange **ranges, int nranges)display Specifies the connection to the X server.datum_flagsSpecifies whether detailed time or sequence info shouldbe sent.clients Specifies the clients to record.nclients Specifies the number of clients.ranges Specifies the protocol ranges to record.nranges Specifies the number of protocol ranges.&#9474;__ The XRecordCreateContext function creates a record context andreturns an XRecordContext, which is then used in the other Recordlibrary calls. This request is typically executed by therecording client over its control connection to the X server.The datum_flags specifies whether server time and/or clientsequence number should precede protocol elements recorded bycontext (see section 2.1). When a clients element identifies aparticular client, the client is added to the context and theprotocol to record for that client is set to the union of allranges. When a clients element is XRecordCurrentClients,XRecordFutureClients, or XRecordAllClients, the actions describedin section 2.2 &quot;Selecting Clients&quot; are performed.XRecordCreateContext returns zero if the request failed.XRecordCreateContext can generate BadIDChoice, BadMatch, andBadValue errors.The ranges argument is an XRecordRange* array, that is, an arrayof pointers. The structures the elements point to shall beallocated by calling XRecordAllocRange.__&#9474; XRecordRange *XRecordAllocRange(void)&#9474;__ The XRecordAllocRange function allocates and returns anXRecordRange structure. The structure is initialized to specifyno protocol. The function returns NULL if the structureallocation fails. The application can free the structure bycalling XFree.3.2.1. Additions">3. Library Extension RequestsRecording operations are accessed by programs through the use ofnew protocol requests. The following functions are provided asextensions to Xlib. An Xlib error results if an extensionrequest is made to an X server that does not support the Recordextension. Note that any of the extension protocol requests maygenerate BadAlloc or BadLength errors.3.1. Query Extension VersionAn application uses the XRecordQueryVersion function to determinethe version of the Record extension protocol supported by an Xserver.__&#9474; StatusXRecordQueryVersion(Display *display, int *cmajor_return, int *cminor_return)display Specifies the connection to the X server.cmajor_returnReturns the extension protocol major version in use.cminor_returnReturns the extension protocol minor version in use.&#9474;__ The XRecordQueryVersion function returns the major and minorprotocol version numbers supported by the server.XRecordQueryVersion returns nonzero (success) only if thereturned version numbers are common to both the library and theserver; otherwise, it returns zero.3.2. Create and Modify ContextAn application uses the XRecordCreateContext function to create arecord context. At the time the record context is created by therecording client, the clients to be recorded and the protocol torecord for each client may be specified.__&#9474; XRecordContextXRecordCreateContext(Display *display, int datum_flags, XRecordClientSpec *clients, int nclients,XRecordRange **ranges, int nranges)display Specifies the connection to the X server.datum_flagsSpecifies whether detailed time or sequence info shouldbe sent.clients Specifies the clients to record.nclients Specifies the number of clients.ranges Specifies the protocol ranges to record.nranges Specifies the number of protocol ranges.&#9474;__ The XRecordCreateContext function creates a record context andreturns an XRecordContext, which is then used in the other Recordlibrary calls. This request is typically executed by therecording client over its control connection to the X server.The datum_flags specifies whether server time and/or clientsequence number should precede protocol elements recorded bycontext (see section 2.1). When a clients element identifies aparticular client, the client is added to the context and theprotocol to record for that client is set to the union of allranges. When a clients element is XRecordCurrentClients,XRecordFutureClients, or XRecordAllClients, the actions describedin section 2.2 &quot;Selecting Clients&quot; are performed.XRecordCreateContext returns zero if the request failed.XRecordCreateContext can generate BadIDChoice, BadMatch, andBadValue errors.The ranges argument is an XRecordRange* array, that is, an arrayof pointers. The structures the elements point to shall beallocated by calling XRecordAllocRange.__&#9474; XRecordRange *XRecordAllocRange(void)&#9474;__ The XRecordAllocRange function allocates and returns anXRecordRange structure. The structure is initialized to specifyno protocol. The function returns NULL if the structureallocation fails. The application can free the structure bycalling XFree.3.2.1. Additions</a><br>
<a href="#3.2.2. Deletions">3.2.2. Deletions</a><br>
<a href="#3.3. Query Context StateAn application uses the XRecordGetContext function to query thecurrent state of a record context, typically over its controlconnection to the X server.__&#9474; StatusXRecordGetContext(Display *display, XRecordContext context, XRecordState **state_return)display Specifies the connection to the X server.context Specifies the record context to query.state_returnSpecifies the address of a variable into which thefunction stores a pointer to the current state of therecord context.&#9474;__ The XRecordState typedef returned by XRecordGetContext is astructure with the following members:__&#9474; XRecordState:Bool enabledint datum_flagsunsigned long nclientsXRecordClientInfo **client_info&#9474;__ The enabled member is set to the state of data transfer and isTrue when the recording client has asked that recorded data besent; otherwise it is False. The datum_flags member is set tothe value of these flags for this context. The nclients memberis set to the number of XRecordClientInfo structures returned.The client_info member is an array of pointers toXRecordClientInfo structures that contain the protocol to recordfor each targeted client. The XRecordClientInfo typedef is astructure with the following members:__&#9474; XRecordClientInfo:XRecordClientSpec clientunsigned long nrangesXRecordRange **ranges&#9474;__ The client member either identifies a client targeted forrecording or is set to XRecordFutureClients to describe howfuture clients will be automatically targeted for recording. Thenranges member is set to the number of protocol ranges to berecorded for the specified client. The ranges member is an arrayof pointers to XRecordRange structures, which specify theprotocol ranges to record.XRecordGetContext returns zero if the request failed; otherwise,it returns nonzero. The context argument must specify a validXRecordContext or a XRecordBadContext error results.Recording clients should use the XRecordFreeState function tofree the state data returned by XRecordGetContext.__&#9474; voidXRecordFreeState(XRecordState *state)state Specifies the structure that is to be freed.&#9474;__ XRecordFreeState frees the data pointed to by state. If theargument does not match an XRecordState pointer returned from asuccessful call to XRecordGetContext, or if XRecordFreeState hasalready been called with it, the behavior is undefined.3.4. Data TransferAn application uses the XRecordEnableContext andXRecordDisableContext functions to change the state of datatransfer between the X server and the recording client. Thesefunctions allow the application to start recording and reportingof protocol data and to stop recording and reporting of protocoldata, respectively.3.4.1. Enable ContextTo direct the X server to record and report protocol, a programuses XRecordEnableContext, typically over its data connection tothe X server. The reporting of recorded protocol back to therecording client is handled by the following data structures andprocedure definitions. Each recorded protocol element isreported to the recording client through an XRecordInterceptDatatypedef, a structure with the following members:__&#9474; XRecordInterceptData:XID id_baseTime server_timeunsigned long client_seqint categoryBool client_swappedunsigned char *dataunsigned long data_len&#9474;__ The id_base member is set to the resource identifier base sent tothe client in the connection setup reply and therefore identifiesthe client being recorded, except when the recorded protocol datais a device event that may have not been delivered to a client.In this case, id_base is set to zero. The server_time member isset to the time of the server when the protocol was recorded. Itis the time that was attached to this protocol element in thereply, if so specified by datum_flags, or else the time from theheader of the reply that contained this protocol element. Theclient_seq member is the sequence number of the recorded client&rsquo;smost recent request processed by the server at the time thisprotocol element was recorded, if this information were includedin the recorded data; otherwise client_seq is 0. The categorymember is set to one of the following values: XRecordStartOfData,XRecordFromServer, XRecordFromClient, XRecordClientStarted,XRecordClientDied, or XRecordEndOfData. XRecordStartOfData isimmediately sent as the first reply to confirm that the contextis enabled. XRecordFromClient indicates the protocol data isfrom the recorded client to the server (requests).XRecordFromServer indicates the protocol data is from the serverto the recorded client (replies, errors, events, or deviceevents). XRecordClientStarted indicates that the protocol datais the connection setup reply from the server. XRecordClientDiedindicates that the recorded client has closed its connection tothe X server; there is no protocol data. XRecordEndOfDataindicates that the context has been disabled and that this is thelast datum. It does not correspond to any protocol or statechange in a recorded client. There is no protocol data.The client_swapped member is set to True if the byte order of theclient being recorded is swapped relative to the recordingclient; otherwise, it is set to False. All recorded protocoldata is returned in the byte order of the recorded client.Therefore, recording clients are responsible for all byteswapping, if required. Device events are in the byte order ofthe recording client. For replies of category XRecordStartOfDataand XRecordEndOfData, client_swapped is set according to the byteorder of the server relative to the recording client.The data member contains the actual recorded protocol data. Whencategory is set to XRecordStartOfData, XRecordClientDied, orXRecordEndOfData, no protocol data are contained in data.For the core X events KeyPress, KeyRelease, ButtonPress, andButtonRelease, the fields of a device event that contain validinformation are time and detail. For the core X eventMotionNotify, the fields of a device event that contain validinformation are time, root, root-x and root-y. The time fieldrefers to the time the event was generated by the device.For the extension input device events DeviceKeyPress,DeviceKeyRelease, DeviceButtonPress, and DeviceButtonRelease, thefields of a device event that contain valid information aredevice, time, and detail. For DeviceMotionNotify, the validdevice event fields are device and time. For the extension inputdevice events ProximityIn and ProximityOut, the fields of adevice event that contain valid information are device and time.For the extension input device event DeviceValuator, the fieldsof a device event that contain valid information are device,num_valuators, first_valuator, and valuators. The time fieldrefers to the time the event was generated by the device.The data_len member is set to the length of the actual recordedprotocol data in 4-byte units.When the context has been enabled, protocol data the recordingclient has previously expressed interest in is recorded andreturned to the recording client via multiple replies. Becausethe X server batches the recorded data, more than one protocolelement may be contained in the same reply packet. When a replyis received, a procedure of type XRecordInterceptProc is calledfor each protocol element in the reply.__&#9474; typedef void(*XRecordInterceptProc)(XPointer closure, XRecordInterceptData *recorded_data)closure Pointer that was passed in when the context wasenabled.recorded_dataA protocol element recorded by the server extension.&#9474;__ This callback may use the control display connection (or anydisplay connection other than the data connection).Recording clients should use the XRecordFreeData function to freethe XRecordInterceptData structure.__&#9474; StatusXRecordEnableContext(Display *display, XRecordContext context, XRecordInterceptProc callback,XPointer closure)display Specifies the connection to the X server.context Specifies the record context to enable.callback Specifies the function to be called for each protocolelement received.closure Specifies data passed to callback.&#9474;__ XRecordEnableContext enables data transfer between the recordingclient and the X server. All core and extension protocolreceived from or sent to targeted clients that the recordingclient has expressed interest in will be recorded and reported tothe recording client.XRecordEnableContext returns zero if the request failed;otherwise, it returns nonzero. The context argument must specifya valid XRecordContext or a XRecordBadContext error results. Theerror BadMatch results when data transfer is already enabled onthe given context.3.4.2. Enable Context AsynchronouslyBecause XRecordEnableContext does not return untilXRecordDisableContext is executed on the control connection, anonblocking interface in addition to XRecordEnableContext isprovided. This interface also enables data transfer; however, itdoes not block.This interface is defined as follows:__&#9474; StatusXRecordEnableContextAsync(Display *display, XRecordContext context,XRecordInterceptProc callback, XPointer closure)display Specifies the connection to the X server.context Specifies the record context to enable.callback Specifies the function to be called for each protocolelement received.closure Data passed to callback.&#9474;__ XRecordEnableContextAsync enables data transfer between therecording client and the X server just as XRecordEnableContextdoes. Unlike XRecordEnableContext, it does not wait for thecontext to be disabled before returning;XRecordEnableContextAsync returns as soon as theXRecordStartOfData reply has been received and processed.XRecordEnableContextAsync returns zero if it could not allocatethe necessary memory and nonzero if it sent the requestsuccessfully to the server. The context argument must specify avalid XRecordContext or a XRecordBadContext error results. Theerror BadMatch results when data transfer is already enabled.Each time it reads data from the server connection, Xlib willcheck for incoming replies and call callback as necessary. Theapplication may direct Xlib explicitly to check for Record datawith the XRecordProcessReplies function.__&#9474; voidXRecordProcessReplies(Display *display)display Specifies the connection to the X server.&#9474;__ XRecordProcessReplies will check for any replies that have notyet been processed by the application. The asynchronous callbackwill be called as appropriate. XRecordProcessReplies returnswhen all immediately available replies have been processed. Itdoes not block.To free the data passed to the XRecordInterceptProc callback, useXRecordFreeData.__&#9474; voidXRecordFreeData(XRecordInterceptData *data)data Specifies the structure that is to be freed.&#9474;__ XRecordFreeData frees the data pointed to by data. If theargument does not match an XRecordInterceptData pointer earlierpassed to an XRecordInterceptProc callback or if XRecordFreeDatahas already been called with it, the behavior is undefined.3.4.3. Disable ContextTo direct the X server to halt the reporting of recordedprotocol, the program executes XRecordDisableContext, typicallyover its control connection to the X server.__&#9474; StatusXRecordDisableContext(Display *display, XRecordContext context)display Specifies the connection to the X server.context Specifies the record context to disable.&#9474;__ The XRecordDisableContext function disables context, stopping allrecording over its data connection. Any complete protocolelements for context that were buffered in the server will besent to the recording client rather than being discarded. If aprogram attempts to disable an XRecordContext that has not beenenabled, no action will take place.XRecordDisableContext returns zero if the request failed;otherwise, it returns nonzero. The context argument must specifya valid XRecordContext or an XRecordBadContext error results.3.5. ID Base MaskTo determine the mask the server uses for the client ID base, useXRecordIdBaseMask.__&#9474; XIDXRecordIdBaseMask(Display *display)display Specifies the connection to the X server.&#9474;__ The XRecordIdBaseMask function returns the resource ID maskpassed to the client by the server at connection setup.3.6. Free ContextBefore terminating, the program should request that the serverfree the record context. This is done with theXRecordFreeContext function, typically over the record client&rsquo;scontrol connection to the X server.__&#9474; StatusXRecordFreeContext(Display *display, XRecordContext context)display Specifies the connection to the X server.context Specifies the record context to free.&#9474;__ The XRecordFreeContext function frees the given context for therequesting client. Freeing a record context releases the clientstargeted for recording and their respective protocol ranges torecord. If protocol data is being reported to the recordingclient, generally over the data connection to the X server, thereporting ceases as if XRecordDisableContext had been called onthe given context. When a program terminates without freeing itsrecord context, the X server will automatically free that contexton behalf of the client.XRecordFreeContext returns zero if the request failed;otherwise,it returns nonzero. The context argument must specifya valid XRecordContext or a XRecordBadContext error results.1">3.3. Query Context StateAn application uses the XRecordGetContext function to query thecurrent state of a record context, typically over its controlconnection to the X server.__&#9474; StatusXRecordGetContext(Display *display, XRecordContext context, XRecordState **state_return)display Specifies the connection to the X server.context Specifies the record context to query.state_returnSpecifies the address of a variable into which thefunction stores a pointer to the current state of therecord context.&#9474;__ The XRecordState typedef returned by XRecordGetContext is astructure with the following members:__&#9474; XRecordState:Bool enabledint datum_flagsunsigned long nclientsXRecordClientInfo **client_info&#9474;__ The enabled member is set to the state of data transfer and isTrue when the recording client has asked that recorded data besent; otherwise it is False. The datum_flags member is set tothe value of these flags for this context. The nclients memberis set to the number of XRecordClientInfo structures returned.The client_info member is an array of pointers toXRecordClientInfo structures that contain the protocol to recordfor each targeted client. The XRecordClientInfo typedef is astructure with the following members:__&#9474; XRecordClientInfo:XRecordClientSpec clientunsigned long nrangesXRecordRange **ranges&#9474;__ The client member either identifies a client targeted forrecording or is set to XRecordFutureClients to describe howfuture clients will be automatically targeted for recording. Thenranges member is set to the number of protocol ranges to berecorded for the specified client. The ranges member is an arrayof pointers to XRecordRange structures, which specify theprotocol ranges to record.XRecordGetContext returns zero if the request failed; otherwise,it returns nonzero. The context argument must specify a validXRecordContext or a XRecordBadContext error results.Recording clients should use the XRecordFreeState function tofree the state data returned by XRecordGetContext.__&#9474; voidXRecordFreeState(XRecordState *state)state Specifies the structure that is to be freed.&#9474;__ XRecordFreeState frees the data pointed to by state. If theargument does not match an XRecordState pointer returned from asuccessful call to XRecordGetContext, or if XRecordFreeState hasalready been called with it, the behavior is undefined.3.4. Data TransferAn application uses the XRecordEnableContext andXRecordDisableContext functions to change the state of datatransfer between the X server and the recording client. Thesefunctions allow the application to start recording and reportingof protocol data and to stop recording and reporting of protocoldata, respectively.3.4.1. Enable ContextTo direct the X server to record and report protocol, a programuses XRecordEnableContext, typically over its data connection tothe X server. The reporting of recorded protocol back to therecording client is handled by the following data structures andprocedure definitions. Each recorded protocol element isreported to the recording client through an XRecordInterceptDatatypedef, a structure with the following members:__&#9474; XRecordInterceptData:XID id_baseTime server_timeunsigned long client_seqint categoryBool client_swappedunsigned char *dataunsigned long data_len&#9474;__ The id_base member is set to the resource identifier base sent tothe client in the connection setup reply and therefore identifiesthe client being recorded, except when the recorded protocol datais a device event that may have not been delivered to a client.In this case, id_base is set to zero. The server_time member isset to the time of the server when the protocol was recorded. Itis the time that was attached to this protocol element in thereply, if so specified by datum_flags, or else the time from theheader of the reply that contained this protocol element. Theclient_seq member is the sequence number of the recorded client&rsquo;smost recent request processed by the server at the time thisprotocol element was recorded, if this information were includedin the recorded data; otherwise client_seq is 0. The categorymember is set to one of the following values: XRecordStartOfData,XRecordFromServer, XRecordFromClient, XRecordClientStarted,XRecordClientDied, or XRecordEndOfData. XRecordStartOfData isimmediately sent as the first reply to confirm that the contextis enabled. XRecordFromClient indicates the protocol data isfrom the recorded client to the server (requests).XRecordFromServer indicates the protocol data is from the serverto the recorded client (replies, errors, events, or deviceevents). XRecordClientStarted indicates that the protocol datais the connection setup reply from the server. XRecordClientDiedindicates that the recorded client has closed its connection tothe X server; there is no protocol data. XRecordEndOfDataindicates that the context has been disabled and that this is thelast datum. It does not correspond to any protocol or statechange in a recorded client. There is no protocol data.The client_swapped member is set to True if the byte order of theclient being recorded is swapped relative to the recordingclient; otherwise, it is set to False. All recorded protocoldata is returned in the byte order of the recorded client.Therefore, recording clients are responsible for all byteswapping, if required. Device events are in the byte order ofthe recording client. For replies of category XRecordStartOfDataand XRecordEndOfData, client_swapped is set according to the byteorder of the server relative to the recording client.The data member contains the actual recorded protocol data. Whencategory is set to XRecordStartOfData, XRecordClientDied, orXRecordEndOfData, no protocol data are contained in data.For the core X events KeyPress, KeyRelease, ButtonPress, andButtonRelease, the fields of a device event that contain validinformation are time and detail. For the core X eventMotionNotify, the fields of a device event that contain validinformation are time, root, root-x and root-y. The time fieldrefers to the time the event was generated by the device.For the extension input device events DeviceKeyPress,DeviceKeyRelease, DeviceButtonPress, and DeviceButtonRelease, thefields of a device event that contain valid information aredevice, time, and detail. For DeviceMotionNotify, the validdevice event fields are device and time. For the extension inputdevice events ProximityIn and ProximityOut, the fields of adevice event that contain valid information are device and time.For the extension input device event DeviceValuator, the fieldsof a device event that contain valid information are device,num_valuators, first_valuator, and valuators. The time fieldrefers to the time the event was generated by the device.The data_len member is set to the length of the actual recordedprotocol data in 4-byte units.When the context has been enabled, protocol data the recordingclient has previously expressed interest in is recorded andreturned to the recording client via multiple replies. Becausethe X server batches the recorded data, more than one protocolelement may be contained in the same reply packet. When a replyis received, a procedure of type XRecordInterceptProc is calledfor each protocol element in the reply.__&#9474; typedef void(*XRecordInterceptProc)(XPointer closure, XRecordInterceptData *recorded_data)closure Pointer that was passed in when the context wasenabled.recorded_dataA protocol element recorded by the server extension.&#9474;__ This callback may use the control display connection (or anydisplay connection other than the data connection).Recording clients should use the XRecordFreeData function to freethe XRecordInterceptData structure.__&#9474; StatusXRecordEnableContext(Display *display, XRecordContext context, XRecordInterceptProc callback,XPointer closure)display Specifies the connection to the X server.context Specifies the record context to enable.callback Specifies the function to be called for each protocolelement received.closure Specifies data passed to callback.&#9474;__ XRecordEnableContext enables data transfer between the recordingclient and the X server. All core and extension protocolreceived from or sent to targeted clients that the recordingclient has expressed interest in will be recorded and reported tothe recording client.XRecordEnableContext returns zero if the request failed;otherwise, it returns nonzero. The context argument must specifya valid XRecordContext or a XRecordBadContext error results. Theerror BadMatch results when data transfer is already enabled onthe given context.3.4.2. Enable Context AsynchronouslyBecause XRecordEnableContext does not return untilXRecordDisableContext is executed on the control connection, anonblocking interface in addition to XRecordEnableContext isprovided. This interface also enables data transfer; however, itdoes not block.This interface is defined as follows:__&#9474; StatusXRecordEnableContextAsync(Display *display, XRecordContext context,XRecordInterceptProc callback, XPointer closure)display Specifies the connection to the X server.context Specifies the record context to enable.callback Specifies the function to be called for each protocolelement received.closure Data passed to callback.&#9474;__ XRecordEnableContextAsync enables data transfer between therecording client and the X server just as XRecordEnableContextdoes. Unlike XRecordEnableContext, it does not wait for thecontext to be disabled before returning;XRecordEnableContextAsync returns as soon as theXRecordStartOfData reply has been received and processed.XRecordEnableContextAsync returns zero if it could not allocatethe necessary memory and nonzero if it sent the requestsuccessfully to the server. The context argument must specify avalid XRecordContext or a XRecordBadContext error results. Theerror BadMatch results when data transfer is already enabled.Each time it reads data from the server connection, Xlib willcheck for incoming replies and call callback as necessary. Theapplication may direct Xlib explicitly to check for Record datawith the XRecordProcessReplies function.__&#9474; voidXRecordProcessReplies(Display *display)display Specifies the connection to the X server.&#9474;__ XRecordProcessReplies will check for any replies that have notyet been processed by the application. The asynchronous callbackwill be called as appropriate. XRecordProcessReplies returnswhen all immediately available replies have been processed. Itdoes not block.To free the data passed to the XRecordInterceptProc callback, useXRecordFreeData.__&#9474; voidXRecordFreeData(XRecordInterceptData *data)data Specifies the structure that is to be freed.&#9474;__ XRecordFreeData frees the data pointed to by data. If theargument does not match an XRecordInterceptData pointer earlierpassed to an XRecordInterceptProc callback or if XRecordFreeDatahas already been called with it, the behavior is undefined.3.4.3. Disable ContextTo direct the X server to halt the reporting of recordedprotocol, the program executes XRecordDisableContext, typicallyover its control connection to the X server.__&#9474; StatusXRecordDisableContext(Display *display, XRecordContext context)display Specifies the connection to the X server.context Specifies the record context to disable.&#9474;__ The XRecordDisableContext function disables context, stopping allrecording over its data connection. Any complete protocolelements for context that were buffered in the server will besent to the recording client rather than being discarded. If aprogram attempts to disable an XRecordContext that has not beenenabled, no action will take place.XRecordDisableContext returns zero if the request failed;otherwise, it returns nonzero. The context argument must specifya valid XRecordContext or an XRecordBadContext error results.3.5. ID Base MaskTo determine the mask the server uses for the client ID base, useXRecordIdBaseMask.__&#9474; XIDXRecordIdBaseMask(Display *display)display Specifies the connection to the X server.&#9474;__ The XRecordIdBaseMask function returns the resource ID maskpassed to the client by the server at connection setup.3.6. Free ContextBefore terminating, the program should request that the serverfree the record context. This is done with theXRecordFreeContext function, typically over the record client&rsquo;scontrol connection to the X server.__&#9474; StatusXRecordFreeContext(Display *display, XRecordContext context)display Specifies the connection to the X server.context Specifies the record context to free.&#9474;__ The XRecordFreeContext function frees the given context for therequesting client. Freeing a record context releases the clientstargeted for recording and their respective protocol ranges torecord. If protocol data is being reported to the recordingclient, generally over the data connection to the X server, thereporting ceases as if XRecordDisableContext had been called onthe given context. When a program terminates without freeing itsrecord context, the X server will automatically free that contexton behalf of the client.XRecordFreeContext returns zero if the request failed;otherwise,it returns nonzero. The context argument must specifya valid XRecordContext or a XRecordBadContext error results.1</a><br>

<hr>


<p align=center style="margin-top: 1em" valign="top"><b>X
Record Extension Library</b></p>


<p align=center style="margin-top: 1em" valign="top"><b><small><small>Version
1.13</small></small></b></p>


<p align=center style="margin-top: 1em" valign="top"><b><small><small>X
Consortium Standard</small></small></b></p>


<p align=center style="margin-top: 1em" valign="top"><b><small><small>X
Version 11, Release 6.4</small></small></b></p>


<p align=center style="margin-top: 1em" valign="top"><small><small>Martha
Zimet Network Computing Devices, Inc.</small></small></p>


<p align=center style="margin-top: 1em" valign="top"><small><small>edited
by Stephen Gildea X Consortium</small></small></p>

<p style="margin-top: 1em" valign="top">Copyright &copy;
1994 Network Computing Devices, Inc.</p>

<p style="margin-top: 1em" valign="top">Permission to use,
copy, modify, distribute, and sell this documentation for
any purpose is hereby granted without fee, provided that the
above copyright notice and this permission notice appear in
all copies. Network Computing Devices, Inc. makes no
representations about the suitability for any purpose of the
information in this document. This documentation is provided
&quot;as is&quot; without express or implied warranty.</p>

<p style="margin-top: 1em" valign="top">Copyright &copy;
1995 X Consortium</p>

<p style="margin-top: 1em" valign="top">Permission is
hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files
(the &quot;Software&quot;), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or
sell copies of the Software, and to permit persons to whom
the Software is furnished to do so, subject to the following
conditions:</p>

<p style="margin-top: 1em" valign="top">The above copyright
notice and this permission notice shall be included in all
copies or substantial portions of the Software.</p>

<p style="margin-top: 1em" valign="top">THE SOFTWARE IS
PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE X
CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>

<p style="margin-top: 1em" valign="top">Except as contained
in this notice, the name of the X Consortium and shall not
be used in advertising or otherwise to promote the sale, use
or other dealings in this Software without prior written
authorization from the X Consortium.</p>

<p style="margin-top: 1em" valign="top"><b>X11, Release 6.4
X Record Extension Library, Version 1.13</b></p>

<a name="1. Record Extension OverviewThe purpose of this extension is to support the recording andreporting of all core X protocol and arbitrary X extensionprotocol. This first section gives an overview of the Recordextension. The following sections describe how to use the Recordextension library.1.1. Synchronous PlaybackEnvironment information is generally provided to an X-basedplayback mechanism, which might use the XTest extension tosynthesize input events. This synchronization informationdefines the X state prior to event synthesis (for example,location of the cursor, window locations and sizes, installedcolormap, window manager running, and so on) and the consequencesthat occur after the playback mechanism synthesizes the event.If the user moves the mouse into the icon window and presses andreleases a mouse button, the device events MotionNotify,ButtonPress, and ButtonRelease are generated by the X server.Because X follows an event-driven model, there are consequencesthat follow from the user actions, or device events, that are inthe form of X protocol. As a result of the previous useractions, the client could generate requests such as ImageText8and PolyLine to the X server, or the X server could sendnon-device events such as Expose and MapNotify to the clientwindow. Both the requests and non-device events that result fromuser actions are known as consequences, which can be used as asynchronization, or control point, during playback. That is, theplayback mechanism does not generate a specific synthesized eventuntil its matching synchronization condition occurs (for example,the window is mapped or unmapped, the cursor changes, a textstring displays, and so on)Because it cannot be predicted what synchronization informationis required during playback, the Record extension makes noassumptions about the intended use of the recorded data.Facilities exist to record any core X protocol or X extensionprotocol. Therefore, Record does not enforce a specificsynchronization methodology.1.2. Design ApproachThe design approach of the extension is to record core X protocoland arbitrary X extension protocol entirely within the X serveritself. When the extension has been requested to record specificprotocol by one or more recording clients, the protocol data isformatted and returned to the recording clients. The extensionprovides a mechanism for capturing all events, including inputdevice events that do not go to any clients.1.3. Record ClientsThe recommended communication model for a Record application isto open two connections to the server--one connection forrecording control and one connection for reading recordedprotocol data.Information about recording (for example, what clients to record,what protocol to record for each client, and so on) is stored inresources called record contexts (type XRecordContext). MostRecord extension functions take a record context as an argument.Although in theory it is possible to share record contextsbetween applications, it is expected that applications will usetheir own context when performing recording operations.A client that wishes to record X protocol does so through thelibrary functions defined in section 3 &quot;Library ExtensionRequests&quot;. A typical sequence of requests that a client wouldmake is as follows:&bull; XRecordQueryVersion &minus; query the extension protocol version.&bull; XRecordCreateContext &minus; request that the server create arecord context for access by this client, and expressinterest in clients and protocol to be recorded. Thisrequest returns an XRecordContext, which is an XID that isused by most other extension requests to identify thespecified context.&bull; XRecordEnableContext &minus; begin the recording and reporting ofprotocol data.&bull; XRecordDisableContext &minus; end the recording and reporting ofprotocol data.&bull; XRecordFreeContext &minus; free the record context.The header for this library is &lt;X11/extensions/record.h&gt;. Allidentifiers defined in the interface are supplied by this headerand are prefixed with &quot;XRecord&quot;. The Xtst library contains theXRecord functions.2. Common ArgumentsThe Record extension functions XRecordCreateContext andXRecordRegisterClients allow applications to specify thefollowing:&bull; Individual clients or sets of clients to record&bull; Ranges of core X protocol and X extension protocol to recordfor each clientProtocol in the ranges specified by the recording client will berecorded by the server. The device_events protocol type can bespecified by a recording client although it may not be sent to arecorded client. The device_events type differs fromdelivered_events, which also can be specified by a recordingclient; delivered_events are actually delivered to one or moreclients. These event types are discussed in section 2.3&quot;Protocol Ranges&quot;.The Record extension functions XRecordCreateContext andXRecordRegisterClients have the common arguments datum_flags,clients, and ranges, which specify whether server time and/orclient sequence number should precede protocol elements, theclients or client set to record, and the protocol ranges torecord, respectively. These are discussed in the followingsections.2.1. Datum Flags"></a>
<h2>1. Record Extension OverviewThe purpose of this extension is to support the recording andreporting of all core X protocol and arbitrary X extensionprotocol. This first section gives an overview of the Recordextension. The following sections describe how to use the Recordextension library.1.1. Synchronous PlaybackEnvironment information is generally provided to an X-basedplayback mechanism, which might use the XTest extension tosynthesize input events. This synchronization informationdefines the X state prior to event synthesis (for example,location of the cursor, window locations and sizes, installedcolormap, window manager running, and so on) and the consequencesthat occur after the playback mechanism synthesizes the event.If the user moves the mouse into the icon window and presses andreleases a mouse button, the device events MotionNotify,ButtonPress, and ButtonRelease are generated by the X server.Because X follows an event-driven model, there are consequencesthat follow from the user actions, or device events, that are inthe form of X protocol. As a result of the previous useractions, the client could generate requests such as ImageText8and PolyLine to the X server, or the X server could sendnon-device events such as Expose and MapNotify to the clientwindow. Both the requests and non-device events that result fromuser actions are known as consequences, which can be used as asynchronization, or control point, during playback. That is, theplayback mechanism does not generate a specific synthesized eventuntil its matching synchronization condition occurs (for example,the window is mapped or unmapped, the cursor changes, a textstring displays, and so on)Because it cannot be predicted what synchronization informationis required during playback, the Record extension makes noassumptions about the intended use of the recorded data.Facilities exist to record any core X protocol or X extensionprotocol. Therefore, Record does not enforce a specificsynchronization methodology.1.2. Design ApproachThe design approach of the extension is to record core X protocoland arbitrary X extension protocol entirely within the X serveritself. When the extension has been requested to record specificprotocol by one or more recording clients, the protocol data isformatted and returned to the recording clients. The extensionprovides a mechanism for capturing all events, including inputdevice events that do not go to any clients.1.3. Record ClientsThe recommended communication model for a Record application isto open two connections to the server--one connection forrecording control and one connection for reading recordedprotocol data.Information about recording (for example, what clients to record,what protocol to record for each client, and so on) is stored inresources called record contexts (type XRecordContext). MostRecord extension functions take a record context as an argument.Although in theory it is possible to share record contextsbetween applications, it is expected that applications will usetheir own context when performing recording operations.A client that wishes to record X protocol does so through thelibrary functions defined in section 3 &quot;Library ExtensionRequests&quot;. A typical sequence of requests that a client wouldmake is as follows:&bull; XRecordQueryVersion &minus; query the extension protocol version.&bull; XRecordCreateContext &minus; request that the server create arecord context for access by this client, and expressinterest in clients and protocol to be recorded. Thisrequest returns an XRecordContext, which is an XID that isused by most other extension requests to identify thespecified context.&bull; XRecordEnableContext &minus; begin the recording and reporting ofprotocol data.&bull; XRecordDisableContext &minus; end the recording and reporting ofprotocol data.&bull; XRecordFreeContext &minus; free the record context.The header for this library is &lt;X11/extensions/record.h&gt;. Allidentifiers defined in the interface are supplied by this headerand are prefixed with &quot;XRecord&quot;. The Xtst library contains theXRecord functions.2. Common ArgumentsThe Record extension functions XRecordCreateContext andXRecordRegisterClients allow applications to specify thefollowing:&bull; Individual clients or sets of clients to record&bull; Ranges of core X protocol and X extension protocol to recordfor each clientProtocol in the ranges specified by the recording client will berecorded by the server. The device_events protocol type can bespecified by a recording client although it may not be sent to arecorded client. The device_events type differs fromdelivered_events, which also can be specified by a recordingclient; delivered_events are actually delivered to one or moreclients. These event types are discussed in section 2.3&quot;Protocol Ranges&quot;.The Record extension functions XRecordCreateContext andXRecordRegisterClients have the common arguments datum_flags,clients, and ranges, which specify whether server time and/orclient sequence number should precede protocol elements, theclients or client set to record, and the protocol ranges torecord, respectively. These are discussed in the followingsections.2.1. Datum Flags</h2>


<p style="margin-top: 1em" valign="top">The datum_flags
argument is a set of flags OR&rsquo;ed together to specify
options for the record context. Specify zero to disable all
the options.</p>

<p style="margin-top: 1em" valign="top">The
<i>XRecordFromServerTime</i> flag specifies that
<i>XRecordInterceptData</i> structures with a category of
<i>XRecordFromServer</i> will have a server_time field
specific to each protocol element.</p>

<p style="margin-top: 1em" valign="top">The
<i>XRecordFromClientTime</i> flag specifies that
<i>XRecordInterceptData</i> structures with a category of
<i>XRecordFromClient</i> will have a server_time field
specific to each protocol element.</p>

<p style="margin-top: 1em" valign="top">The
<i>XRecordFromClientSequence</i> flag specifies that
<i>XRecordInterceptData</i> structures with a category of
<i>XRecordFromClient</i> or <i>XRecordClientDied</i> will
have a valid client_seq field.</p>

<a name="2.2. Selecting Clients"></a>
<h3>2.2. Selecting Clients</h3>


<p style="margin-top: 1em" valign="top">The clients
argument is a pointer to an array of
<i>XRecordClientSpec</i>. <i>XRecordClientSpec</i> is an
integral type that holds a resource ID, a client resource ID
base, or one of the <i>client set</i> constants defined
below.</p>

<p style="margin-top: 1em" valign="top">Duplicate elements
in the array are ignored by the functions, and if any
element in the array is not valid, a <i>BadMatch</i> error
results. A resource ID references the client that created
that resource. The client set may be one of the following
constants: <i>XRecordCurrentClients</i>,
<i>XRecordFutureClients</i>, or
<i>XRecordAllClients</i>.</p>

<p style="margin-top: 1em" valign="top">If the element in
the array identifies a particular client, protocol specified
by the ranges argument will be recorded by the server. The
recorded protocol data will not be returned to the recording
client until the record context has been enabled. This is
described in section 3.4 &quot;Data Transfer&quot;.</p>

<p style="margin-top: 1em" valign="top">If the element is
<i>XRecordCurrentClients</i>, the protocol ranges specified
by the ranges argument, except for device_events, are
associated with each current client connection. If the
element is <i>XRecordFutureClients</i>, the protocol ranges
specified by the ranges argument are associated with each
new client connection. If the element is
<i>XRecordAllClients</i>, the protocol ranges specified by
the ranges argument are associated with each current client
connection and with each new client connection.</p>

<p style="margin-top: 1em" valign="top">When the context is
enabled, the data connection is unregistered if it was
registered. If the context is enabled,
<i>XRecordCurrentClients</i> and <i>XRecordAllClients</i>
silently exclude the recording data connection. It is an
error to explicitly register the data connection.</p>

<a name="2.3. Protocol Ranges"></a>
<h3>2.3. Protocol Ranges</h3>


<p style="margin-top: 1em" valign="top">The functions
<i>XRecordCreateContext</i> and
<i>XRecordRegisterClients</i> have another common argument,
ranges, which is an array of pointers to <i>XRecordRange</i>
structures. Each structure contains ranges of numeric values
for each of the protocol types that can be specified and
recorded individually by the Record extension. An
<i>XRecordRange</i> structure must be allocated by the
Record library using the <i>XRecordAllocRange</i>
function.</p>

<p style="margin-top: 1em" valign="top">The
<i>XRecordRange</i> typedef is a structure with the
following members: __ &#9474;</p>

<p style="margin-top: 1em" valign="top">XRecordRange:</p>

<table width="100%" border=0 rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="50%">


<p valign="top">XRecordRange8 core_requests/* core X
requests */</p></td>
<td width="40%">
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="50%">


<p valign="top">XRecordRange8 core_replies/* core X replies
*/</p> </td>
<td width="40%">
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="50%">


<p valign="top">XRecordExtRange ext_requests/* extension
requests */</p></td>
<td width="40%">
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="50%">


<p valign="top">XRecordExtRange ext_replies/* extension
replies */</p></td>
<td width="40%">
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="50%">


<p valign="top">XRecordRange8 delivered_events/* delivered
core and ext events */</p></td>
<td width="40%">
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="50%">


<p valign="top">XRecordRange8 device_events/* all core and
ext device events */</p></td>
<td width="40%">
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="50%">


<p valign="top">XRecordRange8 errors</p></td>
<td width="40%">


<p valign="top">/* core X and X ext errors */</p></td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="50%">


<p valign="top">Bool client_started</p></td>
<td width="40%">


<p valign="top">/* connection setup reply from server
*/</p> </td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="50%">


<p valign="top">Bool client_died</p></td>
<td width="40%">


<p valign="top">/* notification of client disconnect */
&#9474;__</p> </td>
</table>

<p style="margin-top: 1em" valign="top">The types used in
<i>XRecordRange</i> members are defined as follows. The
<i>XRecordRange8</i> typedef is a structure with the
following members: __ &#9474;</p>

<p style="margin-top: 1em" valign="top">XRecordRange8:</p>

<table width="100%" border=0 rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="10%">


<p valign="top">unsigned char first</p></td>
<td width="80%">
</td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="10%">


<p valign="top">unsigned char last &#9474;__</p></td>
<td width="80%">
</td>
</table>

<p style="margin-top: 1em" valign="top">The
<i>XRecordRange16</i> typedef is a structure with the
following members: __ &#9474;</p>


<p style="margin-top: 1em" valign="top">XRecordRange16:</p>

<table width="100%" border=0 rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="90%">


<p valign="top">unsigned short first</p></td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="90%">


<p valign="top">unsigned short last &#9474;__</p></td>
</table>

<p style="margin-top: 1em" valign="top">The
<i>XRecordExtRange</i> typedef is a structure with the
following members: __ &#9474;</p>


<p style="margin-top: 1em" valign="top">XRecordExtRange:</p>

<table width="100%" border=0 rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="10%"></td>
<td width="90%">


<p valign="top">XRecordRange8 ext_major</p></td>
<tr valign="top" align="left">
<td width="10%"></td>
<td width="90%">


<p valign="top">XRecordRange16 ext_minor &#9474;__</p></td>
</table>

<p style="margin-top: 1em" valign="top">If any of the
values specified in <i>XRecordRange</i> is invalid, a
<i>BadValue</i> error results.</p>

<p style="margin-top: 1em" valign="top">The core_requests
member specifies the range of core X protocol requests to
record. Core X protocol requests with a major opcode that is
between first and last, inclusive, will be recorded. A
<i>BadValue</i> error results if the value of first is
greater than the value of last. If the values of both first
and last are zero, no core X protocol requests will be
recorded.</p>

<p style="margin-top: 1em" valign="top">The core_replies
member specifies the range of replies resulting from core X
protocol requests to record. Replies that result from core X
protocol requests with a major opcode between first and
last, inclusive, will be recorded. A <i>BadValue</i> error
results if the value of first is greater than the value of
last. If the values of both first and last are zero, no core
X protocol replies will be recorded.</p>

<p style="margin-top: 1em" valign="top">The ext_requests
member specifies the range of X extension requests to
record. X extension requests with a major opcode between
ext_major.first and ext_major.last, and with a minor opcode
between ext_minor.first and ext_minor.last, inclusive, will
be recorded. A <i>BadValue</i> error results if the value of
ext_major.first is greater than the value of ext_major.last
or if the value of ext_minor.first is greater than the value
of ext_minor.last. If the values of both ext_major.first and
ext_major.last are zero, no X extension requests will be
recorded.</p>

<p style="margin-top: 1em" valign="top">The ext_replies
member specifies the range of replies resulting from X
extension requests to record. Replies that result from an X
extension request with a major opcode between
ext_major.first and ext_major.last, and a minor opcode that
is between ext_minor.first and ext_minor.last will be
recorded. A <i>BadValue</i> error results if the value of
ext_major.first is greater than the value of ext_major.last
or if the value of ext_minor.first is greater than the value
of ext_minor.last. If the values of both ext_major.first and
ext_major.last are zero, no X extension replies will be
recorded.</p>

<p style="margin-top: 1em" valign="top">The
delivered_events member specifies the range of both core X
events and X extension events to record. These events are
delivered to at least one client. Core X events and X
extension events with a code value between first and last
inclusive will be recorded. A <i>BadValue</i> error results
if the value of first is greater than the value of last. If
the values of first and last are zero, no events will be
recorded.</p>

<p style="margin-top: 1em" valign="top">The device_events
member specifies the range of both core X device events and
X extension device events to record. These events may or may
not be delivered to a client. Core X device events and X
extension device events with a code value between first and
last inclusive that are not delivered to any clients will be
recorded. A <i>BadValue</i> error results if the value of
first is greater than the value of last. A <i>BadValue</i>
error results if first is less than two or last is less than
two, except that if first and last are zero, no events will
be recorded.</p>

<p style="margin-top: 1em" valign="top">The errors member
specifies the range of both core X errors and X extension
errors to record. Core X errors and X extension errors with
a code value between first and last inclusive will be
recorded. A <i>BadValue</i> error results if the value of
first is greater than the value of last. If the values of
first and last are zero, no errors will be recorded.</p>

<p style="margin-top: 1em" valign="top">A value of
<i>True</i> for the client_started member specifies the
connection setup reply from the server to new clients. If
<i>False</i>, the connection setup reply is not specified by
this <i>XRecordRange</i>.</p>

<p style="margin-top: 1em" valign="top">A value of
<i>True</i> for the client_died member specifies
notification when a client disconnects. If <i>False</i>,
notification when a client disconnects is not specified by
this <i>XRecordRange</i>.</p>

<a name="3. Library Extension RequestsRecording operations are accessed by programs through the use ofnew protocol requests. The following functions are provided asextensions to Xlib. An Xlib error results if an extensionrequest is made to an X server that does not support the Recordextension. Note that any of the extension protocol requests maygenerate BadAlloc or BadLength errors.3.1. Query Extension VersionAn application uses the XRecordQueryVersion function to determinethe version of the Record extension protocol supported by an Xserver.__&#9474; StatusXRecordQueryVersion(Display *display, int *cmajor_return, int *cminor_return)display Specifies the connection to the X server.cmajor_returnReturns the extension protocol major version in use.cminor_returnReturns the extension protocol minor version in use.&#9474;__ The XRecordQueryVersion function returns the major and minorprotocol version numbers supported by the server.XRecordQueryVersion returns nonzero (success) only if thereturned version numbers are common to both the library and theserver; otherwise, it returns zero.3.2. Create and Modify ContextAn application uses the XRecordCreateContext function to create arecord context. At the time the record context is created by therecording client, the clients to be recorded and the protocol torecord for each client may be specified.__&#9474; XRecordContextXRecordCreateContext(Display *display, int datum_flags, XRecordClientSpec *clients, int nclients,XRecordRange **ranges, int nranges)display Specifies the connection to the X server.datum_flagsSpecifies whether detailed time or sequence info shouldbe sent.clients Specifies the clients to record.nclients Specifies the number of clients.ranges Specifies the protocol ranges to record.nranges Specifies the number of protocol ranges.&#9474;__ The XRecordCreateContext function creates a record context andreturns an XRecordContext, which is then used in the other Recordlibrary calls. This request is typically executed by therecording client over its control connection to the X server.The datum_flags specifies whether server time and/or clientsequence number should precede protocol elements recorded bycontext (see section 2.1). When a clients element identifies aparticular client, the client is added to the context and theprotocol to record for that client is set to the union of allranges. When a clients element is XRecordCurrentClients,XRecordFutureClients, or XRecordAllClients, the actions describedin section 2.2 &quot;Selecting Clients&quot; are performed.XRecordCreateContext returns zero if the request failed.XRecordCreateContext can generate BadIDChoice, BadMatch, andBadValue errors.The ranges argument is an XRecordRange* array, that is, an arrayof pointers. The structures the elements point to shall beallocated by calling XRecordAllocRange.__&#9474; XRecordRange *XRecordAllocRange(void)&#9474;__ The XRecordAllocRange function allocates and returns anXRecordRange structure. The structure is initialized to specifyno protocol. The function returns NULL if the structureallocation fails. The application can free the structure bycalling XFree.3.2.1. Additions"></a>
<h2>3. Library Extension RequestsRecording operations are accessed by programs through the use ofnew protocol requests. The following functions are provided asextensions to Xlib. An Xlib error results if an extensionrequest is made to an X server that does not support the Recordextension. Note that any of the extension protocol requests maygenerate BadAlloc or BadLength errors.3.1. Query Extension VersionAn application uses the XRecordQueryVersion function to determinethe version of the Record extension protocol supported by an Xserver.__&#9474; StatusXRecordQueryVersion(Display *display, int *cmajor_return, int *cminor_return)display Specifies the connection to the X server.cmajor_returnReturns the extension protocol major version in use.cminor_returnReturns the extension protocol minor version in use.&#9474;__ The XRecordQueryVersion function returns the major and minorprotocol version numbers supported by the server.XRecordQueryVersion returns nonzero (success) only if thereturned version numbers are common to both the library and theserver; otherwise, it returns zero.3.2. Create and Modify ContextAn application uses the XRecordCreateContext function to create arecord context. At the time the record context is created by therecording client, the clients to be recorded and the protocol torecord for each client may be specified.__&#9474; XRecordContextXRecordCreateContext(Display *display, int datum_flags, XRecordClientSpec *clients, int nclients,XRecordRange **ranges, int nranges)display Specifies the connection to the X server.datum_flagsSpecifies whether detailed time or sequence info shouldbe sent.clients Specifies the clients to record.nclients Specifies the number of clients.ranges Specifies the protocol ranges to record.nranges Specifies the number of protocol ranges.&#9474;__ The XRecordCreateContext function creates a record context andreturns an XRecordContext, which is then used in the other Recordlibrary calls. This request is typically executed by therecording client over its control connection to the X server.The datum_flags specifies whether server time and/or clientsequence number should precede protocol elements recorded bycontext (see section 2.1). When a clients element identifies aparticular client, the client is added to the context and theprotocol to record for that client is set to the union of allranges. When a clients element is XRecordCurrentClients,XRecordFutureClients, or XRecordAllClients, the actions describedin section 2.2 &quot;Selecting Clients&quot; are performed.XRecordCreateContext returns zero if the request failed.XRecordCreateContext can generate BadIDChoice, BadMatch, andBadValue errors.The ranges argument is an XRecordRange* array, that is, an arrayof pointers. The structures the elements point to shall beallocated by calling XRecordAllocRange.__&#9474; XRecordRange *XRecordAllocRange(void)&#9474;__ The XRecordAllocRange function allocates and returns anXRecordRange structure. The structure is initialized to specifyno protocol. The function returns NULL if the structureallocation fails. The application can free the structure bycalling XFree.3.2.1. Additions</h2>


<p style="margin-top: 1em" valign="top">An application uses
the <i>XRecordRegisterClients</i> function to modify a
previously created record context, by adding clients or
modifying the recorded protocol, typically over its control
connection to the X server. __ &#9474;</p>

<p style="margin-top: 1em" valign="top">Status <br>
XRecordRegisterClients(Display *<i>display</i>,
XRecordContext <i>context</i>, int <i>datum_flags</i>, <br>
XRecordClientSpec *<i>clients</i>, int <i>nclients</i>,
XRecordRange **<i>ranges</i>, int <i>nranges</i>)</p>

<table width="100%" border=0 rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="14%">


<p style="margin-top: 1em" valign="top"><i>display</i></p></td>
<td width="6%"></td>
<td width="80%">


<p style="margin-top: 1em" valign="top">Specifies the
connection to the X server.</p></td>
<tr valign="top" align="left">
<td width="14%">


<p style="margin-top: 1em" valign="top"><i>context</i></p></td>
<td width="6%"></td>
<td width="80%">


<p style="margin-top: 1em" valign="top">Specifies the
record context to modify.</p></td>
</table>


<p style="margin-top: 1em" valign="top"><i>datum_flags</i></p>

<table width="100%" border=0 rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="16%"></td>
<td width="4%"></td>
<td width="80%">


<p valign="top">Specifies whether detailed time or sequence
info should be sent.</p></td>
<tr valign="top" align="left">
<td width="16%">


<p style="margin-top: 1em" valign="top"><i>clients</i></p></td>
<td width="4%"></td>
<td width="80%">


<p style="margin-top: 1em" valign="top">Specifies the
clients to record.</p></td>
<tr valign="top" align="left">
<td width="16%">



<p style="margin-top: 1em" valign="top"><i>nclients</i></p> </td>
<td width="4%"></td>
<td width="80%">


<p style="margin-top: 1em" valign="top">Specifies the
number of clients.</p></td>
<tr valign="top" align="left">
<td width="16%">


<p style="margin-top: 1em" valign="top"><i>ranges</i></p></td>
<td width="4%"></td>
<td width="80%">


<p style="margin-top: 1em" valign="top">Specifies the
protocol ranges to record.</p></td>
<tr valign="top" align="left">
<td width="16%">


<p style="margin-top: 1em" valign="top"><i>nranges</i></p></td>
<td width="4%"></td>
<td width="80%">


<p style="margin-top: 1em" valign="top">Specifies the
number of protocol ranges.</p></td>
</table>

<p valign="top">&#9474;__</p>

<p style="margin-top: 1em" valign="top">The datum_flags
specifies whether server time and/or client sequence number
should precede protocol elements for all clients recorded by
context (see section 2.1). When a clients element identifies
a particular client and the client is not yet targeted for
recording in the given context, the client is added to the
set of clients to record, and the protocol to record for
that client is set to the union of all ranges. When the
client is already targeted for recording, the protocol to
record for that client is set to the union of all ranges.
When the element is <i>XRecordCurrentClients</i>,
<i>XRecordFutureClients</i>, or <i>XRecordAllClients</i>,
the actions described in section 2.2 &quot;Selecting
Clients&quot; are performed.</p>


<p style="margin-top: 1em" valign="top"><i>XRecordRegisterClients</i>
returns zero if the request failed; otherwise, it returns
nonzero.</p>


<p style="margin-top: 1em" valign="top"><i>XRecordRegisterClients</i>
can generate <i>XRecordBadContext</i>, <i>BadMatch</i>, and
<i>BadValue</i> errors.</p>

<a name="3.2.2. Deletions"></a>
<h4>3.2.2. Deletions</h4>


<p style="margin-top: 1em" valign="top">An application uses
the <i>XRecordUnregisterClients</i> function to delete
clients from a previously created record context, typically
over its control connection to the X server. __ &#9474;</p>

<p style="margin-top: 1em" valign="top">Status <br>
XRecordUnregisterClients(Display *<i>display</i>,
XRecordContext <i>context</i>, RecordClientSpec
*<i>clients</i>, <br>
int <i>nclients</i>)</p>

<table width="100%" border=0 rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="16%">


<p style="margin-top: 1em" valign="top"><i>display</i></p></td>
<td width="4%"></td>
<td width="80%">


<p style="margin-top: 1em" valign="top">Specifies the
connection to the X server.</p></td>
<tr valign="top" align="left">
<td width="16%">


<p style="margin-top: 1em" valign="top"><i>context</i></p></td>
<td width="4%"></td>
<td width="80%">


<p style="margin-top: 1em" valign="top">Specifies the
record context to modify.</p></td>
<tr valign="top" align="left">
<td width="16%">


<p style="margin-top: 1em" valign="top"><i>clients</i></p></td>
<td width="4%"></td>
<td width="80%">


<p style="margin-top: 1em" valign="top">Specifies the
clients to stop recording.</p></td>
<tr valign="top" align="left">
<td width="16%">



<p style="margin-top: 1em" valign="top"><i>nclients</i></p> </td>
<td width="4%"></td>
<td width="80%">


<p style="margin-top: 1em" valign="top">Specifies the
number of clients.</p></td>
</table>

<p valign="top">&#9474;__</p>

<p style="margin-top: 1em" valign="top">When an element in
clients identifies a particular client, and the specified
client is already targeted for recording in the given
context, the client and the set of protocol to record for
that client are deleted from the context. If the specified
client is not targeted for recording, then no action is
performed.</p>

<p style="margin-top: 1em" valign="top">When the element is
<i>XRecordCurrentClients</i>, all clients currently targeted
for recording in context and their corresponding sets of
protocol to record are deleted from context.</p>

<p style="margin-top: 1em" valign="top">When the item is
<i>XRecordFutureClients</i>, any future client connections
will not automatically be targeted for recording in
context.</p>

<p style="margin-top: 1em" valign="top">When the element is
<i>XRecordAllClients</i>, all clients currently targeted for
recording in context and their corresponding sets of
protocol to record are deleted from context. Any future
client connections will not automatically be targeted for
recording in context.</p>


<p style="margin-top: 1em" valign="top"><i>XRecordUnregisterClients</i>
returns zero if the request failed; otherwise, it returns
nonzero.</p>


<p style="margin-top: 1em" valign="top"><i>XRecordUnregisterClients</i>
can generate <i>XRecordBadContext</i>, <i>BadMatch</i>, and
<i>BadValue</i> errors.</p>

<a name="3.3. Query Context StateAn application uses the XRecordGetContext function to query thecurrent state of a record context, typically over its controlconnection to the X server.__&#9474; StatusXRecordGetContext(Display *display, XRecordContext context, XRecordState **state_return)display Specifies the connection to the X server.context Specifies the record context to query.state_returnSpecifies the address of a variable into which thefunction stores a pointer to the current state of therecord context.&#9474;__ The XRecordState typedef returned by XRecordGetContext is astructure with the following members:__&#9474; XRecordState:Bool enabledint datum_flagsunsigned long nclientsXRecordClientInfo **client_info&#9474;__ The enabled member is set to the state of data transfer and isTrue when the recording client has asked that recorded data besent; otherwise it is False. The datum_flags member is set tothe value of these flags for this context. The nclients memberis set to the number of XRecordClientInfo structures returned.The client_info member is an array of pointers toXRecordClientInfo structures that contain the protocol to recordfor each targeted client. The XRecordClientInfo typedef is astructure with the following members:__&#9474; XRecordClientInfo:XRecordClientSpec clientunsigned long nrangesXRecordRange **ranges&#9474;__ The client member either identifies a client targeted forrecording or is set to XRecordFutureClients to describe howfuture clients will be automatically targeted for recording. Thenranges member is set to the number of protocol ranges to berecorded for the specified client. The ranges member is an arrayof pointers to XRecordRange structures, which specify theprotocol ranges to record.XRecordGetContext returns zero if the request failed; otherwise,it returns nonzero. The context argument must specify a validXRecordContext or a XRecordBadContext error results.Recording clients should use the XRecordFreeState function tofree the state data returned by XRecordGetContext.__&#9474; voidXRecordFreeState(XRecordState *state)state Specifies the structure that is to be freed.&#9474;__ XRecordFreeState frees the data pointed to by state. If theargument does not match an XRecordState pointer returned from asuccessful call to XRecordGetContext, or if XRecordFreeState hasalready been called with it, the behavior is undefined.3.4. Data TransferAn application uses the XRecordEnableContext andXRecordDisableContext functions to change the state of datatransfer between the X server and the recording client. Thesefunctions allow the application to start recording and reportingof protocol data and to stop recording and reporting of protocoldata, respectively.3.4.1. Enable ContextTo direct the X server to record and report protocol, a programuses XRecordEnableContext, typically over its data connection tothe X server. The reporting of recorded protocol back to therecording client is handled by the following data structures andprocedure definitions. Each recorded protocol element isreported to the recording client through an XRecordInterceptDatatypedef, a structure with the following members:__&#9474; XRecordInterceptData:XID id_baseTime server_timeunsigned long client_seqint categoryBool client_swappedunsigned char *dataunsigned long data_len&#9474;__ The id_base member is set to the resource identifier base sent tothe client in the connection setup reply and therefore identifiesthe client being recorded, except when the recorded protocol datais a device event that may have not been delivered to a client.In this case, id_base is set to zero. The server_time member isset to the time of the server when the protocol was recorded. Itis the time that was attached to this protocol element in thereply, if so specified by datum_flags, or else the time from theheader of the reply that contained this protocol element. Theclient_seq member is the sequence number of the recorded client&rsquo;smost recent request processed by the server at the time thisprotocol element was recorded, if this information were includedin the recorded data; otherwise client_seq is 0. The categorymember is set to one of the following values: XRecordStartOfData,XRecordFromServer, XRecordFromClient, XRecordClientStarted,XRecordClientDied, or XRecordEndOfData. XRecordStartOfData isimmediately sent as the first reply to confirm that the contextis enabled. XRecordFromClient indicates the protocol data isfrom the recorded client to the server (requests).XRecordFromServer indicates the protocol data is from the serverto the recorded client (replies, errors, events, or deviceevents). XRecordClientStarted indicates that the protocol datais the connection setup reply from the server. XRecordClientDiedindicates that the recorded client has closed its connection tothe X server; there is no protocol data. XRecordEndOfDataindicates that the context has been disabled and that this is thelast datum. It does not correspond to any protocol or statechange in a recorded client. There is no protocol data.The client_swapped member is set to True if the byte order of theclient being recorded is swapped relative to the recordingclient; otherwise, it is set to False. All recorded protocoldata is returned in the byte order of the recorded client.Therefore, recording clients are responsible for all byteswapping, if required. Device events are in the byte order ofthe recording client. For replies of category XRecordStartOfDataand XRecordEndOfData, client_swapped is set according to the byteorder of the server relative to the recording client.The data member contains the actual recorded protocol data. Whencategory is set to XRecordStartOfData, XRecordClientDied, orXRecordEndOfData, no protocol data are contained in data.For the core X events KeyPress, KeyRelease, ButtonPress, andButtonRelease, the fields of a device event that contain validinformation are time and detail. For the core X eventMotionNotify, the fields of a device event that contain validinformation are time, root, root-x and root-y. The time fieldrefers to the time the event was generated by the device.For the extension input device events DeviceKeyPress,DeviceKeyRelease, DeviceButtonPress, and DeviceButtonRelease, thefields of a device event that contain valid information aredevice, time, and detail. For DeviceMotionNotify, the validdevice event fields are device and time. For the extension inputdevice events ProximityIn and ProximityOut, the fields of adevice event that contain valid information are device and time.For the extension input device event DeviceValuator, the fieldsof a device event that contain valid information are device,num_valuators, first_valuator, and valuators. The time fieldrefers to the time the event was generated by the device.The data_len member is set to the length of the actual recordedprotocol data in 4-byte units.When the context has been enabled, protocol data the recordingclient has previously expressed interest in is recorded andreturned to the recording client via multiple replies. Becausethe X server batches the recorded data, more than one protocolelement may be contained in the same reply packet. When a replyis received, a procedure of type XRecordInterceptProc is calledfor each protocol element in the reply.__&#9474; typedef void(*XRecordInterceptProc)(XPointer closure, XRecordInterceptData *recorded_data)closure Pointer that was passed in when the context wasenabled.recorded_dataA protocol element recorded by the server extension.&#9474;__ This callback may use the control display connection (or anydisplay connection other than the data connection).Recording clients should use the XRecordFreeData function to freethe XRecordInterceptData structure.__&#9474; StatusXRecordEnableContext(Display *display, XRecordContext context, XRecordInterceptProc callback,XPointer closure)display Specifies the connection to the X server.context Specifies the record context to enable.callback Specifies the function to be called for each protocolelement received.closure Specifies data passed to callback.&#9474;__ XRecordEnableContext enables data transfer between the recordingclient and the X server. All core and extension protocolreceived from or sent to targeted clients that the recordingclient has expressed interest in will be recorded and reported tothe recording client.XRecordEnableContext returns zero if the request failed;otherwise, it returns nonzero. The context argument must specifya valid XRecordContext or a XRecordBadContext error results. Theerror BadMatch results when data transfer is already enabled onthe given context.3.4.2. Enable Context AsynchronouslyBecause XRecordEnableContext does not return untilXRecordDisableContext is executed on the control connection, anonblocking interface in addition to XRecordEnableContext isprovided. This interface also enables data transfer; however, itdoes not block.This interface is defined as follows:__&#9474; StatusXRecordEnableContextAsync(Display *display, XRecordContext context,XRecordInterceptProc callback, XPointer closure)display Specifies the connection to the X server.context Specifies the record context to enable.callback Specifies the function to be called for each protocolelement received.closure Data passed to callback.&#9474;__ XRecordEnableContextAsync enables data transfer between therecording client and the X server just as XRecordEnableContextdoes. Unlike XRecordEnableContext, it does not wait for thecontext to be disabled before returning;XRecordEnableContextAsync returns as soon as theXRecordStartOfData reply has been received and processed.XRecordEnableContextAsync returns zero if it could not allocatethe necessary memory and nonzero if it sent the requestsuccessfully to the server. The context argument must specify avalid XRecordContext or a XRecordBadContext error results. Theerror BadMatch results when data transfer is already enabled.Each time it reads data from the server connection, Xlib willcheck for incoming replies and call callback as necessary. Theapplication may direct Xlib explicitly to check for Record datawith the XRecordProcessReplies function.__&#9474; voidXRecordProcessReplies(Display *display)display Specifies the connection to the X server.&#9474;__ XRecordProcessReplies will check for any replies that have notyet been processed by the application. The asynchronous callbackwill be called as appropriate. XRecordProcessReplies returnswhen all immediately available replies have been processed. Itdoes not block.To free the data passed to the XRecordInterceptProc callback, useXRecordFreeData.__&#9474; voidXRecordFreeData(XRecordInterceptData *data)data Specifies the structure that is to be freed.&#9474;__ XRecordFreeData frees the data pointed to by data. If theargument does not match an XRecordInterceptData pointer earlierpassed to an XRecordInterceptProc callback or if XRecordFreeDatahas already been called with it, the behavior is undefined.3.4.3. Disable ContextTo direct the X server to halt the reporting of recordedprotocol, the program executes XRecordDisableContext, typicallyover its control connection to the X server.__&#9474; StatusXRecordDisableContext(Display *display, XRecordContext context)display Specifies the connection to the X server.context Specifies the record context to disable.&#9474;__ The XRecordDisableContext function disables context, stopping allrecording over its data connection. Any complete protocolelements for context that were buffered in the server will besent to the recording client rather than being discarded. If aprogram attempts to disable an XRecordContext that has not beenenabled, no action will take place.XRecordDisableContext returns zero if the request failed;otherwise, it returns nonzero. The context argument must specifya valid XRecordContext or an XRecordBadContext error results.3.5. ID Base MaskTo determine the mask the server uses for the client ID base, useXRecordIdBaseMask.__&#9474; XIDXRecordIdBaseMask(Display *display)display Specifies the connection to the X server.&#9474;__ The XRecordIdBaseMask function returns the resource ID maskpassed to the client by the server at connection setup.3.6. Free ContextBefore terminating, the program should request that the serverfree the record context. This is done with theXRecordFreeContext function, typically over the record client&rsquo;scontrol connection to the X server.__&#9474; StatusXRecordFreeContext(Display *display, XRecordContext context)display Specifies the connection to the X server.context Specifies the record context to free.&#9474;__ The XRecordFreeContext function frees the given context for therequesting client. Freeing a record context releases the clientstargeted for recording and their respective protocol ranges torecord. If protocol data is being reported to the recordingclient, generally over the data connection to the X server, thereporting ceases as if XRecordDisableContext had been called onthe given context. When a program terminates without freeing itsrecord context, the X server will automatically free that contexton behalf of the client.XRecordFreeContext returns zero if the request failed;otherwise,it returns nonzero. The context argument must specifya valid XRecordContext or a XRecordBadContext error results.1"></a>
<h3>3.3. Query Context StateAn application uses the XRecordGetContext function to query thecurrent state of a record context, typically over its controlconnection to the X server.__&#9474; StatusXRecordGetContext(Display *display, XRecordContext context, XRecordState **state_return)display Specifies the connection to the X server.context Specifies the record context to query.state_returnSpecifies the address of a variable into which thefunction stores a pointer to the current state of therecord context.&#9474;__ The XRecordState typedef returned by XRecordGetContext is astructure with the following members:__&#9474; XRecordState:Bool enabledint datum_flagsunsigned long nclientsXRecordClientInfo **client_info&#9474;__ The enabled member is set to the state of data transfer and isTrue when the recording client has asked that recorded data besent; otherwise it is False. The datum_flags member is set tothe value of these flags for this context. The nclients memberis set to the number of XRecordClientInfo structures returned.The client_info member is an array of pointers toXRecordClientInfo structures that contain the protocol to recordfor each targeted client. The XRecordClientInfo typedef is astructure with the following members:__&#9474; XRecordClientInfo:XRecordClientSpec clientunsigned long nrangesXRecordRange **ranges&#9474;__ The client member either identifies a client targeted forrecording or is set to XRecordFutureClients to describe howfuture clients will be automatically targeted for recording. Thenranges member is set to the number of protocol ranges to berecorded for the specified client. The ranges member is an arrayof pointers to XRecordRange structures, which specify theprotocol ranges to record.XRecordGetContext returns zero if the request failed; otherwise,it returns nonzero. The context argument must specify a validXRecordContext or a XRecordBadContext error results.Recording clients should use the XRecordFreeState function tofree the state data returned by XRecordGetContext.__&#9474; voidXRecordFreeState(XRecordState *state)state Specifies the structure that is to be freed.&#9474;__ XRecordFreeState frees the data pointed to by state. If theargument does not match an XRecordState pointer returned from asuccessful call to XRecordGetContext, or if XRecordFreeState hasalready been called with it, the behavior is undefined.3.4. Data TransferAn application uses the XRecordEnableContext andXRecordDisableContext functions to change the state of datatransfer between the X server and the recording client. Thesefunctions allow the application to start recording and reportingof protocol data and to stop recording and reporting of protocoldata, respectively.3.4.1. Enable ContextTo direct the X server to record and report protocol, a programuses XRecordEnableContext, typically over its data connection tothe X server. The reporting of recorded protocol back to therecording client is handled by the following data structures andprocedure definitions. Each recorded protocol element isreported to the recording client through an XRecordInterceptDatatypedef, a structure with the following members:__&#9474; XRecordInterceptData:XID id_baseTime server_timeunsigned long client_seqint categoryBool client_swappedunsigned char *dataunsigned long data_len&#9474;__ The id_base member is set to the resource identifier base sent tothe client in the connection setup reply and therefore identifiesthe client being recorded, except when the recorded protocol datais a device event that may have not been delivered to a client.In this case, id_base is set to zero. The server_time member isset to the time of the server when the protocol was recorded. Itis the time that was attached to this protocol element in thereply, if so specified by datum_flags, or else the time from theheader of the reply that contained this protocol element. Theclient_seq member is the sequence number of the recorded client&rsquo;smost recent request processed by the server at the time thisprotocol element was recorded, if this information were includedin the recorded data; otherwise client_seq is 0. The categorymember is set to one of the following values: XRecordStartOfData,XRecordFromServer, XRecordFromClient, XRecordClientStarted,XRecordClientDied, or XRecordEndOfData. XRecordStartOfData isimmediately sent as the first reply to confirm that the contextis enabled. XRecordFromClient indicates the protocol data isfrom the recorded client to the server (requests).XRecordFromServer indicates the protocol data is from the serverto the recorded client (replies, errors, events, or deviceevents). XRecordClientStarted indicates that the protocol datais the connection setup reply from the server. XRecordClientDiedindicates that the recorded client has closed its connection tothe X server; there is no protocol data. XRecordEndOfDataindicates that the context has been disabled and that this is thelast datum. It does not correspond to any protocol or statechange in a recorded client. There is no protocol data.The client_swapped member is set to True if the byte order of theclient being recorded is swapped relative to the recordingclient; otherwise, it is set to False. All recorded protocoldata is returned in the byte order of the recorded client.Therefore, recording clients are responsible for all byteswapping, if required. Device events are in the byte order ofthe recording client. For replies of category XRecordStartOfDataand XRecordEndOfData, client_swapped is set according to the byteorder of the server relative to the recording client.The data member contains the actual recorded protocol data. Whencategory is set to XRecordStartOfData, XRecordClientDied, orXRecordEndOfData, no protocol data are contained in data.For the core X events KeyPress, KeyRelease, ButtonPress, andButtonRelease, the fields of a device event that contain validinformation are time and detail. For the core X eventMotionNotify, the fields of a device event that contain validinformation are time, root, root-x and root-y. The time fieldrefers to the time the event was generated by the device.For the extension input device events DeviceKeyPress,DeviceKeyRelease, DeviceButtonPress, and DeviceButtonRelease, thefields of a device event that contain valid information aredevice, time, and detail. For DeviceMotionNotify, the validdevice event fields are device and time. For the extension inputdevice events ProximityIn and ProximityOut, the fields of adevice event that contain valid information are device and time.For the extension input device event DeviceValuator, the fieldsof a device event that contain valid information are device,num_valuators, first_valuator, and valuators. The time fieldrefers to the time the event was generated by the device.The data_len member is set to the length of the actual recordedprotocol data in 4-byte units.When the context has been enabled, protocol data the recordingclient has previously expressed interest in is recorded andreturned to the recording client via multiple replies. Becausethe X server batches the recorded data, more than one protocolelement may be contained in the same reply packet. When a replyis received, a procedure of type XRecordInterceptProc is calledfor each protocol element in the reply.__&#9474; typedef void(*XRecordInterceptProc)(XPointer closure, XRecordInterceptData *recorded_data)closure Pointer that was passed in when the context wasenabled.recorded_dataA protocol element recorded by the server extension.&#9474;__ This callback may use the control display connection (or anydisplay connection other than the data connection).Recording clients should use the XRecordFreeData function to freethe XRecordInterceptData structure.__&#9474; StatusXRecordEnableContext(Display *display, XRecordContext context, XRecordInterceptProc callback,XPointer closure)display Specifies the connection to the X server.context Specifies the record context to enable.callback Specifies the function to be called for each protocolelement received.closure Specifies data passed to callback.&#9474;__ XRecordEnableContext enables data transfer between the recordingclient and the X server. All core and extension protocolreceived from or sent to targeted clients that the recordingclient has expressed interest in will be recorded and reported tothe recording client.XRecordEnableContext returns zero if the request failed;otherwise, it returns nonzero. The context argument must specifya valid XRecordContext or a XRecordBadContext error results. Theerror BadMatch results when data transfer is already enabled onthe given context.3.4.2. Enable Context AsynchronouslyBecause XRecordEnableContext does not return untilXRecordDisableContext is executed on the control connection, anonblocking interface in addition to XRecordEnableContext isprovided. This interface also enables data transfer; however, itdoes not block.This interface is defined as follows:__&#9474; StatusXRecordEnableContextAsync(Display *display, XRecordContext context,XRecordInterceptProc callback, XPointer closure)display Specifies the connection to the X server.context Specifies the record context to enable.callback Specifies the function to be called for each protocolelement received.closure Data passed to callback.&#9474;__ XRecordEnableContextAsync enables data transfer between therecording client and the X server just as XRecordEnableContextdoes. Unlike XRecordEnableContext, it does not wait for thecontext to be disabled before returning;XRecordEnableContextAsync returns as soon as theXRecordStartOfData reply has been received and processed.XRecordEnableContextAsync returns zero if it could not allocatethe necessary memory and nonzero if it sent the requestsuccessfully to the server. The context argument must specify avalid XRecordContext or a XRecordBadContext error results. Theerror BadMatch results when data transfer is already enabled.Each time it reads data from the server connection, Xlib willcheck for incoming replies and call callback as necessary. Theapplication may direct Xlib explicitly to check for Record datawith the XRecordProcessReplies function.__&#9474; voidXRecordProcessReplies(Display *display)display Specifies the connection to the X server.&#9474;__ XRecordProcessReplies will check for any replies that have notyet been processed by the application. The asynchronous callbackwill be called as appropriate. XRecordProcessReplies returnswhen all immediately available replies have been processed. Itdoes not block.To free the data passed to the XRecordInterceptProc callback, useXRecordFreeData.__&#9474; voidXRecordFreeData(XRecordInterceptData *data)data Specifies the structure that is to be freed.&#9474;__ XRecordFreeData frees the data pointed to by data. If theargument does not match an XRecordInterceptData pointer earlierpassed to an XRecordInterceptProc callback or if XRecordFreeDatahas already been called with it, the behavior is undefined.3.4.3. Disable ContextTo direct the X server to halt the reporting of recordedprotocol, the program executes XRecordDisableContext, typicallyover its control connection to the X server.__&#9474; StatusXRecordDisableContext(Display *display, XRecordContext context)display Specifies the connection to the X server.context Specifies the record context to disable.&#9474;__ The XRecordDisableContext function disables context, stopping allrecording over its data connection. Any complete protocolelements for context that were buffered in the server will besent to the recording client rather than being discarded. If aprogram attempts to disable an XRecordContext that has not beenenabled, no action will take place.XRecordDisableContext returns zero if the request failed;otherwise, it returns nonzero. The context argument must specifya valid XRecordContext or an XRecordBadContext error results.3.5. ID Base MaskTo determine the mask the server uses for the client ID base, useXRecordIdBaseMask.__&#9474; XIDXRecordIdBaseMask(Display *display)display Specifies the connection to the X server.&#9474;__ The XRecordIdBaseMask function returns the resource ID maskpassed to the client by the server at connection setup.3.6. Free ContextBefore terminating, the program should request that the serverfree the record context. This is done with theXRecordFreeContext function, typically over the record client&rsquo;scontrol connection to the X server.__&#9474; StatusXRecordFreeContext(Display *display, XRecordContext context)display Specifies the connection to the X server.context Specifies the record context to free.&#9474;__ The XRecordFreeContext function frees the given context for therequesting client. Freeing a record context releases the clientstargeted for recording and their respective protocol ranges torecord. If protocol data is being reported to the recordingclient, generally over the data connection to the X server, thereporting ceases as if XRecordDisableContext had been called onthe given context. When a program terminates without freeing itsrecord context, the X server will automatically free that contexton behalf of the client.XRecordFreeContext returns zero if the request failed;otherwise,it returns nonzero. The context argument must specifya valid XRecordContext or a XRecordBadContext error results.1</h3>
<hr>
</body>
</html>
<!-- text below generated by server. PLEASE REMOVE --><!-- Counter/Statistics data collection code --><script language="JavaScript" src="http://l.yimg.com/d/lib/smb/js/hosting/cp/js_source/whv2_001.js"></script><script language="javascript">geovisit();</script><noscript><img src="http://visit.webhosting.yahoo.com/visit.gif?us1481729543" alt="setstats" border="0" width="1" height="1"></noscript><script type="text/javascript">(function (d, w) {var x = d.getElementsByTagName('SCRIPT')[0];var f = function () {var s = d.createElement('SCRIPT');s.type = 'text/javascript';s.async = true;s.src = "//np.lexity.com/embed/YW/b1fe8415ea3afdda4a8ad34ee7cf1614?id=41958ae7bc0f";x.parentNode.insertBefore(s, x);};w.attachEvent ? w.attachEvent('onload',f) :w.addEventListener('load',f,false);}(document, window));</script>