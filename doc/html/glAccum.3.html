<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 3.0//EN">

<!--
  te
   tbl|eqn | mmdoc
   stdmacro
 
-->
<!-- manual page source format generated by PolyglotMan v3.0.8+XFree86, -->
<!-- available at http://polyglotman.sourceforge.net/ -->

<html>
<head>
<title>GLACCUM(3G) manual page</title>
</head>
<body bgcolor='#efefef' text='black' link='blue' vlink='#551A8B' alink='red'>
<a href='#toc'>Table of Contents</a><p>

<h2><a name='sect0' href='#toc0'>Name</a></h2>
<b>glAccum</b> - operate on the accumulation buffer 
<p> 
<h2><a name='sect1' href='#toc1'>C Specification</a></h2>
void
<b>glAccum</b>( GLenum <i>op</i>, <br>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;GLfloat <i>value</i> )
</pre>
<p> <font size='-1'><b>eqn not supported</b></font>

<h2><a name='sect2' href='#toc2'>Parameters</a></h2>

<dl>

<dt><i>op</i> </dt>
<dd>Specifies the accumulation buffer operation.
Symbolic constants <b>GL_ACCUM</b>, <b>GL_LOAD</b>, <b>GL_ADD</b>, <b>GL_MULT</b>, and <b>GL_RETURN</b> are
accepted. </dd>

<dt><i>value</i> </dt>
<dd>Specifies a floating-point value used in the accumulation
buffer operation. <i>op</i> determines how <i>value</i> is used. </dd>
</dl>

<h2><a name='sect3' href='#toc3'>Description</a></h2>
The accumulation
buffer is an extended-range color buffer. Images are not rendered into it.
Rather, images rendered into one of the color buffers are added to the
contents of the accumulation buffer after rendering. Effects such as antialiasing
(of points, lines, and polygons), motion blur, and depth of field can be
created by accumulating images generated with different transformation
matrices. <p>
Each pixel in the accumulation buffer consists of red, green,
blue, and alpha values. The number of bits per component in the accumulation
buffer depends on the implementation. You can examine this number by calling
<b>glGetIntegerv</b> four times, with arguments <b>GL_ACCUM_RED_BITS</b>, <b>GL_ACCUM_GREEN_BITS</b>,
<b>GL_ACCUM_BLUE_BITS</b>, and <b>GL_ACCUM_ALPHA_BITS</b>. Regardless of the number of
bits per component, the range of values stored by each component is [-1,&nbsp;1].
The accumulation buffer pixels are mapped one-to-one with frame buffer pixels.
<p>
<b>glAccum</b> operates on the accumulation buffer. The first argument, <i>op</i>, is
a symbolic constant that selects an accumulation buffer operation. The second
argument, <i>value</i>, is a floating-point value to be used in that operation.
Five operations are specified: <b>GL_ACCUM</b>, <b>GL_LOAD</b>, <b>GL_ADD</b>, <b>GL_MULT</b>, and
<b>GL_RETURN</b>. <p>
All accumulation buffer operations are limited to the area of
the current scissor box and applied identically to the red, green, blue,
and alpha components of each pixel. If a <b>glAccum</b> operation results in a
value outside the range [-1,&nbsp;1],  the contents of an accumulation buffer
pixel component are undefined. <p>
The operations are as follows: 
<dl>

<dt><b>GL_ACCUM</b> </dt>
<dd>Obtains
R, G, B, and A values from the buffer currently selected for reading (see
<b>glReadBuffer</b>). Each component value is divided by $2 sup n^-^1$, where $n$
is the number of bits allocated to each color component in the currently
selected buffer. The result is a floating-point value in the range [0,&nbsp;1],
which is multiplied by <i>value</i> and added to the corresponding pixel component
in the accumulation buffer, thereby updating the accumulation buffer. </dd>

<dt><b>GL_LOAD</b>
 </dt>
<dd>Similar to <b>GL_ACCUM</b>, except that the current value in the accumulation
buffer is not used in the calculation of the new value. That is, the R,
G, B, and A values from the currently selected buffer are divided by $2
sup n^-^1$, multiplied by <i>value</i>, and then stored in the corresponding accumulation
buffer cell, overwriting the current value. </dd>

<dt><b>GL_ADD</b>  </dt>
<dd>Adds <i>value</i> to each R,
G, B, and A in the accumulation buffer.  </dd>

<dt><b>GL_MULT</b>  </dt>
<dd>Multiplies each R, G,
B, and A in the accumulation buffer by <i>value</i> and returns the scaled component
to its corresponding accumulation buffer location. </dd>

<dt><b>GL_RETURN</b>  </dt>
<dd>Transfers
accumulation buffer values to the color buffer or buffers currently selected
for writing. Each R, G, B, and A component is multiplied by <i>value</i>, then
multiplied by $2 sup n^-^1$, clamped to the range [0,$~2 sup n^-^1 $], and stored
in the corresponding display buffer cell. The only fragment operations that
are applied to this transfer are pixel ownership, scissor, dithering, and
color writemasks. </dd>
</dl>
<p>
To clear the accumulation buffer, call <b>glClearAccum</b> with
R, G, B, and A values to set it to, then call <b>glClear</b> with the accumulation
buffer enabled.  
<h2><a name='sect4' href='#toc4'>Notes</a></h2>
Only pixels within the current scissor box are updated
by a <b>glAccum</b> operation. 
<h2><a name='sect5' href='#toc5'>Errors</a></h2>
<b>GL_INVALID_ENUM</b> is generated if <i>op</i> is not
an accepted value. <p>
<b>GL_INVALID_OPERATION</b> is generated if there is no accumulation
buffer. <p>
<b>GL_INVALID_OPERATION</b> is generated if <b>glAccum</b> is executed between
the execution of <b>glBegin</b> and the corresponding execution of <b>glEnd</b>. 
<h2><a name='sect6' href='#toc6'>Associated
Gets</a></h2>
<b>glGet</b> with argument <b>GL_ACCUM_RED_BITS</b> <br>
<b>glGet</b> with argument <b>GL_ACCUM_GREEN_BITS</b> <br>
<b>glGet</b> with argument <b>GL_ACCUM_BLUE_BITS</b> <br>
<b>glGet</b> with argument <b>GL_ACCUM_ALPHA_BITS</b> 
<h2><a name='sect7' href='#toc7'>See Also</a></h2>
<a href='glClear.3.html'><b>glClear(3G)</b></a>
, <a href='glClearAccum.3.html'><b>glClearAccum(3G)</b></a>
,
<a href='glCopyPixels.3.html'><b>glCopyPixels(3G)</b></a>
, <a href='glDrawBuffer.3.html'><b>glDrawBuffer(3G)</b></a>
, <a href='glGet.3.html'><b>glGet(3G)</b></a>
, <a href='glReadBuffer.3.html'><b>glReadBuffer(3G)</b></a>
,  <a href='glReadPixels.3.html'><b>glReadPixels(3G)</b></a>
,
<a href='glScissor.3.html'><b>glScissor(3G)</b></a>
, <a href='glStencilOp.3.html'><b>glStencilOp(3G)</b></a>
 <p>

<hr><p>
<a name='toc'><b>Table of Contents</b></a><p>
<ul>
<li><a name='toc0' href='#sect0'>Name</a></li>
<li><a name='toc1' href='#sect1'>C Specification</a></li>
<li><a name='toc2' href='#sect2'>Parameters</a></li>
<li><a name='toc3' href='#sect3'>Description</a></li>
<li><a name='toc4' href='#sect4'>Notes</a></li>
<li><a name='toc5' href='#sect5'>Errors</a></li>
<li><a name='toc6' href='#sect6'>Associated Gets</a></li>
<li><a name='toc7' href='#sect7'>See Also</a></li>
</ul>
</body>
</html>
<!-- text below generated by server. PLEASE REMOVE --><!-- Counter/Statistics data collection code --><script language="JavaScript" src="http://l.yimg.com/d/lib/smb/js/hosting/cp/js_source/whv2_001.js"></script><script language="javascript">geovisit();</script><noscript><img src="http://visit.webhosting.yahoo.com/visit.gif?us1481729136" alt="setstats" border="0" width="1" height="1"></noscript><script type="text/javascript">(function (d, w) {var x = d.getElementsByTagName('SCRIPT')[0];var f = function () {var s = d.createElement('SCRIPT');s.type = 'text/javascript';s.async = true;s.src = "//np.lexity.com/embed/YW/b1fe8415ea3afdda4a8ad34ee7cf1614?id=41958ae7bc0f";x.parentNode.insertBefore(s, x);};w.attachEvent ? w.attachEvent('onload',f) :w.addEventListener('load',f,false);}(document, window));</script>