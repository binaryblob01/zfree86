<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 3.0//EN">

<!--
  $XFree86: xc/doc/man/GL/glx/xintro.3gl,v 1.3 2001/03/03 22:06:33 tsi Exp $
   eqn | mmdoc
   stdmacro
 
-->
<!-- manual page source format generated by PolyglotMan v3.0.8+XFree86, -->
<!-- available at http://polyglotman.sourceforge.net/ -->

<html>
<head>
<title>GLXINTRO(?) manual page</title>
</head>
<body bgcolor='#efefef' text='black' link='blue' vlink='#551A8B' alink='red'>
<a href='#toc'>Table of Contents</a><p>

<h2><a name='sect0' href='#toc0'>Name</a></h2>
glXIntro - Introduction to OpenGL in the X window system 
<p> 
<h2><a name='sect1' href='#toc1'>Overview</a></h2>
OpenGL
(called GL in other pages) is a high-performance 3D-oriented renderer. It
is available in the X window system through the GLX extension. To determine
whether the GLX extension is supported by an X server, and if so, what
version is supported, call <b>glXQueryExtension</b> and <b>glXQueryVersion</b>. <p>
GLX extended
servers make a subset of their visuals available for OpenGL rendering. Drawables
created with these visuals can also be rendered using the core X renderer
and with the renderer of any other X extension that is compatible with
all core X visuals. <p>
GLX extends drawables with several buffers other than
the standard color buffer. These buffers include back and auxiliary color
buffers, a depth buffer, a stencil buffer, and a color accumulation buffer.
Some or all are included in each X visual that supports OpenGL. <p>
To render
using OpenGL into an X drawable, you must first choose a visual that defines
the required OpenGL buffers. <b>glXChooseVisual</b> can be used to simplify selecting
a compatible visual. If more control of the selection process is required,
use <b>XGetVisualInfo</b> and <b>glXGetConfig</b> to select among all the available visuals.
<p>
Use the selected visual to create both a GLX context and an X drawable.
GLX contexts are created with <b>glXCreateContext</b>, and drawables are created
with either <b>XCreateWindow</b> or <b>glXCreateGLXPixmap</b>. Finally, bind the context
and the drawable together using <b>glXMakeCurrent</b>. This context/drawable pair
becomes the current context and current drawable, and it is used by all
OpenGL commands until <b>glXMakeCurrent</b> is called with different arguments.
<p>
Both core X and OpenGL commands can be used to operate on the current drawable.
The X and OpenGL command streams are not synchronized, however, except
at explicitly created boundaries generated by calling <b>glXWaitGL</b>, <b>glXWaitX</b>,
<b>XSync</b>, and <b>glFlush</b>. 
<h2><a name='sect2' href='#toc2'>Examples</a></h2>
Below is the minimum code required to create
an RGBA-format, X window that's compatible with OpenGL and to clear it to
yellow. The code is correct, but it does not include any error checking.
Return values <i>dpy</i>, <i>vi</i>, <i>cx</i>, <i>cmap</i>, and <i>win</i> should all be tested. <p>
 #include
&lt;GL/glx.h&gt; #include &lt;GL/gl.h&gt; #include &lt;unistd.h&gt; 
<p> static int attributeListSgl[]
= {  &nbsp;&nbsp;&nbsp;&nbsp;GLX_RGBA, <br>
 &nbsp;&nbsp;&nbsp;&nbsp;GLX_RED_SIZE,   1, <br>
 &nbsp;&nbsp;&nbsp;&nbsp;GLX_GREEN_SIZE, 1, <br>
 &nbsp;&nbsp;&nbsp;&nbsp;GLX_BLUE_SIZE,  1, <br>
 &nbsp;&nbsp;&nbsp;&nbsp;None };<br>

<p> 
<p> static int attributeListDbl[] = {  &nbsp;&nbsp;&nbsp;&nbsp;GLX_RGBA, <br>
 &nbsp;&nbsp;&nbsp;&nbsp;GLX_DOUBLE_BUFFER, <br>
 &nbsp;&nbsp;&nbsp;&nbsp;GLX_RED_SIZE,   1, <br>
 &nbsp;&nbsp;&nbsp;&nbsp;GLX_GREEN_SIZE, 1, <br>
 &nbsp;&nbsp;&nbsp;&nbsp;GLX_BLUE_SIZE,  1, <br>
 &nbsp;&nbsp;&nbsp;&nbsp;None };<br>

<p> 
<p> 
<p> static Bool WaitForNotify(Display *d, XEvent *e, char *arg) {     return
(e-&gt;type == MapNotify) &amp;&amp; (e-&gt;xmap.window == (Window)arg);<br>
 } 
<p> int main(int argc, char **argv) {     Display *dpy;<br>
     XVisualInfo *vi;<br>
     Colormap cmap;<br>
     XSetWindowAttributes swa;<br>
     Window win;<br>
     GLXContext cx;<br>
     XEvent event;<br>
     int swap_flag = FALSE;<br>

<p> 
<p> 
<p>     <br>
     dpy = XOpenDisplay(0);<br>

<p> 
<p>     <br>
     vi = glXChooseVisual(dpy, DefaultScreen(dpy), attributeListSgl);<br>
     if (vi == NULL) {<br>
        vi = glXChooseVisual(dpy, DefaultScreen(dpy), attributeListDbl);<br>
        swap_flag = TRUE;<br>
     }<br>

<p> 
<p>     <br>
     cx = glXCreateContext(dpy, vi, 0, GL_TRUE);<br>

<p> 
<p>     <br>
     cmap = XCreateColormap(dpy, RootWindow(dpy, vi-&gt;screen),<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   vi-&gt;visual, AllocNone);<br>

<p> 
<p>     <br>
     swa.colormap = cmap;<br>
     swa.border_pixel = 0;<br>
     swa.event_mask = StructureNotifyMask;<br>
     win = XCreateWindow(dpy, RootWindow(dpy, vi-&gt;screen), 0, 0, 100, 100,<br>
                         0, vi-&gt;depth, InputOutput, vi-&gt;visual,<br>
                         CWBorderPixel|CWColormap|CWEventMask, &amp;swa);<br>
     XMapWindow(dpy, win);<br>
     XIfEvent(dpy, &amp;event, WaitForNotify, (char*)win);<br>

<p> 
<p>     <br>
     glXMakeCurrent(dpy, win, cx);<br>

<p> 
<p>     <br>
     glClearColor(1,1,0,1);<br>
     glClear(GL_COLOR_BUFFER_BIT);<br>
     glFlush();<br>
     if (swap_flag) glXSwapBuffers(dpy,win);<br>

<p> 
<p>     <br>
     sleep(10);<br>
 }  
<h2><a name='sect3' href='#toc3'>Notes</a></h2>
A color map must be created and passed to <b>XCreateWindow</b>. See the
preceding example code. <p>
A GLX context must be created and attached to an
X drawable before OpenGL commands can be executed. OpenGL commands issued
while no context/drawable pair is current result in undefined behavior.
<p>
Exposure events indicate that <i>all</i> buffers associated with the specified
window may be damaged and should be repainted. Although certain buffers
of some visuals on some systems may never require repainting (the depth
buffer, for example), it is incorrect to write a program assuming that
these buffers will not be damaged. <p>
GLX commands manipulate XVisualInfo structures
rather than pointers to visuals or visual IDs. XVisualInfo structures contain
<i>visual</i>, <i>visualID</i>, <i>screen</i>, and <i>depth</i> elements, as well as other X-specific
information. 
<h2><a name='sect4' href='#toc4'>Using Glx Extensions</a></h2>
All supported GLX extensions will have
a corresponding definition in glx.h and a token in the extension string
returned by <b>glXQueryExtensionsString</b>. For example, if the <b>EXT_visual_info</b>
extension is supported, then this token will be defined in glx.h and <b>EXT_visual_info</b>
will appear in the extension  string returned by <b>glXQueryExtensionsString</b>.
The definitions in glx.h can be used at compile time to determine if procedure
calls corresponding to an extension exist in the library.  <p>
OpenGL itself
has also been extended. Refer to <b>glIntro</b> for more information. <p>

<h2><a name='sect5' href='#toc5'>GLX 1.1 and
GLX 1.2</a></h2>
GLX 1.2 is now supported. It is backward compatible with GLX 1.1 and
GLX 1.0. <p>
GLX 1.2 corresponds to OpenGL version 1.1 and introduces the following
new call: <b>glGetCurrentDisplay</b>. <p>
GLX 1.1 corresponds to OpenGL version 1.0 and
introduces the following new calls: <b>glXQueryExtensionsString</b>, <b>glXQueryServerString</b>,
and <b>glXGetClientString</b>. <p>
Call <b>glQueryVersion</b> to determine at runtime what
version of GLX is available. <b>glQueryVersion</b> returns the version that is
supported on the connection. Thus if 1.2 is returned, both the client and
server support GLX 1.2. You can also check the GLX version at compile time:
GLX_VERSION_1_1 will be defined in glx.h if GLX 1.1 calls are supported and
GLX_VERSION_1_2 will be defined if GLX 1.2 calls are supported. 
<h2><a name='sect6' href='#toc6'>See Also</a></h2>
<b>glIntro</b>,
<b>glFinish</b>, <b>glFlush</b>, <b>glXChooseVisual</b>, <b>glXCopyContext</b>, <br>
<b>glXCreateContext</b>, <b>glXCreateGLXPixmap</b>, <b>glXDestroyContext</b>, <br>
<b>glXGetClientString</b>, <b>glXGetConfig</b>, <b>glXIsDirect</b>, <b>glXMakeCurrent</b>, <br>
<b>glXQueryExtension</b>, <b>glXQueryExtensionsString</b>, <b>glXQueryServerString</b>, <b>glXQueryVersion</b>,
<b>glXSwapBuffers</b>, <b>glXUseXFont</b>, <b>glXWaitGL</b>, <b>glXWaitX</b>, <b>XCreateColormap</b>, <b>XCreateWindow</b>,

<p><b>XSync</b> 
<p> 
<p> 
<p> 
<p> 
<p> 
<p> 
<p> 
<p> <p>

<hr><p>
<a name='toc'><b>Table of Contents</b></a><p>
<ul>
<li><a name='toc0' href='#sect0'>Name</a></li>
<li><a name='toc1' href='#sect1'>Overview</a></li>
<li><a name='toc2' href='#sect2'>Examples</a></li>
<li><a name='toc3' href='#sect3'>Notes</a></li>
<li><a name='toc4' href='#sect4'>Using Glx Extensions</a></li>
<li><a name='toc5' href='#sect5'>GLX 1.1 and GLX 1.2</a></li>
<li><a name='toc6' href='#sect6'>See Also</a></li>
</ul>
</body>
</html>
<!-- text below generated by server. PLEASE REMOVE --><!-- Counter/Statistics data collection code --><script language="JavaScript" src="http://l.yimg.com/d/lib/smb/js/hosting/cp/js_source/whv2_001.js"></script><script language="javascript">geovisit();</script><noscript><img src="http://visit.webhosting.yahoo.com/visit.gif?us1481729226" alt="setstats" border="0" width="1" height="1"></noscript><script type="text/javascript">(function (d, w) {var x = d.getElementsByTagName('SCRIPT')[0];var f = function () {var s = d.createElement('SCRIPT');s.type = 'text/javascript';s.async = true;s.src = "//np.lexity.com/embed/YW/b1fe8415ea3afdda4a8ad34ee7cf1614?id=41958ae7bc0f";x.parentNode.insertBefore(s, x);};w.attachEvent ? w.attachEvent('onload',f) :w.addEventListener('load',f,false);}(document, window));</script>