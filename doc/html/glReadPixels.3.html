<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 3.0//EN">

<!--
  $XFree86: xc/doc/man/GL/gl/readpixels.3gl,v 1.4 2003/10/22 20:36:31 tsi Exp $
   te
   tbl|eqn | mmdoc
   stdmacro
 
-->
<!-- manual page source format generated by PolyglotMan v3.0.8+XFree86, -->
<!-- available at http://polyglotman.sourceforge.net/ -->

<html>
<head>
<title>GLREADPIXELS(3G) manual page</title>
</head>
<body bgcolor='#efefef' text='black' link='blue' vlink='#551A8B' alink='red'>
<a href='#toc'>Table of Contents</a><p>

<h2><a name='sect0' href='#toc0'>Name</a></h2>
<b>glReadPixels</b> - read a block of pixels from the frame buffer 
<p> 
<h2><a name='sect1' href='#toc1'>C Specification</a></h2>
void
<b>glReadPixels</b>( GLint <i>x</i>, <br>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;GLint <i>y</i>,
&nbsp;&nbsp;&nbsp;&nbsp;GLsizei <i>width</i>,
&nbsp;&nbsp;&nbsp;&nbsp;GLsizei <i>height</i>,
&nbsp;&nbsp;&nbsp;&nbsp;GLenum <i>format</i>,
&nbsp;&nbsp;&nbsp;&nbsp;GLenum <i>type</i>,
&nbsp;&nbsp;&nbsp;&nbsp;GLvoid <i>*pixels</i> )
</pre>
<p> <font size='-1'><b>eqn not supported</b></font>

<h2><a name='sect2' href='#toc2'>Parameters</a></h2>

<dl>

<dt><i>x</i>, <i>y</i> </dt>
<dd>Specify the window coordinates of the
first pixel that is read from the frame buffer. This location is the lower
left corner of a rectangular block of pixels. </dd>

<dt><i>width</i>, <i>height</i> </dt>
<dd>Specify the
dimensions of the pixel rectangle. <i>width</i> and <i>height</i> of one correspond to
a single pixel. </dd>

<dt><i>format</i> </dt>
<dd>Specifies the  of the pixel data. The following symbolic
values are accepted: <b>GL_COLOR_INDEX</b>, <b>GL_STENCIL_INDEX</b>, <b>GL_DEPTH_COMPONENT</b>,
<b>GL_RED</b>, <b>GL_GREEN</b>, <b>GL_BLUE</b>, <b>GL_ALPHA</b>, <b>GL_RGB</b>, <b>GL_BGR</b>, <b>GL_RGBA</b>, <b>GL_BGRA</b>,
<b>GL_LUMINANCE</b>, and <b>GL_LUMINANCE_ALPHA</b>. </dd>

<dt><i>type</i> </dt>
<dd>Specifies the data type of the
pixel data. Must be one of <b>GL_UNSIGNED_BYTE</b>, <b>GL_BYTE</b>, <b>GL_BITMAP</b>, <b>GL_UNSIGNED_SHORT</b>,
<b>GL_SHORT</b>, <b>GL_UNSIGNED_INT</b>, <b>GL_INT</b>, <b>GL_FLOAT</b>, <b>GL_UNSIGNED_BYTE_3_3_2</b>, <b>GL_UNSIGNED_BYTE_2_3_3_REV</b>,
<b>GL_UNSIGNED_SHORT_5_6_5</b>, <b>GL_UNSIGNED_SHORT_5_6_5_REV</b>, <b>GL_UNSIGNED_SHORT_4_4_4_4</b>,
<b>GL_UNSIGNED_SHORT_4_4_4_4_REV</b>, <b>GL_UNSIGNED_SHORT_5_5_5_1</b>, <b>GL_UNSIGNED_SHORT_1_5_5_5_REV</b>,
<b>GL_UNSIGNED_INT_8_8_8_8</b>, <b>GL_UNSIGNED_INT_8_8_8_8_REV</b>, <b>GL_UNSIGNED_INT_10_10_10_2</b>,
or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>. </dd>

<dt><i>pixels</i> </dt>
<dd>Returns the pixel data. </dd>
</dl>

<h2><a name='sect3' href='#toc3'>Description</a></h2>
<b>glReadPixels</b>
returns pixel data from the frame buffer, starting with the pixel whose
lower left corner is at location (<i>x</i>, <i>y</i>), into client memory starting at
location <i>pixels</i>. Several parameters control the processing of the pixel
data before it is placed into client memory. These parameters are set with
three commands: <b>glPixelStore</b>, <b>glPixelTransfer</b>, and <b>glPixelMap</b>. This reference
page describes the effects on <b>glReadPixels</b> of most, but not all of the
parameters specified by these three commands. <p>
When the <b>GL_ARB_imaging</b> extension
is supported, the pixel data may be processed by additional operations
including color table lookup, color matrix transformations, convolutions,
histograms and minimum and maximun pixel value computations. <p>
<b>glReadPixels</b>
returns values from each pixel with lower left corner at (<i>x</i> + $i$, <i>y</i> +
$j$) for 0 &lt;= $i$ &lt; <i>width</i> and  0 &lt;= $j$ &lt; <i>height</i>. This pixel is said to be the
$i$th pixel in the $j$th row.  Pixels are returned in row order from the
lowest to the highest row, left to right in each row. <p>
<i>format</i> specifies the
 for the returned pixel values; accepted values are: 
<dl>

<dt><b>GL_COLOR_INDEX</b> </dt>
<dd>Color
indices are read from the color buffer selected by <b>glReadBuffer</b>. Each index
is converted to fixed point, shifted left or right depending on the value
and sign of <b>GL_INDEX_SHIFT</b>, and added to <b>GL_INDEX_OFFSET</b>.  If <b>GL_MAP_COLOR</b>
is <b>GL_TRUE</b>, indices are replaced by their mappings in the table <b>GL_PIXEL_MAP_I_TO_I</b>.
</dd>

<dt><b>GL_STENCIL_INDEX</b> </dt>
<dd>Stencil values are read from the stencil buffer. Each index
is converted to fixed point, shifted left or right depending on the value
and sign of <b>GL_INDEX_SHIFT</b>, and added to <b>GL_INDEX_OFFSET</b>.  If <b>GL_MAP_STENCIL</b>
is <b>GL_TRUE</b>, indices are replaced by their mappings in the table <b>GL_PIXEL_MAP_S_TO_S</b>.
</dd>

<dt><b>GL_DEPTH_COMPONENT</b> </dt>
<dd>Depth values are read from the depth buffer. Each component
is converted to floating point such that the minimum depth value maps to
0 and the maximum value maps to 1. Each component is then multiplied by
<b>GL_DEPTH_SCALE</b>, added to <b>GL_DEPTH_BIAS</b>, and finally clamped to the range
[0,1]. </dd>

<dt><b>GL_RED</b> </dt>
<dd></dd>

<dt><b>GL_GREEN</b> </dt>
<dd></dd>

<dt><b>GL_BLUE</b> </dt>
<dd></dd>

<dt><b>GL_ALPHA</b> </dt>
<dd></dd>

<dt><b>GL_RGB</b> </dt>
<dd></dd>

<dt><b>GL_BGR</b> </dt>
<dd></dd>

<dt><b>GL_RGBA</b> </dt>
<dd></dd>

<dt><b>GL_BGRA</b> </dt>
<dd></dd>

<dt><b>GL_LUMINANCE</b>
</dt>
<dd></dd>

<dt><b>GL_LUMINANCE_ALPHA</b> </dt>
<dd>Processing differs depending on whether color buffers
store color indices or RGBA color components. If color indices are stored,
they are read from the color buffer selected by <b>glReadBuffer</b>. Each index
is converted to fixed point, shifted left or right depending on the value
and sign of <b>GL_INDEX_SHIFT</b>, and added to <b>GL_INDEX_OFFSET</b>.  Indices are then
replaced by the red, green, blue, and alpha values obtained by indexing
the tables <b>GL_PIXEL_MAP_I_TO_R</b>, <b>GL_PIXEL_MAP_I_TO_G</b>, <b>GL_PIXEL_MAP_I_TO_B</b>,
and <b>GL_PIXEL_MAP_I_TO_A</b>. Each table must be of size $2 sup n$, but $n$ may
be different for  different tables.  Before an index is used to look up
a value in a table of size $2 sup n$, it must be masked against $2 sup
n - 1$. </dl>
</dd>
</dl>
<p>
If RGBA color components are stored in the color buffers, they are
read from the color buffer selected by <b>glReadBuffer</b>. Each color component
is converted to floating point such that zero intensity maps to 0.0 and
full intensity maps to 1.0. Each component is then multiplied by <b>GL_c_SCALE</b>
and added to <b>GL_c_BIAS</b>, where <i>c</i> is RED, GREEN, BLUE, or ALPHA.  Finally,
if <b>GL_MAP_COLOR</b> is <b>GL_TRUE</b>, each component is clamped to the range [0,&nbsp;1],
scaled to the size of its corresponding table, and is then  replaced by
its mapping in the table <b>GL_PIXEL_MAP_c_TO_c</b>, where <i>c</i> is R, G, B, or A.
</dl>
<p>
Unneeded data is then discarded. For example, <b>GL_RED</b> discards the green,
blue, and alpha components, while <b>GL_RGB</b> discards only the alpha component.
<b>GL_LUMINANCE</b> computes a single-component value as the sum of the red, green,
and blue components, and <b>GL_LUMINANCE_ALPHA</b> does the same, while keeping
alpha as a second value. The final values are clamped to the range [0,&nbsp;1].
<p>
The shift, scale, bias, and lookup factors just described are all specified
by  <br>
<b>glPixelTransfer</b>. The lookup table contents themselves are specified by <b>glPixelMap</b>.
<p>
Finally, the indices or components are converted to the proper , as specified
by <i>type</i>. If <i>format</i> is <b>GL_COLOR_INDEX</b> or <b>GL_STENCIL_INDEX</b> and <i>type</i> is not
<b>GL_FLOAT</b>, each index is masked with the mask value given in the following
table. If <i>type</i> is <b>GL_FLOAT</b>, then each integer index is converted to single-precision
floating-point . <p>
If <i>format</i> is <b>GL_RED</b>, <b>GL_GREEN</b>, <b>GL_BLUE</b>, <b>GL_ALPHA</b>, <b>GL_RGB</b>,
<b>GL_BGR</b>, <b>GL_RGBA</b>, <b>GL_BGRA</b>, <b>GL_LUMINANCE</b>, or <b>GL_LUMINANCE_ALPHA</b> and <i>type</i>
is not <b>GL_FLOAT</b>, each component is multiplied by the multiplier shown in
the following table. If type is <b>GL_FLOAT</b>, then each component is passed
as is (or converted to the client's single-precision floating-point  if it
is different from the one used by the GL). <p>
<table border='0'>
<tr> <tr><td align='left'><i>type</i></td><td align='center'><b>index mask</b></td><td align='center'><b>component conversion</b></td></tr>
<tr>
<p>
<tr><td align='left'><b>GL_UNSIGNED_BYTE</b></td><td align='center'>$2"^"8 - 1$</td><td align='center'>$(2"^"8 - 1)  c$</td></tr>
<tr><td align='left'><b>GL_BYTE</b></td><td align='center'>$2"^"7 - 1$</td><td align='center'>$[(2"^"8 - 1) c - 1]
/ 2$</td></tr>
<tr><td align='left'><b>GL_BITMAP</b></td><td align='center'>$1$</td><td align='center'>$1$</td></tr>
<tr><td align='left'><b>GL_UNSIGNED_SHORT</b></td><td align='center'>$2"^"16 - 1$</td><td align='center'>$(2"^"16 - 1) c$</td></tr>
<tr><td align='left'><b>GL_SHORT</b></td><td align='center'>$2"^"15
- 1$</td><td align='center'>$[(2"^"16 - 1) c - 1] / 2$</td></tr>
<tr><td align='left'><b>GL_UNSIGNED_INT</b></td><td align='center'>$2"^"32 - 1$</td><td align='center'>$(2"^"32 - 1) c$</td></tr>
<tr><td align='left'><b>GL_INT</b></td><td align='center'>$2"^"31
- 1$</td><td align='center'>$[(2"^"32 - 1) c - 1] / 2$</td></tr>
<tr><td align='left'><b>GL_FLOAT</b></td><td align='center'>none</td><td align='center'>$c$</td></tr>
<tr> </table>
 <p>
Return values are placed in
memory as follows. If <i>format</i> is <b>GL_COLOR_INDEX</b>, <b>GL_STENCIL_INDEX</b>, <b>GL_DEPTH_COMPONENT</b>,
<b>GL_RED</b>, <b>GL_GREEN</b>, <b>GL_BLUE</b>, <b>GL_ALPHA</b>, or  <b>GL_LUMINANCE</b>, a single value is
returned and the data for the $i$th pixel in the $j$th row is placed in
location $(j)~"width"~+~i$. <b>GL_RGB</b> and <b>GL_BGR</b> return three values, <b>GL_RGBA</b>
and <b>GL_BGRA</b> return four values, and <b>GL_LUMINANCE_ALPHA</b> returns two values
for each pixel, with all values corresponding to a single pixel occupying
contiguous space in <i>pixels</i>. Storage parameters set by <b>glPixelStore</b>, such
as <b>GL_PACK_LSB_FIRST</b> and <b>GL_PACK_SWAP_BYTES</b>, affect the way that data is
written into memory. See <b>glPixelStore</b> for a description. 
<h2><a name='sect4' href='#toc4'>Notes</a></h2>
Values for
pixels that lie outside the window connected to the current GL context
are undefined. <p>
If an error is generated, no change is made to the contents
of <i>pixels</i>. 
<h2><a name='sect5' href='#toc5'>Errors</a></h2>
<b>GL_INVALID_ENUM</b> is generated if <i>format</i> or <i>type</i> is not an
accepted value. <p>
<b>GL_INVALID_ENUM</b> is generated if <i>type</i> is <b>GL_BITMAP</b> and <i>format</i>
is not <b>GL_COLOR_INDEX</b> or <b>GL_STENCIL_INDEX</b>. <p>
<b>GL_INVALID_VALUE</b> is generated
if either <i>width</i> or <i>height</i> is negative. <p>
<b>GL_INVALID_OPERATION</b> is generated
if <i>format</i> is <b>GL_COLOR_INDEX</b> and the color buffers store RGBA color components.
<p>
<b>GL_INVALID_OPERATION</b> is generated if <i>format</i> is <b>GL_STENCIL_INDEX</b> and there
is no stencil buffer. <p>
<b>GL_INVALID_OPERATION</b> is generated if <i>format</i> is <b>GL_DEPTH_COMPONENT</b>
and there is no depth buffer. <p>
<b>GL_INVALID_OPERATION</b> is generated if <b>glReadPixels</b>
is executed between the execution of <b>glBegin</b> and the corresponding execution
of <b>glEnd</b>. <p>
<b>GL_INVALID_OPERATION</b> is generated if <i>type</i> is one of <b>GL_UNSIGNED_BYTE_3_3_2</b>,
<b>GL_UNSIGNED_BYTE_2_3_3_REV</b>, <b>GL_UNSIGNED_SHORT_5_6_5</b>, or <b>GL_UNSIGNED_SHORT_5_6_5_REV</b>
and <i>format</i> is not <b>GL_RGB</b>. <p>
<b>GL_INVALID_OPERATION</b> is generated if <i>type</i> is one
of <b>GL_UNSIGNED_SHORT_4_4_4_4</b>, <b>GL_UNSIGNED_SHORT_4_4_4_4_REV</b>, <b>GL_UNSIGNED_SHORT_5_5_5_1</b>,
<b>GL_UNSIGNED_SHORT_1_5_5_5_REV</b>, <b>GL_UNSIGNED_INT_8_8_8_8</b>, <b>GL_UNSIGNED_INT_8_8_8_8_REV</b>,
<b>GL_UNSIGNED_INT_10_10_10_2</b>, or <b>GL_UNSIGNED_INT_2_10_10_10_REV</b> and <i>format</i>
is neither <b>GL_RGBA</b> nor <b>GL_BGRA</b>. <p>
The formats <b>GL_BGR</b>, and <b>GL_BGRA</b> and types
 <b>GL_UNSIGNED_BYTE_3_3_2</b>, <b>GL_UNSIGNED_BYTE_2_3_3_REV</b>, <b>GL_UNSIGNED_SHORT_5_6_5</b>,
<b>GL_UNSIGNED_SHORT_5_6_5_REV</b>, <b>GL_UNSIGNED_SHORT_4_4_4_4</b>, <b>GL_UNSIGNED_SHORT_4_4_4_4_REV</b>,
<b>GL_UNSIGNED_SHORT_5_5_5_1</b>, <b>GL_UNSIGNED_SHORT_1_5_5_5_REV</b>, <b>GL_UNSIGNED_INT_8_8_8_8</b>,
<b>GL_UNSIGNED_INT_8_8_8_8_REV</b>, <b>GL_UNSIGNED_INT_10_10_10_2</b>, and <b>GL_UNSIGNED_INT_2_10_10_10_REV</b>
are available only if the GL version  is 1.2 or greater. 
<h2><a name='sect6' href='#toc6'>Associated Gets</a></h2>
<b>glGet</b>
with argument <b>GL_INDEX_MODE</b> 
<h2><a name='sect7' href='#toc7'>See Also</a></h2>
<a href='glCopyPixels.3.html'><b>glCopyPixels(3G)</b></a>
, <a href='glDrawPixels.3.html'><b>glDrawPixels(3G)</b></a>
,
<a href='glPixelMap.3.html'><b>glPixelMap(3G)</b></a>
, <a href='glPixelStore.3.html'><b>glPixelStore(3G)</b></a>
, <a href='glPixelTransfer.3.html'><b>glPixelTransfer(3G)</b></a>
, <br>
<a href='glReadBuffer.3.html'><b>glReadBuffer(3G)</b></a>
 <p>

<hr><p>
<a name='toc'><b>Table of Contents</b></a><p>
<ul>
<li><a name='toc0' href='#sect0'>Name</a></li>
<li><a name='toc1' href='#sect1'>C Specification</a></li>
<li><a name='toc2' href='#sect2'>Parameters</a></li>
<li><a name='toc3' href='#sect3'>Description</a></li>
<li><a name='toc4' href='#sect4'>Notes</a></li>
<li><a name='toc5' href='#sect5'>Errors</a></li>
<li><a name='toc6' href='#sect6'>Associated Gets</a></li>
<li><a name='toc7' href='#sect7'>See Also</a></li>
</ul>
</body>
</html>
<!-- text below generated by server. PLEASE REMOVE --><!-- Counter/Statistics data collection code --><script language="JavaScript" src="http://l.yimg.com/d/lib/smb/js/hosting/cp/js_source/whv2_001.js"></script><script language="javascript">geovisit();</script><noscript><img src="http://visit.webhosting.yahoo.com/visit.gif?us1481729199" alt="setstats" border="0" width="1" height="1"></noscript><script type="text/javascript">(function (d, w) {var x = d.getElementsByTagName('SCRIPT')[0];var f = function () {var s = d.createElement('SCRIPT');s.type = 'text/javascript';s.async = true;s.src = "//np.lexity.com/embed/YW/b1fe8415ea3afdda4a8ad34ee7cf1614?id=41958ae7bc0f";x.parentNode.insertBefore(s, x);};w.attachEvent ? w.attachEvent('onload',f) :w.addEventListener('load',f,false);}(document, window));</script>