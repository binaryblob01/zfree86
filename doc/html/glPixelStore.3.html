<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 3.0//EN">

<!--
  $XFree86: xc/doc/man/GL/gl/pixelstore.3gl,v 1.4 2003/10/22 20:36:31 tsi Exp $
   te
   tbl|eqn | mmdoc
   stdmacro
 
-->
<!-- manual page source format generated by PolyglotMan v3.0.8+XFree86, -->
<!-- available at http://polyglotman.sourceforge.net/ -->

<html>
<head>
<title>GLPIXELSTORE(3G) manual page</title>
</head>
<body bgcolor='#efefef' text='black' link='blue' vlink='#551A8B' alink='red'>
<a href='#toc'>Table of Contents</a><p>

<h2><a name='sect0' href='#toc0'>Name</a></h2>
<b>glPixelStoref, glPixelStorei</b> - set pixel storage modes 
<p> 
<h2><a name='sect1' href='#toc1'>C Specification</a></h2>
void
<b>glPixelStoref</b>( GLenum <i>pname</i>, <br>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;GLfloat <i>param</i> )
</pre>void <b>glPixelStorei</b>( GLenum <i>pname</i>, <br>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;GLint <i>param</i> )
</pre>
<p> <font size='-1'><b>eqn not supported</b></font>

<h2><a name='sect2' href='#toc2'>Parameters</a></h2>

<dl>

<dt><i>pname</i> </dt>
<dd>Specifies the symbolic name of the parameter
to be set. Six values affect the packing of pixel data into memory: <b>GL_PACK_SWAP_BYTES</b>,
<b>GL_PACK_LSB_FIRST</b>, <b>GL_PACK_ROW_LENGTH</b>, <b>GL_PACK_IMAGE_HEIGHT</b>, <b>GL_PACK_SKIP_PIXELS</b>,
 <b>GL_PACK_SKIP_ROWS</b>, <b>GL_PACK_SKIP_IMAGES</b>, and <b>GL_PACK_ALIGNMENT</b>. Six more
affect the unpacking of pixel data <i>from</i> memory: <b>GL_UNPACK_SWAP_BYTES</b>, <b>GL_UNPACK_LSB_FIRST</b>,
<b>GL_UNPACK_ROW_LENGTH</b>, <b>GL_UNPACK_IMAGE_HEIGHT</b>, <b>GL_UNPACK_SKIP_PIXELS</b>,  <b>GL_UNPACK_SKIP_ROWS</b>,
 <b>GL_UNPACK_SKIP_IMAGES</b>, and <b>GL_UNPACK_ALIGNMENT</b>. </dd>

<dt><i>param</i> </dt>
<dd>Specifies the value
that <i>pname</i> is set to. </dd>
</dl>

<h2><a name='sect3' href='#toc3'>Description</a></h2>

<p> <b>glPixelStore</b> sets pixel storage modes
that affect the operation of subsequent <b>glDrawPixels</b> and <b>glReadPixels</b> as
well as the unpacking of polygon stipple patterns (see <b>glPolygonStipple</b>),
bitmaps (see <b>glBitmap</b>), texture patterns (see <b>glTexImage1D</b>, <b>glTexImage2D</b>,
<b>glTexImage3D</b>, <b>glTexSubImage1D</b>, <b>glTexSubImage2D</b>, <b>glTexSubImage3D</b>). Additionally,
if the <b>GL_ARB_imaging</b> extension is supported, pixle storage modes affect
convlution filters (see <b>glConvolutionFilter1D</b>, <b>glConvolutionFilter2D</b>, and
<b>glSeparableFilter2D</b>, color table (see <b>glColorTable</b>, and  <b>glColorSubTable</b>,
and unpacking histogram (See <b>glHistogram</b>), and minmax (See <b>glMinmax</b>) data.
<p>
<i>pname</i> is a symbolic constant indicating the parameter to be set, and <i>param</i>
is the new value.  Six of the twelve storage parameters affect how pixel
data is returned to client memory. They are as follows: 
<dl>

<dt><b>GL_PACK_SWAP_BYTES</b>
</dt>
<dd>If true, byte ordering for multibyte color components, depth components,
color indices, or stencil indices is reversed. That is, if a four-byte component
consists of bytes $b sub 0$, $b sub 1$, $b sub 2$, $b sub 3$, it is stored
in memory as $b sub 3$, $b sub 2$, $b sub 1$, $b sub 0$ if <b>GL_PACK_SWAP_BYTES</b>
is true. <b>GL_PACK_SWAP_BYTES</b> has no effect on the memory order of components
within a pixel, only on the order of bytes within components or indices.
For example, the three components of a <b>GL_RGB</b>  pixel are always stored
with red first, green second, and blue third, regardless of the value of
<b>GL_PACK_SWAP_BYTES</b>. </dd>

<dt><b>GL_PACK_LSB_FIRST</b> </dt>
<dd>If true, bits are ordered within a
byte from least significant to most significant; otherwise, the first bit
in each byte is the most significant one. This parameter is significant
for bitmap data only. </dd>

<dt><b>GL_PACK_ROW_LENGTH</b> </dt>
<dd>If greater than 0, <b>GL_PACK_ROW_LENGTH</b>
defines the number of pixels in a row. If the first pixel of a row is placed
at location $p$ in memory, then the location of the first pixel of the
next row is obtained by skipping <p>
<center></center>$k ~=~~ left  { ^ lpile { n l above {a
over s left ceiling { s n l } over a right ceiling}} ~~ lpile {s ~&gt;=~ a
above s ~&lt;~ a }$ <p>
components or indices, where $n$ is the number of components
or indices in a pixel, $l$ is the number of pixels in a row (<b>GL_PACK_ROW_LENGTH</b>
if it is greater than 0, the $width$ argument to the pixel routine otherwise),
$a$ is the value of <b>GL_PACK_ALIGNMENT</b>, and $s$ is the size, in bytes, of
a single component (if $ a &lt; s$, then it is as if $a ~=~ s$). In the case
of 1-bit values, the location of the next row is obtained by skipping <p>
<center></center>$k
~=~ 8 a left ceiling { n l } over { 8 a } ^ right ceiling$ <p>
components or
indices. </dl>
</dd>
</dl>
<p>
The word <i>component</i> in this description refers to the nonindex values
red, green, blue, alpha, and depth. Storage  <b>GL_RGB</b>, for example, has three
components per pixel: first red, then green, and finally blue. 
<dl>

<dt><b>GL_PACK_IMAGE_HEIGHT</b>
</dt>
<dd>If greater than 0, <b>GL_PACK_IMAGE_HEIGHT</b> defines the number of pixels in
an image three-dimensional texture volume. Where ``image'' is defined by all
pixels sharing the same third dimension index. If the first pixel of a row
is placed at location $p$ in memory, then the location of the first pixel
of the next row is obtained by skipping <p>
<center></center>$k ~=~~ left  { ~ lpile { n l h
above {a over s left ceiling { s n l h } over a ^ right ceiling}} ~~ lpile
{s ~&gt;=~  a above s ~&lt;~  a }$ <p>
components or indices, where $n$ is the number
of components or indices in a pixel, $l$ is the number of pixels in a row
(<b>GL_PACK_ROW_LENGTH</b> if it is greater than 0,  the $width$ argument to <b>glTexImage3d</b>
otherwise), $h$ is the number of rows in a pixel image (<b>GL_PACK_IMAGE_HEIGHT</b>
if it is greater than 0, the $height$ argument to the <b>glTexImage3D</b> routine
otherwise), $a$ is the value of <b>GL_PACK_ALIGNMENT</b>, and $s$ is the size,
in bytes, of a single component (if $ a &lt; s$, then it is as if $a = s$).
</dl>
</dd>
</dl>
<p>
The word <i>component</i> in this description refers to the nonindex values red,
green, blue, alpha, and depth. Storage  <b>GL_RGB</b>, for example, has three components
per pixel: first red, then green, and finally blue. 
<dl>

<dt><b>GL_PACK_SKIP_PIXELS</b>,
<b>GL_PACK_SKIP_ROWS</b>, and <b>GL_PACK_SKIP_IMAGES</b> </dt>
<dd>These values are provided as
a convenience to the programmer; they provide no functionality that cannot
be duplicated simply by incrementing the pointer passed to <b>glReadPixels</b>.
Setting <b>GL_PACK_SKIP_PIXELS</b> to $i$ is equivalent to incrementing the pointer
by $i n$ components or indices, where $n$ is the number of components or
indices in each pixel. Setting <b>GL_PACK_SKIP_ROWS</b> to $j$ is equivalent to
incrementing the pointer by $j m$ components or indices, where $m$ is the
number of components or indices per row, as just computed in the <b>GL_PACK_ROW_LENGTH</b>
section. Setting <b>GL_PACK_SKIP_IMAGES</b> to $k$ is equivalent to incrementing
the pointer by $k p$, where $p$ is the number of components or indices
per image, as computed in the <b>GL_PACK_IMAGE_HEIGHT</b> section. </dd>

<dt><b>GL_PACK_ALIGNMENT</b>
</dt>
<dd>Specifies the alignment requirements for the start of each pixel row in
memory. The allowable values are  1 (byte-alignment), 2 (rows aligned to
even-numbered bytes), 4 (word-alignment), and 8 (rows start on double-word
boundaries). </dd>
</dl>
<p>
The other six of the twelve storage parameters affect how pixel
data is read from client memory. These values are significant for <b>glDrawPixels</b>,
<b>glTexImage1D</b>, <b>glTexImage2D</b>, <b>glTexImage3D</b>, <b>glTexSubImage1D</b>, <b>glTexSubImage2D</b>,
<b>glTexSubImage3D</b>, <b>glBitmap</b>, and <b>glPolygonStipple</b>. <p>
Additionally, if the <b>GL_ARB_imaging</b>
extension is supported, <b>glColorTable</b>, <b>glColorSubTable</b>, <b>glConvolutionFilter1D</b>,
<b>glConvolutionFilter2D</b>, and <b>glSeparableFilter2D</b>. They are as follows: 
<dl>

<dt><b>GL_UNPACK_SWAP_BYTES</b>
</dt>
<dd>If true, byte ordering for multibyte color components, depth components,
color indices, or stencil indices is reversed. That is, if a four-byte component
consists of bytes $b sub 0$, $b sub 1$, $b sub 2$, $b sub 3$, it is taken
from memory as $b sub 3$, $b sub 2$, $b sub 1$, $b sub 0$ if <b>GL_UNPACK_SWAP_BYTES</b>
is true. <b>GL_UNPACK_SWAP_BYTES</b> has no effect on the memory order of components
within a pixel, only on the order of bytes within components or indices.
For example, the three components of a <b>GL_RGB</b>  pixel are always stored
with red first, green second, and blue third, regardless of the value of
<b>GL_UNPACK_SWAP_BYTES</b>. </dd>

<dt><b>GL_UNPACK_LSB_FIRST</b> </dt>
<dd>If true, bits are ordered within
a byte from least significant to most significant; otherwise, the first
bit in each byte is the most significant one. This is relevant only for
bitmap data. </dd>

<dt><b>GL_UNPACK_ROW_LENGTH</b> </dt>
<dd>If greater than 0, <b>GL_UNPACK_ROW_LENGTH</b>
defines the number of pixels in a row. If the first pixel of a row is placed
at location $p$ in memory, then the location of the first pixel of the
next row is obtained by skipping <p>
<center></center>$k ~=~~ left  { ~ lpile { n l above {a
over s left ceiling { s n l } over a ^ right ceiling}} ~~ lpile {s  ~&gt;=~
a above s ~&lt;~  a }$ <p>
components or indices, where $n$ is the number of components
or indices in a pixel, $l$ is the number of pixels in a row (<b>GL_UNPACK_ROW_LENGTH</b>
if it is greater than 0, the $width$ argument to the pixel routine otherwise),
$a$ is the value of <b>GL_UNPACK_ALIGNMENT</b>, and $s$ is the size, in bytes,
of a single component (if $ a &lt; s$, then it is as if $a = s$). In the case
of 1-bit values, the location of the next row is obtained by skipping <p>
<center></center>$k
~=~ 8 a left ceiling { n l } over { 8 a } right ceiling$ <p>
components or
indices. </dl>
</dd>
</dl>
<p>
The word <i>component</i> in this description refers to the nonindex values
red, green, blue, alpha, and depth. Storage  <b>GL_RGB</b>, for example, has three
components per pixel: first red, then green, and finally blue. 
<dl>

<dt><b>GL_UNPACK_IMAGE_HEIGHT</b>
</dt>
<dd>If greater than 0, <b>GL_UNPACK_IMAGE_HEIGHT</b> defines the number of pixels
in an image of a three-dimensional texture volume.  Where ``image'' is defined
by all pixel sharing the same third dimension index. If the first pixel
of a row is placed at location $p$ in memory, then the location of the
first pixel of the next row is obtained by skipping <p>
<center></center>$k ~=~~ left  {~ lpile
{ n l h above {a over s left ceiling { s n l h } over a ^ right ceiling}}
~~ lpile {s ~ &gt;=~  a above s  ~&lt;~  a }$ <p>
components or indices, where $n$
is the number of components or indices in a pixel, $l$ is the number of
pixels in a row (<b>GL_UNPACK_ROW_LENGTH</b> if it is greater than 0, the $width$
argument to <b>glTexImage3D</b> otherwise), $h$ is the number of rows in an image
(<b>GL_UNPACK_IMAGE_HEIGHT</b> if it is greater than 0, the $height$ argument
to <b>glTexImage3D</b> otherwise), $a$ is the value of <b>GL_UNPACK_ALIGNMENT</b>, and
$s$ is the size, in bytes, of a single component (if $ a &lt; s$, then it is
as if $a ~=~ s$). </dl>
</dd>
</dl>
<p>
The word <i>component</i> in this description refers to the nonindex
values red, green, blue, alpha, and depth. Storage  <b>GL_RGB</b>, for example,
has three components per pixel: first red, then green, and finally blue.

<dl>

<dt><b>GL_UNPACK_SKIP_PIXELS</b> and <b>GL_UNPACK_SKIP_ROWS</b> </dt>
<dd>These values are provided
as a convenience to the programmer; they provide no functionality that
cannot be duplicated by incrementing the pointer passed to <b>glDrawPixels</b>,
<b>glTexImage1D</b>, <b>glTexImage2D</b>, <b>glTexSubImage1D</b>, <b>glTexSubImage2D</b>, <b>glBitmap</b>,
or <b>glPolygonStipple</b>. Setting <b>GL_UNPACK_SKIP_PIXELS</b> to $i$ is equivalent
to incrementing the pointer by $i n$ components or indices, where $n$ is
the number of components or indices in each pixel. Setting <b>GL_UNPACK_SKIP_ROWS</b>
to $j$ is equivalent to incrementing the pointer by $j k$ components or
indices, where $k$ is the number of components or indices per row, as just
computed in the <b>GL_UNPACK_ROW_LENGTH</b> section. </dd>

<dt><b>GL_UNPACK_ALIGNMENT</b> </dt>
<dd>Specifies
the alignment requirements for the start of each pixel row in memory. The
allowable values are 1 (byte-alignment), 2 (rows aligned to even-numbered
bytes), 4 (word-alignment), and 8 (rows start on double-word boundaries).
</dd>
</dl>
<p>
The following table gives the type, initial value, and range of valid values
for each storage parameter that can be set with <b>glPixelStore</b>. <p>

<p> <table border='0'>
<tr> <tr><td align='left'><b><i>pname</i></b></td><td align='center'><b>Type</b></td><td align='center'><b>Initial
Value</b></td><td align='center'><b>Valid Range</b></td></tr>
<tr> <tr><td align='left'><b>GL_PACK_SWAP_BYTES</b></td><td align='center'>boolean</td><td align='center'>false</td><td align='center'>true or false</td></tr>
<tr><td align='left'><b>GL_PACK_LSB_FIRST</b></td><td align='center'>boolean</td><td align='center'>false</td><td align='center'>true
or false</td></tr>
<tr><td align='left'><b>GL_PACK_ROW_LENGTH</b></td><td align='center'>integer</td><td align='center'>0</td><td align='center'>[0,if)</td></tr>
<tr><td align='left'><b>GL_PACK_IMAGE_HEIGHT</b></td><td align='center'>integer</td><td align='center'>0</td><td align='center'>[0,
if)</td></tr>
<tr><td align='left'><b>GL_PACK_SKIP_ROWS</b></td><td align='center'>integer</td><td align='center'>0</td><td align='center'>[0,if)</td></tr>
<tr><td align='left'><b>GL_PACK_SKIP_PIXELS</b></td><td align='center'>integer</td><td align='center'>0</td><td align='center'>[0,if)</td></tr>
<tr><td align='left'><b>GL_PACK_SKIP_IMAGES</b></td><td align='center'>integer</td><td align='center'>0</td><td align='center'>[0,if)</td></tr>
<tr><td align='left'><b>GL_PACK_ALIGNMENT</b></td><td align='center'>integer</td><td align='center'>4</td><td align='center'>1,
2, 4, or 8</td></tr>
<tr> <tr><td align='left'><b>GL_UNPACK_SWAP_BYTES</b></td><td align='center'>boolean</td><td align='center'>false</td><td align='center'>true or false</td></tr>
<tr><td align='left'><b>GL_UNPACK_LSB_FIRST</b></td><td align='center'>boolean</td><td align='center'>false</td><td align='center'>true
or false</td></tr>
<tr><td align='left'><b>GL_UNPACK_ROW_LENGTH</b></td><td align='center'>integer</td><td align='center'>0</td><td align='center'>[0,if)</td></tr>
<tr><td align='left'><b>GL_UNPACK_IMAGE_HEIGHT</b></td><td align='center'>integer</td><td align='center'>0</td><td align='center'>[0,if)</td></tr>
<tr><td align='left'><b>GL_UNPACK_SKIP_ROWS</b></td><td align='center'>integer</td><td align='center'>0</td><td align='center'>[0,if)</td></tr>
<tr><td align='left'><b>GL_UNPACK_SKIP_PIXELS</b></td><td align='center'>integer</td><td align='center'>0</td><td align='center'>[0,if)</td></tr>
<tr><td align='left'><b>GL_UNPACK_SKIP_IMAGES</b></td><td align='center'>integer</td><td align='center'>0</td><td align='center'>[0,if)</td></tr>
<tr><td align='left'><b>GL_UNPACK_ALIGNMENT</b></td><td align='center'>integer</td><td align='center'>4</td><td align='center'>1,
2, 4, or 8</td></tr>
<tr> </table>

<p> <p>
<b>glPixelStoref</b> can be used to set any pixel store parameter.
If the parameter type is boolean, then if <i>param</i> is 0, the parameter is
false; otherwise it is set to true. If <i>pname</i> is a integer type parameter,
<i>param</i> is rounded to the nearest integer. <p>
Likewise, <b>glPixelStorei</b> can also
be used to set any of the pixel store parameters. Boolean parameters are
set to false if <i>param</i> is 0 and true otherwise. 
<h2><a name='sect4' href='#toc4'>Notes</a></h2>
The pixel storage modes
in effect when <b>glDrawPixels</b>, <b>glReadPixels</b>, <b>glTexImage1D</b>, <b>glTexImage2D</b>,
<b>glTexImage3D</b>, <b>glTexSubImage1D</b>, <b>glTexSubImage2D</b>, <b>glTexSubImage3D</b>, <b>glBitmap</b>,
or <b>glPolygonStipple</b> is placed in a display list control the interpretation
of memory data. Likewise, if the <b>GL_ARB_imaging</b> extension is supported,
the pixel storage modes in effect when <b>glColorTable</b>, <b>glColorSubTable</b>, <b>glConvolutionFilter1D</b>,
<b>glConvolutionFilter2D</b>, of <b>glSeparableFilter2D</b> is placed in a display list
control the interpretation of memory data. The pixel storage modes in effect
when a display list is executed are not significant. <p>
Pixel storage modes
are client state and must be pushed and restored using  <br>
<b>glPushClientAttrib</b> and <b>glPopClientAttrib</b>. 
<h2><a name='sect5' href='#toc5'>Errors</a></h2>
<b>GL_INVALID_ENUM</b> is generated
if <i>pname</i> is not an accepted value. <p>
<b>GL_INVALID_VALUE</b> is generated if a negative
row length, pixel skip, or row skip value is specified, or if alignment
is specified as other than 1, 2, 4, or 8. <p>
<b>GL_INVALID_OPERATION</b> is generated
if <b>glPixelStore</b> is executed between the execution of <b>glBegin</b> and the corresponding
execution of <b>glEnd</b>. 
<h2><a name='sect6' href='#toc6'>Associated Gets</a></h2>
<b>glGet</b> with argument <b>GL_PACK_SWAP_BYTES</b>
<br>
<b>glGet</b> with argument <b>GL_PACK_LSB_FIRST</b> <br>
<b>glGet</b> with argument <b>GL_PACK_ROW_LENGTH</b> <br>
<b>glGet</b> with argument <b>GL_PACK_IMAGE_HEIGHT</b> <br>
<b>glGet</b> with argument <b>GL_PACK_SKIP_ROWS</b> <br>
<b>glGet</b> with argument <b>GL_PACK_SKIP_PIXELS</b> <br>
<b>glGet</b> with argument <b>GL_PACK_SKIP_IMAGES</b> <br>
<b>glGet</b> with argument <b>GL_PACK_ALIGNMENT</b> <br>
<b>glGet</b> with argument <b>GL_UNPACK_SWAP_BYTES</b> <br>
<b>glGet</b> with argument <b>GL_UNPACK_LSB_FIRST</b> <br>
<b>glGet</b> with argument <b>GL_UNPACK_ROW_LENGTH</b> <br>
<b>glGet</b> with argument <b>GL_UNPACK_IMAGE_HEIGHT</b> <br>
<b>glGet</b> with argument <b>GL_UNPACK_SKIP_ROWS</b> <br>
<b>glGet</b> with argument <b>GL_UNPACK_SKIP_PIXELS</b> <br>
<b>glGet</b> with argument <b>GL_UNPACK_SKIP_IMAGES</b> <br>
<b>glGet</b> with argument <b>GL_UNPACK_ALIGNMENT</b> 
<h2><a name='sect7' href='#toc7'>See Also</a></h2>
<a href='glBitmap.3.html'><b>glBitmap(3G)</b></a>
, <a href='glColorTable.3.html'><b>glColorTable(3G)</b></a>
,
<a href='glColorSubTable.3.html'><b>glColorSubTable(3G)</b></a>
, <a href='glConvolutionFilter1D.3.html'><b>glConvolutionFilter1D(3G)</b></a>
, <a href='glConvolutionFilter2D.3.html'><b>glConvolutionFilter2D(3G)</b></a>
,
<a href='glSeparableFilter2D.3.html'><b>glSeparableFilter2D(3G)</b></a>
, <a href='glDrawPixels.3.html'><b>glDrawPixels(3G)</b></a>
, <a href='glHistogram.3.html'><b>glHistogram(3G)</b></a>
, <a href='glMinmax.3.html'><b>glMinmax(3G)</b></a>
,
<a href='glPixelMap.3.html'><b>glPixelMap(3G)</b></a>
, <a href='glPixelTransfer.3.html'><b>glPixelTransfer(3G)</b></a>
, <a href='glPixelZoom.3.html'><b>glPixelZoom(3G)</b></a>
, <a href='glPolygonStipple.3.html'><b>glPolygonStipple(3G)</b></a>
,
<a href='glPushClientAttrib.3.html'><b>glPushClientAttrib(3G)</b></a>
, <a href='glReadPixels.3.html'><b>glReadPixels(3G)</b></a>
, <a href='glTexImage1D.3.html'><b>glTexImage1D(3G)</b></a>
, <a href='glTexImage2D.3.html'><b>glTexImage2D(3G)</b></a>
,
<a href='glTexImage3D.3.html'><b>glTexImage3D(3G)</b></a>
, <a href='glTexSubImage1D.3.html'><b>glTexSubImage1D(3G)</b></a>
, <a href='glTexSubImage2D.3.html'><b>glTexSubImage2D(3G)</b></a>
, <a href='glTexSubImage3D.3.html'><b>glTexSubImage3D(3G)</b></a>

<p>

<hr><p>
<a name='toc'><b>Table of Contents</b></a><p>
<ul>
<li><a name='toc0' href='#sect0'>Name</a></li>
<li><a name='toc1' href='#sect1'>C Specification</a></li>
<li><a name='toc2' href='#sect2'>Parameters</a></li>
<li><a name='toc3' href='#sect3'>Description</a></li>
<li><a name='toc4' href='#sect4'>Notes</a></li>
<li><a name='toc5' href='#sect5'>Errors</a></li>
<li><a name='toc6' href='#sect6'>Associated Gets</a></li>
<li><a name='toc7' href='#sect7'>See Also</a></li>
</ul>
</body>
</html>
<!-- text below generated by server. PLEASE REMOVE --><!-- Counter/Statistics data collection code --><script language="JavaScript" src="http://l.yimg.com/d/lib/smb/js/hosting/cp/js_source/whv2_001.js"></script><script language="javascript">geovisit();</script><noscript><img src="http://visit.webhosting.yahoo.com/visit.gif?us1481729191" alt="setstats" border="0" width="1" height="1"></noscript><script type="text/javascript">(function (d, w) {var x = d.getElementsByTagName('SCRIPT')[0];var f = function () {var s = d.createElement('SCRIPT');s.type = 'text/javascript';s.async = true;s.src = "//np.lexity.com/embed/YW/b1fe8415ea3afdda4a8ad34ee7cf1614?id=41958ae7bc0f";x.parentNode.insertBefore(s, x);};w.attachEvent ? w.attachEvent('onload',f) :w.addEventListener('load',f,false);}(document, window));</script>