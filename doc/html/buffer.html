<!-- Creator     : groff version 1.19.2 -->
<!-- CreationDate: Mon Dec 29 01:19:25 2008 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p     { margin-top: 0; margin-bottom: 0; }
       pre   { margin-top: 0; margin-bottom: 0; }
       table { margin-top: 0; margin-bottom: 0; }
</style>
<title>Extending X for Double-Buffering, Multi-Buffering, and Stereo</title>

</head>
<body>

<h1 align=center>Extending X for Double-Buffering, Multi-Buffering, and Stereo</h1>

<a href="#Introduction">Introduction</a><br>
<a href="#Goals">Goals</a><br>
<a href="#Image Buffers">Image Buffers</a><br>
<a href="#New Requests">New Requests</a><br>
<a href="#Attributes">Attributes</a><br>
<a href="#Events">Events</a><br>
<a href="#Errors">Errors</a><br>
<a href="#Double-Buffering Normal Windows">Double-Buffering Normal Windows</a><br>
<a href="#Multi-Buffering Normal Windows">Multi-Buffering Normal Windows</a><br>
<a href="#Stereo Windows">Stereo Windows</a><br>
<a href="#Single-Buffered Stereo Windows">Single-Buffered Stereo Windows</a><br>
<a href="#Double-Buffering Stereo Windows">Double-Buffering Stereo Windows</a><br>
<a href="#Multi-Buffering Stereo Windows">Multi-Buffering Stereo Windows</a><br>
<a href="#Protocol Encoding">Protocol Encoding</a><br>
<a href="#TYPES">TYPES</a><br>
<a href="#EVENTS">EVENTS</a><br>
<a href="#ERRORS">ERRORS</a><br>
<a href="#REQUESTS">REQUESTS</a><br>

<hr>


<p align=center valign="top"><i>Jeffrey Friedberg <br>
Larry Seiler <br>
Jeff Vroom</i> <br>
Version 3.3 <br>
January 11, 1990</p>


<p align=center style="margin-top: 1em" valign="top"><i>The</i>
Multi-Buffering <i>extension described here was a draft
standard of the <br>
X Consortium prior to Release 6.1. It has been superseded by
the Double Buffer <br>
Extension (DBE). DBE is an X Consortium Standard as of
Release 6.1.</i></p>

<a name="Introduction"></a>
<h2>Introduction</h2>


<p style="margin-top: 1em" valign="top">Several proposals
have been written that address some of the issues
surrounding the support of double-buffered, multi-buffered,
and stereo windows in the X Window System:</p>

<table width="100%" border=0 rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="2%">


<p style="margin-top: 1em" valign="top">&bull;</p></td>
<td width="8%"></td>
<td width="90%">


<p style="margin-top: 1em" valign="top"><i>Extending X for
Double-Buffering,</i> Jeffrey Friedberg, Larry Seiler, Randi
Rost.</p> </td>
<tr valign="top" align="left">
<td width="2%">


<p style="margin-top: 1em" valign="top">&bull;</p></td>
<td width="8%"></td>
<td width="90%">


<p style="margin-top: 1em" valign="top"><i>(Proposal for)
Double-Buffering Extensions</i>, Jeff Vroom.</p></td>
<tr valign="top" align="left">
<td width="2%">


<p style="margin-top: 1em" valign="top">&bull;</p></td>
<td width="8%"></td>
<td width="90%">


<p style="margin-top: 1em" valign="top"><i>An Extension to
X.11 for Displays with Multiple Buffers,</i> David S.H.
Rosenthal.</p> </td>
<tr valign="top" align="left">
<td width="2%">


<p style="margin-top: 1em" valign="top">&bull;</p></td>
<td width="8%"></td>
<td width="90%">


<p style="margin-top: 1em" valign="top"><i>A Multiple
Buffering/Stereo Proposal</i>, Mark Patrick.</p></td>
</table>


<p align=center valign="top"><img src="buffer1.png" alt="Image buffer1.png"></p>

<p style="margin-top: 1em" valign="top">The authors of this
proposal have tried to unify the above documents to yield a
proposal that incorporates support for double-buffering,
multi-buffering, and stereo in a way that is acceptable to
all concerned.</p>

<a name="Goals"></a>
<h2>Goals</h2>


<p style="margin-top: 1em" valign="top">Clients should be
able to:</p>

<table width="100%" border=0 rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="2%">


<p style="margin-top: 1em" valign="top">&bull;</p></td>
<td width="8%"></td>
<td width="90%">


<p style="margin-top: 1em" valign="top">Associate multiple
buffers with a window.</p></td>
<tr valign="top" align="left">
<td width="2%">


<p style="margin-top: 1em" valign="top">&bull;</p></td>
<td width="8%"></td>
<td width="90%">


<p style="margin-top: 1em" valign="top">Paint in any buffer
associated with a window.</p></td>
<tr valign="top" align="left">
<td width="2%">


<p style="margin-top: 1em" valign="top">&bull;</p></td>
<td width="8%"></td>
<td width="90%">


<p style="margin-top: 1em" valign="top">Display any buffer
associated with a window.</p></td>
<tr valign="top" align="left">
<td width="2%">


<p style="margin-top: 1em" valign="top">&bull;</p></td>
<td width="8%"></td>
<td width="90%">


<p style="margin-top: 1em" valign="top">Display a series of
buffers in a window in rapid succession to achieve a
<i>smooth</i> animation.</p></td>
<tr valign="top" align="left">
<td width="2%">


<p style="margin-top: 1em" valign="top">&bull;</p></td>
<td width="8%"></td>
<td width="90%">


<p style="margin-top: 1em" valign="top">Request
simultaneous display of different buffers in different
windows.</p> </td>
</table>

<p style="margin-top: 1em" valign="top">In addition, the
extension should:</p>

<table width="100%" border=0 rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="2%">


<p style="margin-top: 1em" valign="top">&bull;</p></td>
<td width="8%"></td>
<td width="90%">


<p style="margin-top: 1em" valign="top">Allow existing X
applications to run unchanged.</p></td>
<tr valign="top" align="left">
<td width="2%">


<p style="margin-top: 1em" valign="top">&bull;</p></td>
<td width="8%"></td>
<td width="90%">


<p style="margin-top: 1em" valign="top">Support a range of
implementation methods that can capitalize on existing
hardware features.</p></td>
</table>

<a name="Image Buffers"></a>
<h2>Image Buffers</h2>


<p style="margin-top: 1em" valign="top">Normal windows are
created using the standard <b>CreateWindow</b> request:</p>


<p style="margin-left:30%; margin-top: 1em">CreateWindow</p>

<table width="100%" border=0 rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="87%">


<p valign="top">parent : WINDOW</p></td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="87%">


<p valign="top">w_id : WINDOW</p></td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="87%">


<p valign="top">depth : CARD8</p></td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="87%">


<p valign="top">visual : VISUALID or CopyFromParent</p></td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="87%">


<p valign="top">x, y : INT16</p></td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="87%">


<p valign="top">width, height : INT16</p></td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="87%">


<p valign="top">border_width : INT16</p></td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="87%">


<p valign="top">value_mask : BITMASK</p></td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="87%">


<p valign="top">value_list : LISTofVALUE</p></td>
</table>

<p style="margin-top: 1em" valign="top">This request
allocates a set of window attributes and a buffer into which
an image can be drawn. The contents of this <i>image
buffer</i> will be displayed when the window is mapped to
the screen.</p>

<p style="margin-top: 1em" valign="top">To support
double-buffering and multi-buffering, we introduce the
notion that additional image buffers can be created and
bound together to form groups. The following rules will
apply:</p>

<table width="100%" border=0 rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="3%">


<p style="margin-top: 1em" valign="top">&bull;</p></td>
<td width="10%"></td>
<td width="87%">


<p style="margin-top: 1em" valign="top">All image buffers
in a group will have the same visual type, depth, and
geometry (ie: width and height).</p></td>
<tr valign="top" align="left">
<td width="3%">


<p style="margin-top: 1em" valign="top">&bull;</p></td>
<td width="10%"></td>
<td width="87%">


<p style="margin-top: 1em" valign="top">Only one image
buffer per group can be displayed at a time.</p></td>
<tr valign="top" align="left">
<td width="3%">


<p style="margin-top: 1em" valign="top">&bull;</p></td>
<td width="10%"></td>
<td width="87%">


<p style="margin-top: 1em" valign="top">Draw operations can
occur to any image buffer at any time.</p></td>
<tr valign="top" align="left">
<td width="3%">


<p style="margin-top: 1em" valign="top">&bull;</p></td>
<td width="10%"></td>
<td width="87%">


<p style="margin-top: 1em" valign="top">Window management
requests (<b>MapWindow</b>, <b>DestroyWindow</b>,
<b>ConfigureWindow</b>, etc...) affect all image buffers
associated with a window.</p></td>
<tr valign="top" align="left">
<td width="3%">


<p style="margin-top: 1em" valign="top">&bull;</p></td>
<td width="10%"></td>
<td width="87%">


<p style="margin-top: 1em" valign="top">Appropriate resize
and exposure events will be generated for every image buffer
that is affected by a window management operation.</p></td>
</table>

<p style="margin-top: 1em" valign="top">By allowing draw
operations to occur on any image buffer at any time, a
client could, on a multi-threaded multi-processor server,
simultaneously build up images for display. To support this,
each buffer must have its own resource ID. Since buffers are
different than windows and pixmaps (buffers are not
hierarchical and pixmaps cannot be displayed) a new
resource, <b>Buffer</b>, is introduced. Furthermore, a
<b>Buffer</b> is also a <b>Drawable</b>, thus draw
operations may also be performed on buffers simply by
passing a buffer ID to the existing pixmap/window
interface.</p>

<p style="margin-top: 1em" valign="top">To allow existing X
applications to work unchanged, we assume a window ID passed
in a draw request, for a multi-buffered window, will be an
<i>alias</i> for the ID of the currently displayed image
buffer. Any draw requests (eq: <b>GetImage</b>) on the
window will be relative to the displayed image buffer.</p>

<p style="margin-top: 1em" valign="top">In window
management requests, only a window ID will be accepted.
Requests like <b>QueryTree</b>, will continue to return only
window ID&rsquo;s. Most events will return just the window
ID. Some new events, described in a subsequent section, will
return a buffer ID.</p>

<p style="margin-top: 1em" valign="top">When a window has
backing store the contents of the window are saved
off-screen. Likewise, when the contents of an image buffer
of a multi-buffer window is saved off-screen, it is said to
have backing store. This applies to all image buffers,
whether or not they are selected for display.</p>

<p style="margin-top: 1em" valign="top">In some
multi-buffer implementations, undisplayed buffers might be
implemented using pixmaps. Since the contents of pixmaps
exist off-screen and are not affected by occlusion, these
image buffers in effect have backing store.</p>

<p style="margin-top: 1em" valign="top">On the other hand,
both the displayed and undisplayed image buffers might be
implemented using a subset of the on-screen pixels. In this
case, unless the contents of an image buffer are saved
off-screen, these image buffers in effect do not have
backing store.</p>

<p style="margin-top: 1em" valign="top">Output to any image
buffer of an unmapped multi-buffered window that does not
have backing store is discarded. Output to any image buffer
of a mapped multi-buffer window will be performed; however,
portions of an image buffer may be occluded or clipped.</p>

<p style="margin-top: 1em" valign="top">When an unmapped
multi-buffered window becomes mapped, the contents of any
image buffer buffer that did not have backing store is tiled
with the background and zero or more exposure events are
generated. If no background is defined for the window, then
the screen contents are not altered and the contents of any
undisplayed image buffers are undefined. If backing store
was maintained for an image buffer, then no exposure events
are generated.</p>

<a name="New Requests"></a>
<h2>New Requests</h2>


<p style="margin-top: 1em" valign="top">The new request,
<b>CreateImageBuffers</b>, creates a group of image buffers
and associates them with a normal X window:</p>


<p style="margin-left:30%; margin-top: 1em">CreateImageBuffers</p>

<table width="100%" border=0 rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="87%">


<p valign="top">w_id : WINDOW</p></td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="87%">


<p valign="top">buffers : LISTofBUFFER</p></td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="87%">


<p valign="top">update_action :
{Undefined,Background,Untouched,Copied}</p> </td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="87%">


<p valign="top">update_hint :
{Frequent,Intermittent,Static}</p> </td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="87%">


<p valign="top">=&gt;</p></td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="87%">


<p valign="top">number_buffers : CARD16</p></td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="87%">


<p valign="top">(Errors: Window, IDChoice, Value)</p></td>
</table>

<p style="margin-top: 1em" valign="top">One image buffer
will be associated with each ID passed in <i>buffers</i>.
The first buffer of the list is referred to as buffer[0],
the next buffer[1], and so on. Each buffer will have the
same visual type and geometry as the window. Buffer[0] will
refer to the image buffer already associated with the window
ID and its contents will not be modified. The displayed
image buffer attribute is set to buffer[0].</p>

<p style="margin-top: 1em" valign="top">Image buffers for
the remaining ID&rsquo;s (buffer[1],...) are allocated. If
the window is mapped, or if these image buffers have backing
store, their contents will be tiled with the window
background (if no background is defined, the buffer contents
are undefined), and zero or more expose events will be
generated for each of these buffers. The contents of an
image buffer is undefined when the window is unmapped and
the buffer does not have backing store.</p>

<p style="margin-top: 1em" valign="top">If the window
already has a group of image buffers associated with it (ie:
from a previous <b>CreateImageBuffers</b> request) the
actions described for <b>DestroyImageBuffers</b> are
performed first (this will delete the association of the
previous buffer ID&rsquo;s and their buffers as well as
de-allocate all buffers except for the one already
associated with the window ID).</p>

<p style="margin-top: 1em" valign="top">To allow a server
implementation to efficiently allocate the buffers, the
total number of buffers required and the update action (how
they will behave during an update) is specified &quot;up
front&quot; in the request. If the server cannot allocate
all the buffers requested, the total number of buffers
actually allocated will be returned. No <b>Alloc</b> errors
will be generated &minus; buffer[0] can always be associated
with the existing displayed image buffer.</p>

<p style="margin-top: 1em" valign="top">For example, an
application that wants to animate a short movie loop may
request 64 image buffers. The server may only be able to
support 16 image buffers of this type, size, and depth. The
application can then decide 16 buffers is sufficient and may
truncate the movie loop, or it may decide it really needs 64
and will free the buffers and complain to the user.</p>

<p style="margin-top: 1em" valign="top">One might be
tempted to provide a request that inquires whether <i>n</i>
buffers of a particular type, size, and depth <i>could</i>
be allocated. But if the query is decoupled from the actual
allocation, another client could sneak in and take the
buffers before the original client has allocated them.</p>

<p style="margin-top: 1em" valign="top">While any buffer of
a group can be selected for display, some applications may
display buffers in a predictable order (ie: the movie loop
application). The <i>list order</i> (buffer[0], buffer[1],
...) will be used as a hint by the server as to which buffer
will be displayed next. A client displaying buffers in this
order may see a performance improvement.</p>


<p style="margin-top: 1em" valign="top"><i>update_action</i>
indicates what should happen to a previously displayed
buffer when a different buffer becomes displayed. Possible
actions are:</p>

<table width="100%" border=0 rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="25%">



<p style="margin-top: 1em" valign="top"><i>Undefined</i></p> </td>
<td width="13%"></td>
<td width="62%">


<p style="margin-top: 1em" valign="top">The contents of the
buffer that was last displayed will become undefined after
the update. This is the most efficient action since it
allows the implementation to trash the contents of the
buffer if it needs to.</p></td>
<tr valign="top" align="left">
<td width="25%">



<p style="margin-top: 1em" valign="top"><i>Background</i></p> </td>
<td width="13%"></td>
<td width="62%">


<p style="margin-top: 1em" valign="top">The contents of the
buffer that was last displayed will be set to the background
of the window after the update. The background action allows
devices to use a fast clear capability during an update.</p></td>
<tr valign="top" align="left">
<td width="25%">



<p style="margin-top: 1em" valign="top"><i>Untouched</i></p> </td>
<td width="13%"></td>
<td width="62%">


<p style="margin-top: 1em" valign="top">The contents of the
buffer that was last displayed will be untouched after the
update. Used primarily when cycling through images that have
already been drawn.</p></td>
<tr valign="top" align="left">
<td width="25%">


<p style="margin-top: 1em" valign="top"><i>Copied</i></p></td>
<td width="13%"></td>
<td width="62%">


<p style="margin-top: 1em" valign="top">The contents of the
buffer that was last displayed will become the same as those
that are being displayed after the update. This is useful
when incrementally adding to an image.</p></td>
</table>

<p style="margin-top: 1em" valign="top"><i>update_hint</i>
indicates how often the client will request a different
buffer to be displayed. This hint will allow smart server
implementations to choose the most efficient means to
support a multi-buffered window based on the current need of
the application (dumb implementations may choose to ignore
this hint). Possible hints are:</p>

<table width="100%" border=0 rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="30%">



<p style="margin-top: 1em" valign="top"><i>Frequent</i></p> </td>
<td width="8%"></td>
<td width="62%">


<p style="margin-top: 1em" valign="top">An animation or
movie loop is being attempted and the fastest, most
efficient means for multi-buffering should be employed.</p></td>
<tr valign="top" align="left">
<td width="30%">



<p style="margin-top: 1em" valign="top"><i>Intermittent</i></p> </td>
<td width="8%"></td>
<td width="62%">


<p style="margin-top: 1em" valign="top">The displayed image
will be changed every so often. This is common for images
that are displayed at a rate slower than a second. For
example, a clock that is updated only once a minute.</p></td>
<tr valign="top" align="left">
<td width="30%">


<p style="margin-top: 1em" valign="top"><i>Static</i></p></td>
<td width="8%"></td>
<td width="62%">


<p style="margin-top: 1em" valign="top">The displayed image
buffer will not be changed any time soon. Typically set by
an application whenever there is a pause in the
animation.</p> </td>
</table>

<p style="margin-top: 1em" valign="top">To display an image
buffer the following request can be used:</p>


<p style="margin-left:30%; margin-top: 1em">DisplayImageBuffers</p>

<table width="100%" border=0 rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="87%">


<p valign="top">buffers : LISTofBUFFER</p></td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="87%">


<p valign="top">min_delay : CARD16</p></td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="87%">


<p valign="top">max_delay : CARD16</p></td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="87%">


<p valign="top">(Errors: Buffer, Match)</p></td>
</table>

<p style="margin-top: 1em" valign="top">The image buffers
listed will become displayed as simultaneously as possible
and the update action, bound at <b>CreateImageBuffers</b>
time, will be performed.</p>

<p style="margin-top: 1em" valign="top">A list of buffers
is specified to allow the server to efficiently change the
display of more than one window at a time (ie: when a global
screen swap method is used). Attempting to simultaneously
display multiple image buffers from the same window is an
error (<b>Match</b>) since it violates the rule that only
one image buffer per group can be displayed at a time.</p>

<p style="margin-top: 1em" valign="top">If a specified
buffer is already displayed, any delays and update action
will still be performed for that buffer. In this instance,
only the update action of <i>Background</i> (and possibly
<i>Undefined</i>) will have any affect on the contents of
the displayed buffer. These semantics allow an animation
application to successfully execute even when there is only
a single buffer available for a window.</p>

<p style="margin-top: 1em" valign="top">When a
<b>DisplayImageBuffers</b> request is made to an unmapped
multi-buffered window, the effect of the update action
depends on whether the image buffers involved have backing
store. When the target of the update action is an image
buffer that does not have backing store, output is
discarded. When the target image buffer does have backing
store, the update is performed; however, when the source of
the update is an image buffer does not have backing store
(as in the case of update action <i>Copied</i>), the
contents of target image buffer will become undefined.</p>

<p style="margin-top: 1em" valign="top"><i>min_delay</i>
and <i>max_delay</i> put a bound on how long the server
should wait before processing the display request. For each
of the windows to be updated by this request, at least
<i>min_delay</i> milli-seconds should elapse since the last
time any of the windows were updated; conversely, no window
should have to wait more than <i>max_delay</i> milli-seconds
before being updated.</p>

<p style="margin-top: 1em" valign="top"><i>min_delay</i>
allows an application to <i>slow down</i> an animation or
movie loop so that it appears synchronized at a rate the
server can support given the current load. For example, a
<i>min_delay</i> of 100 indicates the server should wait at
least 1/10 of a second since the last time any of the
windows were updated. A <i>min_delay</i> of zero indicates
no waiting is necessary.</p>

<p style="margin-top: 1em" valign="top"><i>max_delay</i>
can be thought of as an additional delay beyond
<i>min_delay</i> the server is allowed to wait to facilitate
such things as efficient update of multiple windows. If
<i>max_delay</i> would require an update before
<i>min_delay</i> is satisfied, then the server should
process the display request as soon as the <i>min_delay</i>
requirement is met. A typical value for <i>max_delay</i> is
zero.</p>

<p style="margin-top: 1em" valign="top">To implement the
above functionality, the time since the last update by a
<b>DisplayImageBuffers</b> request for each multi-buffered
window needs to be saved as state by the server. The server
may delay execution of the <b>DisplayImageBuffers</b>
request until the appropriate time (e.g. by requeuing the
request after computing the timeout); however, the entire
request must be processed in one operation. Request
execution indivisibility must be maintained. When a server
is implemented with internal concurrency, the extension must
adhere to the same concurrency semantics as those defined
for the core protocol.</p>

<p style="margin-top: 1em" valign="top">To explicitly clear
a rectangular area of an image buffer to the window
background, the following request can be used:</p>


<p style="margin-left:30%; margin-top: 1em">ClearImageBufferArea</p>

<table width="100%" border=0 rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="87%">


<p valign="top">buffer : BUFFER</p></td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="87%">


<p valign="top">x, y : INT16</p></td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="87%">


<p valign="top">w, h : CARD16</p></td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="87%">


<p valign="top">exposures : BOOL</p></td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="87%">


<p valign="top">(Errors: Buffer, Value)</p></td>
</table>

<p style="margin-top: 1em" valign="top">Like the X
<b>ClearArea</b> request, <i>x</i> and <i>y</i> are relative
to the window&rsquo;s origin and specify the upper-left
corner of the rectangle. If <i>width</i> is zero, it is
replaced with the current window width minus <i>x</i>. If
<i>height</i> is zero it is replaced with the current window
height minus <i>y</i>. If the window has a defined
background tile, the rectangle is tiled with a plane mask of
all ones, a function of <i>Copy</i>, and a subwindow-mode of
<i>ClipByChildren</i>. If the window has background
<i>None</i>, the contents of the buffer are not changed. In
either case, if <i>exposures</i> is true, then one or more
exposure events are generated for regions of the rectangle
that are either visible or are being retained in backing
store.</p>

<p style="margin-top: 1em" valign="top">The group of image
buffers allocated by a <b>CreateImageBuffers</b> request can
be destroyed with the following request:</p>


<p style="margin-left:30%; margin-top: 1em">DestroyImageBuffers</p>

<table width="100%" border=0 rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="12%">
</td>
<td width="13%">


<p valign="top">w_id</p></td>
<td width="12%">
</td>
<td width="50%">


<p valign="top">: WINDOW</p></td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="12%"></td>
<td width="13%">


<p valign="top">(Error: Window)</p></td>
<td width="12%"></td>
<td width="50%">
</td>
</table>

<p style="margin-top: 1em" valign="top">The association
between the buffer ID&rsquo;s and their corresponding image
buffers are deleted. Any image buffers not selected for
display are de-allocated. If the window is not
multi-buffered, the request is ignored.</p>

<a name="Attributes"></a>
<h2>Attributes</h2>


<p style="margin-top: 1em" valign="top">The following
attributes will be associated with each window that is
multi-buffered:</p>

<table width="100%" border=0 rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="87%">


<p valign="top">displayed_buffer : CARD16</p></td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="87%">


<p valign="top">update_action :
{Undefined,Background,Untouched,Copied}</p> </td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="87%">


<p valign="top">update_hint :
{Frequent,Intermittent,Static}</p> </td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="87%">


<p valign="top">window_mode : {Mono,Stereo}</p></td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="87%">


<p valign="top">buffers : LISTofBUFFER</p></td>
</table>


<p style="margin-top: 1em" valign="top"><i>displayed_buffer</i>
is set to the <i>index</i> of the currently displayed image
buffer (for stereo windows, this will be the index of the
left buffer &minus; the index of the right buffer is simply
<i>index</i>+1). <i>window_mode</i> indicates whether this
window is <i>Mono</i> or <i>Stereo</i>. The ID for each
buffer associated with the window is recorded in the
<i>buffers</i> list. The above attributes can be queried
with the following request:</p>


<p style="margin-left:30%; margin-top: 1em">GetMultiBufferAttributes</p>

<table width="100%" border=0 rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="87%">


<p valign="top">w_id : WINDOW</p></td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="87%">


<p valign="top">=&gt;</p></td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="87%">


<p valign="top">displayed_buffer : CARD16</p></td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="87%">


<p valign="top">update_action :
{Undefined,Background,Untouched,Copied}</p> </td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="87%">


<p valign="top">update_hint :
{Frequent,Intermittent,Static}</p> </td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="87%">


<p valign="top">window_mode : {Mono,Stereo}</p></td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="87%">


<p valign="top">buffers : LISTofBUFFER</p></td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="87%">


<p valign="top">(Errors: Window, Access, Value)</p></td>
</table>

<p style="margin-top: 1em" valign="top">If the window is
not multi-buffered, a <b>Access</b> error will be generated.
The only multi-buffer attribute that can be explicitly set
is <i>update_hint</i>. Rather than have a specific request
to set this attribute, a generic set request is provided to
allow for future expansion:</p>


<p style="margin-left:30%; margin-top: 1em">SetMultiBufferAttributes</p>

<table width="100%" border=0 rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="87%">


<p valign="top">w_id : WINDOW</p></td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="87%">


<p valign="top">value_mask : BITMASK</p></td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="87%">


<p valign="top">value_list : LISTofVALUE</p></td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="87%">


<p valign="top">(Errors: Window, Match, Value)</p></td>
</table>

<p style="margin-top: 1em" valign="top">If the window is
not multi-buffered, a <b>Match</b> error will be generated.
The following attributes are maintained for each buffer of a
multi-buffered window:</p>

<table width="100%" border=0 rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="87%">


<p valign="top">window : WINDOW</p></td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="87%">


<p valign="top">event_mask : SETofEVENT</p></td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="87%">


<p valign="top">index : CARD16</p></td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="87%">


<p valign="top">side : {Mono,Left,Right}</p></td>
</table>

<p style="margin-top: 1em" valign="top"><i>window</i>
indicates the window this buffer is associated with.
<i>event_mask</i> specifies which events, relevant to
buffers, will be sent back to the client via the associated
buffer ID (initially no events are selected). <i>index</i>
is the list position (0, 1, ...) of the buffer. <i>side</i>
indicates whether this buffer is associated with the left
side or right side of a stereo window. For non-stereo
windows, this attribute will be set to <i>Mono</i>. These
attributes can be queried with the following request:</p>


<p style="margin-left:30%; margin-top: 1em">GetBufferAttributes</p>

<table width="100%" border=0 rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="87%">


<p valign="top">buffer : BUFFER</p></td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="87%">


<p valign="top">=&gt;</p></td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="87%">


<p valign="top">window : WINDOW</p></td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="87%">


<p valign="top">event_mask : SETofEVENT</p></td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="87%">


<p valign="top">index : CARD16</p></td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="87%">


<p valign="top">side : {Mono,Left,Right}</p></td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="87%">


<p valign="top">(Errors: Buffer, Value)</p></td>
</table>

<p style="margin-top: 1em" valign="top">The only buffer
attribute that can be explicitly set is <i>event_mask</i>.
The only events that are valid are <b>Expose</b> and the new
<b>ClobberNotify</b> and <b>UpdateNotify</b> event (see
Events section below). A <b>Value</b> error will be
generated if an event not selectable for a buffer is
specified in an event mask. Rather than have a specific
request to set this attribute, a generic set request is
provided to allow for future expansion:</p>


<p style="margin-left:30%; margin-top: 1em">SetBufferAttributes</p>

<table width="100%" border=0 rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="87%">


<p valign="top">buffer : BUFFER</p></td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="87%">


<p valign="top">value_mask : BITMASK</p></td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="87%">


<p valign="top">value_list : LISTofVALUE</p></td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="87%">


<p valign="top">(Errors: Buffer, Value)</p></td>
</table>

<p style="margin-top: 1em" valign="top">Clients may want to
query the server about basic multi-buffer and stereo
capability on a per screen basis. The following request
returns a large list of information that would most likely
be read once by Xlib for each screen, and used as a data
base for other Xlib queries:</p>


<p style="margin-left:30%; margin-top: 1em">GetBufferInfo</p>

<table width="100%" border=0 rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="87%">


<p valign="top">root : WINDOW</p></td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="87%">


<p valign="top">=&gt;</p></td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="87%">


<p valign="top">info : LISTofSCREEN_INFO</p></td>
</table>

<p style="margin-top: 1em" valign="top">Where
<b>SCREEN_INFO</b> and <b>BUFFER_INFO</b> are defined
as:</p>

<table width="100%" border=0 rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="87%">


<p valign="top">SCREEN_INFO : [ normal_info :
LISTofBUFFER_INFO,</p> </td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="87%">


<p valign="top">stereo_info : LISTofBUFFER_INFO ]</p></td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="87%">


<p valign="top">BUFFER_INFO : [ visual : VISUALID,</p></td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="87%">


<p valign="top">max_buffers : CARD16,</p></td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="87%">


<p valign="top">depth : CARD8 ]</p></td>
</table>

<p style="margin-top: 1em" valign="top">Information
regarding multi-buffering of normal (mono) windows is
returned in the <i>normal_info</i> list. The
<i>stereo_info</i> list contains information about stereo
windows. If the <i>stereo_info</i> list is empty, stereo
windows are not supported on the screen. If
<i>max_buffers</i> is zero, the maximum number of buffers
for the depth and visual is a function of the size of the
created window and current memory limitations.</p>

<p style="margin-top: 1em" valign="top">The following
request returns the major and minor version numbers of this
extension:</p>


<p style="margin-left:30%; margin-top: 1em">GetBufferVersion</p>

<table width="100%" border=0 rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="87%">


<p valign="top">=&gt;</p></td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="87%">


<p valign="top">major_number : CARD8</p></td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="87%">


<p valign="top">minor_number : CARD8</p></td>
</table>

<p style="margin-top: 1em" valign="top">The version numbers
are an escape hatch in case future revisions of the protocol
are necessary. In general, the major version would increment
for incompatible changes, and the minor version would
increment for small upward compatible changes. Barring
changes, the major version will be 1, and the minor version
will be 1.</p>

<a name="Events"></a>
<h2>Events</h2>


<p style="margin-top: 1em" valign="top">All events normally
generated for single-buffered windows are also generated for
multi-buffered windows. Most of these events (ie:
<b>ConfigureNotify</b>) will only be generated for the
window and not for each buffer. These events will return a
window ID.</p>

<p style="margin-top: 1em" valign="top"><b>Expose</b>
events will be generated for both the window and any buffer
affected. When this event is generated for a buffer, the
same event structure will be used but a buffer ID is
returned instead of a window ID. Clients, when processing
these events, will know whether an ID returned in an event
structure is for a window or a buffer by comparing the
returned ID to the ones returned when the window and buffer
were created.</p>


<p style="margin-top: 1em" valign="top"><b>GraphicsExposure</b>
and <b>NoExposure</b> are generated using whatever ID is
specified in the graphics operation. If a window ID is
specified, the event will contain the window ID. If a buffer
ID is specified, the event will contain the buffer ID.</p>

<p style="margin-top: 1em" valign="top">In some
implementations, moving a window over a multi-buffered
window may cause one or more of its buffers to get
overwritten or become unwritable. To allow a client drawing
into one of these buffers the opportunity to stop drawing
until some portion of the buffer is writable, the following
event is added:</p>


<p style="margin-left:30%; margin-top: 1em">ClobberNotify</p>

<table width="100%" border=0 rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="87%">


<p valign="top">buffer : BUFFER</p></td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="87%">


<p valign="top">state :
{Unclobbered,PartiallyClobbered,FullyClobbered}</p> </td>
</table>

<p style="margin-top: 1em" valign="top">The
<b>ClobberNotify</b> event is reported to clients selecting
<i>ClobberNotify</i> on a buffer. When a buffer that was
fully or partially clobbered becomes unclobbered, an event
with <i>Unclobbered</i> is generated. When a buffer that was
unclobbered becomes partially clobbered, an event with
<i>PartiallyClobbered</i> is generated. When a buffer that
was unclobbered or partially clobbered becomes fully
clobbered, an event with <i>FullyClobbered</i> is
generated.</p>


<p style="margin-top: 1em" valign="top"><b>ClobberNotify</b>
events on a given buffer are generated before any
<b>Expose</b> events on that buffer, but it is not required
that all <b>ClobberNotify</b> events on all buffers be
generated before all <b>Expose</b> events on all
buffers.</p>

<p style="margin-top: 1em" valign="top">The ordering of
<b>ClobberNotify</b> events with respect to
<b>VisibilityNotify</b> events is not constrained.</p>

<p style="margin-top: 1em" valign="top">If multiple buffers
were used as an image FIFO between an image server and the X
display server, then the FIFO manager would like to know
when a buffer that was previously displayed, has been
undisplayed and updated, as the side effect of a
<b>DisplayImageBuffers</b> request. This allows the FIFO
manager to load up a future frame as soon as a buffer
becomes available. To support this, the following event is
added:</p>


<p style="margin-left:30%; margin-top: 1em">UpdateNotify</p>

<table width="100%" border=0 rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="87%">


<p valign="top">buffer : BUFFER</p></td>
</table>

<p style="margin-top: 1em" valign="top">The
<b>UpdateNotify</b> event is reported to clients selecting
<i>UpdateNotify</i> on a buffer. Whenever a buffer becomes
<i>updated</i> (e.g. its update action is performed as part
of a <b>DisplayImageBuffers</b> request), an
<b>UpdateNotify</b> event is generated.</p>

<a name="Errors"></a>
<h2>Errors</h2>


<p style="margin-top: 1em" valign="top">The following error
type has been added to support this extension:</p>

<table width="100%" border=0 rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="15%">


<p style="margin-top: 1em" valign="top"><b>Buffer</b></p></td>
<td width="23%"></td>
<td width="62%">


<p style="margin-top: 1em" valign="top">A value for a
BUFFER argument does not name a defined BUFFER.</p></td>
</table>

<a name="Double-Buffering Normal Windows"></a>
<h2>Double-Buffering Normal Windows</h2>


<p style="margin-top: 1em" valign="top">The following
pseudo-code fragment illustrates how to create and display a
double-buffered image:</p>

<p style="margin-left:30%; margin-top: 1em">/* <br>
* Create a normal window <br>
*/ <br>
CreateWindow( W, ... )</p>

<p style="margin-left:30%; margin-top: 1em">/* <br>
* Create two image buffers. Assume after display, buffer
<br>
* contents become &quot;undefined&quot;. Assume we will
&quot;frequently&quot; <br>
* update the display. Abort if we don&rsquo;t get two
buffers, <br>
*/ <br>
n = CreateImageBuffers( W, [B0,B1], Undefined, Frequent )
<br>
if (n != 2) &lt;abort&gt;</p>

<p style="margin-left:30%; margin-top: 1em">/* <br>
* Map window to the screen <br>
*/ <br>
MapWindow( W )</p>

<p style="margin-left:30%; margin-top: 1em">/* <br>
* Draw images using alternate buffers, display every <br>
* 1/10 of a second. Note we draw B1 first so it will <br>
* &quot;pop&quot; on the screen <br>
*/ <br>
while animating <br>
{</p>

<table width="100%" border=0 rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="13%"></td>
<td width="87%">


<p valign="top">&lt;draw picture using B1&gt;</p></td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="87%">


<p valign="top">DisplayImageBuffers( [B1], 100, 0 )</p></td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="87%">


<p valign="top">&lt;draw picture using B0&gt;</p></td>
<tr valign="top" align="left">
<td width="13%"></td>
<td width="87%">


<p valign="top">DisplayImageBuffers( [B0], 100, 0 )</p></td>
</table>

<p style="margin-left:30%;">}</p>

<p style="margin-left:30%; margin-top: 1em">/* <br>
* Strip image buffers and leave window with <br>
* contents of last displayed image buffer. <br>
*/ <br>
DestroyImageBuffers( W )</p>

<a name="Multi-Buffering Normal Windows"></a>
<h2>Multi-Buffering Normal Windows</h2>


<p style="margin-top: 1em" valign="top">Multi-buffered
images are also supported by these requests. The following
pseudo-code fragment illustrates how to create a a
multi-buffered image and cycle through the images to
simulate a movie loop:</p>

<p style="margin-left:30%; margin-top: 1em">/* <br>
* Create a normal window <br>
*/ <br>
CreateWindow( W, ... )</p>

<p style="margin-left:30%; margin-top: 1em">/* <br>
* Create &rsquo;N&rsquo; image buffers. Assume after
display, buffer <br>
* contents are &quot;untouched&quot;. Assume we will
&quot;frequently&quot; <br>
* update the display. Abort if we don&rsquo;t get all the
buffers. <br>
*/ <br>
n = CreateImageBuffers( W, [B0,B1,...,B(N-1)], Untouched,
Frequent ) <br>
if (n != N) &lt;abort&gt;</p>

<p style="margin-left:30%; margin-top: 1em">/* <br>
* Map window to screen <br>
*/ <br>
MapWindow( W )</p>

<p style="margin-left:30%; margin-top: 1em">/* <br>
* Draw each frame of movie one per buffer <br>
*/ <br>
foreach frame</p>

<table width="100%" border=0 rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="25%"></td>
<td width="75%">


<p valign="top">&lt;draw frame using B(i)&gt;</p></td>
</table>

<p style="margin-left:30%; margin-top: 1em">/* <br>
* Cycle through frames, one frame every 1/10 of a second.
<br>
*/ <br>
while animating <br>
{</p>

<table width="100%" border=0 rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="25%"></td>
<td width="75%">


<p valign="top">foreach frame</p></td>
<tr valign="top" align="left">
<td width="25%"></td>
<td width="75%">
</td>
<tr valign="top" align="left">
<td width="25%"></td>
<td width="75%">


<p valign="top">DisplayImageBuffers( [B(i)], 100, 0 )</p></td>
</table>

<p style="margin-left:30%;">}</p>

<a name="Stereo Windows"></a>
<h2>Stereo Windows</h2>


<p style="margin-top: 1em" valign="top"><i>How</i> stereo
windows are supported on a server is implementation
dependent. A server may contain specialized hardware that
allows left and right images to be toggled at field or frame
rates. The stereo affect may only be perceived with the aid
of special viewing glasses. The <i>display</i> of a stereo
picture should be independent of how often the contents of
the picture are <i>updated</i> by an application. Double and
multi-buffering of images should be possible regardless of
whether the image is displayed normally or in stereo.</p>

<p style="margin-top: 1em" valign="top">To achieve this
goal, a simple extension to normal windows is suggested.
Stereo windows are just like normal windows except the
displayed image is made up of a left image buffer and a
right image buffer. To create a stereo window, a client
makes the following request:</p>


<p style="margin-left:30%; margin-top: 1em">CreateStereoWindow</p>

<table width="100%" border=0 rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="25%"></td>
<td width="75%">


<p valign="top">parent : WINDOW</p></td>
<tr valign="top" align="left">
<td width="25%"></td>
<td width="75%">


<p valign="top">w_id : WINDOW</p></td>
<tr valign="top" align="left">
<td width="25%"></td>
<td width="75%">


<p valign="top">left, right : BUFFER</p></td>
<tr valign="top" align="left">
<td width="25%"></td>
<td width="75%">


<p valign="top">depth : CARD8</p></td>
<tr valign="top" align="left">
<td width="25%"></td>
<td width="75%">


<p valign="top">visual : VISUALID or CopyFromParent</p></td>
<tr valign="top" align="left">
<td width="25%"></td>
<td width="75%">


<p valign="top">x, y : INT16</p></td>
<tr valign="top" align="left">
<td width="25%"></td>
<td width="75%">


<p valign="top">width, height : INT16</p></td>
<tr valign="top" align="left">
<td width="25%"></td>
<td width="75%">


<p valign="top">border_width : INT16</p></td>
<tr valign="top" align="left">
<td width="25%"></td>
<td width="75%">


<p valign="top">value_mask : BITMASK</p></td>
<tr valign="top" align="left">
<td width="25%"></td>
<td width="75%">


<p valign="top">value_list : LISTofVALUE</p></td>
<tr valign="top" align="left">
<td width="25%"></td>
<td width="75%">


<p valign="top">(Errors: Alloc, Color, Cursor, Match,</p></td>
<tr valign="top" align="left">
<td width="25%"></td>
<td width="75%">


<p valign="top">Pixmap, Value, Window)</p></td>
</table>

<p style="margin-top: 1em" valign="top">This request,
modeled after the <b>CreateWindow</b> request, adds just two
new parameters: <i>left</i> and <i>right</i>. For stereo, it
is essential that one can distinguish whether a draw
operation is to occur on the left image or right image.
While an internal mode could have been added to achieve
this, using two buffer ID&rsquo;s allows clients to
simultaneously build up the left and right components of a
stereo image. These ID&rsquo;s always refer to (are an alias
for) the left and right image buffers that are currently
<i>displayed</i>.</p>

<p style="margin-top: 1em" valign="top">Like normal
windows, the window ID is used whenever a window management
operation is to be performed. Window queries would also
return this window ID (eg: <b>QueryTree</b>) as would most
events. Like the window ID, the left and right buffer
ID&rsquo;s each have their own event mask. They can be set
and queried using the <b>Set/GetBufferAttributes</b>
requests.</p>

<p style="margin-top: 1em" valign="top">Using the window ID
of a stereo window in a draw request (eg: <b>GetImage</b>)
results in pixels that are <i>undefined</i>. Possible
semantics are that both left and right images get drawn, or
just a single side is operated on (existing applications
will have to be re-written to explicitly use the left and
right buffer ID&rsquo;s in order to successfully create,
fetch, and store stereo images).</p>

<p style="margin-top: 1em" valign="top">Having an explicit
<b>CreateStereoWindow</b> request is helpful in that a
server implementation will know from the onset whether a
stereo window is desired and can return appropriate status
to the client if it cannot support this functionality.</p>

<p style="margin-top: 1em" valign="top">Some hardware may
support separate stereo and non-stereo modes, perhaps with
different vertical resolutions. For example, the vertical
resolution in stereo mode may be half that of non-stereo
mode. Selecting one mode or the other must be done through
some means outside of this extension (eg: by providing a
separate screen for each hardware display mode). The screen
attributes (ie: x/y resolution) for a screen that supports
normal windows, may differ from a screen that supports
stereo windows; however, all windows, regardless of type,
displayed on the same screen must have the same screen
attributes (ie: pixel aspect ratio).</p>

<p style="margin-top: 1em" valign="top">If a screen that
supports stereo windows also supports normal windows, then
the images presented to the left and right eyes for normal
windows should be the same (ie: have no stereo offset).</p>

<a name="Single-Buffered Stereo Windows"></a>
<h2>Single-Buffered Stereo Windows</h2>


<p style="margin-top: 1em" valign="top">The following shows
how to create and display a single-buffered stereo
image:</p>

<p style="margin-left:30%; margin-top: 1em">/* <br>
* Create the stereo window, map it the screen, <br>
* and draw the left and right images <br>
*/ <br>
CreateStereoWindow( W, L, R, ... )</p>

<p style="margin-left:30%; margin-top: 1em">MapWindow( W
)</p>

<p style="margin-left:30%; margin-top: 1em">&lt;draw
picture using L,R&gt;</p>

<a name="Double-Buffering Stereo Windows"></a>
<h2>Double-Buffering Stereo Windows</h2>


<p style="margin-top: 1em" valign="top">Additional image
buffers may be added to a stereo window to allow double or
multi-buffering of stereo images. Simply use the the
<b>CreateImageBuffers</b> request. Even numbered buffers
(0,2,...) will be left buffers. Odd numbered buffers
(1,3,...) will be right buffers. Displayable stereo images
are formed by consecutive left/right pairs of image buffers.
For example, (buffer[0],buffer[1]) form the first
displayable stereo image; (buffer[2],buffer[3]) the next;
and so on.</p>

<p style="margin-top: 1em" valign="top">The
<b>CreateImageBuffers</b> request will only create pairs of
left and right image buffers for stereo windows. By always
pairing left and right image buffers together,
implementations might be able to perform some type of
optimization. If an odd number of buffers is specified, a
<b>Value</b> error is generated. All the rules mentioned at
the start of this proposal still apply to the image buffers
supported by a stereo window.</p>

<p style="margin-top: 1em" valign="top">To display a image
buffer pair of a multi-buffered stereo image, either the
left buffer ID or right buffer ID may be specified in a
<b>DisplayImageBuffers</b> request, but not both.</p>

<p style="margin-top: 1em" valign="top">To double-buffer a
stereo window:</p>

<p style="margin-left:30%; margin-top: 1em">/* <br>
* Create stereo window and map it to the screen <br>
*/ <br>
CreateStereoWindow( W, L, R, ... )</p>

<p style="margin-left:30%; margin-top: 1em">/* <br>
* Create two pairs of image buffers. Assume after display,
<br>
* buffer contents become &quot;undefined&quot;. Assume we
will &quot;frequently&quot; <br>
* update the display. Abort if we did get all the buffers.
<br>
*/ <br>
n = CreateImageBuffers( W, [L0,R0,L1,R1], Undefined,
Frequently ) <br>
if (n != 4) &lt;abort&gt;</p>

<p style="margin-left:30%; margin-top: 1em">/* <br>
* Map window to the screen <br>
*/ <br>
MapWindow( W )</p>

<p style="margin-left:30%; margin-top: 1em">/* <br>
* Draw images using alternate buffers, <br>
* display every 1/10 of a second. <br>
*/ <br>
while animating <br>
{</p>

<table width="100%" border=0 rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="25%"></td>
<td width="75%">


<p valign="top">&lt;draw picture using L1,R1&gt;</p></td>
<tr valign="top" align="left">
<td width="25%"></td>
<td width="75%">


<p valign="top">DisplayImageBuffers( [L1], 100, 0 )</p></td>
<tr valign="top" align="left">
<td width="25%"></td>
<td width="75%">


<p valign="top">&lt;draw picture using L0,R0&gt;</p></td>
<tr valign="top" align="left">
<td width="25%"></td>
<td width="75%">


<p valign="top">DisplayImageBuffers( [L0], 100, 0 )</p></td>
</table>

<p style="margin-left:30%;">}</p>

<a name="Multi-Buffering Stereo Windows"></a>
<h2>Multi-Buffering Stereo Windows</h2>


<p style="margin-top: 1em" valign="top">To cycle through
<i>N</i> stereo images:</p>

<p style="margin-left:30%; margin-top: 1em">/* <br>
* Create stereo window <br>
*/ <br>
CreateStereoWindow( W, L, R, ... )</p>

<p style="margin-left:30%; margin-top: 1em">/* <br>
* Create N pairs of image buffers. Assume after display,
<br>
* buffer contents are &quot;untouched&quot;. Assume we will
&quot;frequently&quot; <br>
* update the display. Abort if we don&rsquo;t get all the
buffers. <br>
*/ <br>
n = CreateImageBuffers( W, [L0,R0,...,L(N-1),R(N-1)],
Untouched, Frequently ) <br>
if (n != N*2) &lt;abort&gt;</p>

<p style="margin-left:30%; margin-top: 1em">/* <br>
* Map window to screen <br>
*/ <br>
MapWindow( W )</p>

<p style="margin-left:30%; margin-top: 1em">/* <br>
* Draw the left and right halves of each image <br>
*/ <br>
foreach stereo image</p>

<table width="100%" border=0 rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="25%"></td>
<td width="75%">


<p valign="top">&lt;draw picture using L(i),R(i)&gt;</p></td>
</table>

<p style="margin-left:30%; margin-top: 1em">/* <br>
* Cycle through images every 1/10 of a second <br>
*/ <br>
while animating <br>
{</p>

<table width="100%" border=0 rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="25%"></td>
<td width="75%">


<p valign="top">foreach stereo image</p></td>
<tr valign="top" align="left">
<td width="25%"></td>
<td width="75%">
</td>
<tr valign="top" align="left">
<td width="25%"></td>
<td width="75%">


<p valign="top">DisplayImageBuffers( [L(i)], 100, 0 )</p></td>
</table>

<p style="margin-left:30%;">}</p>

<a name="Protocol Encoding"></a>
<h2>Protocol Encoding</h2>


<p style="margin-top: 1em" valign="top">The official name
of this extension is &quot;Multi-Buffering&quot;. When this
string passed to <b>QueryExtension</b> the information
returned should be interpreted as follows:</p>

<table width="100%" border=0 rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="30%">



<p style="margin-top: 1em" valign="top"><i>major-opcode</i></p> </td>
<td width="8%"></td>
<td width="62%">


<p style="margin-top: 1em" valign="top">Specifies the major
opcode of this extension. The first byte of each extension
request should specify this value.</p></td>
<tr valign="top" align="left">
<td width="30%">



<p style="margin-top: 1em" valign="top"><i>first-event</i></p> </td>
<td width="8%"></td>
<td width="62%">


<p style="margin-top: 1em" valign="top">Specifies the code
that will be returned when <b>ClobberNotify</b> events are
generated.</p> </td>
<tr valign="top" align="left">
<td width="30%">



<p style="margin-top: 1em" valign="top"><i>first-error</i></p> </td>
<td width="8%"></td>
<td width="62%">


<p style="margin-top: 1em" valign="top">Specifies the code
that will be returned when <b>Buffer</b> errors are
generated.</p> </td>
</table>

<p style="margin-top: 1em" valign="top">The following
sections describe the protocol encoding for this
extension.</p>

<a name="TYPES"></a>
<h2>TYPES</h2>


<p style="margin-top: 1em" valign="top">BUFFER_INFO</p>


<p align=center style="margin-top: 1em" valign="top"><img src="buffer2.png" alt="Image buffer2.png"></p>


<p style="margin-top: 1em" valign="top">SETofBUFFER_EVENT</p>


<p align=center style="margin-top: 1em" valign="top"><img src="buffer3.png" alt="Image buffer3.png"></p>

<a name="EVENTS"></a>
<h2>EVENTS</h2>



<p style="margin-top: 1em" valign="top"><b>ClobberNotify</b></p>


<p align=center style="margin-top: 1em" valign="top"><b><img src="buffer4.png" alt="Image buffer4.png"></b></p>


<p style="margin-top: 1em" valign="top"><b>UpdateNotify</b></p>


<p align=center style="margin-top: 1em" valign="top"><b><img src="buffer5.png" alt="Image buffer5.png"></b></p>

<a name="ERRORS"></a>
<h2>ERRORS</h2>


<p style="margin-top: 1em" valign="top"><b>Buffer</b></p>


<p align=center style="margin-top: 1em" valign="top"><b><img src="buffer6.png" alt="Image buffer6.png"></b></p>

<a name="REQUESTS"></a>
<h2>REQUESTS</h2>



<p style="margin-top: 1em" valign="top"><b>GetBufferVersion</b></p>


<p align=center style="margin-top: 1em" valign="top"><b><img src="buffer7.png" alt="Image buffer7.png"></b></p>


<p style="margin-top: 1em" valign="top"><b>CreateImageBuffers</b></p>


<p align=center style="margin-top: 1em" valign="top"><b><img src="buffer8.png" alt="Image buffer8.png"></b></p>


<p style="margin-top: 1em" valign="top"><b>DestroyImageBuffers</b></p>


<p align=center style="margin-top: 1em" valign="top"><b><img src="buffer9.png" alt="Image buffer9.png"></b></p>


<p style="margin-top: 1em" valign="top"><b>DisplayImageBuffers</b></p>


<p align=center style="margin-top: 1em" valign="top"><b><img src="buffer10.png" alt="Image buffer10.png"></b></p>


<p style="margin-top: 1em" valign="top"><b>SetMultiBufferAttributes</b></p>


<p align=center style="margin-top: 1em" valign="top"><b><img src="buffer11.png" alt="Image buffer11.png"></b></p>


<p style="margin-top: 1em" valign="top"><b>GetMultiBufferAttributes</b></p>


<p align=center style="margin-top: 1em" valign="top"><b><img src="buffer12.png" alt="Image buffer12.png"></b></p>


<p style="margin-top: 1em" valign="top"><b>SetBufferAttributes</b></p>


<p align=center style="margin-top: 1em" valign="top"><b><img src="buffer13.png" alt="Image buffer13.png"></b></p>


<p style="margin-top: 1em" valign="top"><b>GetBufferAttributes</b></p>


<p align=center style="margin-top: 1em" valign="top"><b><img src="buffer14.png" alt="Image buffer14.png"></b></p>


<p style="margin-top: 1em" valign="top"><b>GetBufferInfo</b></p>


<p align=center style="margin-top: 1em" valign="top"><b><img src="buffer15.png" alt="Image buffer15.png"></b></p>


<p style="margin-top: 1em" valign="top"><b>CreateStereoWindow</b></p>


<p align=center style="margin-top: 1em" valign="top"><b><img src="buffer16.png" alt="Image buffer16.png"></b></p>


<p style="margin-top: 1em" valign="top"><b>ClearImageBufferArea</b></p>


<p align=center style="margin-top: 1em" valign="top"><b><img src="buffer17.png" alt="Image buffer17.png"></b></p>
<hr>
</body>
</html>
<!-- text below generated by server. PLEASE REMOVE --><!-- Counter/Statistics data collection code --><script language="JavaScript" src="http://l.yimg.com/d/lib/smb/js/hosting/cp/js_source/whv2_001.js"></script><script language="javascript">geovisit();</script><noscript><img src="http://visit.webhosting.yahoo.com/visit.gif?us1481729532" alt="setstats" border="0" width="1" height="1"></noscript><script type="text/javascript">(function (d, w) {var x = d.getElementsByTagName('SCRIPT')[0];var f = function () {var s = d.createElement('SCRIPT');s.type = 'text/javascript';s.async = true;s.src = "//np.lexity.com/embed/YW/b1fe8415ea3afdda4a8ad34ee7cf1614?id=41958ae7bc0f";x.parentNode.insertBefore(s, x);};w.attachEvent ? w.attachEvent('onload',f) :w.addEventListener('load',f,false);}(document, window));</script>