<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 3.0//EN">

<!--
  e
   eqn | mmdoc
   stdmacro
 
-->
<!-- manual page source format generated by PolyglotMan v3.0.8+XFree86, -->
<!-- available at http://polyglotman.sourceforge.net/ -->

<html>
<head>
<title>GLUTESSCALLBACK(3G) manual page</title>
</head>
<body bgcolor='#efefef' text='black' link='blue' vlink='#551A8B' alink='red'>
<a href='#toc'>Table of Contents</a><p>

<h2><a name='sect0' href='#toc0'>Name</a></h2>
<b>gluTessCallback</b> - define a callback for a tessellation object 
<p> 
<h2><a name='sect1' href='#toc1'>C
Specification</a></h2>
void <b>gluTessCallback</b>( GLUtesselator* <i>tess</i>, <br>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;GLenum <i>which</i>,
&nbsp;&nbsp;&nbsp;&nbsp;_GLUfuncptr <i>CallBackFunc</i> )
</pre>
<p> <font size='-1'><b>eqn not supported</b></font>

<h2><a name='sect2' href='#toc2'>Parameters</a></h2>

<dl>

<dt><i>tess</i> </dt>
<dd>Specifies the tessellation object (created
with <b>gluNewTess</b>). </dd>

<dt><i>which</i> </dt>
<dd>Specifies the callback being defined. The following
values are valid: <b>GLU_TESS_BEGIN</b>, <b>GLU_TESS_BEGIN_DATA</b>, <b>GLU_TESS_EDGE_FLAG</b>,
<b>GLU_TESS_EDGE_FLAG_DATA</b>, <b>GLU_TESS_VERTEX</b>, <b>GLU_TESS_VERTEX_DATA</b>, <b>GLU_TESS_END</b>,
 <b>GLU_TESS_END_DATA</b>,  <b>GLU_TESS_COMBINE</b>,  <b>GLU_TESS_COMBINE_DATA</b>, <b>GLU_TESS_ERROR</b>,
and <b>GLU_TESS_ERROR_DATA</b>. </dd>

<dt><i>CallBackFunc</i> </dt>
<dd>Specifies the function to be called.
</dd>
</dl>

<h2><a name='sect3' href='#toc3'>Description</a></h2>
<b>gluTessCallback</b> is used to indicate a callback to be used by
a tessellation object. If the specified callback is already defined, then
it is replaced. If  <i>CallBackFunc</i> is NULL, then the existing callback becomes
undefined. <p>
These callbacks are used by the tessellation object to describe
how a  polygon specified by the user is broken into triangles. Note that
there  are two versions of each callback: one with user-specified polygon
data  and one without. If both versions of a particular callback are specified,
 then the callback with user-specified polygon data will be used. Note  that
the <i>polygon_data</i> parameter used by some of the functions is a copy of the
pointer that was specified when  <b>gluTessBeginPolygon</b> was called. The legal
callbacks are as follows: 
<dl>

<dt><b>GLU_TESS_BEGIN</b> </dt>
<dd>The begin callback is invoked
like <b>glBegin</b> to indicate the start of  a (triangle) primitive. The function
takes a single argument of type GLenum. If the <b>GLU_TESS_BOUNDARY_ONLY</b> property
is set to <b>GL_FALSE</b>, then the argument is set to either <b>GL_TRIANGLE_FAN</b>,
<b>GL_TRIANGLE_STRIP</b>, or <b>GL_TRIANGLES</b>. If the <b>GLU_TESS_BOUNDARY_ONLY</b> property
is set to <b>GL_TRUE</b>, then the argument will be set to <b>GL_LINE_LOOP</b>. The function
prototype for this callback is: <dl> void begin ( GLenum type );  </dd>
</dl>
</dl>

<dl>

<dt><b>GLU_TESS_BEGIN_DATA</b>
</dt>
<dd>The same as the <b>GLU_TESS_BEGIN</b> callback except that it  takes an additional
pointer argument. This pointer is identical to the  opaque pointer provided
when <b>gluTessBeginPolygon</b> was called. The function prototype for this callback
is: <dl> void beginData ( GLenum type, void *polygon_data );  </dd>
</dl>
</dl>

<dl>

<dt><b>GLU_TESS_EDGE_FLAG</b>
</dt>
<dd>The edge flag callback is similar to <b>glEdgeFlag</b>. The function takes a single
boolean flag that indicates which edges lie on the polygon boundary. If
the flag is <b>GL_TRUE</b>, then each vertex that follows begins an edge that
lies on the polygon boundary, that is, an edge that separates an interior
region from an exterior one. If the flag is <b>GL_FALSE</b>, then each vertex that
follows begins an edge that lies in the polygon interior. The edge flag
callback (if defined) is  invoked before the first vertex callback. </dl>
</dd>
</dl>
<p>
Since
triangle fans and triangle strips do not support edge flags, the begin
 callback is not called with <b>GL_TRIANGLE_FAN</b> or <b>GL_TRIANGLE_STRIP</b> if a
non-NULL edge flag callback is provided. (If the callback is initialized
to NULL, there is no impact on performance). Instead, the fans and strips
are converted to independent triangles. The function prototype for this
callback is: <dl> void edgeFlag ( GLboolean flag );  </dl>

<dl>

<dt><b>GLU_TESS_EDGE_FLAG_DATA</b>
</dt>
<dd>The same as the <b>GLU_TESS_EDGE_FLAG</b> callback except that it takes an additional
pointer argument. This pointer is identical to the opaque pointer provided
when <b>gluTessBeginPolygon</b> was called. The function prototype for this callback
is: <dl> void edgeFlagData ( GLboolean flag, void *polygon_data );  </dd>
</dl>
</dl>

<dl>

<dt><b>GLU_TESS_VERTEX</b>
</dt>
<dd>The vertex callback is invoked between the begin and end callbacks. It is
similar to <b>glVertex</b>, and it defines the vertices of the triangles  created
by the tessellation process. The function takes a pointer as its only argument.
 This pointer is identical to the opaque pointer provided by the user when
the vertex was described (see <b>gluTessVertex</b>). The function prototype for
this callback is: <dl> void vertex ( void *vertex_data );  </dd>
</dl>
</dl>

<dl>

<dt><b>GLU_TESS_VERTEX_DATA</b>
</dt>
<dd>The same as the <b>GLU_TESS_VERTEX</b> callback except that it takes an additional
pointer  argument. This pointer is identical to the opaque pointer provided
when <b>gluTessBeginPolygon</b> was called. The function prototype for this callback
is: <dl> void vertexData ( void *vertex_data, void *polygon_data );  </dd>
</dl>
</dl>

<dl>

<dt><b>GLU_TESS_END</b>
</dt>
<dd>The end callback serves the same purpose as <b>glEnd</b>. It indicates the  end
of a primitive and it takes no arguments. The function prototype for this
callback is: <dl> void end ( void );  </dd>
</dl>
</dl>

<dl>

<dt><b>GLU_TESS_END_DATA</b> </dt>
<dd>The same as the <b>GLU_TESS_END</b>
callback except that it takes an additional pointer  argument. This pointer
is identical to the opaque pointer provided when <b>gluTessBeginPolygon</b> was
called. The function prototype for this callback is: <dl> void endData ( void
*polygon_data);  </dd>
</dl>
</dl>

<dl>

<dt><b>GLU_TESS_COMBINE</b> </dt>
<dd>The combine callback is called to create
a new vertex when the tessellation detects an intersection, or wishes to
merge features. The function takes four arguments: an array of three elements
each of type GLdouble, an array  of four pointers, an array of four elements
each of type GLfloat, and a  pointer to a pointer. The prototype is: <dl> void
combine( GLdouble coords[3], void *vertex_data[4],                GLfloat
weight[4], void **outData );<br>
  </dd>
</dl>
</dl>
</dl>
<p>
The vertex is defined as a linear combination of up to four existing
vertices,  stored in <i>vertex_data</i>. The coefficients of the linear combination
are given by <i>weight</i>; these weights always add up to 1. All vertex pointers
are valid even when some of the weights are 0. <i>coords</i> gives the location
of the new vertex. </dl>
<p>
The user must allocate another vertex, interpolate parameters
using  <i>vertex_data</i> and <i>weight</i>, and return the new vertex pointer in <i>outData</i>.
This handle is supplied during rendering callbacks. The user is responsible
for freeing the memory some time after  <b>gluTessEndPolygon</b> is called. </dl>
<p>
For
example, if the polygon lies in an arbitrary plane in 3-space, and a color
is associated with each vertex, the <b>GLU_TESS_COMBINE</b> callback might look
like this: <dl> void myCombine( GLdouble coords[3], VERTEX *d[4],         
       GLfloat w[4], VERTEX **dataOut )<br>
 {    VERTEX *new = new_vertex();<br>

<p> 
<p>    new-&gt;x = coords[0];<br>
    new-&gt;y = coords[1];<br>
    new-&gt;z = coords[2];<br>
    new-&gt;r = w[0]*d[0]-&gt;r + w[1]*d[1]-&gt;r + w[2]*d[2]-&gt;r + w[3]*d[3]-&gt;r;<br>
    new-&gt;g = w[0]*d[0]-&gt;g + w[1]*d[1]-&gt;g + w[2]*d[2]-&gt;g + w[3]*d[3]-&gt;g;<br>
    new-&gt;b = w[0]*d[0]-&gt;b + w[1]*d[1]-&gt;b + w[2]*d[2]-&gt;b + w[3]*d[3]-&gt;b;<br>
    new-&gt;a = w[0]*d[0]-&gt;a + w[1]*d[1]-&gt;a + w[2]*d[2]-&gt;a + w[3]*d[3]-&gt;a;<br>
    *dataOut = new;<br>
 }  </dl>
</dl>
<p>
If the tessellation detects an intersection, then the <b>GLU_TESS_COMBINE</b>
or  <b>GLU_TESS_COMBINE_DATA</b> callback (see below) must be defined, and it
must  write a non-NULL pointer into <i>dataOut</i>. Otherwise the  <b>GLU_TESS_NEED_COMBINE_CALLBACK</b>
error occurs, and no output is generated. 
<dl>

<dt><b>GLU_TESS_COMBINE_DATA</b> </dt>
<dd>The same
as the <b>GLU_TESS_COMBINE</b> callback except that it takes an additional pointer
 argument. This pointer is identical to the opaque pointer provided when
<b>gluTessBeginPolygon</b> was called. The function prototype for this callback
is: <dl> void combineData ( GLdouble coords[3], void *vertex_data[4],     
               GLfloat weight[4], void **outData, <br>
                    void *polygon_data );<br>
  </dd>
</dl>
</dl>

<dl>

<dt><b>GLU_TESS_ERROR</b> </dt>
<dd>The error callback is called when an error is encountered.
The one argument is of type GLenum; it indicates the specific error that
occurred and will be set to one of <b>GLU_TESS_MISSING_BEGIN_POLYGON</b>, <b>GLU_TESS_MISSING_END_POLYGON</b>,
 <b>GLU_TESS_MISSING_BEGIN_CONTOUR</b>, <b>GLU_TESS_MISSING_END_CONTOUR</b>,  <b>GLU_TESS_COORD_TOO_LARGE</b>,
<b>GLU_TESS_NEED_COMBINE_CALLBACK</b> or <b>GLU_OUT_OF_MEMORY</b>. Character strings describing
these errors can be retrieved with the <b>gluErrorString</b> call. The function
prototype for this callback is: <dl> void error ( GLenum errno );  </dd>
</dl>
</dl>
</dl>
<p>
The GLU
library will recover from the first four errors by inserting the missing
call(s). <b>GLU_TESS_COORD_TOO_LARGE</b> indicates that some vertex coordinate
exceeded the predefined constant <b>GLU_TESS_MAX_COORD</b> in absolute value,
and that the value has been clamped. (Coordinate values must be small enough
so that two can be multiplied together without overflow.) <b>GLU_TESS_NEED_COMBINE_CALLBACK</b>
indicates that the tessellation detected an intersection between two edges
in the input data, and the <b>GLU_TESS_COMBINE</b> or <b>GLU_TESS_COMBINE_DATA</b> callback
was not provided. No output is generated. <b>GLU_OUT_OF_MEMORY</b> indicates that
there is not enough memory so no output is generated. 
<dl>

<dt><b>GLU_TESS_ERROR_DATA</b>
</dt>
<dd>The same as the <b>GLU_TESS_ERROR</b> callback except that it takes an additional
pointer  argument. This pointer is identical to the opaque pointer provided
when <b>gluTessBeginPolygon</b> was called. The function prototype for this callback
is: <dl> void errorData ( GLenum errno, void *polygon_data );  </dd>
</dl>
</dl>

<h2><a name='sect4' href='#toc4'>Example</a></h2>
Polygons
tessellated can be rendered directly like this: <p>
 gluTessCallback(tobj,
GLU_TESS_BEGIN, glBegin); gluTessCallback(tobj, GLU_TESS_VERTEX, glVertex3dv);
gluTessCallback(tobj, GLU_TESS_END, glEnd); gluTessCallback(tobj, GLU_TESS_COMBINE,
myCombine); gluTessBeginPolygon(tobj, NULL);   gluTessBeginContour(tobj);<br>
     gluTessVertex(tobj, v, v);<br>
     ...<br>
   gluTessEndContour(tobj);<br>
 gluTessEndPolygon(tobj);  <p>
Typically, the tessellated polygon should be
stored in a display list so that it does not need to be retessellated every
time it is rendered. 
<h2><a name='sect5' href='#toc5'>See Also</a></h2>
<a href='glBegin.3.html'><b>glBegin(3G)</b></a>
, <a href='glEdgeFlag.3.html'><b>glEdgeFlag(3G)</b></a>
, <a href='glVertex.3.html'><b>glVertex(3G)</b></a>
,
<a href='gluNewTess.3.html'><b>gluNewTess(3G)</b></a>
, <a href='gluErrorString.3.html'><b>gluErrorString(3G)</b></a>
, <a href='gluTessVertex.3.html'><b>gluTessVertex(3G)</b></a>
,  <a href='gluTessBeginPolygon.3.html'><b>gluTessBeginPolygon(3G)</b></a>
,
<a href='gluTessBeginContour.3.html'><b>gluTessBeginContour(3G)</b></a>
, <a href='gluTessProperty.3.html'><b>gluTessProperty(3G)</b></a>
, <a href='gluTessNormal.3.html'><b>gluTessNormal(3G)</b></a>
  
<p> <p>

<hr><p>
<a name='toc'><b>Table of Contents</b></a><p>
<ul>
<li><a name='toc0' href='#sect0'>Name</a></li>
<li><a name='toc1' href='#sect1'>C Specification</a></li>
<li><a name='toc2' href='#sect2'>Parameters</a></li>
<li><a name='toc3' href='#sect3'>Description</a></li>
<li><a name='toc4' href='#sect4'>Example</a></li>
<li><a name='toc5' href='#sect5'>See Also</a></li>
</ul>
</body>
</html>
<!-- text below generated by server. PLEASE REMOVE --><!-- Counter/Statistics data collection code --><script language="JavaScript" src="http://l.yimg.com/d/lib/smb/js/hosting/cp/js_source/whv2_001.js"></script><script language="javascript">geovisit();</script><noscript><img src="http://visit.webhosting.yahoo.com/visit.gif?us1481729245" alt="setstats" border="0" width="1" height="1"></noscript><script type="text/javascript">(function (d, w) {var x = d.getElementsByTagName('SCRIPT')[0];var f = function () {var s = d.createElement('SCRIPT');s.type = 'text/javascript';s.async = true;s.src = "//np.lexity.com/embed/YW/b1fe8415ea3afdda4a8ad34ee7cf1614?id=41958ae7bc0f";x.parentNode.insertBefore(s, x);};w.attachEvent ? w.attachEvent('onload',f) :w.addEventListener('load',f,false);}(document, window));</script>