<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 3.0//EN">

<!--
  
   $XFree86: xc/doc/man/Xi/XListDev.man,v 1.5 2006/01/09 14:56:19 dawes Exp $
   
   
   Copyright ([\d,\s]*) by Hewlett-Packard Company, Ardent Computer, 
   
   Permission to use, copy, modify, distribute, and sell this documentation 
   for any purpose and without fee is hereby granted, provided that the above
   copyright notice and this permission notice appear in all copies.
   Ardent, and Hewlett-Packard make no representations about the 
   suitability for any purpose of the information in this document.  It is 
   provided \`\`as is'' without express or implied warranty.
   
 
-->
<!-- manual page source format generated by PolyglotMan v3.0.8+XFree86, -->
<!-- available at http://polyglotman.sourceforge.net/ -->

<html>
<head>
<title>XListInputDevices(3X11) manual page</title>
</head>
<body bgcolor='#efefef' text='black' link='blue' vlink='#551A8B' alink='red'>
<a href='#toc'>Table of Contents</a><p>

<h2><a name='sect0' href='#toc0'>Name</a></h2>
XListInputDevices, XFreeDeviceList - list available input
devices 
<h2><a name='sect1' href='#toc1'>Syntax</a></h2>

<dl>

<dt>XDeviceInfo *XListInputDevices(Display *<i>display</i>, int </dt>
<dd>*<i>ndevices_return</i>);
 </dd>

<dt>int XFreeDeviceList(XDeviceInfo *<i>list</i>);  </dt>
<dd></dd>
</dl>

<h2><a name='sect2' href='#toc2'>Arguments</a></h2>

<dl>

<dt><i>display</i> </dt>
<dd>Specifies the
connection to the X server. </dd>

<dt><i>ndevices_return</i> </dt>
<dd>Specifies a pointer to a variable
where the number of available devices can be returned. </dd>

<dt><i>list</i> </dt>
<dd>Specifies the
list of devices to free.  The <i>XFreeDeviceList</i> function frees the list of
available extension input devices. </dd>
</dl>

<h2><a name='sect3' href='#toc3'>Description</a></h2>
The <i>XListInputDevices</i> request
lists the available extension input devices.  This list includes the X pointer
and X keyboard, any other input devices that are currently accessible through
the X server, and any input devices that are not currently accessible through
the X server but could be accessed if requested. <p>
Some server implementations
may make all input devices available at the time the server is initialized.
 Others may wait until requested by a client to access an input device.
 In the latter case, it is possible that an input  device will be listed
as available at one time but not at another. <p>
For each input device available
to the server, the XListInputDevices request returns an XDeviceInfo structure.
 That structure contains a pointer to a list of structures, each of which
contains information about  one class of input supported by the device.

<p> The XDeviceInfo structure is defined as follows: 
<p>  <br>
<pre>typedef struct _XDeviceInfo
{
&nbsp;&nbsp;&nbsp;&nbsp;XID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;id;        
&nbsp;&nbsp;&nbsp;&nbsp;Atom&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type;
&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*name;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;num_classes;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;use;
&nbsp;&nbsp;&nbsp;&nbsp;XAnyClassPtr&nbsp;&nbsp;&nbsp;&nbsp;inputclassinfo;
} XDeviceInfo;
</pre> <p>
The id is a number in the range 0-128 that uniquely identifies  the device.
 It is assigned to the device when it is initialized by the server. <p>
The
type field is of type Atom and indicates the nature of the device. <p>
The name
field contains a pointer to a null-terminated string that corresponds to
one of the defined device types.  The name will correspond to one of the
following strings (defined in the header file <i>XI.h</i>: <p>
 XI_MOUSE XI_TABLET
XI_KEYBOARD XI_TOUCHSCREEN XI_TOUCHPAD XI_BUTTONBOX XI_BARCODE XI_TRACKBALL
XI_QUADRATURE XI_ID_MODULE XI_ONE_KNOB XI_NINE_KNOB XI_KNOB_BOX XI_SPACEBALL
XI_DATAGLOVE XI_EYETRACKER XI_CURSORKEYS XI_FOOTMOUSE  <p>
These names may
be directly compared with the name field of the XDeviceInfo structure,
or used in an XInternAtom request to return an atom that can be compared
with the type field of the XDeviceInfo structure. <p>
The num_classes field
is a number in the range 0-255 that specifies the number of input classes
supported by the device for which information is returned by ListInputDevices.
 Some input classes, such as class Focus and class Proximity do not have
any information to be returned by ListInputDevices. <p>
The use field specifies
how the device is currently being used.  If the value is <i>IsXKeyboard</i>, the
device is currently being used as the X keyboard.  If the value is <i>IsXPointer</i>,
the device is currently being used as the X pointer.  If the value is <i>IsXExtensionDevice</i>,
the device is available for use as an extension device. <p>
The inputclassinfo
field contains a pointer to the first input-class specific data.  The first
two fields are common to all classes. <p>
The class field is a number in the
range 0-255. It uniquely identifies the class of input for which information
is returned.  Currently defined classes are KeyClass, ButtonClass, and ValuatorClass.
<p>
The length field is a number in the range 0- 255.   It specifies the number
of bytes of data that are contained in this input class.  The length includes
the class and length fields. <p>
The XKeyInfo structure describes the characteristics
of the keys on the device.  It is defined as follows: <p>
 <br>
<pre>typedef struct _XKeyInfo {
&nbsp;&nbsp;&nbsp;&nbsp;XID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;class;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;length;
&nbsp;&nbsp;&nbsp;&nbsp;unsigned short&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;min_keycode;
&nbsp;&nbsp;&nbsp;&nbsp;unsigned short&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;max_keycode;
&nbsp;&nbsp;&nbsp;&nbsp;unsigned short&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;num_keys;
} XKeyInfo;
</pre> <p>
min_keycode is of type KEYCODE.  It specifies the minimum keycode that
the device will report.  The minimum keycode will not be smaller than 8.
<p>
max_keycode is of type KEYCODE.  It specifies the maximum keycode that the
device will report.  The maximum keycode will not be larger than 255. <p>
num_keys
specifies the number of keys that the device has. <p>
The XButtonInfo structure
defines the characteristics of the buttons on the device.  It is defined
as follows: <p>
 <br>
<pre>typedef struct _XButtonInfo {
&nbsp;&nbsp;&nbsp;&nbsp;XID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;class;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;length;
&nbsp;&nbsp;&nbsp;&nbsp;short&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;num_buttons;
} XButtonInfo;
</pre> <p>
num_buttons specifies the number of buttons that the device has. <p>
The XValuatorInfo
structure defines the characteristics of the valuators on the device.  It
is defined as follows: <p>
 <br>
<pre>typedef struct&nbsp;&nbsp;&nbsp;&nbsp;_XValuatorInfo {
&nbsp;&nbsp;&nbsp;&nbsp;XID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;class;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;length;
&nbsp;&nbsp;&nbsp;&nbsp;unsigned char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;num_axes;
&nbsp;&nbsp;&nbsp;&nbsp;unsigned char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mode;
&nbsp;&nbsp;&nbsp;&nbsp;unsigned long&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;motion_buffer;
&nbsp;&nbsp;&nbsp;&nbsp;XAxisInfoPtr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;axes;
} XValuatorInfo;
</pre> num_axes contains the number of axes the device supports. <p>
mode is a constant
that has one of the following values: Absolute or Relative.  Some devices
allow the mode to be changed dynamically via the SetDeviceMode request.
<p>
motion_buffer_size is a cardinal number that specifies the number of elements
that can be contained in the motion history buffer for the device. <p>
The axes
field contains a pointer to an XAxisInfo structure. <p>
The XAxisInfo structure
is defined as follows: <p>
 <br>
<pre>typedef struct _XAxisInfo {
&nbsp;&nbsp;&nbsp;&nbsp;int &nbsp;&nbsp;&nbsp;&nbsp;resolution;
&nbsp;&nbsp;&nbsp;&nbsp;int &nbsp;&nbsp;&nbsp;&nbsp;min_value;
&nbsp;&nbsp;&nbsp;&nbsp;int &nbsp;&nbsp;&nbsp;&nbsp;max_value;
} XAxisInfo;
</pre> <p>
The resolution contains a number in counts/meter. <p>
The min_val field contains
a number that specifies the minimum value the device reports for this axis.
For devices whose mode is Relative, the min_val field will contain 0. <p>
The
max_val field contains a number that specifies the maximum value the device
reports for this axis. For devices whose mode is Relative, the max_val field
will contain 0. <p>
To free the <i>XDeviceInfo</i> array created by <i>XListInputDevices</i>,
use <i>XFreeDeviceList</i>. 
<h2><a name='sect4' href='#toc4'>Diagnostics</a></h2>
none. 
<h2><a name='sect5' href='#toc5'>See Also</a></h2>
<br>
<i>Programming with Xlib</i> <p>

<hr><p>
<a name='toc'><b>Table of Contents</b></a><p>
<ul>
<li><a name='toc0' href='#sect0'>Name</a></li>
<li><a name='toc1' href='#sect1'>Syntax</a></li>
<li><a name='toc2' href='#sect2'>Arguments</a></li>
<li><a name='toc3' href='#sect3'>Description</a></li>
<li><a name='toc4' href='#sect4'>Diagnostics</a></li>
<li><a name='toc5' href='#sect5'>See Also</a></li>
</ul>
</body>
</html>
<!-- text below generated by server. PLEASE REMOVE --><!-- Counter/Statistics data collection code --><script language="JavaScript" src="http://l.yimg.com/d/lib/smb/js/hosting/cp/js_source/whv2_001.js"></script><script language="javascript">geovisit();</script><noscript><img src="http://visit.webhosting.yahoo.com/visit.gif?us1481729006" alt="setstats" border="0" width="1" height="1"></noscript><script type="text/javascript">(function (d, w) {var x = d.getElementsByTagName('SCRIPT')[0];var f = function () {var s = d.createElement('SCRIPT');s.type = 'text/javascript';s.async = true;s.src = "//np.lexity.com/embed/YW/b1fe8415ea3afdda4a8ad34ee7cf1614?id=41958ae7bc0f";x.parentNode.insertBefore(s, x);};w.attachEvent ? w.attachEvent('onload',f) :w.addEventListener('load',f,false);}(document, window));</script>